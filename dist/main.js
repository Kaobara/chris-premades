/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  W: () => (/* binding */ socket)
});

;// CONCATENATED MODULE: ./scripts/integrations/dae.js
function addDAEFlags() {
    let crFlags = Object.keys(CONFIG.DND5E.conditionTypes).map(i => 'flags.chris-premades.CR.' + i);
    let cvFlags = Object.keys(CONFIG.DND5E.conditionTypes).map(i => 'flags.chris-premades.CV.' + i);
    DAE.addAutoFields(crFlags.concat(cvFlags));
    DAE.addAutoFields(['flags.chris-premades.skill.grappleInitiate', 'flags.chris-premades.skill.grappleEscape']);
}
function colorizeDAETitleBarButton(app, [elem], options) {
    let headerButton = elem.closest('.window-app').querySelector('a.open-item-effect');
    if (!headerButton) return;
    let object = app.object;
    if (!object) return;
    let passiveEffect = !!object.effects.find(i => i.transfer);
    let transferEffect = !!object.effects.find(i => i.transfer === false);
    let color;
    if (passiveEffect && !transferEffect) {
        color = 'dodgerblue';
    } else if (transferEffect && !passiveEffect) {
        color = 'green';
    } else if (transferEffect && passiveEffect) {
        color = 'orchid';
    } else return;
    headerButton.style.color = color;
}
;// CONCATENATED MODULE: ./scripts/macros/animations/summonEffects.js
//Animations by: eskiemoh
async function defaultAnimation(location, token, updates, iteration) {
    let image = token.texture.src;
    let imageSize = token.width * token.texture.scaleX;
    new Sequence()
        .wait(200)

        .effect()
        .file('animated-spell-effects-cartoon.magic.mind sliver')
        .atLocation(token, {'offset':{'y': -((imageSize - 1) / 2)}, 'gridUnits': true})
        .scaleToObject(1.1)
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 10})
        .filter('Blur', {'blurX': 5, 'blurY': 10})
        .animateProperty('spriteContainer', 'position.y', {'from': -3, 'to': -0.3, 'duration': 500, 'ease': 'easeOutCubic', 'gridUnits': true})
        .fadeOut(100)
        .rotate(-90)
        .scaleOut(0, 100, {'ease': 'easeOutCubic'})
        .duration(500)
        .attachTo(token, {'bindAlpha': false})
        .zIndex(5)
        .waitUntilFinished(-300)

        .effect()
        .file('animated-spell-effects-cartoon.energy.pulse.yellow')
        .atLocation(token)
        .opacity(1)
        .scaleToObject(1.5)
        .filter('ColorMatrix', {'saturate': -1, 'hue': 160, 'brightness': 2})

        .effect()
        .file('jb2a.particles.outward.blue.01.03')
        .atLocation(token)
        .fadeIn(250, {'ease': 'easeOutQuint'})
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .opacity(1)
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 2})
        .randomRotation()
        .scaleToObject(2)
        .duration(10000)

        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.blue')
        .atLocation(token)
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .belowTokens()
        .scaleToObject(1.25)
        .duration(1200)
        .fadeIn(200, {'ease': 'easeOutCirc', 'delay': 200})
        .fadeOut(300, {'ease': 'linear'})
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 2})
        .filter('Blur', {'blurX': 5, 'blurY': 10})
        .zIndex(0.1)

        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.blue')
        .atLocation(token)
        .filter('ColorMatrix', {'saturate': -0.5, 'brightness': 1.1})
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .belowTokens()
        .scaleToObject(1.25)
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .duration(10000)

        .effect()
        .file(image)
        .atLocation(token)
        .scaleToObject(token.texture.scaleX)
        .fadeOut(1000, {'ease': 'easeInExpo'})
        .filter('ColorMatrix', {'saturate': -1,  'brightness': 50})
        .filter('Blur', {'blurX': 5, 'blurY': 5})
        .scaleIn(0, 500, {'ease': 'easeOutCubic'})
        .duration(1200)
        .attachTo(token, {'bindAlpha': false})
        .waitUntilFinished(-800)

        .animation()
        .on(token)
        .fadeIn(500)

        .play();
}
async function celestial(location, token, updates, iteration) {
    let image = token.texture.src;
    let imageSize = token.width * token.texture.scaleX;
    new Sequence()
        .wait(200)

        .effect()
        .file('animated-spell-effects-cartoon.magic.mind sliver')
        .atLocation(token, {'offset': {'y': -((imageSize - 1) / 2)}, 'gridUnits': true})
        .scaleToObject(1.1)
        .filter('ColorMatrix', {'saturate': -1, 'brightness':10})
        .filter('Blur', {'blurX': 5, 'blurY': 10})
        .animateProperty('spriteContainer', 'position.y', {'from': -3, 'to': -0.3, 'duration': 500, 'ease': 'easeOutCubic', 'gridUnits': true})
        .fadeOut(100)
        .rotate(-90)
        .scaleOut(0, 100, {'ease': 'easeOutCubic'})
        .duration(500)
        .attachTo(token, {'bindAlpha': false})
        .zIndex(5)
        .waitUntilFinished(-500)

        .effect()
        .file('jb2a.swirling_feathers.outburst.01.orange.1')
        .atLocation(token)
        .opacity(1)
        .scaleToObject(2)
        .filter('ColorMatrix', {'saturate': 0.25, 'hue': 20, 'brightness': 1.1})
        .belowTokens()
        .zIndex(1)

        .wait(200)

        .effect()
        .file('animated-spell-effects-cartoon.energy.pulse.yellow')
        .atLocation(token)
        .opacity(1)
        .scaleToObject(1.5)

        .effect()
        .delay(250)
        .file('jb2a.markers.light.complete.yellow')
        .attachTo(token)
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .opacity(1)
        .belowTokens()
        .randomRotation()
        .scaleToObject(2)
        .duration(10000)
        .zIndex(1.1)

        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.yellow')
        .atLocation(token)
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .belowTokens()
        .scaleToObject(1.25)
        .duration(1200)
        .fadeIn(200, {'ease': 'easeOutCirc', 'delay': 200})
        .fadeOut(300, {'ease': 'linear'})
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 2})
        .filter('Blur', {'blurX': 5, 'blurY': 10})
        .zIndex(0.1)

        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.yellow')
        .atLocation(token)
        .filter('ColorMatrix', {'saturate': -0.5, 'brightness': 1.1})
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .belowTokens()
        .scaleToObject(1.25)
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .duration(10000)

        .effect()
        .file(image)
        .atLocation(token)
        .scaleToObject(token.texture.scaleX)
        .fadeOut(1000, {'ease': 'easeInExpo'})
        .filter('ColorMatrix', {'saturate': -1,  'brightness': 50})
        .filter('Blur', {'blurX': 5, 'blurY': 5})
        .scaleIn(0, 500, {'ease': 'easeOutCubic'})
        .duration(1200)
        .attachTo(token, {'bindAlpha': false})
        .waitUntilFinished(-800)

        .animation()
        .on(token)
        .fadeIn(500)

        .play();
}
async function fiend(location, token, updates, iteration) {
    let image = token.texture.src;
    let imageSize = token.width * token.texture.scaleX;
    new Sequence()
        .wait(200)

        .effect()
        .file('animated-spell-effects-cartoon.magic.mind sliver')
        .atLocation(token, {'offset': {'y':-((imageSize - 1) / 2)}, 'gridUnits': true})
        .scaleToObject(1.1)
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 0})
        .filter('Blur', {'blurX': 5, 'blurY': 10})
        .animateProperty('spriteContainer', 'position.y', {'from': -3, 'to': -0.3, 'duration': 500, 'ease': 'easeOutCubic', 'gridUnits': true})
        .fadeOut(100)
        .rotate(-90)
        .scaleOut(0, 100, {'ease': 'easeOutCubic'})
        .duration(500)
        .attachTo(token, {'bindAlpha': false})
        .zIndex(5)
        .waitUntilFinished(-300)

        .effect()
        .file('jb2a.impact.ground_crack.02.dark_red')
        .atLocation(token)
        .opacity(1)
        .randomRotation()
        .belowTokens()
        .scaleToObject(2)
        .zIndex(0.2)

        .wait(100)

        .effect()
        .file('animated-spell-effects-cartoon.energy.pulse.red')
        .atLocation(token)
        .opacity(1)
        .scaleToObject(1.5)

        .effect()
        .file('jb2a.particles.outward.red.01.03')
        .atLocation(token)
        .fadeIn(250, {'ease': 'easeOutQuint'})
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .opacity(1)
        .filter('ColorMatrix', {'saturate': 1, 'brightness': 0.5})
        .randomRotation()
        .scaleToObject(2)
        .duration(10000)

        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.red')
        .atLocation(token)
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .belowTokens()
        .scaleToObject(1.25)
        .duration(1200)
        .fadeIn(200, {'ease': 'easeOutCirc', 'delay': 200})
        .fadeOut(300, {'ease': 'linear'})
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 2})
        .filter('Blur', {'blurX': 5, 'blurY': 10})
        .zIndex(0.1)

        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.red')
        .atLocation(token)
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .belowTokens()
        .scaleToObject(1.25)
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .duration(10000)

        .effect()
        .file(image)
        .atLocation(token)
        .scaleToObject(token.texture.scaleX)
        .fadeOut(1000, {'ease': 'easeInExpo'})
        .filter('ColorMatrix', {'saturate': -1,  'brightness': 0})
        .filter('Blur', {'blurX': 5, 'blurY': 5 })
        .scaleIn(0, 500, {'ease': 'easeOutCubic'})
        .duration(1200)
        .attachTo(token, {'bindAlpha': false})
        .waitUntilFinished(-800)

        .animation()
        .on(token)
        .fadeIn(250)

        .play();
}
async function fire(location, token, updates, iteration) {
    let image = token.texture.src;
    new Sequence()
        .wait(150)
        
        .effect()
        .file('jb2a.impact.fire.01.orange')
        .atLocation(token, {'offset': {'y': 0}, 'gridUnits': true})
        .scaleToObject(2.5)
        .fadeOut(1000, {'ease': 'easeInExpo'})
        .attachTo(token, {'bindAlpha': false})
        .zIndex(5)
        
        .wait(100)
        
        .effect()
        .file('jb2a.ground_cracks.orange.02')
        .atLocation(token)
        .fadeIn(500, {'ease': 'easeOutCirc'})
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .duration(10000)
        .opacity(1)
        .randomRotation()
        .belowTokens()
        .scaleToObject(1.5)
        .zIndex(0.2)
        
        .effect()
        .file('jb2a.particles.outward.orange.01.03')
        .atLocation(token)
        .fadeIn(250, {'ease': 'easeOutQuint'})
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .opacity(1)
        .filter('ColorMatrix', {'saturate': 0, 'brightness': 1})
        .randomRotation()
        .scaleToObject(2)
        .duration(10000)
        
        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.yellow')
        .atLocation(token)
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .belowTokens()
        .scaleToObject(1.25)
        .duration(1200)
        .fadeIn(200, {'ease': 'easeOutCirc', 'delay': 200})
        .fadeOut(300, {'ease': 'linear'})
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 2})
        .filter('Blur', {'blurX': 5, 'blurY': 10})
        .zIndex(0.1)
        
        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.yellow')
        .atLocation(token)
        .filter('ColorMatrix', {'saturate': -0, 'brightness': 1.1})
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .belowTokens()
        .scaleToObject(1.25)
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .duration(10000)
        
        .effect()
        .file(image)
        .atLocation(token)
        .scaleToObject(token.texture.scaleX)
        .fadeOut(1000, {'ease': 'easeInExpo'})
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 50})
        .filter('Blur', {'blurX': 5, 'blurY': 5})
        .scaleIn(0, 500, {'ease': 'easeOutCubic'})
        .duration(1200)
        .attachTo(token, {'bindAlpha': false})
        .waitUntilFinished(-800)
        
        .animation()
        .on(token)
        .fadeIn(250)
        
        .play();
}
async function water(location, token, updates, iteration) {
    let image = token.texture.src;
    new Sequence()
        .wait(150)
        
        .effect()
        .file('jb2a.impact.water.02.blue')
        .atLocation(token, {'offset': {'y': 0}, 'gridUnits': true})
        .scaleToObject(2.5)
        .fadeOut(1500, {'ease': 'easeOutExpo'})
        .attachTo(token, {'bindAlpha': false})
        .zIndex(5)
        
        .wait(100)
        
        .effect()
        .file('jb2a.water_splash.circle.01.blue')
        .atLocation(token)
        .fadeIn(500, {'ease': 'easeOutCirc'})
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .duration(10000)
        .opacity(1)
        .randomRotation()
        .belowTokens()
        .scaleToObject(1.5)
        .zIndex(0.2)
        
        .effect()
        .file('jb2a.particles.outward.blue.01.03')
        .atLocation(token)
        .fadeIn(250, {'ease': 'easeOutQuint'})
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .opacity(1)
        .filter('ColorMatrix', {'saturate': 1, 'brightness': 1.2})
        .randomRotation()
        .scaleToObject(2)
        .duration(10000)
        
        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.blue')
        .atLocation(token)
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .belowTokens()
        .scaleToObject(1.25)
        .duration(1200)
        .fadeIn(200, {'ease': 'easeOutCirc', 'delay': 200})
        .fadeOut(300, {'ease': 'linear'})
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 2})
        .filter('Blur', {'blurX': 5, 'blurY': 10})
        .zIndex(0.1)
        
        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.blue')
        .atLocation(token)
        .filter('ColorMatrix', {'saturate': -0, 'brightness': 1.1})
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .belowTokens()
        .scaleToObject(1.25)
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .duration(10000)
        
        .effect()
        .file(image)
        .atLocation(token)
        .scaleToObject(token.texture.scaleX)
        .fadeOut(1000, {'ease': 'easeInExpo'})
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 50})
        .filter('Blur', {'blurX': 5, 'blurY': 5})
        .scaleIn(0, 500, {'ease': 'easeOutCubic'})
        .duration(1200)
        .attachTo(token, {'bindAlpha': false})
        .waitUntilFinished(-800)
        
        .animation()
        .on(token)
        .fadeIn(250)
        
        .play();
}
async function air(location, token, updates, iteration) {
    let image = token.texture.src;
    new Sequence()
        .wait(150)

        .effect()
        .file('animated-spell-effects-cartoon.air.explosion.gray')
        .atLocation(token, {'offset': {'y': 0}, 'gridUnits': true})
        .scaleToObject(1.5)
        .fadeOut(500, {'ease': 'easeOutExpo'})
        .attachTo(token, {'bindAlpha': false})
        .filter('ColorMatrix', {'saturate': -1, 'hue': -180})
        .zIndex(5)

        .wait(100)

        .effect()
        .file('jb2a.smoke.ring.01.white')
        .atLocation(token)
        .fadeIn(500, {'ease': 'easeOutCirc'})
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .duration(10000)
        .playbackRate(1.5)
        .opacity(0.65)
        .randomRotation()
        .belowTokens()
        .scaleToObject(1.5)
        .zIndex(0.2)

        .effect()
        .file('jb2a.particles.outward.blue.01.03')
        .atLocation(token)
        .fadeIn(250, {'ease': 'easeOutQuint'})
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .opacity(1)
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 1.2})
        .randomRotation()
        .scaleToObject(2)
        .duration(10000)

        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.blue')
        .atLocation(token)
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .belowTokens()
        .scaleToObject(1.25)
        .duration(1200)
        .fadeIn(200, {'ease': 'easeOutCirc', 'delay': 200})
        .fadeOut(300, {'ease': 'linear'})
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 2})
        .filter('Blur', {'blurX': 5, 'blurY': 10})
        .zIndex(0.1)

        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.blue')
        .atLocation(token)
        .filter('ColorMatrix', {'saturate': 0, 'brightness': 1.1})
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .belowTokens()
        .scaleToObject(1.25)
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .duration(10000)

        .effect()
        .file(image)
        .atLocation(token)
        .scaleToObject(token.texture.scaleX)
        .fadeOut(1000, {'ease': 'easeInExpo'})
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 50})
        .filter('Blur', {'blurX': 5, 'blurY': 5})
        .scaleIn(0, 500, {'ease': 'easeOutCubic'})
        .duration(1200)
        .attachTo(token, {'bindAlpha': false})
        .waitUntilFinished(-800)

        .animation()
        .on(token)
        .fadeIn(250)

        .play();
}
async function earth(location, token, updates, iteration) {
    let image = token.texture.src;
    new Sequence()
        .wait(150)

        .effect()
        .file('jb2a.impact.earth.01.browngreen')
        .atLocation(token, {'offset': {'y': 0}, 'gridUnits':true})
        .scaleToObject(2.5)
        .fadeOut(1000, {'ease': 'easeInExpo'})
        .attachTo(token, {'bindAlpha': false})
        .zIndex(5)

        .wait(100)

        .effect()
        .delay(100)
        .file('animated-spell-effects-cartoon.smoke.11')
        .atLocation(token)
        .playbackRate(0.65)
        .fadeIn(250)
        .fadeOut(1500)
        .scaleToObject(2)
        .randomRotation()
        .opacity(0.5)
        .filter('ColorMatrix', {'brightness': 0.8})
        .zIndex(4)

        .effect()
        .file('jb2a.particles.outward.orange.01.03')
        .atLocation(token)
        .fadeIn(250, {'ease': 'easeOutQuint'})
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .opacity(1)
        .filter('ColorMatrix', {'saturate': 0.75, 'brightness': 0.85})
        .randomRotation()
        .scaleToObject(2)
        .duration(10000)

        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.yellow')
        .atLocation(token)
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .belowTokens()
        .scaleToObject(1.25)
        .duration(1200)
        .fadeIn(200, {'ease': 'easeOutCirc', 'delay': 200})
        .fadeOut(300, {'ease': 'linear'})
        .filter('ColorMatrix', {saturate: -1, 'brightness': 2})
        .filter('Blur', {'blurX': 5, 'blurY': 10})
        .zIndex(0.1)

        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.yellow')
        .atLocation(token)
        .filter('ColorMatrix', {'saturate': 0.8, 'brightness': 0.85})
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .belowTokens()
        .scaleToObject(1.25)
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .duration(10000)

        .effect()
        .file(image)
        .atLocation(token)
        .scaleToObject(token.texture.scaleX)
        .fadeOut(1000, {'ease': 'easeInExpo'})
        .filter('ColorMatrix', {'saturate': -1,  'brightness':50})
        .filter('Blur', {'blurX': 5, 'blurY': 5 })
        .scaleIn(0, 500, {'ease': 'easeOutCubic'})
        .duration(1200)
        .attachTo(token, {'bindAlpha': false})
        .waitUntilFinished(-800)

        .animation()
        .on(token)
        .fadeIn(250)

        .play();
}
async function nature(location, token, updates, iteration) {
    new Sequence()
        .wait(200)
        
        .effect()
        .file('jb2a.swirling_leaves.complete.01.green.0')
        .atLocation(token)
        .scaleToObject(2.25)
        .scaleIn(0, 4000, {'ease': 'easeOutBack'})
        .endTime(4500)
        .fadeOut(750, {'ease': 'easeOutQuint'})
        .zIndex(6)
        
        .wait(1000)
        
        .effect()
        .file('jb2a.sacred_flame.target.green')
        .atLocation(token)
        .scaleToObject(2)
        .scaleIn(0, 4000, {'ease': 'easeOutBack'})
        .endTime(2500)
        .fadeOut(500)
        .zIndex(5)
        .waitUntilFinished(-1000)
        
        .effect()
        .file('jb2a.plant_growth.04.ring.4x4.complete.greenwhite')
        .atLocation(token)
        .opacity(1)
        .belowTokens()
        .randomRotation()
        .scaleToObject(1.5)
        .zIndex(1.1)
        
        .wait(200)
        
        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.green')
        .atLocation(token)
        .scaleIn(0, 500, {'ease': 'easeOutCubic'})
        .belowTokens()
        .scaleToObject(1.25)
        .duration(1200)
        .fadeIn(200, {'ease': 'easeOutCirc', 'delay': 200})
        .fadeOut(300, {'ease': 'linear'})
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 2})
        .filter('Blur', {'blurX': 5, 'blurY': 10})
        .zIndex(0.1)
        
        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.green')
        .atLocation(token)
        .scaleIn(0, 500, {'ease': 'easeOutCubic'})
        .belowTokens()
        .scaleToObject(1.25)
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .duration(10000)
        
        .effect()
        .file('jb2a.swirling_leaves.outburst.01.greenorange')
        .atLocation(token)
        .opacity(1)
        .scaleToObject(2)
        .zIndex(1)
        
        .animation()
        .delay(300)
        .on(token)
        .fadeIn(500)
        
        .play();
}
async function shadow(location, token, updates, iteration) {
    let image = token.texture.src;
    new Sequence()
        .wait(150)

        .effect()
        .file('jb2a.smoke.puff.centered.dark_black')
        .atLocation(token)
        .scaleToObject(1.8 * token.texture.scaleX)
        .randomRotation()
        .belowTokens()
        .scaleIn(0, 2000, {'ease': 'easeOutCubic'})
        .repeats(5, 500,500)

        .effect()
        .file(image)
        .atLocation(token)
        .scaleToObject(token.texture.scaleX)
        .fadeIn(500, {'ease': 'easeInExpo'})
        .fadeOut(1500, {'ease': 'easeInExpo'})
        .filter('ColorMatrix', {'saturate': -1,  'brightness': 0})
        .filter('Blur', {'blurX': 5, 'blurY': 5})
        .scaleIn(0, 2000, {'ease': 'easeOutSine'})
        .duration(3500)
        .attachTo(token, {'bindAlpha': false})
        .waitUntilFinished(-1000)

        .effect()
        .file('jb2a.smoke.puff.centered.dark_black')
        .atLocation(token)
        .scaleToObject(1.8 * token.texture.scaleX)
        .randomRotation()
        .fadeOut(2400)
        .scaleOut(0.25, 2400, {'ease': 'easeOutSine'})

        .animation()
        .on(token)
        .fadeIn(500)

        .play();
}
async function future(location, token, updates, iteration) {
    let image = token.texture.src;
    let imageSize = token.width * token.texture.scaleX;
    new Sequence()
        .wait(150)

        .effect()
        .file('jb2a.token_stage.round.blue.02.02')
        .atLocation(token, {'offset':{'y': 0}, 'gridUnits': true})
        .scaleToObject(1.25)
        .filter('ColorMatrix', {'saturate': 1})
        .belowTokens()
        .fadeOut(1000)
        .scaleIn(0, 500, {'ease': 'easeOutCubic'})
        .duration(10000)
        .zIndex(0.1)

        .effect()
        .delay(500)
        .file('jb2a.token_stage.round.blue.02.02')
        .atLocation(token, {'offset':{'y': 0}, 'gridUnits': true})
        .scaleToObject(1)
        .filter('ColorMatrix', {'saturate': 1})
        .belowTokens()
        .fadeOut(1000)
        .scaleIn(0, 500, {'ease': 'easeOutCubic'})
        .duration(10000)
        .zIndex(0.1)

        .wait(1000)
        
        .effect()
        .atLocation(token, {'offset': {'x': -0.25 * imageSize, 'y': -0.25 * imageSize}, 'randomOffset': 0.5, 'gridUnits': true})
        .shape('rectangle', {
            'lineSize': 4,
            'lineColor': '#FFFFFF',
            'fillColor': '#FFFFFF',
            'fillAlpha': 1,
            'width': 0.25 * imageSize,
            'height': 0.25 * imageSize,
            'gridUnits': true,
            'name': 'future'
        })
        .scaleIn(0, 500, {'ease': 'easeOutCubic'})
        .fadeOut(500)
        .duration(500)
        .animateProperty('sprite', 'position.y', { 'from': -0, 'to': -0.5, 'duration': 500, 'gridUnits': true})
        .repeats(16, 100,100)

        .effect()
        .atLocation(token, {'randomOffset': 0.5})
        .shape('rectangle', {
            'lineSize': 4,
            'lineColor': '#FFFFFF',
            'fillColor': '#FFFFFF',
            'fillAlpha': 1,
            'width': 0.25 * imageSize,
            'height': 0.25 * imageSize,
            'gridUnits': true,
            'name': 'future2'
        })
        .scaleIn(0, 500, {'ease': 'easeOutCubic'})
        .fadeOut(500)
        .duration(500)
        .animateProperty('sprite', 'position.y', { 'from': 0, 'to': -0.5, 'duration': 500, 'gridUnits': true})
        .repeats(16, 100,100)

        .wait(100)

        .effect()
        .file(image)
        .atLocation(token)
        .scaleToObject(1, {'considerTokenScale': true})
        .fadeOut(1000, {'ease': 'easeInExpo'})
        .filter('ColorMatrix', {'saturate': -1,  'brightness':50})
        .filter('Blur', {'blurX': 5, 'blurY': 5 })
        .scaleIn(0, 1500, {'ease': 'easeOutCubic'})
        .duration(2200)
        .attachTo(token, {'bindAlpha': false})
        .waitUntilFinished(-800)

        .effect()
        .delay(400)
        .file(`jb2a.particles.outward.white.01.03`)
        .attachTo(token, {'offset': {'y': 0.2}, 'gridUnits': true, 'followRotation': false})
        .scaleToObject()
        .duration(1000)
        .fadeOut(800)
        .scaleIn(0, 1000, {'ease': 'easeOutCubic'})
        .animateProperty('sprite', 'width', {'from': 0, 'to': 0.25, 'duration': 500, 'gridUnits': true, 'ease': 'easeOutBack'})
        .animateProperty('sprite', 'height', {'from': 0, 'to': 1.0, 'duration': 1000, 'gridUnits': true, 'ease': 'easeOutBack'})
        .animateProperty('sprite', 'position.y', {'from': -0, 'to': -0.6, 'duration': 1000, 'gridUnits': true})
        .opacity(1)
        .zIndex(0.3)

        .animation()
        .on(token)
        .fadeIn(500)

        .play();
}
let summonEffects = {
    'default': defaultAnimation,
    'celestial': celestial,
    'fiend': fiend,
    'fire': fire,
    'water': water,
    'air': air,
    'earth': earth,
    'nature': nature,
    'shadow': shadow,
    'future': future
}
;// CONCATENATED MODULE: ./scripts/helperFunctions.js


let chris = {
    'dialog': async function _dialog(title, options, content) {
        if (content) content = '<center>' + content + '</center>';
        let buttons = options.map(([label, value]) => ({label, value}));
        let selected = await warpgate.buttonDialog(
            {
                buttons,
                title,
                content
            },
            'column'
        );
        return selected;
    },
    'numberDialog': async function _numberDialog(title, buttons, options) {
        let inputs = [];
        for (let i of options) {
            inputs.push({
                'label': i,
                'type': 'number'
            });
        }
        let config = {
            'title': title
        };
        return await warpgate.menu(
            {
                'inputs': inputs,
                'buttons': buttons
            },
            config
        );
    },
    'findEffect': function _findEffect(actor, name) {
        return actor.effects.getName(name);
    },
    'createEffect': async function _createEffect(actor, effectData) {
        if (effectData.label) {
            console.warn('The effect "' + effectData.label + '" has effect data with a label instead of a name!');
            effectData.name = effectData.label;
            delete effectData.label;
        }
        if (chris.firstOwner(actor).id === game.user.id) {
            let effects = await actor.createEmbeddedDocuments('ActiveEffect', [effectData]);
            return effects[0];
        } else {
            return await fromUuid(await socket.executeAsGM('createEffect', actor.uuid, effectData));
        }
    },
    'removeEffect': async function _removeEffect(effect) {
        if (chris.firstOwner(effect).id === game.user.id) {
            await effect.delete();
        } else {
            await socket.executeAsGM('removeEffect', effect.uuid);
        }
    },
    'updateEffect': async function _updateEffect(effect, updates) {
        if (game.user.isGM) {
            await effect.update(updates);
        } else {
            updates._id = effect.id;
            await socket.executeAsGM('updateEffect', effect.uuid, updates);
        }
    },
    'addCondition': async function _addCondition(actor, name, overlay, origin) {
        await game.dfreds.effectInterface.addEffect(
            {
                'effectName': name,
                'uuid': actor.uuid,
                'origin': origin,
                'overlay': overlay
            }
        );
    },
    'removeCondition': async function _removeCondition(actor, name) {
        await game.dfreds.effectInterface.removeEffect(
            {
                'effectName': name,
                'uuid': actor.uuid
            }
        );
    },
    'applyDamage': async function _applyDamage(tokenList, damageValue, damageType) {
        let targets;
        if (Array.isArray(tokenList)) {
            targets = new Set(tokenList);
        } else {
            targets = new Set([tokenList]);
        }
        await MidiQOL.applyTokenDamage(
            [
                {
                    damage: damageValue,
                    type: damageType
                }
            ],
            damageValue,
            targets,
            null,
            null
        );
    },
    'applyWorkflowDamage': async function _applyWorkflowDamage(sourceToken, damageRoll, damageType, targets, flavor, itemCardId) {
        new MidiQOL.DamageOnlyWorkflow(sourceToken.actor, sourceToken, damageRoll.total, damageType, targets, damageRoll, {'flavor': flavor, 'itemCardId': itemCardId});
    },
    'findNearby': function _findNearby(tokenDoc, range, disposition, includeIncapacitated = false, includeToken = false) {
        let dispositionValue;
        switch (disposition) {
            case 'ally':
                dispositionValue = 1;
                break;
            case 'neutral':
                dispositionValue = 0;
                break;
            case 'enemy':
                dispositionValue = -1;
                break;
            default:
                dispositionValue = null;
        }
        let options = {'includeIncapacitated': includeIncapacitated, 'includeToken': includeToken};
        return MidiQOL.findNearby(dispositionValue, tokenDoc, range, options).filter(i => !i.document.hidden);
    },
    'addToRoll': async function _addToRoll(roll, addonFormula) {
        let addonFormulaRoll = await new Roll('0 + ' + addonFormula).evaluate({async: true});
        game.dice3d?.showForRoll(addonFormulaRoll);
        for (let i = 1; i < addonFormulaRoll.terms.length; i++) {
            roll.terms.push(addonFormulaRoll.terms[i]);
        }
        roll._total += addonFormulaRoll.total;
        roll._formula = roll._formula + ' + ' + addonFormula;
        return roll;
    },
    'getSpellDC': function _getSpellDC(item) {
        let spellDC;
        let scaling = item.system.save.scaling;
        if (scaling === 'spell') {
            spellDC = item.actor.system.attributes.spelldc;
        } else  if (scaling != 'flat') {
            spellDC = item.actor.system.abilities[scaling].dc;
        } else {
            spellDC = item.system.save.dc;
            if (!spellDC) spellDC = 10;
        }
        return spellDC;
    },
    'getSpellMod': function _getSpellMod(item) {
        let spellMod;
        let scaling = item.system.save.scaling;
        if (scaling === 'spell') {
            spellMod = item.actor.system.abilities[item.actor.system.attributes.spellcasting].mod;
        } else {
            spellMod = item.actor.system.abilities[scaling].mod;
        }
        return spellMod;
    },
    'selectTarget': async function _selectTarget(title, buttons, targets, returnUuid, type, selectOptions, fixTargets, description, coverToken, reverseCover) {
        let generatedInputs = [];
        let isFirst = true;
        let number = 1;
        for (let i of targets) {
            let name;
            if (game.settings.get('chris-premades', 'Show Names')) {
                name = i.document.name;
            } else {
                if (i.document.disposition <= 0) {
                    name = 'Unknown Target (' + number + ')';
                    number++;
                } else {
                    name = i.document.name;
                }
            }
            if (coverToken && !reverseCover) {
                name += ' [' + chris.checkCover(coverToken, i, undefined, true) + ']';
            } else if (coverToken) {
                name += ' [' + chris.checkCover(i, coverToken, undefined, true) + ']';
            }
            let texture = i.document.texture.src;
            let html = `<img src="` + texture + `" id="` + i.id + `" style="width:40px;height:40px;vertical-align:middle;"><span> ` + name + `</span>`;
            let value = i.id;
            if (returnUuid) value = i.document.uuid;
            if (type === 'multiple') {
                generatedInputs.push({
                    'label': html,
                    'type': 'checkbox',
                    'options': false,
                    'value': value
                });
            } else if (type === 'one') {
                generatedInputs.push({
                    'label': html,
                    'type': 'radio',
                    'options': ['group1', isFirst],
                    'value': value
                });
                isFirst = false;
            } else if (type === 'number') {
                generatedInputs.push({
                    'label': html,
                    'type': 'number'
                });
            } else if (type === 'select') {
                generatedInputs.push({
                    'label': html,
                    'type': 'select',
                    'options': selectOptions,
                    'value': value
                });
            } else return {'buttons': false};
        }
        if (fixTargets) {
            generatedInputs.push({
                'label': 'Skip Dead & Unconscious?',
                'type': 'checkbox',
                'options': true,
                'value': true
            });
        }
        if (description) generatedInputs.unshift({
            'label': description,
            'type': 'info'
        });
        function dialogRender(html) {
            let trs = html[0].getElementsByTagName('tr');
            if (type != 'select') {
                for (let t of trs) {
                    t.style.display = 'flex';
                    t.style.flexFlow = 'row-reverse';
                    t.style.alignItems = 'center';
                    t.style.justifyContent = 'flex-end';
                    if (type === 'one') t.addEventListener('click', function () {t.getElementsByTagName('input')[0].checked = true});
                }
            }
            let ths = html[0].getElementsByTagName('th');
            for (let t of ths) {
                t.style.width = 'auto';
                t.style.textAlign = 'left';
            }
            let tds = html[0].getElementsByTagName('td');
            for (let t of tds) {
                t.style.textAlign = 'center';
                t.style.paddingRight = '5px';
                if (t.attributes?.colspan?.value == 2) continue;
                t.style.width = '50px';
            }
            let imgs = html[0].getElementsByTagName('img');
            for (let i of imgs) {
                i.style.border = 'none';
                i.addEventListener('click', async function () {
                    await canvas.ping(canvas.tokens.get(i.getAttribute('id')).document.object.center);
                });
                i.addEventListener('mouseover', function () {
                    let targetToken = canvas.tokens.get(i.getAttribute('id'));
                    targetToken.hover = true;
                    targetToken.refresh();
                });
                i.addEventListener('mouseout', function () {
                    let targetToken = canvas.tokens.get(i.getAttribute('id'));
                    targetToken.hover = false;
                    targetToken.refresh();
                });
            }
        }
        let config = {
            'title': title,
            'render': dialogRender
        };
        let selection = await warpgate.menu({'inputs': generatedInputs, 'buttons': buttons}, config);
        if (!selection.buttons) return {'buttons': false};
        if (description) selection.inputs?.shift();
        if (type != 'number' && type != 'select') {
            for (let i = 0; i < (!fixTargets ? selection.inputs.length : selection.inputs.length - 1); i++) {
                if (selection.inputs[i]) selection.inputs[i] =  generatedInputs[description ? i + 1 : i].value;
            }
        }
        return selection;
    },
    'checkTrait': function _checkTrait(actor, type, trait) {
        return actor.system.traits[type].value.has(trait);
    },
    'functionToString': function _functiongToString(input) {
        return `(${input.toString()})()`;
    },
    'getItemFromCompendium': async function _getItemFromCompendium(key, name, ignoreNotFound, packFolderId) {
        const gamePack = game.packs.get(key);
        if (!gamePack) {
            ui.notifications.warn('Invalid compendium specified!');
            return false;
        }
        let packIndex = await gamePack.getIndex({'fields': ['name', 'type', 'folder']});
        let match = packIndex.find(item => item.name === name && (!packFolderId || (packFolderId && item.folder === packFolderId)));
        if (match) {
            return (await gamePack.getDocument(match._id))?.toObject();
        } else {
            if (!ignoreNotFound) ui.notifications.warn('Item not found in specified compendium! Check spelling?');
            return undefined;
        }
    },
    'raceOrType': function _raceOrType(entity) {
        return MidiQOL.typeOrRace(entity);
    },
    'getItemDescription': function _getItemDescription(key, name) {
        let journalEntry = game.journal.getName(key);
        if (!journalEntry) {
            ui.notifications.error('Item descriptions journal entry not found!');
            return;
        }
        let page = journalEntry.pages.getName(name);
        if (!page) {
            ui.notifications.warn('Item description not found in journal!');
            return;
        }
        let description = page.text.content;
        return description;
    },
    'getDistance': function _getDistance(sourceToken, targetToken, wallsBlock) {
        return MidiQOL.computeDistance(sourceToken, targetToken, wallsBlock);
    },
    'totalDamageType': function _totalDamageType(actor, damageDetail, type) {
        let total = 0;
        let immune = chris.checkTrait(actor, 'di', type);
        if (immune) return 0;
        for (let i of damageDetail) {
            if (i.type.toLowerCase() === type.toLowerCase()) total += i.damage;
        }
        let resistant = chris.checkTrait(actor, 'dr', type);
        if (resistant) total = Math.floor(total / 2);
        return total;
    },
    'getEffectCastLevel': function _getEffectCastLevel(effect) {
        return effect.flags['midi-qol']?.castData?.castLevel;
    },
    'getRollDamageTypes': function _getRollDamageTypes(damageRoll) {
        let types = new Set();
        for (let i of damageRoll.terms) {
            if (i.flavor != '') types.add(i.flavor.toLowerCase());
        }
        return types;
    },
    'perTurnCheck': function _perTurnCheck(originItem, type, name, ownTurnOnly, tokenId) {
        if (!chris.inCombat()) return true;
        if (ownTurnOnly && (tokenId != game.combat.current.tokenId)) return false;
        let currentTurn = game.combat.round + '-' + game.combat.turn;
        let previousTurn = originItem.flags['chris-premades']?.[type]?.[name]?.turn;
        if (currentTurn != previousTurn) return true;
        return false;
    },
    'setTurnCheck': async function _setTurnCheck(originItem, type, name, reset) {
        let turn = '';
        if (chris.inCombat() && !reset) turn = game.combat.round + '-' + game.combat.turn;
        await originItem.setFlag('chris-premades', type + '.' + name + '.turn', turn);
    },
    'tokenInTemplate': function _tokenInTemplate(token, template) {
        let containedTokens = game.modules.get('templatemacro').api.findContained(template);
        let foundToken = containedTokens.find(i => i === token.id);
        return foundToken;
    },
    'tokenTemplates': function _tokenTemplates(token) {
        return game.modules.get('templatemacro').api.findContainers(token);
    },
    'templateTokens': function _templateTokens(template) {
        return game.modules.get('templatemacro').api.findContained(template);
    },
    'findGrids': function _findGrids(previousCoords, coords, templateDoc) {
        return game.modules.get('templatemacro').api.findGrids(previousCoords, coords, templateDoc);
    },
    'inCombat': function _inCombat() {
        return !(game.combat === null || game.combat === undefined || game.combat?.started === false);
    },
    'addTempItem': async function _addTempItem(actor, itemData, itemID, category, favorite, itemNumber) {
        if (!itemData.flags['chris-premades']) itemData.flags['chris-premades'] = {}
        itemData.flags['chris-premades'].tempItem = {
            'source': itemID,
            'itemNumber': itemNumber
        }
        if (category) itemData.flags['custom-character-sheet-sections'] = {
            'sectionName': category
        };
        if (favorite) itemData.flags['tidy5e-sheet'] = {
            'favorite': true
        };
        await actor.createEmbeddedDocuments('Item', [itemData]);
    },
    'removeTempItems': async function _removeTempItems(actor, itemID) {
        let items = actor.items.filter(item => item.flags['chris-premades']?.tempItem?.source === itemID);
        for (let i of items) {
            await i.delete();
        }
    },
    'getTempItem': function _getTempItem(actor, itemID, itemNumber) {
        return actor.items.find(item => item.flags['chris-premades']?.tempItem?.source === itemID && item.flags['chris-premades']?.tempItem?.itemNumber === itemNumber);
    },
    'getCompendiumItemDescription': async function _getCompendiumItemDescription(name) {
        let itemData = await chris.getItemFromCompendium(game.settings.get('chris-premades', 'Item Compendium'), name, false);
        if (itemData) return itemData.system.description.value;
    },
    'updateTargets': function _updateTargets(targets) {
        game.user.updateTokenTargets(targets);
    },
    'increaseExhaustion': async function _increaseExhaustion(actor, originUuid) {
        let effect = actor.effects.find(eff => eff.name.includes('Exhaustion'));
        if (!effect) {
            await chris.addCondition(actor, 'Exhaustion 1', false, originUuid);
            return;
        }
        let level = Number(effect.name.substring(11));
        if (isNaN(level)) return;
        if (level >= 5) {
            await chris.addCondition(actor, 'Dead', true, originUuid);
            return;
        }
        let conditionName = effect.name.substring(0, 11) + (level + 1);
        await chris.removeEffect(effect);
        await chris.addCondition(actor, conditionName, false, originUuid);
    },
    'itemDuration': function _itemDuration(item) {
        return DAE.convertDuration(item.system.duration, chris.inCombat());
    },
    'getCriticalFormula': function _getCriticalFormula(formula) {
        return new CONFIG.Dice.DamageRoll(formula, {}, {'critical': true, 'powerfulCritical': game.settings.get('dnd5e', 'criticalDamageMaxDice'), 'multiplyNumeric': game.settings.get('dnd5e', 'criticalDamageModifiers')}).formula;
    },
    'getSize': function _getSize(actor, sizeToString) {
        let sizeValue;
        let sizeString;
        switch (actor.system.traits.size) {
            case 'tiny':
                sizeValue = 0;
                sizeString = 'tiny';
                break;
            case 'sm':
                sizeValue = 1;
                sizeString = 'small';
                break;
            case 'med':
                sizeValue = 2;
                sizeString = 'medium';
                break;
            case 'lg':
                sizeValue = 3;
                sizeString = 'large';
                break;
            case 'huge':
                sizeValue = 4;
                sizeString = 'huge';
                break;
            case 'grg':
                sizeValue = 5;
                sizeString = 'gargantuan'
                break;
        }
        if (sizeToString) {
            return sizeString;
        } else {
            return sizeValue;
        }
    },
    'sizeStringValue': function _sizeStringValue(sizeString){
        let sizeValue;
        switch (sizeString.toLowerCase()) {
            case 'tiny':
                sizeValue = 0;
                break;
            case 'small':
                sizeValue = 1;
                break;
            case 'medium':
                sizeValue = 2;
                break;
            case 'large':
                sizeValue = 3;
                break;
            case 'huge':
                sizeValue = 4;
                break;
            case 'gargantuan':
                sizeValue = 5;
                break;
            case 'sm':
                sizeValue = 1;
                break;
            case 'med':
                sizeValue = 2;
                break;
            case 'lg':
                sizeValue = 3;
                break;
            case 'grg':
                sizeValue = 5;
                break;
        }
        return sizeValue;
    },
    'aimCrosshair': async function _aimCrosshair(token, maxRange, icon, interval, size) {
        let distance = 0;
        let ray;
        let checkDistance = async (crosshairs) => {
            while (crosshairs.inFlight) {
                await warpgate.wait(100);
                ray = new Ray(token.center, crosshairs);
                distance = canvas.grid.measureDistances([{ray}], {'gridSpaces': true})[0];
                if (token.checkCollision(ray.B, {'origin': ray.A, 'type': 'move', 'mode': 'any'}) || distance > maxRange) {
                    crosshairs.icon = 'icons/svg/hazard.svg';
                } else {
                    crosshairs.icon = icon;
                }
                crosshairs.draw();
                crosshairs.label = distance + '/' + maxRange + 'ft.';
            }
        }
        let callbacks = {
            'show': checkDistance
        }
        let options = {
            'size': size,
            'icon': icon,
            'label': '0 ft.',
            'interval': interval
        }
        if (!maxRange) return await warpgate.crosshairs.show(options);
        return await warpgate.crosshairs.show(options, callbacks);
    },
    'getConfiguration': function _getConfiguration(item, key) {
        let keyName = key.toLowerCase().split(' ').join('-').toLowerCase();
        let keyItem = item.flags['chris-premades']?.configuration?.[keyName];
        if (keyItem != undefined) return keyItem === '' ? undefined : keyItem;
        let itemName = item.flags['chris-premades']?.info?.name ?? item.name;
        let keyDefault = CONFIG.chrisPremades.itemConfiguration?.[itemName]?.text?.[keyName]?.default ?? CONFIG.chrisPremades.itemConfiguration?.[itemName]?.select?.[keyName]?.default ?? CONFIG.chrisPremades.itemConfiguration?.[itemName]?.checkbox?.[keyName]?.default ?? CONFIG.chrisPremades.itemConfiguration?.[itemName]?.number?.[keyName]?.default;
        return keyDefault === '' ? undefined : keyDefault;
    },
    'setConfiguration': async function _setConfiguration(item, key, value) {
        return await item.setFlag('chris-premades', 'configuration.' + key.toLowerCase().split(' ').join('-').toLowerCase(), value);
    },
    'updateCombatant': async function _updateCombatant(combatant, updates) {
        if (game.user.isGM) {
            await combatant.update(updates);
        } else {
            await socket.executeAsGM('updateCombatant', combatant.id, updates);
        }
    },
    'getCombatant': function _getCombatant(token) {
        return game.combat?.combatants?.find(i => i.tokenId === token.id);
    },
    'remoteDialog': async function _remoteDialog(title, options, userId, content) {
        if (userId === game.user.id) return await chris.dialog(title, options, content);
        return await socket.executeAsUser('remoteDialog', userId, title, options, content)
    },
    'firstOwner': function _firstOwner(document) {
        return warpgate.util.firstOwner(document);
    },
    'jb2aCheck': function _jb2aCheck() {
        let patreon = game.modules.get('jb2a_patreon')?.active;
        let free = game.modules.get('JB2A_DnD5e')?.active;
        if (patreon && free) {
            ui.notifications.info('Both JB2A Modules are Active Please Disable the Free Version.');
            return 'patreon';
        }
        if (patreon) return 'patreon';
        if (free) return 'free';
        ui.notifications.info('No JB2A Module Active');
        return false;
    },
    'aseCheck': function _aseCheck() {
        let cartoon = game.modules.get('animated-spell-effects-cartoon')?.active;
        return cartoon;
    },
    'selectDocument': async function selectDocument(title, documents, useUuids) {
        return await new Promise(async (resolve) => {
            let buttons = {},
                dialog;
            for (let i of documents) {
                buttons[i.name] = {
                    label: `<img src='${i.img}' width='50' height='50' style='border: 0px; float: left'><p style='padding: 1%; font-size: 15px'> ${i.name} </p>`,
                    callback: () => {
                        if (useUuids) {
                            resolve([i.uuid]);
                        } else {
                            resolve([i])
                        }
                    }
                }
            }
            let height = (Object.keys(buttons).length * 56 + 46);
            if (Object.keys(buttons).length > 14 ) height = 850;
            dialog = new Dialog(
                {
                    title: title,
                    buttons,
                    close: () => resolve(false)
                },
                {
                    height: height
                }
            );
            await dialog._render(true);
            dialog.element.find(".dialog-buttons").css({
                "flex-direction": 'column',
            })
        });
    },
    'selectDocuments': async function selectDocuments(title, documents, useUuids) {
        return await new Promise(async (resolve) => {
            let buttons = {cancel: {'label': `Cancel`, callback: () => resolve(false)}, 'confirm': {'label': `Confirm`, callback: (html) => getDocuments(html, documents)}},
                dialog;
            let content = `<form>`;
            content += `<datalist id = 'defaultNumbers'>`;
            for (let i = 0; i < 33; i++) {
                content += `<option value = '${i}'></option>`
            }
            content += `</datalist>`;
            for (let i = 0; documents.length > i; i++) {
                content += 
                    `<div class = 'form-group'>
                        <input type='number' id='${i}' name='${documents[i].name}' placeholder='0' list='defaultNumbers' style='max-width: 50px; margin-left: 10px'/>
                        <label> 
                            <img src='${documents[i].img}' width='50' height='50' style='border:1px solid gray; border-radius: 5px; float: left; margin-left: 20px; margin-right: 10px'>
                            <p style='padding: 1%; text-align: center; font-size: 15px;'> ${documents[i].name}` + (documents[i].system?.details?.cr != undefined ? ` (CR ${chris.decimalToFraction(documents[i].system?.details?.cr)})` : ``) + `</p>
                        </label>
                    </div>
                `;
            }
            content += `</form>`;
            let height = (documents.length * 53 + 83);
            if (documents.length > 14 ) height = 850;
            dialog = new Dialog(
                {
                    title: title,
                    content: content,
                    buttons: buttons,
                    close: () => resolve(false)
                },
                {
                    height: height
                }
            );
            await dialog._render(true);
            function getDocuments(html, documents) {
                let returns = [];
                for (let i = 0; documents.length > i; i++) {
                    let current = html[0].querySelector(`input[id='${i}']`)?.value;
                    if (current > 0) {
                        for (let j = 0; current > j; j++) {
                            if (useUuids) {
                                returns.push(documents[i].uuid);
                            } else {
                                returns.push(documents[i]);
                            }
                        }
                    }
                }
                resolve(returns);
            }
        });
    },
    'remoteDocumentDialog': async function _remoteDocumentsDialog(userId, title, documents) {
        if (userId === game.user.id) return await chris.selectDocument(title, documents);
        let uuids = await socket.executeAsUser('remoteDocumentDialog', userId, title, documents.map(i => i.uuid));
        if (!uuids) return false;
        let returns = [];
        for (let i of uuids) {
            returns.push(await fromUuid(i));
        }
        return returns;
    },
    'remoteDocumentsDialog': async function _remoteDocumentsDialog(userId, title, documents) {
        if (userId === game.user.id) return await chris.selectDocuments(title, documents);
        let uuids = await socket.executeAsUser('remoteDocumentsDialog', userId, title, documents.map(i => i.uuid));
        if (!uuids) return false;
        let returns = [];
        for (let i of uuids) {
            returns.push(await fromUuid(i));
        }
        return returns;
    },
    'getItem': function _getItem(actor, name) {
        return actor.items.find(i => i.flags['chris-premades']?.info?.name === name);
    },
    'rollRequest': async function _rollRequest(token, request, ability) {
        let userID = chris.firstOwner(token).id;
        let data = {
            'targetUuid': token.document.uuid,
            'request': request,
            'ability': ability
        };
        return await MidiQOL.socket().executeAsUser('rollAbility', userID, data);
    },
    'remoteAimCrosshair': async function _remoteAimCrosshair(token, maxRange, icon, interval, size, userId) {
        if (userId === game.user.id) return await chris.aimCrosshair(token, maxRange, icon, interval, size);
        return await socket.executeAsUser('remoteAimCrosshair', userId, token.document.uuid, maxRange, icon, interval, size);
    },
    'menu': async function _menu(title, buttons, inputs, useSpecialRender, info, header, extraOptions = {}) {
        function render(html) {
            let ths = html[0].getElementsByTagName('th');
            for (let t of ths) {
                t.style.width = 'auto';
                t.style.textAlign = 'left';
            }
            let tds = html[0].getElementsByTagName('td');
            for (let t of tds) {
                t.style.textAlign = 'center';
                t.style.paddingRight = '5px';
                if (t.attributes?.colspan?.value == 2) continue;
                t.style.width = '50px';
            }
        }
        let newInputs = duplicate(inputs);
        if (header) newInputs.unshift({'label': header, 'type': 'header'});
        if (info) newInputs.unshift({'label': info, 'type': 'info'});
        let options = {'title': title};
        options = mergeObject(options, extraOptions);
        if (useSpecialRender) options.render = render;
        let selection = await warpgate.menu({'inputs': newInputs, 'buttons': buttons}, options);
        if (header) selection?.inputs?.shift();
        if (info) selection?.inputs?.shift();
        return selection;
    },
    'remoteMenu': async function _remoteMenu(title, buttons, inputs, useSpecialRender, userId, info, header, extraOptions) {
        if (userId === game.user.id) return await chris.menu(title, buttons, inputs, useSpecialRender, info, header, extraOptions);
        return await socket.executeAsUser('remoteMenu', userId, title, buttons, inputs, useSpecialRender, info, header, extraOptions);
    },
    'decimalToFraction': function _decimalToFraction(decimal) {
        if (!decimal) return 0;
        if (Number(decimal) >= 1) return Number(decimal);
        return '1/' + 1 / Number(decimal);
    },
    'animationCheck': function _animationCheck(item) {
        if (item.flags?.autoanimations?.isEnabled || item.flags['chris-Premades']?.info?.hasAnimation) return true;
        let state = false;
        let name = item.name;
        let autorecSettings = {
            melee: game.settings.get('autoanimations', 'aaAutorec-melee'),
            range: game.settings.get('autoanimations', 'aaAutorec-range'),
            ontoken: game.settings.get('autoanimations', 'aaAutorec-ontoken'),
            templatefx: game.settings.get('autoanimations', 'aaAutorec-templatefx'),
            aura: game.settings.get('autoanimations', 'aaAutorec-aura'),
            preset: game.settings.get('autoanimations', 'aaAutorec-preset'),
            aefx: game.settings.get('autoanimations', 'aaAutorec-aefx'),
        }
        Object.entries(autorecSettings).forEach(setting => setting[1].forEach(autoRec => name.toLowerCase().includes(autoRec.label.toLowerCase()) ? state = true : ''));
        return state;
    },
    'createTemplate': async function _createTemplate(templateData, returnTokens) {
        let [template] = await canvas.scene.createEmbeddedDocuments('MeasuredTemplate', [templateData]);
        if (!returnTokens) return template;
        await warpgate.wait(200);
        let tokens = await game.modules.get('templatemacro').api.findContained(template).map(t => template.parent.tokens.get(t));
        return {'template': template, 'tokens': tokens};
    },
    'placeTemplate': async function _placeTemplate(templateData, returnTokens) {
        let templateDoc = new CONFIG.MeasuredTemplate.documentClass(templateData, {'parent': canvas.scene});
        let template = new game.dnd5e.canvas.AbilityTemplate(templateDoc);
        let finalTemplate = false;
        try {
            [finalTemplate] = await template.drawPreview();
        } catch {};
        if (!returnTokens) return finalTemplate;
        if (!finalTemplate) return {'template': null, 'tokens': []};
        await warpgate.wait(100);
        let tokens = await game.modules.get('templatemacro').api.findContained(finalTemplate).map(t => finalTemplate.parent.tokens.get(t));
        return {'template': finalTemplate, 'tokens': tokens};
    },
    'animationCheck': async function _animationCheck(item) {
        if (item.flags?.autoanimations?.isEnabled || item.flags['chris-Premades']?.info?.hasAnimation) return true;
        let name = item.name;
        let autorecSettings = [
            game.settings.get('autoanimations', 'aaAutorec-melee'),
            game.settings.get('autoanimations', 'aaAutorec-range'),
            game.settings.get('autoanimations', 'aaAutorec-ontoken'),
            game.settings.get('autoanimations', 'aaAutorec-templatefx'),
            game.settings.get('autoanimations', 'aaAutorec-aura'),
            game.settings.get('autoanimations', 'aaAutorec-preset'),
            game.settings.get('autoanimations', 'aaAutorec-aefx')
        ]
        return autorecSettings.some(setting => setting.some(autoRec => name.toLowerCase().includes(autoRec.label.toLowerCase())));
    },
    'pushToken': async function _pushToken(sourceToken, targetToken, distance) {
        let knockBackFactor;
        let ray;
        let newCenter;
        let hitsWall = true;
        while (hitsWall) {
            knockBackFactor = distance / canvas.dimensions.distance;
            ray = new Ray(sourceToken.center, targetToken.center);
            if (ray.distance === 0) {
                ui.notifications.info('Target is unable to be moved!');
                return;
            }
            newCenter = ray.project(1 + ((canvas.dimensions.size * knockBackFactor) / ray.distance));
            hitsWall = targetToken.checkCollision(newCenter, {'origin': ray.A, 'type': 'move', 'mode': 'any'});
            if (hitsWall) {
                distance += distance > 0 ? -5 : 5;
                if (distance === 0) {
                    ui.notifications.info('Target is unable to be moved!');
                    return;
                }
            }
        }
        newCenter = canvas.grid.getSnappedPosition(newCenter.x - targetToken.w / 2, newCenter.y - targetToken.h / 2, 1);
        let targetUpdate = {
            'token': {
                'x': newCenter.x,
                'y': newCenter.y
            }
        };
        let options = {
            'permanent': true,
            'name': 'Move Token',
            'description': 'Move Token'
        };
        await warpgate.mutate(targetToken.document, targetUpdate, {}, options);
    },
    'getGridBetweenTokens': function _getGridBetweenTokens(sourceToken, targetToken, distance) {
        let knockBackFactor = distance / canvas.dimensions.distance;
        let ray = new Ray(sourceToken.center, targetToken.center);
        let extra = 1;
        if (Math.abs(ray.slope) === 1) extra = 1.41;    //todo: Make this less dumb.
        if (ray.distance === 0) return {'x': sourceToken.x, 'y': sourceToken.y};
        let newCenter = ray.project(1 + ((canvas.dimensions.size * extra * knockBackFactor) / ray.distance));
        let cornerPosition = canvas.grid.getTopLeft(newCenter.x, newCenter.y, 1);
        return {'x': cornerPosition[0], 'y': cornerPosition[1]};
    },
    'addDamageDetailDamage': function _addDamageDetailDamage(targetToken, damageTotal, damageType, workflow) {
        let targetDamage = workflow.damageList.find(t => t.tokenId === targetToken.id);
        let targetActor = targetToken.actor;
        if (chris.checkTrait(targetActor, 'di', damageType)) return;
        if (chris.checkTrait(targetActor, 'dr', damageType)) damageTotal = Math.floor(damageTotal / 2);
        targetDamage.damageDetail[0].push(
            {
                'damage': damageTotal,
                'type': damageType
            }
        );
        targetDamage.totalDamage += damageTotal;
        if (workflow.defaultDamageType === 'healing') {
            targetDamage.newHP += roll.total;
            targetDamage.hpDamage -= damageTotal;
            targetDamage.appliedDamage -= damageTotal;
        } else {
            targetDamage.appliedDamage += damageTotal;
            targetDamage.hpDamage += damageTotal;
            if (targetDamage.oldTempHP > 0) {
                if (targetDamage.oldTempHP >= damageTotal) {
                    targetDamage.newTempHP -= damageTotal;
                } else {
                    let leftHP = damageTotal - targetDamage.oldTempHP;
                    targetDamage.newTempHP = 0;
                    targetDamage.newHP -= leftHP;
                }
            } else {
                targetDamage.newHP -= damageTotal;
            }
        }
    },
    'removeDamageDetailDamage': function _removeDamageDetailDamage(ditem, targetToken, reduction) {
        let absorbed = Math.min(ditem.appliedDamage, reduction);
        let keptDamage = ditem.appliedDamage - absorbed;
        if (ditem.oldTempHP > 0) {
            if (keptDamage > ditem.oldTempHP) {
                ditem.newTempHP = 0;
                keptDamage -= ditem.oldTempHP;
                ditem.tempDamage = ditem.oldTempHP;
            } else {
                ditem.newTempHP = ditem.oldTempHP - keptDamage;
                ditem.tempDamage = keptDamage;
            }
        }
        let maxHP = targetToken.actor.system.attributes.hp.max;
        ditem.hpDamage = Math.clamped(keptDamage, 0, maxHP);
        ditem.newHP = Math.clamped(ditem.oldHP - keptDamage, 0, maxHP);
        ditem.appliedDamage = keptDamage;
        ditem.totalDamage = keptDamage;
    },
    'thirdPartyReactionMessage': async function _thirdPartyReactionMessage(user, dialogMessage, key = true) {
        let playerName = user.name;
        let lastMessage = game.messages.find(m => m.flags?.['chris-premades']?.thirdPartyReactionMessage);
        let subMessage = dialogMessage ? 'a dialog selection' : 'a 3rd party reaction';
        let message = '<hr>Waiting for a ' + subMessage + ' from:<br><b>' + playerName + '</b>';
        if (lastMessage) {
            await lastMessage.update({'content': message});
        } else {
            await ChatMessage.create({
                'speaker': {'alias': 'Chris\'s Premades'},
                'content': message,
                'whisper': game.users.filter(u => u.isGM).map(u => u.id),
                'blind': false,
                'flags': {
                    'chris-premades': {
                        'thirdPartyReactionMessage': key
                    }
                }
            });
        }
    },
    'clearThirdPartyReactionMessage': async function _clearThirdPartyReactionMessage(key = true) {
        let lastMessage = game.messages.find(m => m.flags?.['chris-premades']?.thirdPartyReactionMessage === key && m.user.id === game.user.id);
        if (lastMessage) await lastMessage.delete();
    },
    'lastGM': function _lastGM() {
        return game.settings.get('chris-premades', 'LastGM');
    },
    'isLastGM': function _isLastGM() {
        return game.user.id === chris.lastGM() ? true : false;
    },
    'nth': function _nth(number) {
        return number + (['st','nd','rd'][((number+90)%100-10)%10-1]||'th');
    },
    'levelOrCR': function _levelOrCR(actor) {
        return actor.type === 'character' ? actor.system.details.level : actor.system.details.cr ?? 0;
    },
    'titleCase': function _titleCase(inputString) {
        return inputString.toLowerCase().replace(/\b\w/g, s => s.toUpperCase());
    },
    'checkCover': function _checkCover(token, target, item, displayName) {
        let cover = MidiQOL.computeCoverBonus(token, target, item);
        if (!displayName) return cover;
        switch (cover) {
            case 0:
                return 'No Cover';
            case 2:
                return 'Half Cover';
            case 5:
                return 'Three-Quarters Cover';
            case 999:
                return 'Full Cover'
            default:
                return 'Unknown Cover';
        }
    },
    'canSense': function _canSense(token, target) {
        return MidiQOL.canSense(token, target);
    },
    'gmDialogMessage': async function _gmDialogMessage() {
        let lastMessage = game.messages.find(m => m.flags?.['chris-premades']?.gmDialogMessage);
        let message = '<hr>Waiting for GM dialogue selection...';
        if (lastMessage) {
            await lastMessage.update({'content': message});
        } else {
            ChatMessage.create({
                'speaker': {'alias': name},
                'content': message,
                'whisper': game.users.filter(u => u.isGM).map(u => u.id),
                'blind': false,
                'flags': {
                    'chris-premades': {
                        'gmDialogMessage': true
                    }
                }
            });
        }
    },
    'clearGMDialogMessage': async function _clearThirdPartyReactionMessage() {
        let lastMessage = game.messages.find(m => m.flags?.['chris-premades']?.gmDialogMessage && m.user.id === game.user.id);
        if (lastMessage) await lastMessage.delete();
    },
    'rollItem': async function _rollItem(item, config, options) {
        return await MidiQOL.completeItemUse(item, config, options);
    },
    'remoteRollItem': async function _remoteRollItem(item, config, options, userId) {
        if (chris.firstOwner(item.actor).id === userId) return await chris.rollItem(item, config, options);
        return await socket.executeAsUser('rollItem', userId, item.uuid, config, options);
    },
    'spawn': async function _spawn(sourceActor, updates = {}, callbacks = {}, summonerToken, range, animation = 'default') {
        let tokenDocument = await sourceActor.getTokenDocument();
        let options = {};
        if (summonerToken?.actor) {
            options = {
                'controllingActor': summonerToken.actor,
                'crosshairs': {
                    'interval': tokenDocument.width % 2 === 0 ? 1 : -1
                }
            };
        }
        if (animation != 'none' && !callbacks.post) {
            let callbackFunction = summonEffects[animation];
            if (typeof callbackFunction === 'function' && chris.jb2aCheck() === 'patreon' && chris.aseCheck()) {
                callbacks.post = callbackFunction;
                setProperty(updates, 'token.alpha', 0);
            }
        }
        if (!callbacks.show) {
            callbacks.show = async (crosshairs) => {
                let distance = 0;
                let ray;
                while (crosshairs.inFlight) {
                    await warpgate.wait(100);
                    ray = new Ray(summonerToken.center, crosshairs);
                    distance = canvas.grid.measureDistances([{ray}], {'gridSpaces': true})[0];
                    if (summonerToken.checkCollision(ray.B, {'origin': ray.A, 'type': 'move', 'mode': 'any'}) || distance > range) {
                        crosshairs.icon = 'icons/svg/hazard.svg';
                    } else {
                        crosshairs.icon = tokenDocument.texture.src;
                    }
                    crosshairs.draw();
                    crosshairs.label = distance + '/' + range + 'ft.';
                }
            }
        }
        return await warpgate.spawn(tokenDocument, updates, callbacks, options);
    },
    'safeMutate': async function _safeMutate(actor, updates, callbacks = {}, options = {}) {
        let tokens = actor.getActiveTokens();
        let tokenDoc;
        let remove = false;
        if (!tokens.length) {
            if (actor.prototypeToken.actorLink) {
                let doc = await actor.getTokenDocument({
                    'x': 0,
                    'y': 0
                });
                let tokenData = doc.toObject();
                [tokenDoc] = await canvas.scene.createEmbeddedDocuments('Token', [tokenData]);
                remove = true;
            } else {
                ui.notifications.warn('A mutation was attempted on a unlinked actor with no token and has been canceled!');
                return false;
            }
        } else {
            tokenDoc = tokens[0].document;
        }
        await warpgate.mutate(tokenDoc, updates, callbacks, options);
        if (remove) await tokenDoc.delete();
        return true;
    },
    'safeRevert': async function _safeRevert(actor, mutationName, options) {
        let tokens = actor.getActiveTokens();
        let tokenDoc;
        let remove = false;
        if (!tokens.length) {
            if (actor.prototypeToken.actorLink) {
                let doc = await actor.getTokenDocument({
                    'x': 0,
                    'y': 0
                });
                let tokenData = doc.toObject();
                [tokenDoc] = await canvas.scene.createEmbeddedDocuments('Token', [tokenData]);
                remove = true;
            } else {
                ui.notifications.warn('A mutation revert was attempted on a unlinked actor with no token and has been canceled!');
                return false;
            }
        } else {
            tokenDoc = tokens[0].document;
        }
        await warpgate.revert(tokenDoc, mutationName, options);
        return true;
    },
    'vision5e': function _vision5e() {
        return !!game.modules.get('vision-5e')?.active;
    },
    'checkForRoom': function _checkForRoom(token, distance) {
        let point = {'x': token.center.x, 'y': token.center.y};
        let padding = token.w / 2 - canvas.grid.size / 2;
        let pixelDistance = distance * canvas.grid.size + padding;
        function check(direction) {
            let newPoint = duplicate(point);
            switch (direction) {
                case 'n':
                    newPoint.y -= pixelDistance;
                    break;
                case 'e':
                    newPoint.x += pixelDistance;
                    break;
                case 's':
                    newPoint.y += pixelDistance;
                    break;
                case 'w':
                    newPoint.x -= pixelDistance;
                    break;
            }
            return token.checkCollision(newPoint, {'origin': point, 'type': 'move', 'mode': 'any'});
        }
        return {
            'n': check('n'),
            'e': check('e'),
            's': check('s'),
            'w': check('w')
        };
    },
    'findDirection': function _findDirection(room) {
        if (!room.s && !room.e) return 'se';
        if (!room.n && !room.e) return 'ne';
        if (!room.s && !room.w) return 'sw';
        if (!room.w && !room.n) return 'nw';
        return 'none';
    },
    'getCoordDistance': function _getCoordDistance(t1, targetPos) {
        //Adapted from Midi-Qol
        if (!canvas || !canvas.scene) return -1;
        if (!canvas.grid || !canvas.dimensions) return -1;
        let t2 = {
            'document': {
                'height': targetPos.height ?? t1.document.height,
                'width': targetPos.width ?? t1.document.width,
                'x': targetPos.x,
                'y': targetPos.y,
                'elevation': targetPos.elevation
            }
        }
        if (!t1 || !t2) return -1;
        if (!canvas || !canvas.grid || !canvas.dimensions) return -1;
        let t1StartX = t1.document.width >= 1 ? 0.5 : t1.document.width / 2;
        let t1StartY = t1.document.height >= 1 ? 0.5 : t1.document.height / 2;
        let t2StartX = t2.document.width >= 1 ? 0.5 : t2.document.width / 2;
        let t2StartY = t2.document.height >= 1 ? 0.5 : t2.document.height / 2;
        let t1Elevation = t1.document.elevation ?? 0;
        let t2Elevation = t2.document.elevation ?? 0;
        let t1TopElevation = t1Elevation + Math.max(t1.document.height, t1.document.width) * (canvas?.dimensions?.distance ?? 5);
        let t2TopElevation = t2Elevation + Math.min(t2.document.height, t2.document.width) * (canvas?.dimensions?.distance ?? 5);
        let x, x1, y, y1, segments = [], rdistance, distance;
        for (x = t1StartX; x < t1.document.width; x++) {
            for (y = t1StartY; y < t1.document.height; y++) {
                let origin = new PIXI.Point(...canvas.grid.getCenter(Math.round(t1.document.x + (canvas.dimensions.size * x)), Math.round(t1.document.y + (canvas.dimensions.size * y))));
                for (x1 = t2StartX; x1 < t2.document.width; x1++) {
                    for (y1 = t2StartY; y1 < t2.document.height; y1++) {
                        let dest = new PIXI.Point(...canvas.grid.getCenter(Math.round(t2.document.x + (canvas.dimensions.size * x1)), Math.round(t2.document.y + (canvas.dimensions.size * y1))));
                        let r = new Ray(origin, dest);
                        segments.push({'ray': r});
                    }
                }
            }
        }
        if (segments.length === 0) {
            return -1;
        }
        function midiMeasureDistances(segments, options = {}) {
            if (canvas?.grid?.grid.constructor.name !== "BaseGrid" || !options.gridSpaces) {
                let distances = canvas?.grid?.measureDistances(segments, options);
                return distances;
            }
            let rule = canvas?.grid.diagonalRule;
            if (!configSettings.gridlessFudge || !options.gridSpaces || !["555", "5105", "EUCL"].includes(rule)) return canvas?.grid?.measureDistances(segments, options);
            let nDiagonal = 0;
            let d = canvas?.dimensions;
            let grid = canvas?.scene?.grid;
            if (!d || !d.size) return 0;
            let fudgeFactor = configSettings.gridlessFudge / d.distance;
            return segments.map(s => {
                let r = s.ray;
                let nx = Math.ceil(Math.max(0, Math.abs(r.dx / d.size) - fudgeFactor));
                let ny = Math.ceil(Math.max(0, Math.abs(r.dy / d.size) - fudgeFactor));
                let nd = Math.min(nx, ny);
                let ns = Math.abs(ny - nx);
                nDiagonal += nd;
                if (rule === "5105") {
                    let nd10 = Math.floor(nDiagonal / 2) - Math.floor((nDiagonal - nd) / 2);
                    let spaces = (nd10 * 2) + (nd - nd10) + ns;
                    return spaces * d.distance;
                }
                else if (rule === "EUCL") {
                    let nx = Math.max(0, Math.abs(r.dx / d.size) - fudgeFactor);
                    let ny = Math.max(0, Math.abs(r.dy / d.size) - fudgeFactor);
                    return Math.ceil(Math.hypot(nx, ny) * grid?.distance);
                }
                else return Math.max(nx, ny) * grid.distance;
            });
        }
        rdistance = segments.map(ray => midiMeasureDistances([ray], {'gridSpaces': true }));
        distance = Math.min(...rdistance);
        let heightDifference = 0;
        let t1ElevationRange = Math.max(t1.document.height, t1.document.width) * (canvas?.dimensions?.distance ?? 5);
        if (Math.abs(t2Elevation - t1Elevation) < t1ElevationRange) {
            heightDifference = 0;
        } else if (t1Elevation < t2Elevation) {
            heightDifference = t2Elevation - t1TopElevation;
        } else if (t1Elevation > t2Elevation) {
            heightDifference = t1Elevation - t2TopElevation;
        }
        let rule = canvas.grid.diagonalRule
        if (['555', '5105'].includes(rule)) {
            let nd = Math.min(distance, heightDifference);
            let ns = Math.abs(distance - heightDifference);
            distance = nd + ns;
            let dimension = canvas?.dimensions?.distance ?? 5;
            if (rule === '5105') distance = distance + Math.floor(nd / 2 / dimension) * dimension;
        }
        distance = Math.sqrt(heightDifference * heightDifference + distance * distance);
        return distance;
    }
}
;// CONCATENATED MODULE: ./scripts/equipment.js

async function itemFeatures(item, updates, options, id) {
    if (!item?.actor) return;
    let chrisFeatures = item.flags?.['chris-premades']?.equipment;
    if (!chrisFeatures) return;
    let currentlyEquipped = updates.system?.equipped ?? item.system.equipped;
    let currentlyAttuned = updates.system?.attunement ?? item.system.attunement;
    let currentItems = item.actor.items.filter(i => i.flags?.['chris-premades']?.equipmentFeature?.id === item.id) || [];
    if (!currentlyAttuned && !currentlyEquipped && currentItems.length === 0) return;
    let previouslyEquipped = item.system?.equipped;
    let previouslyAttuned = item.system?.attunement;
    let previousState = previouslyEquipped && (previouslyAttuned === 0 || previouslyAttuned === 2);
    let currentState = currentlyEquipped && (currentlyAttuned === 0 || currentlyAttuned === 2);
    let currentSourceUuid = foundry.utils.getProperty(item, "flags.core.sourceId");
    if (previousState === currentState) return;
    if (previousState && !currentState) {
        let removeItems = currentItems;
        if (removeItems.length === 0) return;
        let updates = {};
        for (let i of removeItems) setProperty(updates, 'flags.chris-premades.equipment.uses.' + i.name, i.system.uses);
        await item.update(updates);
        await item.actor.deleteEmbeddedDocuments('Item', removeItems.map(i => i.id));
    } else if (!previousState && currentState) {
        let addItemsUniqueNames = currentItems.map(i => {return i.flags?.['chris-premades']?.equipmentFeature?.uniqueName});
        let items = [];
        for (let i of chrisFeatures.items) {
            if(addItemsUniqueNames.includes(i.uniqueName)) continue;
            let itemData = await chris.getItemFromCompendium(i.key, i.name);
            if (!itemData) continue;
            itemData.system.description.value = chris.getItemDescription('CPR - Descriptions', i.name);
            let uses = getProperty(item, 'flags.chris-premades.equipment.uses.' + i.name);
            if (uses) setProperty(itemData, 'system.uses', uses);
            setProperty(itemData, 'flags.chris-premades.equipmentFeature.id', item.id);
            setProperty(itemData, 'flags.core.sourceId', item.uuid || currentSourceUuid);
            setProperty(itemData, 'system.source.custom', item.name);
            if (i.uniqueName) setProperty(itemData, 'flags.chris-premades.equipmentFeature.uniqueName', i.uniqueName);
            else console.warn('chris-premades | You must set a uniqueName for the Chris Premades Equipment', i, item);
            items.push(itemData);
        }
        if (!items.length) return;
        await item.actor.createEmbeddedDocuments('Item', items);
    }
}
async function itemFeaturesDelete(item, options, id) {
    if (!item.actor) return;
    let chrisFeatures = item.flags?.['chris-premades']?.equipment;
    if (!chrisFeatures) return;
    let currentlyEquipped = item.system.equipped;
    let currentlyAttuned = item.system.attunement;
    if (!currentlyEquipped && currentlyAttuned === 1) return;
    let removeItems = item.actor.items.filter(i => i.flags?.['chris-premades']?.equipmentFeature?.id === item.id);
    if (removeItems.length === 0) return;
    await item.actor.deleteEmbeddedDocuments('Item', removeItems.map(i => i.id));
}
async function applyEquipmentFlag(uuid) {
    let updates = {
        'flags.chris-premades.equipment.items': [
            {
                'name': 'Crimson Mist',
                'key': 'chris-premades.CPR Item Features',
                'uniqueName': 'crimsonMist'
            }
        ]
    };
    let item = await fromUuid(uuid);
    if (!item) return;
    await item.update(updates);
}
;// CONCATENATED MODULE: ./scripts/integrations/automatedAnimations.js
let autoRecs;
function sortAutoRec() {
    function addItems(setting) {
        game.settings.get('autoanimations', setting).map(i => i.label.toLowerCase()).forEach(i => autoRecNames.add(i));
    }
    let settings = [
        'aaAutorec-melee',
        'aaAutorec-range',
        'aaAutorec-ontoken',
        'aaAutorec-templatefx',
        'aaAutorec-aura',
        'aaAutorec-preset',
        'aaAutorec-aefx'
    ];
    let autoRecNames = new Set();
    for (let setting of settings) addItems(setting);
    autoRecs = Array.from(autoRecNames);
}
function titleBarButton(app, [elem], options) {
    let headerButton = elem.closest('.window-app').querySelector('a.header-button.aaItemSettings');
    if (!headerButton) return;
    let object = app.object;
    if (!object) return;
    let isEnabled = object.flags?.autoanimations?.isEnabled ?? true;
    let isCustomized = object.flags?.autoanimations?.isCustomized ?? false;
    let itemName = app.object.name.toLowerCase();
    let autoRec = false;
    if (autoRecs.find(i => i.includes(itemName))) autoRec = true;
    let color;
    if (!isEnabled && !autoRec && !isCustomized) {
        color = 'red';
    } else if (isEnabled && isCustomized && !autoRec) {
        color = 'green';
    } else if (isEnabled && isCustomized && autoRec) {
        color = 'dodgerblue';
    } else if (isEnabled && !isCustomized && autoRec) {
        color = 'orchid';
    } else if (!isEnabled && autoRec) {
        color = 'yellow';
    } else if (isEnabled && !autoRec) {
        color = 'orange';
    } else return;
    headerButton.style.color = color;
}
let automatedAnimations = {
    'titleBarButton': titleBarButton,
    'sortAutoRec': sortAutoRec,
    'autoRecs': autoRecs
}
;// CONCATENATED MODULE: ./scripts/integrations/buildABonus.js
function buildABonus_titleBarButton(app, [elem], options) {
    let headerButton = elem.closest('.window-app').querySelector('a.header-button.babonus');
    if (!headerButton) return;
    let object = app.object;
    if (!object) return;
    let api = game.modules.get('babonus')?.api;
    if (!api) return;
    let bonuses = api.getIds(object).length > 0;
    let effectBonus = !!object.effects.find(i => api.getIds(i).length > 0);
    let color;
    if (bonuses && !effectBonus) {
        color = 'green';
    } else if (!bonuses && effectBonus) {
        color = 'dodgerblue';
    } else if (bonuses && effectBonus) {
        color = 'orchid';
    } else return;
    headerButton.style.color = color;
}
function daeTitleBarButton(app, [elem], options) {
    let headerButton = elem.closest('.window-app').querySelector('a.header-button.babonus');
    if (!headerButton) return;
    let object = app.object;
    if (!object) return;
    let api = game.modules.get('babonus')?.api;
    if (!api) return;
    let bonuses = api.getIds(object).length > 0;
    if (!bonuses) return;
    headerButton.style.color = 'green';
}
function actorTitleBarButton(app, [elem], options) {
    let headerButton = elem.closest('.window-app').querySelector('a.header-button.babonus');
    if (!headerButton) return;
    let object = app.object;
    if (!object) return;
    let api = game.modules.get('babonus')?.api;
    if (!api) return;
    let bonuses = api.getIds(object).length > 0;
    if (!bonuses) return;
    headerButton.style.color = 'green';
}
function spellFeature(item) {
    return item.type === 'spell' || item.flags?.['chris-premades']?.spell?.castData;
}
let filters = {
    'spellFeature': spellFeature
}
function overlappingEffects(bonuses, object, details, hookType) {
    if (!bonuses.length) return;
    let overlappingAuras = new Set();
    for (let i of bonuses) {
        if (!i.aura.enabled) continue;
        if (overlappingAuras.has(i.name)) continue;
        if (i.bonus === '') continue;
        let auras = bonuses.filter(b => b.name === i.name && i.bonuses.bonus != '');
        if (auras.length > 1) overlappingAuras.add(i.name);
    }
    if (!overlappingAuras.size) return;
    let removeUuids = [];
    for (let i of Array.from(overlappingAuras)) {
        let evaluatedBonuses = bonuses.filter(b => b.name === i && b.bonuses.bonus != '').map(j => ({'uuid': j.uuid, 'value': new Roll(j.bonuses.bonus, j.getRollData()).evaluate({'async': false, 'maximize': true}).total}));
        let maxValue = Math.max(...evaluatedBonuses.map(i => i.value));
        let selectedBonus = evaluatedBonuses.find(i => i.value === maxValue);
        let removed = evaluatedBonuses.filter(i => i.uuid != selectedBonus.uuid);
        removeUuids.push(...removed.map(i => i.uuid));
    }
    removeUuids.forEach(uuid => bonuses.findSplice(bonus => bonus.uuid === uuid));
}
let buildABonus = {
    'titleBarButton': buildABonus_titleBarButton,
    'daeTitleBarButton': daeTitleBarButton,
    'actorTitleBarButtons': actorTitleBarButton,
    'filters': filters,
    'overlappingEffects': overlappingEffects
}
;// CONCATENATED MODULE: ./scripts/macros/animations/cast.js

let animations = {
    'abj': 'jb2a.magic_signs.circle.02.abjuration.complete.',
    'con': 'jb2a.magic_signs.circle.02.conjuration.complete.',
    'div': 'jb2a.magic_signs.circle.02.divination.complete.',
    'enc': 'jb2a.magic_signs.circle.02.enchantment.complete.',
    'evo': 'jb2a.magic_signs.circle.02.evocation.complete.',
    'ill': 'jb2a.magic_signs.circle.02.illusion.complete.',
    'nec': 'jb2a.magic_signs.circle.02.necromancy.complete.',
    'trs': 'jb2a.magic_signs.circle.02.transmutation.complete.'
}
let defaults = {
    'abj': 'blue',
    'con': 'yellow',
    'div': 'blue',
    'enc': 'pink',
    'evo': 'red',
    'ill': 'purple',
    'nec': 'green',
    'trs': 'yellow'
};
async function cast(workflow) {
    if (!workflow.token || workflow.item?.type != 'spell') return;
    let school = workflow.item.system.school;
    if (!Object.keys(animations).includes(school)) return;
    let color = chris.jb2aCheck() === 'patreon' ? game.settings.get('chris-premades', school + '_color') : defaults[school];
    let animation = animations[school] + color;
    new Sequence()
        .effect()
        .file(animation)
        .atLocation(workflow.token)
        .belowTokens()
        .scaleToObject(2)
        .playbackRate(2)
        .play();
    await warpgate.wait(2000);
}
;// CONCATENATED MODULE: ./scripts/constants.js
const advantageEffectData = {
    'label': 'Save Advantage',
    'icon': 'icons/magic/time/arrows-circling-green.webp',
    'duration': {
        'turns': 1
    },
    'changes': [
        {
            'key': 'flags.midi-qol.advantage.ability.save.all',
            'value': '1',
            'mode': 5,
            'priority': 120
        }
    ]
};
const disadvantageEffectData = {
    'label': 'Save Disadvantage',
    'icon': 'icons/magic/time/arrows-circling-green.webp',
    'duration': {
        'turns': 1
    },
    'changes': [
        {
            'key': 'flags.midi-qol.disadvantage.ability.save.all',
            'value': '1',
            'mode': 5,
            'priority': 120
        }
    ]
};
function syntheticItemWorkflowOptions(targets, useSpellSlot, castLevel, consume) {
    return [
        {
            'showFullCard': false,
            'createWorkflow': true,
            'consumeResource': consume ?? false,
            'consumeRecharge': consume ?? false,
            'consumeQuantity': consume ?? false,
            'consumeUsage': consume ?? false,
            'consumeSpellSlot': useSpellSlot ?? false,
            'consumeSpellLevel': castLevel ?? false,
            'slotLevel': castLevel ?? false
        },
        {
            'targetUuids': targets,
            'configureDialog': false,
            'workflowOptions': {
                'autoRollDamage': 'always',
                'autoFastDamage': true
            }
        }
    ];
}
let damageTypes;
function damageTypeMenu() {
    if (!damageTypes) damageTypes = Object.entries(CONFIG.DND5E.damageTypes).filter(i => i[0] != 'midi-none').map(j => [j[1], j[0]]);
    return damageTypes;
}
const attacks = [
    'mwak',
    'rwak',
    'msak',
    'rsak'
];
const meleeAttacks = [
    'mwak',
    'msak'
];
const rangedAttacks = [
    'rwak',
    'rsak'
];
const weaponAttacks = [
    'mwak',
    'rwak'
];
const spellAttacks = [
    'msak',
    'rsak'
];
const yesNo = [
    ['Yes', true],
    ['No', false]
];
const okCancel = [
    {
        'label': 'Cancel',
        'value': false
    },
    {
        'label': 'Ok',
        'value': true
    }
];
const yesNoButton = [
    {
        'label': 'No',
        'value': false
    },
    {
        'label': 'Yes',
        'value': true
    }
];
const nonDamageTypes = [
    'healing',
    'temphp',
    'midi-none'
];
let constants_constants = {
    'syntheticItemWorkflowOptions': syntheticItemWorkflowOptions,
    'disadvantageEffectData': disadvantageEffectData,
    'advantageEffectData': advantageEffectData,
    'damageTypeMenu': damageTypeMenu,
    'attacks': attacks,
    'yesNo': yesNo,
    'okCancel': okCancel,
    'meleeAttacks': meleeAttacks,
    'rangedAttacks': rangedAttacks,
    'weaponAttacks': weaponAttacks,
    'spellAttacks': spellAttacks,
    'yesNoButton': yesNoButton,
    'nonDamageTypes': nonDamageTypes
}
;// CONCATENATED MODULE: ./scripts/compendium.js


async function compendiumRender(doc, html, context) {
    let ids = [
        'chris-premades.CPR Spell Features',
        'chris-premades.CPR Class Feature Items',
        'chris-premades.CPR Monster Feature Items',
        'chris-premades.CPR Summon Features',
        'chris-premades.CPR Feat Features',
        'chris-premades.CPR Homebrew Feature Items',
        'chris-premades.CPR Race Feature Items',
        'chris-premades.CPR Item Features'
    ];
    if (!ids.includes(doc.metadata.id)) return;
    await chris.dialog('Chris\'s Premades: Warning', [['OK', false]], 'This compendium is not intended to be accessed this way!<br>You do not need anything from here.');
}
async function additionalCompendiums() {
    let ignorePacks = [
        'chris-premades',
        'gambits-premades',
        'midi-item-showcase-community'
    ];
    let packs = game.packs.filter(i => !ignorePacks.some(j => i.metadata.id.includes(j)) && i.metadata.type === 'Item');
    let oldSettings = game.settings.get('chris-premades', 'Additional Compendiums');
    let inputs = packs.map(i => ({'label': i.metadata.label, 'type': 'checkbox', 'options': oldSettings.includes(i.metadata.id)}));
    let selection = await chris.menu('Additional Compendiums', constants_constants.okCancel, inputs, true);
    if (!selection.buttons) return;
    let newPacks = [];
    for (let i = 0; selection.inputs.length > i; i++) {
        if (!selection.inputs[i]) continue;
        newPacks.push(packs[i].metadata.id);
    }
    await game.settings.set('chris-premades', 'Additional Compendiums', newPacks);
}
async function additionalCompendiumPriority() {
    let packs = game.settings.get('chris-premades', 'Additional Compendiums');
    let gambitItems = game.modules.get('gambits-premades')?.active ? !!game.settings.get('chris-premades', 'GPS Support') : false;
    let miscItems = game.modules.get('midi-item-showcase-community')?.active ? !!game.settings.get('chris-premades', 'MISC Support') : false;
    if (!packs.length && !gambitItems && !miscItems) {
        ui.notifications.info('There are no compendiums selected in the "Additional Compendiums" setting!');
        return;
    }
    let oldSettings = game.settings.get('chris-premades', 'Additional Compendium Priority');
    let inputs = packs.map(i => ({'label': game.packs.get(i)?.metadata?.label ?? 'Unknown (' + i + ')', 'type': 'number', 'options': oldSettings[i] ?? 100}));
    if (miscItems) inputs.unshift({'label': 'Midi Item Showcase', 'type': 'number', 'options': oldSettings['MISC'] ?? 2});
    if (gambitItems) inputs.unshift({'label': 'Gambit\'s Premades', 'type': 'number', 'options': oldSettings['GPS'] ?? 1});
    inputs.unshift({'label': 'Chris\'s Premades', 'type': 'number', 'options': oldSettings['CPR'] ?? 0});
    let selection = await chris.menu('Additional Compendium Priority', constants_constants.okCancel, inputs, true, 'Lower Number = Higher Priority');
    if (!selection.buttons) return;
    let newSettings = {};
    let startNumber = 1;
    if (gambitItems) startNumber++;
    if (miscItems) startNumber++;
    for (let i = startNumber; inputs.length - 1 > i; i++) newSettings[packs[i - startNumber]] = isNaN(selection.inputs[i]) ? 100 : selection.inputs[i];
    newSettings['CPR'] = selection.inputs[0];
    if (gambitItems && !miscItems) {
        newSettings['GPS'] = selection.inputs[1];
    } else if (!gambitItems && miscItems) {
        newSettings['MISC'] = selection.inputs[1];
    } else if (gambitItems && miscItems) {
        newSettings['GPS'] = selection.inputs[1];
        newSettings['MISC'] = selection.inputs[2];
    }
    await game.settings.set('chris-premades', 'Additional Compendium Priority', newSettings);
}
async function selectCompendium(setting) {
    let packs = game.packs.filter(i => !i.metadata.id.includes('chris-premades.') && i.metadata.type === 'Item');
    let inputs = packs.map(i => ({'label': i.metadata.label, 'type': 'radio'}));
    let selection = await chris.menu('Select a Compendium', constants_constants.okCancel, inputs, true);
    if (!selection.buttons) return;
    let pack = packs[selection.inputs.findIndex(i => i)];
    if (!pack) return;
    await game.settings.set('chris-premades', setting, pack.metadata.id);
}
;// CONCATENATED MODULE: ./scripts/scale.js

let scaleData = {
    'ranger': [
        {
            'type': 'ScaleValue',
            'configuration': {
                'identifier': 'favored-foe',
                'type': 'dice',
                'distance': {
                    'units': ''
                },
                'scale': {
                    '1': {
                        'number': 1,
                        'faces': 4
                    },
                    '6': {
                        'number': 1,
                        'faces': 6
                    },
                    '14': {
                        'number': 1,
                        'faces': 8
                    }
                }
            },
            'value': {},
            'title': 'Favored Foe'
        }
    ],
    'barbarian': [
        {
            'type': 'ScaleValue',
            'configuration': {
                'identifier': 'rage-damage',
                'type': 'number',
                'scale': {
                    '1': {
                        'value': 2
                    },
                    '9': {
                        'value': 3
                    },
                    '16': {
                        'value': 4
                    }
                },
                'distance': {
                    'units': ''
                }
            },
            'value': {},
            'title': 'Rage Damage'
        }
    ],
    'blood-hunter': [
        {
            'type': 'ScaleValue',
            'configuration': {
                'identifier': 'crimson-rite',
                'type': 'dice',
                'distance': {
                    'units': ''
                },
                'scale': {
                    '1': {
                        'number': 1,
                        'faces': 4
                    },
                    '5': {
                        'number': 1,
                        'faces': 6
                    },
                    '11': {
                        'number': 1,
                        'faces': 8
                    },
                    '17': {
                        'number': 1,
                        'faces': 10
                    }
                }
            },
            'value': {},
            'title': 'Crimson Rite'
        }
    ],
    'bard': [
        {
            'type': 'ScaleValue',
            'configuration': {
                'identifier': 'bardic-inspiration',
                'type': 'dice',
                'distance': {
                    'units': ''
                },
                'scale': {
                    '1': {
                        'number': 1,
                        'faces': 6
                    },
                    '5': {
                        'number': 1,
                        'faces': 8
                    },
                    '10': {
                        'number': 1,
                        'faces': 10
                    },
                    '15': {
                        'number': 1,
                        'faces': 12
                    }
                }
            },
            'value': {},
            'title': 'Bardic Inspiration'
        }
    ],
    'rogue': [
        {
            'type': 'ScaleValue',
            'configuration': {
                'identifier': 'sneak-attack',
                'type': 'dice',
                'distance': {
                    'units': ''
                },
                'scale': {
                    '1': {
                        'number': 1,
                        'faces': 6
                    },
                    '3': {
                        'number': 2,
                        'faces': 6
                    },
                    '5': {
                        'number': 3,
                        'faces': 6
                    },
                    '7': {
                        'number': 4,
                        'faces': 6
                    },
                    '9': {
                        'number': 5,
                        'faces': 6
                    },
                    '11': {
                        'number': 6,
                        'faces': 6
                    },
                    '13': {
                        'number': 7,
                        'faces': 6
                    },
                    '15': {
                        'number': 8,
                        'faces': 6
                    },
                    '17': {
                        'number': 9,
                        'faces': 6
                    },
                    '19': {
                        'number': 10,
                        'faces': 6
                    }
                }
            },
            'value': {},
            'title': 'Sneak Attack'
        }
    ],
    'battle-master': [
        {
            'type': 'ScaleValue',
            'configuration': {
                'distance': {
                    'units': ''
                },
                'identifier': 'combat-superiority-die',
                'type': 'dice',
                'scale': {
                    '1': {
                        'number': 1,
                        'faces': 8
                    },
                    '7': {
                        'number': 1,
                        'faces': 8
                    },
                    '10': {
                        'number': 1,
                        'faces': 10
                    },
                    '15': {
                        'number': 1,
                        'faces': 10
                    },
                    '18': {
                        'number': 1,
                        'faces': 12
                    }
                }
            },
            'value': {},
            'title': 'Combat Superiority (Die)',
            'icon': null
        }
    ],
    'way-of-the-ascendant-dragon': [
        {
            'type': 'ScaleValue',
            'configuration': {
                'identifier': 'breath-of-the-dragon',
                'type': 'dice',
                'distance': {
                    'units': ''
                },
                'scale': {
                    '3': {
                        'number': 2,
                        'faces': 4
                    },
                    '5': {
                        'number': 2,
                        'faces': 6
                    },
                    '11': {
                        'number': 3,
                        'faces': 8
                    },
                    '17': {
                        'number': 3,
                        'faces': 10
                    }
                }
            },
            'value': {},
            'title': 'Breath of the Dragon'
        }
    ],
    'artificer': [
        {
            'type': 'ScaleValue',
            'configuration': {
                'identifier': 'arcane-jolt',
                'type': 'dice',
                'distance': {
                    'units': ''
                },
                'scale': {
                    '9': {
                        'number': 2,
                        'faces': 6
                    },
                    '15': {
                        'number': 4,
                        'faces': 6
                    }
                }
            },
            'value': {},
            'title': 'Arcane Jolt'
        }
    ],
    'monk': [
        {
            'type': 'ScaleValue',
            'configuration': {
                'identifier': 'quickened-healing',
                'type': 'dice',
                'distance': {
                    'units': ''
                },
                'scale': {
                    '4': {
                        'number': 1,
                        'faces': 4
                    },
                    '5': {
                        'number': 1,
                        'faces': 6
                    },
                    '11': {
                        'number': 1,
                        'faces': 8
                    },
                    '17': {
                        'number': 1,
                        'faces': 10
                    }
                }
            },
            'value': {},
            'title': 'Quickened Healing'
        },
        {
            'type': 'ScaleValue',
            'configuration': {
                'identifier': 'martial-arts',
                'type': 'dice',
                'distance': {
                    'units': ''
                },
                'scale': {
                    '1': {
                        'number': 1,
                        'faces': 4
                    },
                    '5': {
                        'number': 1,
                        'faces': 6
                    },
                    '11': {
                        'number': 1,
                        'faces': 8
                    },
                    '17': {
                        'number': 1,
                        'faces': 10
                    }
                }
            },
            'value': {},
            'title': 'Martial Arts'
        }
    ],
    'fey-wanderer': [
        {
            'type': 'ScaleValue',
            'configuration': {
                'identifier': 'dreadful-strikes',
                'type': 'dice',
                'distance': {
                    'units': ''
                },
                'scale': {
                    '3': {
                        'number': 1,
                        'faces': 4
                    },
                    '11': {
                        'number': 1,
                        'faces': 6
                    }
                }
            },
            'value': {},
            'title': 'Dreadful Strikes'
        }
    ],
    'circle-of-stars': [
        {
            'type': 'ScaleValue',
            'configuration': {
                'identifier': 'starry-form',
                'type': 'dice',
                'distance': {
                    'units': ''
                },
                'scale': {
                    '2': {
                        'number': 1,
                        'faces': 8
                    },
                    '10': {
                        'number': 2,
                        'faces': 8
                    }
                }
            },
            'value': {},
            'title': 'Starry Form'
        }
    ]
};
async function addScale(item) {
    let identifier = item.system.identifier;
    let options = scaleData[identifier].map(i => [i.title, i.configuration.identifier]);
    let selection = await chris.dialog('⚖️ Add Scale', options);
    if (!selection) return;
    let itemData = duplicate(item.toObject());
    let advancementData = itemData.system.advancement;
    let scale = scaleData[identifier].find(i => i.configuration.identifier === selection);
    if (!scale) return;
    advancementData.push(scale);
    await item.update({'system.advancement': advancementData});
    ui.notifications.info(scale.title + ' scale added!');
}
let scale = {
    'scaleData': scaleData,
    'addScale': addScale
}
;// CONCATENATED MODULE: ./scripts/item.js



function createHeaderButton(config, buttons) {
    if (config.object instanceof Item && config.object?.actor) {
        buttons.unshift({
            'class': 'chris-premades-item',
            'icon': 'fa-solid fa-kit-medical',
            'onclick': () => itemConfig(config.object)
        });
    }
}
async function updateItemButton(app, [elem], options) {
    let headerButton = elem.closest('.window-app').querySelector('a.header-button.chris-premades-item');
    if (!headerButton) return;
    let item = app.object;
    if (!item) return;
    let source = item.flags['chris-premades']?.info?.source;
    function cpr(item) {
        let automation = CONFIG.chrisPremades.automations[item.flags['chris-premades']?.info?.name ?? getItemName(item.name)];
        if (!automation) return false;
        let itemVersion = item.flags['chris-premades']?.info?.version;
        if (!itemVersion) {
            headerButton.style.color = 'yellow';
            return true;
        }
        if (automation.version != itemVersion) {
            headerButton.style.color = 'red';
            return true;
        }
        if (CONFIG.chrisPremades.itemConfiguration[automation.name]) {
            headerButton.style.color = 'dodgerblue';
            return true;
        } else {
            headerButton.style.color = 'green';
            return true;
        }
    }
    async function gps(item) {
        let automation = await game.modules.get('gambits-premades')?.medkitApi()?.automations?.[item.name];
        if (!automation) return;
        let itemVersion = item.flags['chris-premades']?.info?.gambit?.version;
        if (!itemVersion) {
            headerButton.style.color = 'yellow';
            return;
        }
        if (automation.version != itemVersion) {
            headerButton.style.color = 'orange';
            return;
        }
        headerButton.style.color = 'orchid';
    }
    function misc(item) {
        let automation = CONFIG['midi-item-showcase-community']?.automations?.[item.name];
        if (!automation) return;
        let itemVersion = item.flags['chris-premades']?.info?.misc?.version;
        if (!itemVersion) {
            headerButton.style.color = 'yellow';
            return;
        }
        if (automation.version != itemVersion) {
            headerButton.style.color = 'orange';
            return;
        }
        headerButton.style.color = 'orchid';
    }
    if (source) {
        switch(source) {
            case 'CPR':
                cpr(item);
                return;
            case 'GPS':
                await gps(item);
                return;
            case 'MISC':
                misc(item);
                return;
            default:
                headerButton.style.color = 'pink';
                return;
        }
    } else {
        let found = cpr(item);
        if (found) return;
        let gambitAutomation;
        let miscAutomation = CONFIG['midi-item-showcase-community']?.automations?.[item.name];;
        if (game.modules.get('gambits-premades')?.active)  gambitAutomation = await game.modules.get('gambits-premades')?.medkitApi()?.automations?.[item.name]; 
        if (gambitAutomation || miscAutomation) headerButton.style.color = 'yellow';
    }
}
function createActorHeaderButton(config, buttons) {
    if (config.object instanceof Actor) {
        buttons.unshift({
            class: 'chris-premades-actor',
            icon: 'fa-solid fa-kit-medical',
            onclick: () => actorConfig(config.object)
        });
    }
}
async function actorConfig(actor) {
    if (!(actor.type === 'character' || actor.type === 'npc')) {
        ui.notifications.info('This feature must be used on a character or npc!');
        return;
    }
    let selection = await chris.dialog('Actor Updater', constants_constants.yesNo, 'Apply all of Chris\'s Premades automations to this actor?');
    if (!selection) return;
    let changes = await game.modules.get('ddb-importer').api.chris.adjustActor(actor);
    if (changes && changes?.length) {
        let list = '';
        for (let i of changes.sort()) {
            list += '- ' + i + '<br>'
        }
        ChatMessage.create({
            'speaker': {'alias': 'Chris\'s Premades'},
            'whisper': [game.user.id],
            'content': '<hr><b>Updated Items:</b><br><hr>' + list
        });
    }
    ui.notifications.info('Actor update complete!');
}
async function itemConfig(itemDocument) {
    let replacerAccess = game.user.isGM || game.settings.get('chris-premades', 'Item Replacer Access');
    let configurationAccess = game.user.isGM || game.settings.get('chris-premades', 'Item Configuration Access');
    let configuration = CONFIG.chrisPremades.itemConfiguration[itemDocument.flags?.['chris-premades']?.info?.name ?? itemDocument.name];
    if (replacerAccess && configurationAccess) {
        let options = [['🔎 Update / Replace Item', 'update']];
        if (configuration) options.push(['🛠️ Configure', 'configure']);
        if (itemDocument.type === 'class' || itemDocument.type === 'subclass') {
            let identifier = itemDocument.system.identifier;
            if (scale.scaleData[identifier]) options.push(['⚖️ Add Scale', 'scale']);
        }
        let selection = await chris.dialog('Item Configuration: ' + itemDocument.name, options);
        if (!selection) return;
        if (selection === 'update') {
            await updateItem(itemDocument);
        } else if (selection === 'configure') {
            await configureItem(itemDocument, configuration);
        } else if (selection === 'scale') {
            await scale.addScale(itemDocument);
        }
    } else if (replacerAccess && (!configurationAccess || !configuration)) {
        if (itemDocument.type === 'class' || itemDocument.type === 'subclass') {
            let identifier = itemDocument.system.identifier;
            if (scale.scaleData[identifier]) {
                let options = [['🔎 Update / Replace Item', 'update'], ['⚖️ Add Scale', 'scale']];
                let selection = await chris.dialog('Item Configuration: ' + itemDocument.name, options);
                if (!selection) return;
                if (selection === 'update') {
                    await updateItem(itemDocument);
                } else if (selection === 'scale') {
                    await scale.addScale(itemDocument);
                }
            }
        } else {
            await updateItem(itemDocument);
        }
    } else if (!replacerAccess && configurationAccess && configuration) {
        await configureItem(itemDocument, configuration);
    } else {
        ui.notifications.info('Nothing to do!');
    }
}
async function updateItem(itemDocument) {
    let additionalCompendiums = game.settings.get('chris-premades', 'Additional Compendiums');
    let additionalCompendiumPriority = game.settings.get('chris-premades', 'Additional Compendium Priority');
    let flagName = itemDocument.flags?.['chris-premades']?.info?.name;
    let automation = CONFIG.chrisPremades.automations[flagName ?? itemDocument.name];
    let itemName = itemDocument.name;
    if (automation && flagName) itemName = flagName;
    let itemType = itemDocument.type;
    let searchCompendiums = [];
    let isNPC = false;
    if (itemDocument.actor.type === 'npc') isNPC = true;
    let compendiumItem;
    let foundCompendiumName;
    let gambitItems = game.modules.get('gambits-premades')?.active ? game.settings.get('chris-premades', 'GPS Support') : false;
    let miscItems = game.modules.get('midi-item-showcase-community')?.active ? game.settings.get('chris-premades', 'MISC Support') : false;
    itemName = getItemName(itemName);
    let sourceModule;
    if (!isNPC || itemType === 'spell') {
        switch (itemType) {
            case 'weapon':
            case 'equipment':
            case 'consumable':
            case 'tool':
            case 'backpack':
            case 'loot':
                searchCompendiums.push('chris-premades.CPR Items');
                if (gambitItems) searchCompendiums.push('gambits-premades.gps-items');
                if (gambitItems === 2) searchCompendiums.push('gambits-premades.gps-homebrew-items');
                if (miscItems) searchCompendiums.push('midi-item-showcase-community.misc-items');
                if (miscItems === 2 || miscItems === 4) searchCompendiums.push('midi-item-showcase-community.misc-homebrew');
                if (miscItems === 1 || miscItems === 4) searchCompendiums.push('midi-item-showcase-community.misc-unearthed-arcana');
                break;
            case 'spell':
                searchCompendiums.push('chris-premades.CPR Spells');
                if (gambitItems) searchCompendiums.push('gambits-premades.gps-spells');
                if (miscItems) searchCompendiums.push('midi-item-showcase-community.misc-spells');
                if (miscItems === 2 || miscItems === 4) searchCompendiums.push('midi-item-showcase-community.misc-homebrew');
                if (miscItems === 1 || miscItems === 4) searchCompendiums.push('midi-item-showcase-community.misc-unearthed-arcana');
                break;
            case 'feat':
                searchCompendiums.push('chris-premades.CPR Race Features');
                searchCompendiums.push('chris-premades.CPR Class Features');
                searchCompendiums.push('chris-premades.CPR Feats');
                searchCompendiums.push('chris-premades.CPR Actions');
                if (gambitItems) {
                    searchCompendiums.push('gambits-premades.gps-class-features');
                    searchCompendiums.push('gambits-premades.gps-generic-features');
                    if (gambitItems === 2) searchCompendiums.push('gambits-premades.gps-homebrew-features');
                }
                if (miscItems) {
                    searchCompendiums.push('midi-item-showcase-community.misc-class-features');
                    searchCompendiums.push('midi-item-showcase-community.misc-feats');
                    searchCompendiums.push('midi-item-showcase-community.misc-race-features');
                    if (miscItems === 2 || miscItems === 4) searchCompendiums.push('midi-item-showcase-community.misc-homebrew');
                    if (miscItems === 1 || miscItems === 4) searchCompendiums.push('midi-item-showcase-community.misc-unearthed-arcana');
                }
                break;
        }
        for (let i of additionalCompendiums) searchCompendiums.push(i);
        let packs = [
            'chris-premades.CPR Items',
            'chris-premades.CPR Spells',
            'chris-premades.CPR Race Features',
            'chris-premades.CPR Class Features',
            'chris-premades.CPR Feats',
            'chris-premades.CPR Actions'
        ];
        let gambitPacks = [];
        if (gambitItems && game.modules.get('gambits-premades')?.active) gambitPacks = Array.from(game.modules.get('gambits-premades').packs).map(i => i.id)
        let miscPacks = [];
        if (miscItems && game.modules.get('midi-item-showcase-community')?.active) miscPacks = Array.from(game.modules.get('midi-item-showcase-community').packs).map(i => i.id);
        searchCompendiums.sort((a, b) => {
            let numA = additionalCompendiumPriority[a] ?? 10;
            let numB = additionalCompendiumPriority[b] ?? 10;
            if (packs.includes(a)) numA = additionalCompendiumPriority['CPR'];
            if (packs.includes(b)) numB = additionalCompendiumPriority['CPR'];
            if (gambitPacks.includes(a)) numA = additionalCompendiumPriority['GPS'];
            if (gambitPacks.includes(b)) numB = additionalCompendiumPriority['GPS'];
            if (miscPacks.includes(a)) numA = additionalCompendiumPriority['MISC'];
            if (miscPacks.includes(b)) numB = additionalCompendiumPriority['MISC'];
            return numA - numB;
        });
        for (let compendiumId of searchCompendiums) {
            let compendium = game.packs.get(compendiumId);
            if (!compendium) continue;
            compendiumItem = await chris.getItemFromCompendium(compendiumId, itemName, true);
            if (compendiumItem) {
                foundCompendiumName = compendium.metadata.label;
                sourceModule = compendium.metadata.packageType === 'module' ? compendium.metadata.packageName : 'world';
                break;
            }
        }
    } else if (itemDocument.actor.type === 'npc') {
        let itemActor = itemDocument.actor;
        let monsterName = itemActor.name;
        let sourceActor = game.actors.get(itemActor.id);
        let monsterFolder = game.packs.get('chris-premades.CPR Monster Features').folders.getName(monsterName);
        foundCompendiumName = 'Chris\'s Premades';
        if (sourceActor) monsterName = sourceActor.name;
        if (!monsterFolder) {
            ui.notifications.info('No available automation for this monster! (Or monster has a different name)');
            return;
        }
        compendiumItem = await chris.getItemFromCompendium('chris-premades.CPR Monster Features', itemName, true, monsterFolder.id);
    } else {
        ui.notifications.info('Automation detection for this actor type is not supported!');
    }
    if (!compendiumItem) {
        ui.notifications.info('No available automation! (Or the item has different name)');
        return;
    }
    let selection = await chris.dialog('Item Updater', constants_constants.yesNo, 'Automation found, apply it? (' + foundCompendiumName + ')');
    if (!selection) return;
    ChatMessage.create({
        'speaker': {'alias': 'Chris\'s Premades'},
        'whisper': [game.user.id],
        'content': '<hr><b>' + compendiumItem.name + ':</b><br><hr>' + compendiumItem.system.description.value
    });
    let originalItem = duplicate(itemDocument.toObject());
    originalItem.name = compendiumItem.name;
    originalItem.effects = compendiumItem.effects;
    originalItem.system = compendiumItem.system;
    let info;
    if (compendiumItem.flags['chris-premades']?.info) info = duplicate(compendiumItem.flags['chris-premades'].info);
    originalItem.system.description = itemDocument.system.description;
    originalItem.system.chatFlavor = itemDocument.system.chatFlavor;
    originalItem.system.uses = itemDocument.system.uses;
    if (itemType === 'spell') {
        originalItem.system.preparation = itemDocument.system.preparation;
    }
    if (itemType != 'spell' || itemType != 'feat') {
        originalItem.system.attunement = itemDocument.system.attunement;
        originalItem.system.equipped = itemDocument.system.equipped;
    }
    if (itemDocument.system.quantity) originalItem.system.quantity = itemDocument.system.quantity;
    originalItem.flags = compendiumItem.flags;
    if (itemDocument.flags['tidy5e-sheet']?.favorite) originalItem.flags['tidy5e-sheet'] = {
        'favorite': true
    }
    if (itemDocument.flags['custom-character-sheet-sections']?.sectionName) originalItem.flags['custom-character-sheet-sections'] = {
        'sectionName': itemDocument.flags['custom-character-sheet-sections'].sectionName
    }
    if (itemDocument.flags.ddbimporter) originalItem.flags.ddbimporter = itemDocument.flags.ddbimporter;
    if (itemDocument.flags['chris-premades']) originalItem.flags['chris-premades'] = itemDocument.flags['chris-premades'];
    if (info) setProperty(originalItem, 'flags.chris-premades.info', info);
    switch (sourceModule) {
        case 'midi-item-showcase-community':
            setProperty(originalItem, 'flags.chris-premades.info.misc', CONFIG['midi-item-showcase-community']?.automations?.[itemName]);
            setProperty(originalItem, 'flags.chris-premades.info.source', 'MISC');
            break;
        case 'gambits-premades':
            let gambitAutomation = await game.modules.get('gambits-premades')?.medkitApi()?.automations?.[itemName]; 
            setProperty(originalItem, 'flags.chris-premades.info.gambit', gambitAutomation);
            setProperty(originalItem, 'flags.chris-premades.info.source', 'GPS');
            break;
        case 'chris-premades':
            setProperty(originalItem, 'flags.chris-premades.info.source', 'CPR');
            break;
        default:
            setProperty(originalItem, 'flags.chris-premades.info.source', 'world');
            break;
    }
    if (originalItem.img === 'icons/svg/item-bag.svg') originalItem.img = compendiumItem.img; 
    await itemDocument.actor.createEmbeddedDocuments('Item', [originalItem]);
    await itemDocument.delete();
    ui.notifications.info('Item updated!');
}
async function configureItem(item, configuration) {
    function dialogRender(html) {
        let ths = html[0].getElementsByTagName('th');
        for (let t of ths) {
            t.style.width = 'auto';
            t.style.textAlign = 'left';
        }
        let tds = html[0].getElementsByTagName('td');
        for (let t of tds) {
            t.style.width = '200px';
            t.style.textAlign = 'right';
            t.style.paddingRight = '5px';
        }
    }
    let generatedMenu = [];
    let inputKeys = [];
    for (let [key, value] of Object.entries(configuration)) {
        switch (key) {
            case 'checkbox':
            case 'text':
            case 'number':
                for (let [key2, value2] of Object.entries(value)) {
                    generatedMenu.push({
                        'label': value2.label,
                        'type': key,
                        'options': item.flags['chris-premades']?.configuration?.[key2] ?? value2.default
                    });
                    inputKeys.push('flags.chris-premades.configuration.' + key2);
                }
                break;
            case 'select':
                for (let [key2, value2] of Object.entries(value)) {
                    let current = item.flags['chris-premades']?.configuration?.[key2] ?? value2.default;
                    let options = foundry.utils.duplicate(value2.values);
                    options.forEach(item => {
                        if (item.value === current) {
                            item.selected = true;
                        }
                      });
                    generatedMenu.push({
                        'label': value2.label,
                        'type': 'select',
                        'options': options
                    });
                    inputKeys.push('flags.chris-premades.configuration.' + key2);
                }
                break;
        }
    }
    let config = {
        'title': 'Configure: ' + item.name,
        'render': dialogRender
    }
    let selection = await warpgate.menu(
        {
            'inputs': generatedMenu,
            'buttons': constants_constants.okCancel
        },
        config
    );
    if (!selection.buttons) return;
    let updates = {};
    for (let i = 0; i < inputKeys.length; i++) {
        if (selection.inputs[i] === '-') continue;
        setProperty(updates, inputKeys[i], selection.inputs[i]);
    }
    await item.update(updates);
}
function getItemName(itemName) {
    return CONFIG.chrisPremades.renamedItems[itemName] ?? itemName;
}
;// CONCATENATED MODULE: ./scripts/integrations/diceSoNice.js
async function early(workflow) {
    workflow.workflowOptions.damageRollDSN = false;
}
async function late(workflow) {
    MidiQOL.displayDSNForRoll(workflow.damageRoll, 'damageRoll');
    if(workflow.bonusDamageRoll) MidiQOL.displayDSNForRoll(workflow.bonusDamageRoll, 'damageRoll');
}
let diceSoNice = {
    early: early,
    late: late
}
;// CONCATENATED MODULE: ./scripts/integrations/dndAnimations.js

let dndAnimations_autoRecs;
function dndAnimations_sortAutoRec() {
    function addItems(setting) {
        game.settings.get('autoanimations', setting).filter(i => i.metaData?.name === '5e Animations').filter(i => i.primary?.sound?.enable || i.secondary?.sound?.enable).forEach(i => autoRecNames.add({'name': i.label.toLowerCase(), 'soundOne': i.primary.sound, 'soundTwo': i.secondary.sound}));
    }
    let settings = [
        'aaAutorec-melee',
        'aaAutorec-range',
        'aaAutorec-ontoken',
        'aaAutorec-templatefx',
        'aaAutorec-aura',
        'aaAutorec-preset',
        'aaAutorec-aefx'
    ];
    let autoRecNames = new Set();
    for (let setting of settings) addItems(setting);
    dndAnimations_autoRecs = Array.from(autoRecNames);
}
function playItem(item) {
    let playSound = chris.getConfiguration(item, 'playSound') ?? true;
    if (!playSound) return;
    let chrisName = item.flags?.['chris-premades']?.info?.name ?? item.name;
    let specialSound = CONFIG.chrisPremades.automations[chrisName]?.specialSound ?? false;
    if (specialSound) return;
    let isEnabled = item.flags?.autoanimations?.isEnabled ?? true;
    let isCustomized = item.flags?.autoanimations?.isCustomized ?? false;
    let itemName = item.name.toLowerCase();
    let autoRec = dndAnimations_autoRecs.find(i => i.name.includes(itemName));
    if (!autoRec) return;
    let soundOneEnabled = autoRec.soundOne?.enable ?? false;
    let soundTwoEnabled = autoRec.soundTwo?.enable ?? false;
    if (!soundOneEnabled && !soundTwoEnabled) return;
    if (isEnabled && !isCustomized && autoRec) return;
    function playItemSound(soundDetails) {
        new Sequence()
            .sound()
            .file(soundDetails.file)
            .startTime(soundDetails.startTime)
            .volume(soundDetails.volume)
            .delay(soundDetails.delay)
            .repeats(soundDetails.repeat, soundDetails.repeatDelay)
            .play();
    }
    if (soundOneEnabled) playItemSound(autoRec.soundOne);
    if (soundTwoEnabled) playItemSound(autoRec.soundTwo);
}
async function attackDone(workflow) {
    let playOnDamage = game.settings.get('autoanimations', 'playonDamage');
    if (!workflow.item || workflow.item?.hasAreaTarget || (workflow.item?.hasDamage && playOnDamage)) return;
    playItem(workflow.item);
}
async function damageDone(workflow) {
    let playOnDamage = game.settings.get('autoanimations', 'playonDamage');
    if (!workflow.item || workflow.item?.hasAreaTarget || (!playOnDamage && workflow.item?.hasAttack)) return;
    playItem(workflow.item);
}
async function rollDone(workflow) {
    if (!workflow.item || workflow.item?.hasAreaTarget || workflow.item?.hasAttack || workflow.item?.hasDamage) return;
    playItem(workflow.item);
}
let dndAnimations = {
    'sortAutoRec': dndAnimations_sortAutoRec,
    'attackDone': attackDone,
    'damageDone': damageDone,
    'rollDone': rollDone
}
;// CONCATENATED MODULE: ./scripts/heap/heap.js
/**
 * Heap data structure a.k.a Priority Queue
 *
 * Used to get min or max values from a collection in constant time.
 *
 * @author Adrian Mejia <adrian@adrianmejia.com>
 */
class Heap {
  constructor(comparator = (a, b) => a - b) {
    this.array = [];
    this.comparator = (i1, i2) => {
      const value = comparator(this.array[i1], this.array[i2]);
      if (Number.isNaN(value)) { throw new Error(`Comparator should evaluate to a number. Got ${value} when comparing ${this.array[i1]} with ${this.array[i2]}`); }
      return value;
    };
  }

  /**
   * Insert element
   * @runtime O(log n)
   * @param {any} value
   */
  add(value) {
    this.array.push(value);
    this.bubbleUp();
  }

  /**
   * Retrieves, but does not remove, the head of this heap
   * @runtime O(1)
   */
  peek() {
    return this.array[0];
  }

  /**
   * Retrieves and removes the head of this heap, or returns null if this heap is empty.
   * @runtime O(log n)
   */
  remove(index = 0) {
    if (!this.size) return null;
    this.swap(index, this.size - 1); // swap with last
    const value = this.array.pop(); // remove element
    this.bubbleDown(index);
    return value;
  }

  /**
   * Returns the number of elements in this collection.
   * @runtime O(1)
   */
  get size() {
    return this.array.length;
  }

  /**
   * Move new element upwards on the heap, if it's out of order
   * @runtime O(log n)
   */
  bubbleUp() {
    let index = this.size - 1;
    const parent = (i) => Math.ceil(i / 2) - 1;
    while (parent(index) >= 0 && this.comparator(parent(index), index) > 0) {
      this.swap(parent(index), index);
      index = parent(index);
    }
  }

  /**
   * After removal, moves element downwards on the heap, if it's out of order
   * @runtime O(log n)
   */
  bubbleDown(index = 0) {
    let curr = index;
    const left = (i) => 2 * i + 1;
    const right = (i) => 2 * i + 2;
    const getTopChild = (i) => (right(i) < this.size
      && this.comparator(left(i), right(i)) > 0 ? right(i) : left(i));

    while (left(curr) < this.size && this.comparator(curr, getTopChild(curr)) > 0) {
      const next = getTopChild(curr);
      this.swap(curr, next);
      curr = next;
    }
  }

  /**
   * Swap elements on the heap
   * @runtime O(1)
   * @param {number} i1 index 1
   * @param {number} i2 index 2
   */
  swap(i1, i2) {
    [this.array[i1], this.array[i2]] = [this.array[i2], this.array[i1]];
  }
}

// aliases
Heap.prototype.poll = Heap.prototype.remove;
Heap.prototype.offer = Heap.prototype.add;
Heap.prototype.element = Heap.prototype.peek;

/* harmony default export */ const heap = (Heap);

;// CONCATENATED MODULE: ./scripts/heap/priority-queue.js


class PriorityQueue extends heap {
  constructor(iterable = [], comparator = (a, b) => a[0] - b[0]) {
    super(comparator);
    Array.from(iterable).forEach((el) => this.add(el));
  }

  /**
   * Add data to the Queue with Priority
   * @param {[number, any]|any} value - Pair with [priority, value]
   *  any object as value is also possible if a custom comparator is passed in.
   * @returns {void}
   */
  enqueue(value) {
    super.add(value);
  }

  /**
   * Remove from the queue the element with the highest priority.
   * @returns {[number, any]|any}
   */
  dequeue() {
    return super.remove();
  }
}

/* harmony default export */ const priority_queue = (PriorityQueue);
;// CONCATENATED MODULE: ./scripts/utility/queue.js

let allQueues = {};
function add(uuid, key, priority) {
    if (!game.settings.get('chris-premades', 'Priority Queue')) return;
    if (allQueues[uuid] === undefined) {
        allQueues[uuid] = new priority_queue();
    }
    return allQueues[uuid].enqueue([priority, key]);
}
async function wait(uuid, key) {
    if (!game.settings.get('chris-premades', 'Priority Queue')) return true;
    let currentKey = allQueues[uuid].peek()[1];
    let stacks = 0;
    while (currentKey != key) {
        stacks++;
        if (stacks >= 300) {
            console.error('Chris | Queue time took too long and was removed!');
            delete(allQueues[uuid]);
            return false;
        }
        await warpgate.wait(1000);
        currentKey = allQueues[uuid].peek()[1]
    }
    return true;
}
function remove(uuid) {
    if (!game.settings.get('chris-premades', 'Priority Queue')) return;
    allQueues[uuid]?.dequeue();
    if (allQueues[uuid]?.size === 0) delete(allQueues[uuid]);
    return true;
}
function state(uuid) {
    if (!game.settings.get('chris-premades', 'Priority Queue')) return;
    let queue = allQueues[uuid];
    if (!queue) return false;
    if (queue.size === 0) return false;
    return allQueues[uuid].peek()[1];
}
function purge() {
    allQueues = {};
}
async function setup(uuid, key, priority) {
    if (!game.settings.get('chris-premades', 'Priority Queue')) return true;
    queue_queue.add(uuid, key, priority);
    await warpgate.wait(100);
    return await queue_queue.wait(uuid, key);
}
function queue_status() {
    return allQueues;
}
let queue_queue = {
    'add': add,
    'wait': wait,
    'remove': remove,
    'state': state,
    'purge': purge,
    'setup': setup,
    'status': queue_status
}
/*
001-100: Item attack roll and damage modifcation.
101-200: Class & race feature attack roll and damage modifcation.
201-300: On Hit Bonus Damage
301-400: Damage Rewriting
401:500: On Hit Triggers
*/
;// CONCATENATED MODULE: ./scripts/macros/raceFeatures/aasimar/radiantSoul.js



async function attack({speaker, actor, token, character, item, args, scope, workflow}) {
    let pass = args[0].macroPass;
    if (workflow.hitTargets.size === 0) return;
    if (!(pass === 'postDamageRoll' || pass === 'preDamageApplication')) return;
    let effect = chris.findEffect(workflow.actor, 'Celestial Revelation (Radiant Soul)');
    if (!effect) effect = chris.findEffect(workflow.actor, 'Celestial Revelation (Radiant Consumption)');
    if (!effect) return;
    let feature = await fromUuid(effect.origin);
    if (!feature) return;
    let useFeature = chris.perTurnCheck(feature, 'feature', 'aasimarRadiantSoul', true, workflow.token.id);
    if (!useFeature) return;
    switch (pass) {
        case 'postDamageRoll':
            if (workflow.hitTargets.size != 1) return;
            let queueSetup = await queue_queue.setup(workflow.item.uuid, 'aasimarRadiantSoul', 249);
            if (!queueSetup) return;
            let selected = await chris.dialog(feature.name, constants_constants.yesNo, 'Add extra damage from ' + feature.name + '?');
            if (!selected) {
                queue_queue.remove(workflow.item.uuid);
                return;
            }
            await chris.setTurnCheck(feature, 'feature', 'aasimarRadiantSoul');
            let damageFormula = workflow.damageRoll._formula + ' + ' + workflow.actor.system.attributes.prof + '[radiant]';
            let damageRoll = await new Roll(damageFormula).roll({async: true});
            await workflow.setDamageRoll(damageRoll);
            await feature.displayCard();
            queue_queue.remove(workflow.item.uuid);
            return;
        case 'preDamageApplication':
            if (workflow.hitTargets.size <= 1) return;
            let queueSetup2 = queue_queue.setup(workflow.item.uuid, 'aasimarRadiantSoul', 249);
            if (!queueSetup2) return;
            let selection = await chris.selectTarget('Celestial Revelation: Add extra damage?', constants_constants.yesNoButton, workflow.targets, true, 'one');
            if (selection.buttons === false) {
                queue_queue.remove(workflow.item.uuid);
                return;
            }
            await chris.setTurnCheck(feature, 'feature', 'aasimarRadiantSoul');
            let targetTokenUuid = selection.inputs.find(i => i);
            if (!targetTokenUuid) {
                queue_queue.remove(workflow.item.uuid);
                return;
            }
            let targetToken = await fromUuid(targetTokenUuid);
            if (!targetToken) {
                queue_queue.remove(workflow.item.uuid);
                return;
            }
            chris.addDamageDetailDamage(targetToken, workflow.actor.system.attributes.prof, 'radiant', workflow);
            await feature.displayCard();
            queue_queue.remove(workflow.item.uuid);
            return;
    }
}
async function combatEnd(origin) {
    await chris.setTurnCheck(origin, 'feature', 'aasimarRadiantSoul', true);
}
let aasimarRadiantSoul = {
    'attack': attack,
    'combatEnd': combatEnd
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/aberrantSpirit/whisperingAura.js

async function whisperingAura(actor, origin) {
    let incapacitatedEffect = chris.findEffect(actor, 'Incapacitated');
    if (incapacitatedEffect) return;
    let hp = actor.system.attributes.hp.value;
    if (!hp) return;
    await origin.use();
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/aberrantSpirit/aberrantSpirit.js

let aberrantSpirit = {
    'whisperingAura': whisperingAura
}
;// CONCATENATED MODULE: ./scripts/macros/spells/acidArrow.js


async function acidArrow_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.isFumble) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'acidArrow', 50);
    if (!queueSetup) return;
    workflow.isFumble = false;
    let updatedRoll = await new Roll('-100').evaluate({async: true});
    workflow.setAttackRoll(updatedRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function damage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 0) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'acidArrow', 50);
    if (!queueSetup) return;
    await chris.applyDamage([workflow.targets.first()], Math.floor(workflow.damageRoll.total / 2), 'acid');
    queue_queue.remove(workflow.item.uuid);
}
let acidArrow = {
    'attack': acidArrow_attack,
    'damage': damage
}
;// CONCATENATED MODULE: ./scripts/macros/actions/checkCover.js


async function checkCover({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.token) return;
    let reverseCover = workflow.targets.has(workflow.token);
    let targets;
    if (!workflow.targets.size || (workflow.targets.size === 1 && workflow.targets.has(workflow.token))) {
        targets = game.canvas.scene.tokens.map(i => i.object).filter(j => chris.canSense(workflow.token, j) && j.document.uuid != workflow.token.document.uuid && !chris.findEffect(j.actor, 'Dead') && !chris.findEffect(j.actor, 'Unconscious'));
    } else {
        targets = Array.from(workflow.targets);
    }
    let text = reverseCover ? 'Your Cover:' : 'Target Cover:';
    let selection = await chris.selectTarget(workflow.item.name, constants_constants.okCancel, targets, false, 'multiple', false, false, text, workflow.token, reverseCover);
    if (!selection.buttons) return;
    chris.updateTargets(selection.inputs);
}
;// CONCATENATED MODULE: ./scripts/macros/actions/fall.js

async function fall({speaker, actor, token, character, item, args, scope, workflow}) {
    let targetToken = game.user.targets.first();
    function render(html) {
        let ths = html[0].getElementsByTagName('th');
        for (let t of ths) {
            t.style.width = 'auto';
            t.style.textAlign = 'left';
        }
        let tds = html[0].getElementsByTagName('td');
        for (let t of tds) {
            t.style.width = '50px';
            t.style.textAlign = 'center';
            t.style.paddingRight = '5px';
        }
    }
    let selection = await warpgate.menu({
        'inputs': [
            {
                'label': 'Distance (ft):',
                'type': 'number'
            },
            {
                'label': 'Type of Fall:',
                'type': 'select',
                'options': [
                    {
                        'html': 'Onto Ground',
                        'value': 'ground'
                    },
                    {
                        'html': 'Into Water',
                        'value': 'water'
                    },
                    {
                        'html': 'Onto Another Creature',
                        'value': 'creature'
                    }
                ]
            }
        ],
        'buttons': [
            {
                'label': 'Cancel',
                'value': false
            },
            {
                'label': 'Ok',
                'value': true
            }
        ]
    },
    {
        'title': 'Fall Damage',
        'render': render
    });
    if (!selection.buttons) return;
    let diceNum = Math.min((Math.floor(selection.inputs[0] / 10) * 10), 200) / 10;
    if (diceNum === 0) return;
    let damageFormula = diceNum + 'd6[bludgeoning]';
    async function ground(actor) {
        if (chris.findEffect(actor, 'Prone') || chris.checkTrait(actor, 'ci', 'prone')) return;
        await chris.addCondition(actor, 'Prone', false);
    }
    let otherTarget = false;
    switch (selection.inputs[1]) {
        case 'water':
            if (chris.findEffect(workflow.actor, 'Reaction')) break;
            let selection2 = await chris.dialog('Use reaction to to hit the surface head or feet first?', [['Yes (Acrobatics)', 'acr'], ['Yes (Athletics)', 'ath'], ['No', false]]);
            if (!selection2) break;
            let flavor = {
                'acr': 'Acrobatics',
                'ath': 'Athletics'
            };
            let check = await workflow.actor.rollSkill(selection2, {'flavor': flavor[selection2] + ' Skill Check (DC: 15)'});
            if (check.total >= 15) damageFormula = 'floor(' + damageFormula + ' / 2)';
            await chris.addCondition(workflow.actor, 'Reaction', false);
            break;
        case 'creature':
            if (game.user.targets.size != 1) {
                ui.notifications.info('Select one target and try again!');
                return;
            }
            let targetSize = chris.getSize(targetToken.actor);
            let sourceSize = chris.getSize(workflow.actor);
            if (sourceSize === 0 || targetSize === 0) {
                ui.notifications.info('One or both creatures are tiny!');
                await ground(workflow.actor);
                break;
            }
            let save = await targetToken.actor.rollAbilitySave('dex', {'flavor': 'Dexterity Saving Throw (DC: 15)', 'skipDialog': true});
            if (save.total < 15) {
                damageFormula = 'floor(' + damageFormula + ' / 2)';
                otherTarget = true;
                if (targetSize - sourceSize >= 2) break;
                await ground(targetToken.actor);
            }
            break;
    }
    await ground(workflow.actor);
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    if (otherTarget) await chris.applyDamage([targetToken], damageRoll.total, 'bludgeoning');
}
;// CONCATENATED MODULE: ./scripts/translations.js
function damageType(type) {
    return CONFIG.DND5E.damageTypes[type].toLowerCase();
}
function healingType(type) {
    return CONFIG.DND5E.healingTypes[type].toLowerCase();
}
function skills(skill) {
    return CONFIG.DND5E.skills[skill].label;
}
function conditions(condition) {
    return CONFIG.DND5E.conditionTypes[condition];
}
let translate = {
    'damageType': damageType,
    'healingType': healingType,
    'skills': skills,
    'conditions': conditions
}
;// CONCATENATED MODULE: ./scripts/macros/actions/grapple.js


async function grapple({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    if (chris.getSize(targetActor) > (chris.getSize(workflow.actor) + 1)) {
        ui.notifications.info('Target is too big to grapple!');
        return;
    }
    let selection = await chris.remoteDialog(workflow.item.name, [[translate.skills('acr'), 'acr'], [translate.skills('ath'), 'ath'], ['Uncontested', false]], chris.firstOwner(targetToken).id, 'How would you like to contest the grapple?');
    if (selection) {
        let sourceRoll = await workflow.actor.rollSkill('ath');
        let targetRoll = await chris.rollRequest(targetToken, 'skill', selection);
        if (targetRoll.total >= sourceRoll.total) return;
    }
    if(game.modules.get('Rideable')?.active) {
        game.Rideable.Mount([targetToken.document], workflow.token.document, {'Grappled': true, 'MountingEffectsOverride': ['Grappled']});
    } else {
        await chris.addCondition(targetActor, 'Grappled', false, workflow.item.uuid);
    }
}
;// CONCATENATED MODULE: ./scripts/macros/actions/help.js

async function help({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    if (targetToken.id === workflow.token.id) return;
    let effectData;
    let targetDisposition = targetToken.document.disposition;
    let selfDisposition = workflow.token.document.disposition;
    if (targetDisposition === selfDisposition) {
        effectData = {
            'label': workflow.item.name,
            'icon': workflow.item.img,
            'origin': workflow.item.uuid,
            'duration': {
                'seconds': 3600
            },
            'changes': [
                {
                    'key': 'flags.midi-qol.advantage.ability.all',
                    'mode': 0,
                    'value': '1',
                    'priority': 20
                }
            ],
            'flags': {
                'dae': {
                    'transfer': false,
                    'specialDuration': [
                        'isSkill'
                    ],
                    'stackable': 'multi',
                    'macroRepeat': 'none'
                }
            }
        }
    } else {
        effectData = {
            'label': workflow.item.name,
            'icon': workflow.item.img,
            'origin': workflow.item.uuid,
            'duration': {
                'seconds': 12
            },
            'changes': [
                {
                    'key': 'flags.midi-qol.grants.advantage.attack.all',
                    'mode': 0,
                    'value': '1',
                    'priority': 20
                }
            ],
            'flags': {
                'dae': {
                    'transfer': false,
                    'specialDuration': [
                        'isAttacked',
                        'turnStartSource'
                    ],
                    'stackable': 'multi',
                    'macroRepeat': 'none'
                }
            }
        }
    }
    await chris.createEffect(targetToken.actor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/actions/nonLethal.js

async function nonLethal({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let validTypes = [
        'mwak',
        'msak'
    ];
    if (!validTypes.includes(workflow.item.system.actionType)) return;
    let targetActor = workflow.targets.first().actor;
    let effect = chris.findEffect(targetActor, 'Dead');
    if (!effect) return;
    if (!workflow.damageList.length) return;
    if (workflow.damageList[0].newHP != 0 || workflow.damageList[0].oldHP === 0) return;
    await chris.removeCondition(targetActor, 'Dead');
    await chris.addCondition(targetActor, 'Unconscious', true);
}
;// CONCATENATED MODULE: ./scripts/macros/actions/search.js

async function search({speaker, actor, token, character, item, args, scope, workflow}) {
    let selection = await chris.dialog('What Skill?', [['Perception', 'prc'], ['Investigation', 'inv']]);
    if (!selection) return;
    await workflow.actor.rollSkill(selection);
}
;// CONCATENATED MODULE: ./scripts/macros/actions/shove.js


async function shove({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let skipCheck = false;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    if (workflow.actor.uuid === targetActor.uuid) return;
    if ((chris.getSize(targetActor)) > (chris.getSize(actor) + 1)) {
        ui.notifications.info('Target is too big to shove!');
        return;
    }
    let effect = chris.findEffect(targetActor, 'Incapacitated');
    if (effect) skipCheck = true;
    if (!skipCheck) {
        let selection = await chris.remoteDialog(workflow.item.name, [[translate.skills('acr'), 'acr'], [translate.skills('ath'), 'ath'], ['Uncontested', false]], chris.firstOwner(targetToken).id, 'How would you like to contest the shove?');
        if (selection) {
            let sourceRoll = await workflow.actor.rollSkill('ath');
            let targetRoll = await chris.rollRequest(targetToken, 'skill', selection);
            if (targetRoll.total >= sourceRoll.total) return;
        }
    }
    let selection = await chris.dialog('What do you want to do?', [['Move', 'move'], ['Knock Prone', 'prone']]);
    if (!selection) return;
    if (selection === 'prone') {
        await chris.addCondition(targetActor, 'Prone', false, null);
        return;
    } else {
        let distance = 5;
        let knockBackFactor;
        let ray;
        let newCenter;
        let hitsWall = true;
        let targetToken = workflow.targets.first();
        while (hitsWall) {
            knockBackFactor = distance / canvas.dimensions.distance;
            ray = new Ray(workflow.token.center, targetToken.center);
            if (ray.distance === 0) {
                ui.notifications.info('Target is unable to be moved!');
                queue.remove(workflow.item.uuid);
                return;
            }
            newCenter = ray.project(1 + ((canvas.dimensions.size * knockBackFactor) / ray.distance));
            hitsWall = targetToken.checkCollision(newCenter, {origin: ray.A, type: "move", mode: "any"});
            if (hitsWall) {
                distance -= 5;
                if (distance === 0) {
                    ui.notifications.info('Target is unable to be moved!');
                    return;
                }
            }
        }
        newCenter = canvas.grid.getSnappedPosition(newCenter.x - targetToken.w / 2, newCenter.y - targetToken.h / 2, 1);
        let targetUpdate = {
            'token': {
                'x': newCenter.x,
                'y': newCenter.y
            }
        };
        let options2 = {
            'permanent': true,
            'name': workflow.item.name,
            'description': workflow.item.name
        };
        await warpgate.mutate(targetToken.document, targetUpdate, {}, options2);
    }
}
;// CONCATENATED MODULE: ./scripts/macros/actions/stealth.js
async function stealthCheck({speaker, actor, token, character, item, args, scope, workflow}) {
    await workflow.actor.rollSkill('ste');
}
;// CONCATENATED MODULE: ./scripts/macros/actions/underwater.js


async function underwater_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    switch (workflow.item.system.actionType) {
        case 'mwak':
            if (workflow.actor.system.attributes.movement.swim > 0) return;
            let validMeleeTypes = [
                'dagger',
                'javelin',
                'shortsword',
                'spear',
                'trident'
            ]
            if (validMeleeTypes.includes(workflow.item.system.baseItem)) return;
            break;;
        case 'rwak':
            let validRangedTypes = [
                'lightcrossbow',
                'handcrossbow',
                'heavycrossbow',
                'net',
                'javelin',
                'spear',
                'trident',
                'dart'
            ]
            if (validRangedTypes.includes(workflow.item.system.baseItem)) return;
            break;
        default:
            return;
    }
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'underwater', 1);
    if (!queueSetup) return;
    workflow.disadvantage = true;
    workflow.attackAdvAttribution.add('Disadvantage: Underwater');
    queue_queue.remove(workflow.item.uuid);
}
async function range({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    if (workflow.item.system.actionType != 'rwak') return;
    let distance = chris.getDistance(workflow.token, workflow.targets.first());
    if (distance <= workflow.item.system.range.value) return
    ui.notifications.info('Target is too far away while underwater!')
    return false;
}
let underwater = {
    'attack': underwater_attack,
    'range': range
}
;// CONCATENATED MODULE: ./scripts/macros/actions/actions.js









let actions = {
    'checkCover': checkCover,
    'fall': fall,
    'grapple': grapple,
    'nonLethal': nonLethal,
    'search': search,
    'shove': shove,
    'stealth': stealthCheck,
    'underwater': underwater,
    'help': help
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/barbarian/ancestralGuardian/ancestralProtectors.js



async function sourceAttack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let effect = chris.findEffect(workflow.actor, 'Rage');
    if (!effect) return;
    if (!constants_constants.attacks.includes(workflow.item.system.actionType)) return;
    let originItem = chris.getItem(workflow.actor, 'Ancestral Protectors');
    if (!originItem) return;
    let useFeature = chris.perTurnCheck(originItem, 'feature', 'ancestralProtectors', true, workflow.token.id);
    if (!useFeature) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'ancestralProtectors', 450);
    if (!queueSetup) return;
    let effectData = {
        'label': 'Ancestral Protectors Target',
        'icon': originItem.img,
        'origin': originItem.uuid,
        'duration': {
            'rounds': 2
        },
        'changes': [
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.ancestralProtectors.targetAttack,preAttackRoll',
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.ancestralProtectors.targetDamage,postDamageRoll',
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    'turnStartSource'
                ]
            }
        }
    };
    await chris.createEffect(workflow.targets.first().actor, effectData);
    await chris.setTurnCheck(originItem, 'feature', 'ancestralProtectors');
    queue_queue.remove(workflow.item.uuid);
}
async function targetAttack({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Ancestral Protectors Target');
    if (!effect) return;
    let origin = await fromUuid(effect.origin);
    if (!origin) return;
    let originActorUuid = origin.actor.uuid;
    let targetActorUuid = workflow.targets.first().actor.uuid;
    if (originActorUuid === targetActorUuid) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'ancestralProtectors', 50);
    if (!queueSetup) return;
    workflow.disadvantage = true;
    workflow.attackAdvAttribution.add('Disadvantage: Ancestral Protectors');
    queue_queue.remove(workflow.item.uuid);
}
async function targetDamage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let effect = chris.findEffect(workflow.actor, 'Ancestral Protectors Target');
    if (!effect) return;
    let origin = await fromUuid(effect.origin);
    if (!origin) return;
    let originActorUuid = origin.actor.uuid;
    let targetActorUuid = workflow.targets.first().actor.uuid;
    if (originActorUuid === targetActorUuid) return;
    let queueSetup =  await queue_queue.setup(workflow.item.uuid, 'ancestralProtectors', 475);
    if (!queueSetup) return;
    let damageFormula = 'floor((' + workflow.damageRoll._formula + ') / 2)';
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function ancestralProtectors_combatEnd(origin) {
    await chris.setTurnCheck(origin, 'feature', 'ancestralProtectors', true);
}
let ancestralProtectors = {
    'sourceAttack': sourceAttack,
    'targetAttack': targetAttack,
    'targetDamage': targetDamage,
    'combatEnd': ancestralProtectors_combatEnd
}
;// CONCATENATED MODULE: ./scripts/utility/summons.js


async function spawn(sourceActors, updates, duration, originItem, useActorOrigin = false, groupInitiative = false, maxRange, casterToken, spawnAnimation, callbacks) {
    async function effectMacro () {
        let summons = effect.flags['chris-premades']?.summons?.ids[effect.name];
        if (!summons) return;
        for (let i of summons) {await warpgate.dismiss(i)};
    }
    let effect = chris.findEffect(originItem.actor, originItem.name);
    if (!effect) {
        let casterEffectData = {
            'name': originItem.name,
            'icon': originItem.img,
            'duration': {
                'seconds': duration
            },
            'origin': originItem.uuid,
            'flags': {
                'effectmacro': {
                    'onDelete': {
                        'script': chris.functionToString(effectMacro)
                    }
                },
                'chris-premades': {
                    'vae': {
                        'button': 'Dismiss Summon'
                    }
                }
            }
        };
        if (useActorOrigin) casterEffectData.origin = originItem.actor.uuid;
        await chris.createEffect(originItem.actor, casterEffectData);
        effect = chris.findEffect(originItem.actor, originItem.name);
    }
    if (!effect) return;
    let effectData = {
        'name': 'Summoned Creature',
        'icon': originItem.img,
        'duration': {
            'seconds': duration
        },
        'origin': originItem.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': 'let effect = await fromUuid("' + effect.uuid + '"); if (effect) await chrisPremades.helpers.removeEffect(effect);'
                }
            },
            'chris-premades': {
                'vae': {
                    'button': 'Dismiss Summon'
                }
            }
        }
    };
    if (!updates) updates = {};
    setProperty(updates, 'embedded.ActiveEffect.Summoned Creature', effectData);
    let summonsIds = effect.flags['chris-premades']?.summons?.ids[originItem.name] ?? [];
    let overwriteInitiative = chris.getConfiguration(originItem, 'overwriteInitiative');
    let groupInitiativeValue;
    for (let i of sourceActors) {
        let updates2 = duplicate(updates);
        if (originItem.actor.flags['chris-premades']?.feature?.undeadThralls && originItem.system.school === 'nec') { // Undead Thralls automation
            let wizardLevels = originItem.actor.classes.wizard?.system?.levels;
            if (wizardLevels) {
                setProperty(updates2, 'actor.system.attributes.hp.formula', i.system.attributes.hp.formula + ' + ' + wizardLevels);
                setProperty(updates2, 'actor.system.bonuses.mwak.damage', originItem.actor.system.attributes.prof);
                setProperty(updates2, 'actor.system.bonuses.rwak.damage', originItem.actor.system.attributes.prof);
            }
        }
        let spawnedTokens = await chris.spawn(i, updates2, callbacks, casterToken, maxRange, spawnAnimation);
        if (!spawnedTokens) return;
        let spawnedToken = game.canvas.scene.tokens.get(spawnedTokens[0]);
        if (!spawnedToken) return;
        summonsIds.push(spawnedToken.id);
        if (chris.inCombat()) {
            let casterCombatant = game.combat.combatants.contents.find(combatant => combatant.actorId === originItem.actor.id);
            if (casterCombatant) {
                let initiative;
                if (groupInitiative) {
                    if (groupInitiativeValue) {
                        await socket.executeAsGM('createCombatant', spawnedToken.id, spawnedToken.actor.id, canvas.scene.id, groupInitiativeValue);
                    } else {
                        await socket.executeAsGM('createCombatant', spawnedToken.id, spawnedToken.actor.id, canvas.scene.id, null);
                        await spawnedToken.actor.rollInitiative();
                        groupInitiativeValue = spawnedToken.actor.initiative;
                    }
                } else if (game.settings.get('chris-premades', 'Tasha Initiative') != overwriteInitiative) {
                    initiative = casterCombatant.initiative - 0.01;
                    await socket.executeAsGM('createCombatant', spawnedToken.id, spawnedToken.actor.id, canvas.scene.id, initiative)
                } else {
                    await socket.executeAsGM('createCombatant', spawnedToken.id, spawnedToken.actor.id, canvas.scene.id, null);
                    await spawnedToken.actor.rollInitiative();
                }
            }
        }
    }
    let effectUpdates = {
        'flags': {
            'chris-premades': {
                'summons': {
                    'ids': {
                        [originItem.name]: summonsIds
                    }
                }
            }
        }
    }
    await chris.updateEffect(effect, effectUpdates);
}
let summons = {
    'spawn': spawn,
};
;// CONCATENATED MODULE: ./scripts/macros/spells/animateDead.js


async function animateDead({speaker, actor, token, character, item, args, scope, workflow}) {
    let zombieActor = game.actors.getName('CPR - Zombie');
    let skeletonActor = game.actors.getName('CPR - Skeleton');
    if (!zombieActor || !skeletonActor) {
        ui.notifications.warn('Missing required sidebar actor!');
        return;
    }
    let spellLevel = workflow.castData?.castLevel;
    if (!spellLevel) return;
    let totalSummons = 1 + (spellLevel - 3) * 2;
    if (workflow.actor.flags['chris-premades']?.feature?.undeadThralls) totalSummons += 1;
    if (!totalSummons || totalSummons < 1) return;
    let sourceActors = await chris.selectDocuments('Select Summons (Max ' + totalSummons + ')', [zombieActor, skeletonActor]);
    if (!sourceActors) return;
    if (sourceActors.length > totalSummons) {
        ui.notifications.info('Too many selected, try again!');
        return;
    }
    let updates =  {
        'token': {
            'disposition': 1 
        }
    }
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? ((chris.jb2aCheck() === 'patreon' && chris.aseCheck()) ? 'shadow' : 'none');
    await summons.spawn(sourceActors, updates, 86400, workflow.item, undefined, undefined, 10, workflow.token, animation);
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Animate Dead - Command', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Animate Dead - Command');
    let updates2 = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': workflow.item.name,
        'description': featureData.name
    };
    await warpgate.mutate(workflow.token.document, updates2, {}, options);
    let effect = chris.findEffect(workflow.actor, workflow.item.name);
    if (!effect) return;
    let currentScript = effect.flags.effectmacro?.onDelete?.script;
    if (!currentScript) return;
    let effectUpdates = {
        'flags': {
            'effectmacro': {
                'onDelete': { 
                    'script': currentScript + '; await warpgate.revert(token.document, "' + effect.name + '");'
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    await chris.updateEffect(effect, effectUpdates);
}
;// CONCATENATED MODULE: ./scripts/utility/tashaSummon.js



async function setupFolder() {
    let folder = game.folders.find(i => i.name === 'Chris Premades' && i.type === 'Actor');
    if (!folder) {
        folder = await Folder.create({
            'name': 'Chris Premades',
            'type': 'Actor',
            'color': '#348f2d'
        });
    }
    let summonsCompendium = game.packs.get('chris-premades.CPR Summons');
    if (!summonsCompendium) return;
    let documents = await summonsCompendium.getDocuments();
    if (documents.length === 0) return;
    for (let actor of documents) {
        let folderActor = folder.contents.find(act => act.name === actor.name);
        let avatarImg;
        let tokenImg;
        let imageFlags;
        if (folderActor) {
            let folderVersion = folderActor.flags['chris-premades']?.version;
            let documentVersion = actor.flags['chris-premades']?.version;
            if (folderVersion && folderVersion === documentVersion) continue;
            avatarImg = folderActor.img;
            tokenImg = folderActor.prototypeToken.texture.src;
            imageFlags = folderActor.flags['chris-premades']?.summon;
            await folderActor.delete();
        }
        let actorData = actor.toObject();
        actorData.folder = folder.id;
        if (avatarImg) actorData.img = avatarImg;
        if (tokenImg) actorData.prototypeToken.texture.src = tokenImg;
        if (imageFlags) actorData.flags['chris-premades'].summon = imageFlags;
        await Actor.create(actorData);
    }
}
function getCR(prof) {
    switch (prof) {
        case 2:
            return 0;
        case 3:
            return 5;
        case 4:
            return 9;
        case 5:
            return 13;
        case 6:
            return 17;
        case 7:
            return 21;
        case 8:
            return 25;
        case 9:
            return 29;
    }
}
async function tashaSummon_spawn(sourceActor, updates = {}, duration, originItem, maxRange, casterToken, spawnAnimation, callbacks) {
    async function effectMacro() {
        let originActor = origin.actor;
        await warpgate.dismiss(token.id);
        let castEffect = chrisPremades.helpers.findEffect(originActor, origin.name);
        if (castEffect) await chrisPremades.helpers.removeEffect(castEffect);
    }
    let effectData = {
        'name': 'Summoned Creature',
        'icon': originItem.img,
        'duration': {
            'seconds': duration
        },
        'origin': originItem.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': 'Dismiss Summon'
                }
            }
        }
    };
    if (!updates) updates = {};
    setProperty(updates, 'embedded.ActiveEffect.Summoned Creature', effectData);
    let spawnedTokens = await chris.spawn(sourceActor, updates, callbacks, casterToken, maxRange, spawnAnimation);
    if (!spawnedTokens) return;
    let spawnedToken = game.canvas.scene.tokens.get(spawnedTokens[0]);
    if (!spawnedToken) return;
    let targetEffect = chris.findEffect(spawnedToken.actor, 'Summoned Creature');
    if (!targetEffect) return;
    let casterEffectData = {
        'name': originItem.name,
        'icon': originItem.img,
        'duration': {
            'seconds': duration
        },
        'origin': originItem.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': 'let effect = await fromUuid("' + targetEffect.uuid + '"); if (effect) await chrisPremades.helpers.removeEffect(effect);'
                }
            },
            'chris-premades': {
                'vae': {
                    'button': 'Dismiss Summon'
                }
            }
        }
    };
    await chris.createEffect(originItem.actor, casterEffectData);
    if (chris.inCombat()) {
        let casterCombatant = game.combat.combatants.contents.find(combatant => combatant.actorId === originItem.actor.id);
        if (casterCombatant) {
            let initiative = casterCombatant.initiative - 0.01;
            await socket.executeAsGM('createCombatant', spawnedToken.id, spawnedToken.actor.id, canvas.scene.id, initiative);
        }
    }
    return spawnedToken;
}
async function createCombatant(tokenId, actorId, sceneId, initiative) {
    await game.combat.createEmbeddedDocuments('Combatant', [{
        'tokenId': tokenId,
        'sceneId': sceneId,
        'actorId': actorId,
        'hidden': false,
        'initiative': initiative
    }]);
}
async function meleeAttack({speaker, actor, token, character, item, args, scope, workflow}) {
    let attackBonus = workflow.actor.flags['chris-premades']?.summon?.attackBonus?.melee;
    if (!attackBonus) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'tashaMeleeAttack', 50);
    if (!queueSetup) return;
    let attackRoll = await chris.addToRoll(workflow.attackRoll, attackBonus);
    await workflow.setAttackRoll(attackRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function rangedAttack({speaker, actor, token, character, item, args, scope, workflow}) {
    let attackBonus = workflow.actor.flags['chris-premades']?.summon?.attackBonus?.ranged;
    if (!attackBonus) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'tashaRangedAttack', 50);
    if (!queueSetup) return;
    let attackRoll = await chris.addToRoll(workflow.attackRoll, attackBonus);
    await workflow.setAttackRoll(attackRoll);
    queue_queue.remove(workflow.item.uuid);
}
let tashaSummon = {
    'setupFolder': setupFolder,
    'getCR': getCR,
    'spawn': tashaSummon_spawn,
    'createCombatant': createCombatant,
    'meleeAttack': meleeAttack,
    'rangedAttack': rangedAttack
};
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/bard/collegeOfCreation/animatingPerformance.js


async function item({speaker, actor, token, character, item, args, scope, workflow}) {
    let selection = await chris.dialog('What item size?', [['Large', 'lg'], ['Medium', 'med'], ['Small', 'sm'], ['Tiny','tiny']]);
    if (!selection) return;
    let sourceActor = game.actors.getName('CPR - Dancing Item');
    if (!sourceActor) return;
    let irrpressibleFormData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Irrepressible Dance', false);
    if (!irrpressibleFormData) return;
    irrpressibleFormData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Irrepressible Dance');
    let immutableFormData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Immutable Form', false);
    if (!immutableFormData) return;
    immutableFormData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Immutable Form');
    let forceEmpoweredSlamData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Force-Empowered Slam', false);
    if (!forceEmpoweredSlamData) return;
    forceEmpoweredSlamData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Force-Empowered Slam');
    let dodgeData = await chris.getItemFromCompendium('chris-premades.CPR Actions', 'Dodge', false);
    if (!dodgeData) return;
    dodgeData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Dodge');
    let bardLevel = workflow.actor.classes?.bard?.system?.levels;
    if (!bardLevel) return;
    let hpFormula = 10 + 5 * bardLevel;
    let heightWidth;
    let scale;
    switch (selection) {
        case 'tiny': 
            scale = '0.5';
            heightWidth = '1';
            break;  
        case 'sm':
            scale = '0.8';
            heightWidth = '1';
            break;
        case 'med':
            scale = '1';
            heightWidth = '1';
            break;
        case 'lg':
            scale = '1';
            heightWidth = 2;
            break;
    }
    let name = chris.getConfiguration(workflow.item, 'name') ?? 'Dancing Item';
    if (name === '') name = 'Dancing Item';
    let meleeAttackBonus = await new Roll(workflow.actor.system.bonuses.msak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let rangedAttackBonus = await new Roll(workflow.actor.system.bonuses.rsak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'details': {
                    'cr': tashaSummon.getCR(workflow.actor.system.attributes.prof)
                },
                'attributes': {
                    'hp': {
                        'formula': hpFormula,
                        'max': hpFormula,
                        'value': hpFormula
                    }
                }
            },
            'prototypeToken': {
                'name': name,
                'disposition': workflow.token.document.disposition
            },
            'flags': {
                'chris-premades': {
                    'summon': {
                        'attackBonus': {
                            'melee': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.str.mod + meleeAttackBonus.total,
                            'ranged': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.str.mod + rangedAttackBonus.total
                        }
                    }
                }
            },
            'traits': {
                'size': selection
            },
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition,
            'height': heightWidth,
            'width': heightWidth,
            'texture': {
                'scaleX': scale,
                'scaleY': scale
            }
        },
        'embedded': {
            'Item': {
                [irrpressibleFormData.name]: irrpressibleFormData,
                [immutableFormData.name]: immutableFormData,
                [forceEmpoweredSlamData.name]: forceEmpoweredSlamData,
                [dodgeData.name]: dodgeData,
            }
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar');
    if (avatarImg) updates.actor.img = avatarImg;
    let tokenImg = chris.getConfiguration(workflow.item, 'token');
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? (chris.jb2aCheck() === 'patreon' && chris.aseCheck()) ? 'default' : 'none';
    await tashaSummon.spawn(sourceActor, updates, 3600, workflow.item, 30, workflow.token, animation);
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Animating Performance - Command', false);
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Animating Performance - Command');
    if (!featureData) return;
    let updates2 = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Dancing Item',
        'description': featureData.name
    };
    await warpgate.mutate(workflow.token.document, updates2, {}, options);
    let effect = chris.findEffect(workflow.actor, 'Animating Performance');
    if (!effect) return;
    let currentScript = effect.flags.effectmacro?.onDelete?.script;
    if (!currentScript) return;
    let effectUpdates = {
        'flags': {
            'effectmacro': {
                'onDelete': { 
                    'script': currentScript + ' await warpgate.revert(token.document, "Dancing Item");'
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    await chris.updateEffect(effect, effectUpdates);
}
async function irrepressibleDance(token, origin) {
    if (token.actor.system.attributes.hp.value === 0) return;
    if (!game.combat.current.tokenId) return;
    let targetToken = game.canvas.tokens.get(game.combat.current.tokenId);
    if (!targetToken) return;
    if (targetToken.id === token.id) return;
    let distance = chris.getDistance(token, targetToken);
    if (distance > 10) return;
    let speedValue = 10;
    let disposition = targetToken.document.disposition;
    if (disposition === -1) speedValue = -10;
    let effect = chris.findEffect(targetToken.actor, 'Irrepressible Dance');
    if (effect) await chris.removeEffect(effect);
    let effectData = {
        'label': 'Irrepressible Dance',
        'icon': origin.img,
        'origin': origin.uuid,
        'duration': {
            'turns': 1
        },
        'changes': [
            {
                'key': 'system.attributes.movement.walk',
                'mode': 2,
                'value': speedValue,
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    'combatEnd'
                ],
                'stackable': 'none',
                'macroRepeat': 'none'
            }
        }
    }
    await chris.createEffect(targetToken.actor, effectData);
}
let animatingPerformance = {
    'item': item,
    'irrepressibleDance': irrepressibleDance,
}
;// CONCATENATED MODULE: ./scripts/macros/spells/antagonize.js


async function antagonize({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.failedSaves.size) return;
    let targetToken = workflow.targets.first();
    let reaction = chris.findEffect(targetToken.actor, 'Reaction');
    let nearbyTargets;
    if (!reaction) {
        nearbyTargets = chris.findNearby(targetToken, 5, 'ally', true);
    }
    if (reaction || !nearbyTargets.length) {
        let effectData = {
            'label': workflow.item.name,
            'icon': workflow.item.img,
            'origin': workflow.item.uuid,
            'duration': {
                'seconds': 12
            },
            'changes': [
                {
                    'key': 'flags.midi-qol.disadvantage.attack.all',
                    'mode': 0,
                    'value': '1',
                    'priority': 20
                }
            ],
            'flags': {
                'dae': {
                    'specialDuration': [
                        'turnStartSource',
                        '1Attack'
                    ]
                }
            }
        }
        await chris.createEffect(targetToken.actor, effectData);
    } else {
        let weapons = targetToken.actor.items.filter(i => i.type === 'weapon' && i.system.equipped);
        let weapon;
        if (!weapons.length) {
            chris.remoteDialog(workflow.item.name, [['Ok', true]], chris.lastGM(), 'Target does not have any weapons equipped!');
            return;
        } else if (weapons.length === 1) {
            weapon = weapons[0];
        } else {
            await chris.gmDialogMessage();
            [weapon] = await chris.remoteDocumentDialog(chris.lastGM(), 'What weapon is used to attack?', weapons);
            await chris.clearGMDialogMessage();
            if (!weapon) return;
        }
        let target;
        if (nearbyTargets.length === 1) {
            target = nearbyTargets[0].document;
        } else {
            let selection = await chris.selectTarget(workflow.item.name, constants_constants.okCancel, nearbyTargets, true, 'one', false, false, 'Who gets attacked?');
            if (!selection.buttons) return;
            let targetUuid = selection.inputs.find(i => i);
            if (!targetUuid) return;
            target = await fromUuid(targetUuid);
        }
        let [config , options] = constants_constants.syntheticItemWorkflowOptions([target.uuid]);
        await warpgate.wait(100);
        let test = await chris.remoteRollItem(weapon, config, options, chris.firstOwner(target).id);
        console.log(test);
    }
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/artificer/battleSmith/arcaneJolt.js


async function arcaneJolt_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (workflow.item.system?.properties?.mgc !== true && workflow.item.name !== 'Force-Empowered Rend') return;
    let effect = chris.findEffect(workflow.actor, 'Arcane Jolt');
    if (!effect) return;
    let originFeature = await fromUuid(effect.origin);
    if (!originFeature) return;
    let scale = workflow.actor.system?.scale?.['battle-smith']?.['arcane-jolt'].formula; 
    if (!scale) {
        scale = workflow.actor.flags['chris-premades']?.feature?.arcaneJoltScale;
        if (!scale) return;
    }
    if (chris.inCombat()) {
        let turnCheck = chris.perTurnCheck(originFeature, 'feature', 'arcaneJolt', false);
        if (!turnCheck) return;
    }
    let selection = await chris.dialog('Use Arcane Jolt?', [['Yes', true], ['No', false]]);
    if (!selection) return;
    if (selection === false) return;
    let selection2 = await chris.dialog('Harm or Heal?', [['Harm', 'harm'], ['Heal', 'heal']]);
    if (!selection2) return;
    if (selection2 === 'harm') {
        let queueSetup = await queue_queue.setup(workflow.item.uuid, 'arcaneJolt', 250);
        if (!queueSetup) return;
        if (chris.inCombat()) await originFeature.setFlag('chris-premades', 'feature.arcaneJolt.turn', game.combat.round + '-' + game.combat.turn);
        let bonusDamageFormula = scale + '[force]';
        if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
        let damageFormula = workflow.damageRoll._formula + ' + ' + bonusDamageFormula;
        let damageRoll = await new Roll(damageFormula).roll({async: true});
        await workflow.setDamageRoll(damageRoll);
        await originFeature.use();
        queue_queue.remove(workflow.item.uuid);
    }
    if (selection2 === 'heal') {
        let targetToken = workflow.targets.first();
        let nearbyTargets = chris.findNearby(targetToken, 30, 'enemy');
        if (nearbyTargets.length === 0) return;
        let buttons = [
            {
                'label': 'Yes',
                'value': true
            }, {
                'label': 'No',
                'value': false
            }
        ];
        let queueSetup = await queue_queue.setup(workflow.item.uuid, 'arcaneJolt', 450);
        if (!queueSetup) return;
        if (chris.inCombat()) await originFeature.setFlag('chris-premades', 'feature.arcaneJolt.turn', game.combat.round + '-' + game.combat.turn);
        let selected = await chris.selectTarget('Who to heal?', buttons, nearbyTargets, true, 'one');
        if (selected.buttons === false) {
            queue_queue.remove(workflow.item.uuid);
            return;
        }
        let healTargetTokenUuid = selected.inputs.find(id => id != false);
        if (!healTargetTokenUuid) {
            queue_queue.remove(workflow.item.uuid);
            return;
        }
        let healTargetToken = await fromUuid(healTargetTokenUuid);
        let damageDice = scale + '[healing]';
        let diceRoll = await new Roll(damageDice).roll({async: true});
        await chris.applyWorkflowDamage(workflow.token, diceRoll, 'healing', [healTargetToken], workflow.item.name, workflow.itemCardId);
        await originFeature.use();
        queue_queue.remove(workflow.item.uuid);
    }
}
async function updateUses({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (workflow.actor.type === 'character') {
        let effect = chris.findEffect(workflow.actor, 'Arcane Jolt');
        if (!effect) return;
        let originFeature = await fromUuid(effect.origin);
        if (!originFeature) return;
        let effect2 = chris.findEffect(workflow.actor, 'Steel Defender');
        if (!effect2) return;
        let spawnedTokenUuid = effect2.flags?.['chris-premades']?.feature?.steelDefender?.spawnedTokenUuid;
        if (!spawnedTokenUuid) return;
        let spawnedToken = await fromUuid(spawnedTokenUuid);
        if (!spawnedToken) return;
        let spawnedItem = spawnedToken.actor.items.getName('Arcane Jolt');
        if (!spawnedItem) return;
        await spawnedItem.update({'system.uses.value': originFeature.system?.uses?.value});
    }
    if (workflow.actor.type === 'npc') {
        let effect3 = chris.findEffect(workflow.actor, 'Summoned Creature');
        if (!effect3) return;
        let origin = await fromUuid(effect3.origin);
        if (!origin) return;
        let itemToUpdate = origin.actor.items.getName('Arcane Jolt');
        if (!itemToUpdate) return;
        let originItem = workflow.actor.items.getName('Arcane Jolt');
        if (!originItem) return;
        await itemToUpdate.update({'system.uses.value': originItem.system?.uses?.value});
    }
}
async function arcaneJolt_combatEnd(origin) {
    await origin.setFlag('chris-premades', 'feature.arcaneJolt.turn', '');
}
let arcaneJolt = {
    'item': arcaneJolt_item,
    'updateUses': updateUses,
    'combatEnd': arcaneJolt_combatEnd,
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/wizard/schoolOfAbjuration/arcaneWard.js



async function arcaneWard_damage(targetToken, {workflow, ditem}) {
    if (ditem.newHP >= ditem.oldHP) return;
    async function check(target) {
        let effect = chris.findEffect(target.actor, 'Arcane Ward');
        if (!effect) return;
        if (!effect.origin) return;
        let originItem = await fromUuid(effect.origin);
        if (!originItem) return;
        let uses = originItem.system.uses.value;
        if (uses === 0) return;
        let absorbed = Math.min(ditem.appliedDamage, uses);
        let keptDamage = ditem.appliedDamage - absorbed;
        if (ditem.oldTempHP > 0) {
            if (keptDamage > ditem.oldTempHP) {
                ditem.newTempHP = 0;
                keptDamage -= ditem.oldTempHP;
                ditem.tempDamage = ditem.oldTempHP;
            } else {
                ditem.newTempHP = ditem.oldTempHP - keptDamage;
                ditem.tempDamage = keptDamage;
            }
        }
        let maxHP = target.actor.system.attributes.hp.max;
        ditem.hpDamage = Math.clamped(keptDamage, 0, maxHP);
        ditem.newHP = Math.clamped(ditem.oldHP - keptDamage, 0, maxHP);
        ditem.appliedDamage = keptDamage;
        ditem.totalDamage = keptDamage;
        let updates = {
            'embedded': {
                'Item': {
                    [originItem.name]: {
                        'system.uses.value': uses - absorbed
                    }
                }
            }
        };
        let options = {
            'permanent': true,
            'name': originItem.name,
            'description': originItem.name
        };
        await warpgate.mutate(target.document, updates, {}, options);
        return true;
    }
    let queueSetup = await queue_queue.setup(workflow.uuid, 'arcaneWard', 350);
    if (!queueSetup) return;
    if (targetToken.actor.classes?.wizard?.subclass?.system?.identifier === 'school-of-abjuration') {
        let shielded = await check(targetToken);
        if (shielded) {
            queue_queue.remove(workflow.uuid);
            return;
        }
    }
    let tokens = chris.findNearby(targetToken, 30, 'ally').filter(i => i.actor.classes?.wizard?.subclass?.system?.identifier === 'school-of-abjuration' && i.actor.classes?.wizard?.system?.levels >= 6 && !chris.findEffect(i.actor, 'Reaction'));
    if (tokens.length === 0) {
        queue_queue.remove(workflow.uuid);
        return;
    }
    for (let token of tokens) {
        let firstOwner = chris.firstOwner(token);
        await chris.thirdPartyReactionMessage(firstOwner);
        let message = 'Protect ' + targetToken.actor.name + ' with your arcane ward?';
        if (firstOwner.isGM) message = '[' + token.actor.name + '] ' + message;
        let selection = await chris.remoteDialog('Arcane Ward', constants_constants.yesNo, firstOwner.id, message);
        if (!selection) continue;
        let shielded = check(token);
        if (shielded) {
            await chris.addCondition(token.actor, 'Reaction', false);
            let effect = chris.findEffect(token.actor, 'Projected Ward');
            if (!effect) break;
            if (!effect.origin) break;
            let originItem = await fromUuid(effect.origin);
            if (!originItem) break;
            await originItem.use();
        }
    }
    await chris.clearThirdPartyReactionMessage();
    queue_queue.remove(workflow.uuid);
}
async function spell({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.item.type != 'spell') return;
    if (workflow.item.system.school != 'abj') return;
    if (workflow.castData.castLevel === 0) return;
    let effect = chris.findEffect(workflow.actor, 'Arcane Ward');
    if (!effect) return;
    if (!effect.origin) return;
    let originItem = await fromUuid(effect.origin);
    if (!originItem) return;
    let maxUses = workflow.actor.classes.wizard.system.levels * 2 + workflow.actor.system.abilities.int.mod;
    let add = workflow.castData.castLevel * 2;
    if (!originItem.flags['chris-premades']?.feature?.arcaneWard?.firstUse) {
        add = maxUses;
        await originItem.setFlag('chris-premades', 'feature.arcaneWard.firstUse', true);
    }
    let uses = originItem.system.uses.value;
    let updates = {
        'embedded': {
            'Item': {
                [originItem.name]: {
                    'system.uses.value': Math.clamped(uses + add, 0, maxUses),
                    'system.uses.max': maxUses
                }
            }
        }
    };
    let options = {
        'permanent': true,
        'name': originItem.name,
        'description': originItem.name
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
async function longRest(actor, data) {
    let effect = chris.findEffect(actor, 'Arcane Ward');
    if (!effect) return;
    if (!effect.origin) return;
    let originItem = await fromUuid(effect.origin);
    if (!originItem) return;
    await originItem.update({
        'system.uses.value': 0,
        'system.uses.max': actor.classes.wizard.system.levels * 2 + actor.system.abilities.int.mod,
        'flags.chris-premades.feature.arcaneWard.firstUse': false
    });
}
let arcaneWard = {
    'damage': arcaneWard_damage,
    'spell': spell,
    'longRest': longRest
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/artificer/armorer/armorModel.js


async function guardianArmor({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Arcane Armor: Guardian Model');
    if (effect) return;
    let feature = chris.getItem(workflow.actor, 'Infiltrator Armor: Lightning Launcher');
    if (feature) {
        await feature.delete();
    }
    let fieldUses = workflow.actor.flags['chris-premades']?.feature?.defensiveField;
    if (!fieldUses) fieldUses = workflow.actor.system.attributes.prof;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Guardian Armor: Defensive Field', false);
    let featureData2 = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Guardian Armor: Thunder Gauntlets', false);
    if (!featureData || !featureData2) return;
    featureData.system.uses.value = fieldUses;
    featureData.system.uses.max = workflow.actor.system.attributes.prof;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Guardian Armor: Defensive Field');
    setProperty(featureData, 'flags.chris-premades.info.name', 'Guardian Armor: Defensive Field');
    setProperty(featureData2, 'flags.chris-premades.info.name', 'Guardian Armor: Thunder Gauntlets')
    featureData2.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Guardian Armor: Thunder Gauntlets');
    await workflow.actor.createEmbeddedDocuments('Item', [featureData, featureData2]);
    let effectData = {
        'name': 'Arcane Armor: Guardian Model',
        'icon': workflow.item.img,
        'origin': workflow.item.uuid
    };
    await chris.createEffect(workflow.actor, effectData);
    let effect2 = chris.findEffect(workflow.actor, 'Arcane Armor: Infiltrator Model');
    if (effect2) await effect2.delete();
}
async function infiltratorArmor({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Arcane Armor: Infiltrator Model');
    if (effect) return;
    let feature = chris.getItem(workflow.actor, 'Guardian Armor: Defensive Field');
    if (feature) {
        workflow.actor.setFlag('chris-premades', 'feature.defensiveField', feature.system.uses.value);
        await feature.delete();
    }
    let feature2 = workflow.actor.items.getName('Guardian Armor: Thunder Gauntlets');
    if (feature2) {
        await feature2.delete();
    }
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Infiltrator Armor: Lightning Launcher', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Infiltrator Armor: Lightning Launcher');
    setProperty(featureData, 'flags.chris-premades.info.name', 'Infiltrator Armor: Lightning Launcher');
    await workflow.actor.createEmbeddedDocuments('Item', [featureData]);
    let effectData = {
        'name': 'Arcane Armor: Infiltrator Model',
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'changes': [
            {
                'key': 'system.attributes.movement.walk',
                'value': '+5',
                'mode': 2,
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.advantage.skill.ste',
                'value': 1,
                'mode': 0,
                'priority': 20
            }
        ]
    };
    await chris.createEffect(workflow.actor, effectData);
    let effect2 = chris.findEffect(workflow.actor, 'Arcane Armor: Guardian Model');
    if (effect2) await effect2.delete();
}
async function lightningLauncher({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || workflow.isFumble) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'lightningLauncher', 50);
    if (!queueSetup) return;
    let doExtraDamage = chris.perTurnCheck(workflow.item, 'feature', 'lightningLauncher', true, workflow.token.id);
    if (!doExtraDamage) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let selection = await chris.dialog('Lightning Launcher: Apply extra lightning damage?', [['Yes', true], ['No', false]]);
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    if (chris.inCombat()) await workflow.item.setFlag('chris-premades', 'feature.lightningLauncher.turn', game.combat.round + '-' + game.combat.turn);
    let bonusDamageFormula = '1d6[lightning]';
    if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
    let damageFormula = workflow.damageRoll._formula + ' + ' + bonusDamageFormula;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function thunderGauntlets({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1 || workflow.disadvantage) return;
    let effect = chris.findEffect(workflow.actor, 'Thunder Gauntlets');
    if (!effect) return;
    let origin = await fromUuid(effect.origin);
    if (!origin) return;
    let originActorUuid = origin.actor.uuid;
    let targetActorUuid = workflow.targets.first().actor.uuid;
    if (originActorUuid === targetActorUuid) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'thunderGauntlets', 50);
    if (!queueSetup) return;
    workflow.disadvantage = true;
    workflow.attackAdvAttribution.add('Disadvantage: Thunder Gauntlets');
    queue_queue.remove(workflow.item.uuid);
}
async function armorModel_longRest(actor, data) {
    if (!data.longRest) return;
    let item = actor.items.getName('Armorer');
    if (!item) return;
    if (item.type != 'subclass') return;
    actor.setFlag('chris-premades', 'feature.defensiveField', actor.system.attributes.prof);
}
let armorModel = {
    'guardianArmor': guardianArmor,
    'infiltratorArmor': infiltratorArmor,
    'lightningLauncher': lightningLauncher,
    'thunderGauntlets': thunderGauntlets,
    'longRest': armorModel_longRest
}
;// CONCATENATED MODULE: ./scripts/macros/spells/armorOfAgathys.js




async function onHit(workflow, targetToken) {
    if (workflow.hitTargets.size != 1) return;
    if (!constants_constants.meleeAttacks.includes(workflow.item?.system?.actionType)) return;
    let effect = chris.findEffect(targetToken.actor, 'Armor of Agathys');
    if (!effect) return;
    let damage = effect.flags['midi-qol'].castData.castLevel * 5;
    let queueSetup = await queue_queue.setup(workflow.uuid, 'armorOfAgathys', 50);
    if (!queueSetup) return;
    let tempHP = targetToken.actor.system.attributes.hp.temp;
    if (tempHP === 0) await chris.removeEffect(effect);
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Armor of Agathys - Reflect');
    if (!featureData) {
        queue_queue.remove(workflow.uuid);
        return;
    }
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Armor of Agathys - Reflect');
    delete featureData._id;
    featureData.system.damage.parts[0][0] = damage + '[' + translate.damageType('cold') + ']';
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': targetToken.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.token.document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature, config, options);
    queue_queue.remove(workflow.uuid);
    //Animations by: eskiemoh
    new Sequence()
        .effect()
        .file('jb2a.impact.004.blue')
        .atLocation(targetToken)
        .rotateTowards(workflow.token)
        .scaleToObject(1.45)
        .spriteScale({'x': 0.75, 'y': 1.0 })
        .filter('ColorMatrix', {'saturate': -0.75, 'brightness': 1.5})
        .spriteOffset({'x': -0.15}, {'gridUnits': true})

        .effect()
        .atLocation(targetToken)
        .file('jb2a.side_impact.part.fast.ice_shard.blue')
        .rotateTowards(workflow.token)
        .scaleToObject(2)
        .randomizeMirrorY()
        .zIndex(2)

        .effect()
        .from(workflow.token)
        .atLocation(workflow.token)
        .fadeIn(100)
        .fadeOut(100)
        .loopProperty('sprite', 'position.x', {'from': -0.05, 'to': 0.05, 'duration': 175, 'pingPong': true, 'gridUnits': true})
        .scaleToObject(workflow.token.document.texture.scaleX)
        .duration(500)
        .opacity(0.15)

        .play()
}
async function start(token) {
    if (chris.jb2aCheck() != 'patreon') return;
    //Animations by: eskiemoh
    new Sequence()
        .effect()
        .file('jb2a.ward.rune.dark_purple.01')
        .atLocation(token)
        .scaleToObject(1.85)
        .belowTokens()
        .fadeOut(3000)
        .scaleIn(0, 500, {'ease': 'easeOutCubic'})
        .filter('ColorMatrix', {'brightness': 2, 'saturate': -0.75, 'hue': -75})
        
        .effect()
        .attachTo(token)
        .delay(250)
        .file('jb2a.magic_signs.rune.02.complete.06.blue')
        .scaleToObject(0.75 * token.document.texture.scaleX)
        .scaleIn(0, 500, {'ease': 'easeOutCubic'})
        .playbackRate(2.5)
        .opacity(1)
        .zIndex(3)
        
        .effect()
        .attachTo(token)
        .file('jb2a.extras.tmfx.border.circle.inpulse.01.fast')
        .scaleToObject(1.5 * token.document.texture.scaleX)
        .opacity(1)
        .zIndex(3)
        
        .effect()
        .attachTo(token)
        .name('Armor of Agathys')
        .file('jb2a.extras.tmfx.inflow.circle.01')
        .scaleToObject(1 * token.document.texture.scaleX)
        .randomRotation()
        .fadeIn(1500)
        .fadeOut(500)
        .opacity(0.9)
        .zIndex(2)
        .extraEndDuration(1500)
        .private()
        .persist()
        
        .effect()
        .attachTo(token)
        .name('Armor of Agathys')
        .file('jb2a.extras.tmfx.outflow.circle.01')
        .scaleToObject(1.35 * token.document.texture.scaleX)
        .randomRotation()
        .fadeIn(1500)
        .fadeOut(500)
        .scaleIn(0, 1500, {'ease': 'easeOutCubic'})
        .belowTokens()
        .opacity(0.9)
        .extraEndDuration(1500)
        .zIndex(1)
        .private()
        .persist()
        
        .effect()   
        .attachTo(token)
        .name('Armor of Agathys')
        .file('jb2a.template_circle.symbol.normal.snowflake.blue')
        .scaleToObject(1.35 * token.document.texture.scaleX)
        .randomRotation()
        .fadeIn(1500)
        .fadeOut(500)
        .scaleIn(0, 1500, {'ease': 'easeOutCubic'})
        .belowTokens()
        .opacity(0.75)
        .extraEndDuration(1500)
        .zIndex(2)
        .private()
        .persist()
        
        .effect()
        .attachTo(token)
        .name('Armor of Agathys')
        .file('jb2a.shield.01.loop.blue')
        .scaleToObject(1.5 * token.document.texture.scaleX)
        .opacity(0.75)
        .fadeIn(1500)
        .fadeOut(500)
        .zIndex(1)
        .persist()
        
        .waitUntilFinished(-1000)
        .play();
}
async function end(token) {
    if (chris.jb2aCheck() != 'patreon') return;
    Sequencer.EffectManager.endEffects({'name': 'Armor of Agathys', 'object': token});
    new Sequence()
        .effect()
        .attachTo(token)
        .file('jb2a.shield.01.outro_explode.blue')
        .scaleToObject(1.5 * token.document.texture.scaleX)
        .opacity(0.75)
        .fadeOut(500)
        .zIndex(1)

        .play()
}
let armorOfAgathys = {
    'onHit': onHit,
    'start': start,
    'end': end
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/artificer/infusions/armorOfMagicalStrength.js

async function armorOfMagicalStrength({speaker, actor, token, character, item, args, scope, workflow}) {
    await chris.removeCondition(workflow.actor, 'Prone');
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/paladin/oathOfGlory/auraOfAlacrity.js

async function auraOfAlacrity(token, origin) {
    let targetToken = game.canvas.tokens.get(game.combat.current.tokenId);
    if (!targetToken) return;
    if (targetToken.id === token.id) return;
    if (targetToken.document.disposition != token.document.disposition) return;
    let distance = chris.getDistance(token, targetToken);
    let auraDistance = 5;
    if (token.actor.classes.paladin?.system?.levels >= 18) auraDistance = 10;
    if (distance > auraDistance) return;
    let effect = chris.findEffect(targetToken.actor, 'Aura of Alacrity');
    if (effect) await chris.removeEffect(effect);
    let effectData = {
        'label': 'Aura of Alacrity',
        'icon': origin.img,
        'origin': origin.uuid,
        'duration': {
            'turns': 1
        },
        'changes': [
            {
                'key': 'system.attributes.movement.walk',
                'mode': 2,
                'value': '+10',
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'aura': true,
                'effect': {
                    'noAnimation': true
                }
            }
        }
    }
    await chris.createEffect(targetToken.actor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/paladin/auraOfCourage.js

async function auraOfCourage(token, selectedAura) {
    let originToken = await fromUuid(selectedAura.tokenUuid);
    let originActor = originToken.actor;
    if (!originActor) return;
    let auraEffect = chris.findEffect(originActor, 'Aura of Courage - Aura');
    if (!auraEffect) return;
    let originItem = await fromUuid(auraEffect.origin);
    if (!originItem) return;
    let effectData = {
        'name': 'Aura of Courage',
        'icon': originItem.img,
        'origin': originItem.uuid,
        'duration': {
            'seconds': 604800
        },
        'changes': [
            {
                'key': 'system.traits.ci.value',
                'mode': 0,
                'value': 'frightened',
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'aura': true,
                'effect': {
                    'noAnimation': true
                }
            }
        }
    }
    let effect = chris.findEffect(token.actor, effectData.name);
    if (effect?.origin === effectData.origin) return;
    if (effect) chris.removeEffect(effect);
    await chris.createEffect(token.actor, effectData);
    let frightenedEffect = chris.findEffect(token.actor, 'Frightened');
    if (frightenedEffect) chris.removeEffect(frightenedEffect);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/paladin/oathOfDevotion/auraOfDevotion.js

async function auraOfDevotion(token, selectedAura) {
    let originToken = await fromUuid(selectedAura.tokenUuid);
    if (!originToken) return;
    let originActor = originToken.actor;
    let auraEffect = chris.findEffect(originActor, 'Aura of Devotion - Aura');
    if (!auraEffect) return;
    let originItem = await fromUuid(auraEffect.origin);
    if (!originItem) return;
    let effectData = {
        'name': 'Aura of Devotion',
        'icon': originItem.img,
        'origin': originItem.uuid,
        'duration': {
            'seconds': 604800
        },
        'changes': [
            {
                'key': 'system.traits.ci.value',
                'mode': 0,
                'value': 'charmed',
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'aura': true,
                'effect': {
                    'noAnimation': true
                }
            }
        }
    }
    let effect = chris.findEffect(token.actor, effectData.name);
    if (effect?.origin === effectData.origin) return;
    if (effect) chris.removeEffect(effect);
    await chris.createEffect(token.actor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/paladin/oathbreaker/auraOfHate.js

async function aura(token, selectedAura) {
    let originToken = await fromUuid(selectedAura.tokenUuid);
    if (!originToken) return;
    let originActor = originToken.actor;
    let auraEffect = chris.findEffect(originActor, 'Aura of Hate - Aura');
    if (!auraEffect) return;
    let originItem = await fromUuid(auraEffect.origin);
    if (!originItem) return;
    let effectData = {
        'name': 'Aura of Hate',
        'icon': originItem.img,
        'origin': originItem.uuid,
        'duration': {
            'seconds': 604800
        },
        'changes': [
            {
                'key': 'system.bonuses.mwak.damage',
                'mode': 2,
                'value': '+ ' + selectedAura.castLevel,
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'aura': true,
                'effect': {
                    'noAnimation': true
                }
            }
        }
    };
    let effect = chris.findEffect(token.actor, effectData.name);
    if (effect?.origin === effectData.origin) return;
    if (effect) chris.removeEffect(effect);
    await chris.createEffect(token.actor, effectData);
}
async function special(sourceToken, targetToken) {
    if (sourceToken.disposition === targetToken.disposition) return true;
    let validTypes = [
        'undead',
        'fiend'
    ];
    if (validTypes.includes(chris.raceOrType(targetToken.actor))) return true;
    return false;
}
let auraOfHate = {
    'aura': aura,
    'special': special
}
;// CONCATENATED MODULE: ./scripts/macros/spells/auraOfLife.js


async function auraOfLife_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let flagAuras = {
        'auraOfLife': {
            'name': 'auraOfLife',
            'castLevel': workflow.castData.castLevel,
            'range': 30,
            'disposition': 'ally',
            'effectName': 'Aura of Life',
            'macroName': 'auraOfLife'
        }
    }
    effectAuras.add(flagAuras, workflow.token.document.uuid, true);
}
async function auraOfLife_end(token) {
    effectAuras.remove('auraOfLife', token.document.uuid);
}
function auraOfLife_effect(effect, updates, options, user) {
    if (!updates.changes || !effect.parent) return;
    if (updates.changes.length === 0) return;
    if (effect.parent.constructor.name != 'Actor5e') return;
    if (!chris.findEffect(effect.parent, 'Aura of Life')) return;
    let changed = false;
    for (let i of updates.changes) {
        if (i.key != 'system.attributes.hp.tempmax') continue;
        let number = Number(i.value);
        if (isNaN(number) || number > 0) continue;
        i.value = 0;
        changed = true;
    }
    if (!changed) return;
    effect.updateSource({'changes': updates.changes});
}
async function auraOfLife_aura(token, selectedAura) {
    let originToken = await fromUuid(selectedAura.tokenUuid);
    if (!originToken) return;
    let originActor = originToken.actor;
    let auraEffect = chris.findEffect(originActor, 'Aura of Life - Aura');
    if (!auraEffect) return;
    let originItem = await fromUuid(auraEffect.origin);
    if (!originItem) return;
    let effectData = {
        'name': 'Aura of Life',
        'icon': originItem.img,
        'origin': originItem.uuid,
        'duration': {
            'seconds': 604800
        },
        'changes': [
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'value': 'necrotic',
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'aura': true,
                'effect': {
                    'noAnimation': true
                }
            }
        }
    };
    let effect = chris.findEffect(token.actor, effectData.name);
    if (effect?.origin === effectData.origin) return;
    if (effect) await chris.removeEffect(effect);
    await chris.createEffect(token.actor, effectData);
}
async function turns(token, origin) {
    let targetToken = game.canvas.tokens.get(game.combat.current.tokenId);
    if (!targetToken) return;
    let distance = chris.getDistance(token, targetToken);
    if (distance > 30) return;
    let effect = chris.findEffect(targetToken.actor, 'Aura of Life');
    if (!effect) return;
    if (effect.origin != origin.uuid) return;
    if (targetToken.actor.system.attributes.hp.value > 0) return;
    let deadEffect = chris.findEffect(targetToken.actor, 'Dead');
    if (deadEffect) return;
    await origin.displayCard();
    await chris.applyDamage([targetToken], 1, 'healing');
}
let auraOfLife = {
    'item': auraOfLife_item,
    'end': auraOfLife_end,
    'aura': auraOfLife_aura,
    'effect': auraOfLife_effect,
    'turns': turns
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/paladin/auraOfProtection.js

async function auraOfProtection(token, selectedAura) {
    let originToken = await fromUuid(selectedAura.tokenUuid);
    if (!originToken) return;
    let originActor = originToken.actor;
    let auraEffect = chris.findEffect(originActor, 'Aura of Protection - Aura');
    if (!auraEffect) return;
    let originItem = await fromUuid(auraEffect.origin);
    if (!originItem) return;
    let effectData = {
        'name': 'Aura of Protection',
        'icon': originItem.img,
        'origin': originItem.uuid,
        'duration': {
            'seconds': 604800
        },
        'changes': [
            {
                'key': 'system.bonuses.abilities.save',
                'mode': 2,
                'value': '+' + selectedAura.castLevel,
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'aura': true,
                'effect': {
                    'noAnimation': true
                }
            }
        }
    };
    let effect = chris.findEffect(token.actor, effectData.name);
    if (effect?.origin === effectData.origin) return;
    if (effect) chris.removeEffect(effect);
    await chris.createEffect(token.actor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/auraOfPurity.js


async function move(token, selectedAura) {
    let originToken = await fromUuid(selectedAura.tokenUuid);
    if (!originToken) return;
    let originActor = originToken.actor;
    let auraEffect = chris.findEffect(originActor, 'Aura of Purity - Aura');
    if (!auraEffect) return;
    let originItem = await fromUuid(auraEffect.origin);
    if (!originItem) return;
    let effectData = {
        'name': 'Aura of Purity',
        'icon': originItem.img,
        'origin': originItem.uuid,
        'duration': {
            'seconds': 604800
        },
        'changes': [
            {
                'key': 'system.traits.ci.value',
                'mode': 0,
                'value': 'diseased',
                'priority': 20
            },
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'value': 'poison',
                'priority': 20
            },
            {
                'key': 'flags.chris-premades.CR.blinded',
                'mode': 5,
                'value': '1',
                'priority': 20
            },
            {
                'key': 'flags.chris-premades.CR.charmed',
                'mode': 5,
                'value': '1',
                'priority': 20
            },
            {
                'key': 'flags.chris-premades.CR.deafened',
                'mode': 5,
                'value': '1',
                'priority': 20
            },
            {
                'key': 'flags.chris-premades.CR.frightened',
                'mode': 5,
                'value': '1',
                'priority': 20
            },
            {
                'key': 'flags.chris-premades.CR.paralyzed',
                'mode': 5,
                'value': '1',
                'priority': 20
            },
            {
                'key': 'flags.chris-premades.CR.poisoned',
                'mode': 5,
                'value': '1',
                'priority': 20
            },
            {
                'key': 'flags.chris-premades.CR.stunned',
                'mode': 5,
                'value': '1',
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'aura': true,
                'effect': {
                    'noAnimation': true
                }
            }
        }
    };
    let effect = chris.findEffect(token.actor, effectData.name);
    if (effect?.origin === effectData.origin) return;
    if (effect) await chris.removeEffect(effect);
    await chris.createEffect(token.actor, effectData);
}
async function auraOfPurity_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let flagAuras = {
        'auraOfPurity': {
            'name': 'auraOfPurity',
            'castLevel': workflow.castData.castLevel,
            'range': 30,
            'disposition': 'ally',
            'effectName': 'Aura of Purity',
            'macroName': 'auraOfPurity'
        }
    };
    effectAuras.add(flagAuras, workflow.token.document.uuid, true);
}
async function auraOfPurity_end(token) {
    effectAuras.remove('auraOfPurity', token.document.uuid);
}
let auraOfPurity = {
    'move': move,
    'item': auraOfPurity_item,
    'end': auraOfPurity_end
}
;// CONCATENATED MODULE: ./scripts/macros/spells/auraOfVitality.js

async function auraOfVitality({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Aura of Vitality Healing', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Aura of Vitality Healing');
    async function effectMacro () {
        await warpgate.revert(token.document, 'Aura of Vitality');
    }
    let effectData = {
        'name': 'Aura of Vitality',
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': effectData.name,
        'description': featureData.name,
        'origin': workflow.item.uuid
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/paladin/oathOfTheAncients/auraOfWarding.js

async function auraOfWarding(token, selectedAura) {
    let originToken = await fromUuid(selectedAura.tokenUuid);
    if (!originToken) return;
    let originActor = originToken.actor;
    let auraEffect = chris.findEffect(originActor, 'Aura of Warding - Aura');
    if (!auraEffect) return;
    let originItem = await fromUuid(auraEffect.origin);
    if (!originItem) return;
    let effectData = {
        'name': 'Aura of Warding',
        'icon': originItem.img,
        'origin': originItem.uuid,
        'duration': {
            'seconds': 604800
        },
        'changes': [
            {
                'key': 'system.traits.dr.custom',
                'mode': 2,
                'value': 'Magical Damage',
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'aura': true,
                'effect': {
                    'noAnimation': true
                }
            }
        }
    }
    let effect = chris.findEffect(token.actor, effectData.name);
    if (effect?.origin === effectData.origin) return;
    if (effect) chris.removeEffect(effect);
    await chris.createEffect(token.actor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/autognome/malfunction.js

async function malfunction(workflow, targetToken) {
    if (workflow.hitTargets.size === 0) return;
    if (targetToken.actor.system.attributes.hp.value === 0) return;
    let appliedDamage = workflow.damageList.find(i => i.tokenId === targetToken.id)?.appliedDamage;
    if (!appliedDamage) return;
    if (appliedDamage < 15) return;
    let roll = await new Roll('1d20').roll({async: true});
    let total = roll.total;
    let effect = chris.findEffect(targetToken.actor, 'Malfunction');
    if (!effect) return;
    if (!effect.origin) return;
    let originItem = await fromUuidSync(effect.origin);
    if (!originItem) return;
    let flavor = originItem.name + ': ';
    let effectData = {
        'label': originItem.name,
        'icon': originItem.img,
        'origin': originItem.uuid,
        'duration': {
            'seconds': 86400
        }
    }
    let magicalDay = false;
    if (10 > total) {
        flavor += 'All Fine Here!'
    } else if (13 > total) {
        flavor += 'My Mind Is Going. I Can Feel It.';
        effectData.duration.seconds = 60;
        setProperty(effectData, 'changes', [{
            'key': 'macro.CE',
            'value': 'Incapacitated',
            'mode': 0,
            'priority': 20
        }]);
    } else if (15 >  total) {
        flavor += 'You\'ve Disarmed Me!';
    } else if (17 > total) {
        flavor += 'Who Turned Out the Lights?';
        setProperty(effectData, 'changes', [{
            'key': 'macro.CE',
            'value': 'Blinded',
            'mode': 0,
            'priority': 20
        },
        {
            'key': 'macro.CE',
            'value': 'Deafened',
            'mode': 0,
            'priority': 20
        }]);
    } else {
        flavor += 'Have a Magical Day!';
        magicalDay = true;
    }
    roll.toMessage({
        'rollMode': 'roll',
        'speaker': {'alias': name},
        'flavor': flavor
    });
    if (total < 11) return;
    await chris.createEffect(targetToken.actor, effectData);
    if (!magicalDay) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Monster Feature Items', 'Have a Magical Day!', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Have a Magical Day!');
    delete featureData._id;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': targetToken.actor});
    await warpgate.wait(100);
    await feature.use();
    await chris.applyDamage(targetToken, '10000', 'none');
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/autognome/autognome.js

let autoGnome = {
    'malfunction': malfunction
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/wizard/orderOfScribes/awakenedSpellbook.js


async function awakenedSpellbook({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size === 0) return;
    if (workflow.item.type != 'spell') {
        if (workflow.item.type === 'feat') {
            if (!workflow.item.flags['chris-premades']?.spell?.castData) return;
        } else return;
    }
    let spellLevel = workflow.item.flags['chris-premades']?.spell?.castData?.castLevel ?? workflow.castData?.castLevel;
    if (!spellLevel) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'awakenedSpellbook', 101);
    if (!queueSetup) return;
    let oldDamageRoll = workflow.damageRoll;
    let oldFlavor = oldDamageRoll.terms?.map(term=>term?.flavor)
    let spells = workflow.actor.items.filter(i => i.type === 'spell' && i.system?.level === spellLevel && i.system?.damage?.parts?.length > 0);
    let values = [];
    let effect = chris.findEffect(workflow.actor, 'Awakened Spellbook: Replace Damage');
    if (!effect) return;
    let originItem = await fromUuid(effect.origin);
    if (!originItem) return;
    switch (spellLevel){
        case 1:
            if (actor.items.getName('Magic Missile') || chris.getConfiguration(originItem, 'magicmissile')) values.push('force');
            if (actor.items.getName('Chromatic Orb') || chris.getConfiguration(originItem, 'chromaticorb')) values.push('acid', 'cold', 'fire', 'lightning', 'poison', 'thunder');
            break;
        case 2:
            if (actor.items.getName('Dragon\s Breath') || chris.getConfiguration(originItem, 'dragonsbreath')) values.push('acid', 'cold', 'fire', 'lightning', 'poison');
            break;
        case 3:
            if (actor.items.getName('Protection from Energy') || chris.getConfiguration(originItem, 'protectionfromenergy')) values.push('acid', 'cold', 'fire', 'lightning', 'thunder');
            if (actor.items.getName('Glyph of Warding') || chris.getConfiguration(originItem, 'glyphofwarding')) values.push('acid', 'cold', 'fire', 'lightning', 'thunder');
            if (actor.items.getName('Spirit Shroud') || chris.getConfiguration(originItem, 'spiritshroud')) values.push('cold', 'necrotic', 'radiant');
            if (actor.items.getName('Vampiric Touch') || chris.getConfiguration(originItem, 'vampirictouch')) values.push('necrotic');
            break;
        case 4:
            if (actor.items.getName('Elemental Bane') || chris.getConfiguration(originItem, 'elementalbane')) values.push('acid', 'cold', 'fire', 'lightning', 'thunder');
            break;
        case 5:
            if (actor.items.getName('Cloudkill') || chris.getConfiguration(originItem, 'cloudkill')) values.push('poison');
            break;
        case 7:
            if (actor.items.getName('Prismatic Spray') || chris.getConfiguration(originItem, 'prismaticspray')) values.push('acid', 'cold', 'fire', 'lightning', 'poison');
            break;
        case 8:
            if (actor.items.getName('Illusory Dragon') || chris.getConfiguration(originItem, 'illusorydragon')) values.push('acid', 'cold', 'fire', 'lightning', 'necrotic', 'poison');
           break;
        case 9:
            if (actor.items.getName('Prismatic Wall') || chris.getConfiguration(originItem, 'prismaticwall')) values.push('acid', 'cold', 'fire', 'lightning', 'poison');
            break;
    }
    values = values.filter(function(item, i, arr){return arr.indexOf(item) === i; });
    for (let i = 0; spells.length > i; i++) {
        let currentItem = spells[i];
        for (let j = 0; currentItem.system.damage.parts.length > j; j++) {
            let flavor = currentItem.system.damage.parts[j][1];
            if (!flavor) break;
            if (values.includes(flavor.toLowerCase()) === false && flavor != 'healing' && flavor != 'temphp' && flavor != 'none' && flavor != 'midi-none') values.push(flavor);
        }
    }
    if (values.length === 0) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    function valuesToOptions(arr) {
        let optionsPush = [];
        for (let i = 0; arr.length > i; i++) {
            if (typeof arr[i] != 'string') return;
            optionsPush.push([arr[i].charAt(0).toUpperCase() + arr[i].slice(1), arr[i]]);
        }
        return optionsPush;
    }
    let options = valuesToOptions(values);
    if (options.length < 2) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    options.push(['No', false]);
    let selection = await chris.dialog('Change damage type for ' + workflow.item.name + '?', options);
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    for (let i = 0; oldFlavor.length > i; i++) {
        workflow.damageRoll.terms[i].options.flavor = selection;
        if (oldFlavor[i]) {
            workflow.damageRoll._formula = workflow.damageRoll._formula.replace(oldFlavor[i], selection);
        }
    }
    await workflow.setDamageRoll(workflow.damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/cleric/peaceDomain/balmOfPeace.js


async function balmOfPeace({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size === 0) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Balm of Peace', false);
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Balm of Peace');
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([]);
    for (let targetToken of workflow.targets.values()) {
        options.targetUuids = [targetToken.document.uuid];
        await MidiQOL.completeItemUse(feature, config, options);
    }
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/bard/bardicInspiration.js



async function bardicInspiration_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let classIdentifier = chris.getConfiguration(workflow.item, 'classidentifier') ?? 'bard';
    let scaleIdentifier = chris.getConfiguration(workflow.item, 'scaleidentifier') ?? 'bardic-inspiration';
    let scale = workflow.actor.system.scale[classIdentifier]?.[scaleIdentifier];
    if (!scale) {
        ui.notifications.warn('Actor does not appear to have a Bardic Inspiration scale set!');
        return;
    }
    let effectData = {
        'icon': workflow.item.img,
        'changes': [
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.bardicInspiration.attack,preCheckHits',
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.optional.bardicInspiration.label',
                'mode': 5,
                'value': 'Bardic Inspiration',
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.optional.bardicInspiration.save.all',
                'mode': 5,
                'value': scale.formula,
                'priority': 20
            }
        ],
        'duration': {
            'seconds': 600
        },
        'origin': workflow.item.uuid,
        'name': workflow.item.name,
        'flags': {
            'chris-premades': {
                'feature': {
                    'bardicInspiration': scale.formula
                }
            }
        }
    };
    let moteOfPotentialeOfPotential = chris.getItem(workflow.actor, 'Mote of Potential');
    if (moteOfPotentialeOfPotential) {
        effectData.changes = effectData.changes.concat(
            {
                'key': 'flags.midi-qol.optional.bardicInspiration.check.all',
                'mode': 5,
                'value': '2' + scale.die + 'kh',
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.optional.bardicInspiration.skill.all',
                'mode': 5,
                'value': '2' + scale.die + 'kh',
                'priority': 20
            } ,
            {
                'key': 'flags.midi-qol.optional.bardicInspiration.macroToCall',
                'mode': 5,
                'value': 'function.chrisPremades.macros.moteOfPotential',
                'priority': 20
            }
        );
        setProperty(effectData, 'flags.chris-premades.feature.moteOfPotential', chris.getSpellDC(workflow.item));
    } else {
        effectData.changes = effectData.changes.concat(
            {
                'key': 'flags.midi-qol.optional.bardicInspiration.check.all',
                'mode': 5,
                'value': scale.formula,
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.optional.bardicInspiration.skill.all',
                'mode': 5,
                'value': scale.formula,
                'priority': 20
            }
        );
    }
    let magicalInspiration = chris.getItem(workflow.actor, 'Magical Inspiration');
    if (magicalInspiration) {
        effectData.changes = effectData.changes.concat(
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.bardicInspiration.damage,preDamageApplication',
                'priority': 20
            }

        );
    }
    await chris.createEffect(workflow.targets.first().actor, effectData);
}
async function bardicInspiration_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.targets.size || workflow.isFumble) return;
    let effect = workflow.actor.effects.find(i => i.flags['chris-premades']?.feature?.bardicInspiration);
    if (!effect) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'bardicInspiration', 150);
    if (!queueSetup) return;
    let selection = await chris.dialog(effect.name, constants_constants.yesNo, 'Use ' + effect.name + '? (Attack Total: ' + workflow.attackTotal + ' )');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let bardDice = effect.flags['chris-premades'].feature.bardicInspiration;
    await chris.removeEffect(effect);
    let updatedRoll = await chris.addToRoll(workflow.attackRoll, bardDice);
    workflow.setAttackRoll(updatedRoll);
    let moteOfPotential = effect.flags['chris-premades'].feature.moteOfPotential;
    if (moteOfPotential) {
        let bardDie = updatedRoll.terms[updatedRoll.terms.length - 1].total;
        let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Mote of Potential Attack', false);
        if (!featureData) {
            queue_queue.remove(workflow.item.uuid);
            return;
        }
        featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Mote of Potential Attack');
        featureData.system.save.dc = moteOfPotential;
        featureData.system.damage.parts = [
            [
                bardDie + '[thunder]',
                'thunder'
            ]
        ];
        let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
        let newTargets = await chris.findNearby(workflow.targets.first(), 5, 'ally', false, true).map(i => i.document.uuid);
        let [config, options] = constants_constants.syntheticItemWorkflowOptions(newTargets);
        await warpgate.wait(100);
        await MidiQOL.completeItemUse(feature, config, options);
    }
    queue_queue.remove(workflow.item.uuid);
}
async function bardicInspiration_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.targets.size || workflow.item.type != 'spell') return;
    if ((workflow.item.system.actionType === 'rsak' || workflow.item.system.actionType === 'msak') && !workflow.hitTargets.size) return;
    let effect = workflow.actor.effects.find(i => i.flags['chris-premades']?.feature?.bardicInspiration);
    if (!effect) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'bardicInspiration', 150);
    if (!queueSetup) return;
    let selection = await chris.selectTarget('Use Magical Inspiration?', constants_constants.yesNoButton, workflow.targets, false, 'one');
    if (!selection.buttons) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let bardDice = effect.flags['chris-premades'].feature.bardicInspiration;
    await chris.removeEffect(effect);
    let targetTokenID = selection.inputs.find(i => i);
    if (!targetTokenID) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let targetDamage = workflow.damageList.find(i => i.tokenId === targetTokenID);
    let defaultDamageType = workflow.defaultDamageType;
    let roll = await new Roll(bardDice + '[' + defaultDamageType + ']').roll({async: true});
    roll.toMessage({
        'rollMode': 'roll',
        'speaker': {'alias': name},
        'flavor': 'Magical Inspiration'
    });
    let targetActor = canvas.scene.tokens.get(targetDamage.tokenId).actor;
    if (!targetActor) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let hasDI = chris.checkTrait(targetActor, 'di', defaultDamageType);
    if (hasDI) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let damageTotal = roll.total;
    let hasDR = chris.checkTrait(targetActor, 'dr', defaultDamageType);
    if (hasDR) damageTotal = Math.floor(damageTotal / 2);
    targetDamage.damageDetail[0].push(
        {
            'damage': damageTotal,
            'type': defaultDamageType
        }
    );
    targetDamage.totalDamage += damageTotal;
    if (workflow.defaultDamageType === 'healing') {
        targetDamage.newHP += roll.total;
        targetDamage.hpDamage -= damageTotal;
        targetDamage.appliedDamage -= damageTotal;
    } else {
        targetDamage.appliedDamage += damageTotal;
        targetDamage.hpDamage += damageTotal;
        if (targetDamage.oldTempHP > 0) {
            if (targetDamage.oldTempHP >= damageTotal) {
                targetDamage.newTempHP -= damageTotal;
            } else {
                let leftHP = damageTotal - targetDamage.oldTempHP;
                targetDamage.newTempHP = 0;
                targetDamage.newHP -= leftHP;
            }
        } else {
            targetDamage.newHP -= damageTotal;
        }
    }
    queue_queue.remove(workflow.item.uuid);
}
let bardicInspiration = {
    'item': bardicInspiration_item,
    'attack': bardicInspiration_attack,
    'damage': bardicInspiration_damage
}
;// CONCATENATED MODULE: ./scripts/macros/spells/beaconOfHope.js



async function beaconOfHope(token, {item, workflow, ditem}) {
    let effect = chris.findEffect(token.actor, 'Beacon of Hope');
    if (!effect) return;
    if (!workflow.damageRoll) return;
    if (workflow.defaultDamageType != translate.healingType('healing')) return;
    if (chris.checkTrait(token.actor, 'di', 'healing')) return;
    let newHealingTotal = 0;
    let queueSetup = await queue_queue.setup(workflow.uuid, 'beaconOfHope', 351);
    if (!queueSetup) return;
    for (let i = 0; workflow.damageRoll.terms.length > i; i++) {
        let flavor = workflow.damageRoll.terms[i].flavor;
        let isDeterministic = workflow.damageRoll.terms[i].isDeterministic;
        if (flavor.toLowerCase() === translate.healingType('healing') && !isDeterministic) {
            newHealingTotal += workflow.damageRoll.terms[i].faces * workflow.damageRoll.terms[i].results.length;
        } else {
            if (!isNaN(workflow.damageRoll.terms[i].total)) {
                newHealingTotal += workflow.damageRoll.terms[i].total;
            }
        }
    }
    if (chris.checkTrait(token.actor, 'dr', translate.healingType('healing'))) newHealingTotal = Math.floor(newHealingTotal / 2);
    let maxHP = token.actor.system.attributes.hp.max;
    ditem.hpDamage = -Math.clamped(newHealingTotal, 0, maxHP - ditem.oldHP);
    ditem.newHP = Math.clamped(ditem.oldHP + newHealingTotal, 0, maxHP);
    ditem.totalDamage = newHealingTotal;
    queue_queue.remove(workflow.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/ranger/feyWanderer/beguilingTwist.js

async function beguilingTwist({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1 || workflow.failedSaves.size != 1) return;
    let selection = await chris.dialog('What condition?', [['Charmed', 'Charmed'], ['Frightened', 'Frightened']]);
    if (!selection) return;
    let spellDC = chris.getSpellDC(workflow.item);
    let effectData = {
        'label': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 60
        },
        'changes': [
            {
                'key': 'flags.midi-qol.OverTime',
                'mode': 0,
                'value': 'label=' + workflow.item.name + ' (End of Turn),turn=end,saveDC=' + spellDC + ',saveAbility=wis,savingThrow=true',
                'priority': 20
            },
            {
                'key': 'macro.CE',
                'mode': 0,
                'value': selection,
                'priority': 20
            }
        ]
    }
    await chris.createEffect(workflow.targets.first().actor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/barbarian/beast/bestialSoul.js

async function bestialSoul({speaker, actor, token, character, item, args, scope, workflow}) {
    let selection = await chris.dialog(workflow.item.name, [['Climbing', 'climb'], ['Jumping', 'jump'], ['Swimming', 'swim']], 'Which form?');
    if (!selection) return;
    let effectData = {
        'label': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 604800
        },
        'flags': {
            'dae': {
                'specialDuration': [
                    'longRest',
                    'shortRest'
                ]
            }
        }
    };
    if (selection != 'jump') {
        effectData.changes = [
            {
                'key': 'system.attributes.movement.' + selection,
                'mode': 4,
                'value': '@attributes.movement.walk',
                'priority': 20
            }
        ]
    }
    await chris.createEffect(workflow.actor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/bestowCurse.js



async function bestowCurse_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size != 1) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'bestowCurse', 50);
    if (!queueSetup) return;
    let choices  = [
        ['Disadvantage on Ability Score', 'Ability'],
        ['Disadvantage on Attacks', 'Attack'],
        ['Waste Turn', 'Turn'],
        ['Extra Damage', 'Damage'],
        ['Other', 'Other']
    ];
    let selection = await chris.dialog('What curse do you bestow?', choices);
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let castLevel = workflow.castData.castLevel;
    let duration = 60;
    let concentration = true;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Bestow Curse - ' + selection, false);
    if (!featureData) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Bestow Curse - ' + selection, false);
    let effectData;
    switch (castLevel) {
        case 4:
            duration = 600;
            featureData.system.duration = {
                'units': 'minute',
                'value': 10
            };
            break;
        case 5:
        case 6:
            duration = 28800;
            concentration = false;
            featureData.system.duration = {
                'units': 'hour',
                'value': 8
            };
            break;
        case 7:
        case 8:
            duration = 86400;
            concentration = false;
            featureData.system.duration = {
                'units': 'day',
                'value': 1
            };
            break;
        case 9:
            duration = 'forever';
            concentration = false;
            featureData.system.duration = {
                'units': 'perm',
                'value': ''
            };
            break;
    }
    if (!concentration) featureData.flags.midiProperties.concentration = false;
    switch (selection) {
        case 'Ability':
            let abilityChoices = [
                ['Strength', 'str'],
                ['Dexterity', 'dex'],
                ['Constitution', 'con'],
                ['Intelligence', 'int'],
                ['Wisdom', 'wis'],
                ['Charisma', 'cha']
            ];
            let ability = await chris.dialog('What ability?', abilityChoices);
            if (!ability) {
                queue_queue.remove(workflow.item.uuid);
                return;
            }
            featureData.effects[0].changes[0].key += ability;
            featureData.effects[0].changes[1].key += ability;
            break;
        case 'Damage':
            effectData = {
                'label': featureData.name,
                'icon': featureData.img,
                'origin': workflow.item.uuid,
                'duration': {
                    'seconds': null,
                },
                'changes': [
                    {
                        'key': 'flags.midi-qol.onUseMacroName',
                        'mode': 0,
                        'value': 'function.chrisPremades.macros.bestowCurse.damage,postDamageRoll',
                        'priority': 20
                    },
                    {
                        'key': 'flags.midi-qol.onUseMacroName',
                        'mode': 0,
                        'value': 'function.chrisPremades.macros.bestowCurse.damageApplication,preDamageApplication',
                        'priority': 20
                    },
                    {
                        'key': 'flags.chris-premades.spell.bestowCurse.damage.target',
                        'mode': 5,
                        'value': workflow.targets.first().id,
                        'priority': 20
                    }
                ],
                'flags': {
                    'dae': {
                        'transfer': true
                    }
                }
            };
            if (!isNaN(duration)) effectData.duration.seconds = duration;
            await chris.createEffect(workflow.actor, effectData);
            break;
        case 'Attack':
            featureData.effects[0].changes[0].value = workflow.token.actor.uuid;
            break;
        case 'Turn':
            let saveDC = chris.getSpellDC(workflow.item);
            featureData.effects[0].changes[0].value = 'turn=start,saveAbility=wis,saveMagic=true,saveRemove=false,saveDC=' + saveDC + ',label="Bestow Curse (Start of Turn)"'
            break;
    }
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
    await MidiQOL.completeItemUse(feature, config, options);
    let targetEffect = chris.findEffect(workflow.targets.first().actor, 'Bestow Curse - ' + selection);
    if (!targetEffect) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await chris.updateEffect(targetEffect,
        {
            'origin': workflow.item.uuid,
            'flags': {
                'chris-premades': {
                    'spell': {
                        'bestowCurse': {
                            'level': castLevel,
                            'type': selection
                        }
                    }
                }
            }
        }
    );
    if (concentration) {
        let concentrationEffect = chris.findEffect(workflow.actor, 'Concentrating');
        if (!concentrationEffect) {
            queue_queue.remove(workflow.item.uuid);
            return;
        }
        await chris.updateEffect(concentrationEffect, {'origin': workflow.item.uuid, 'flags.midi-qol.isConcentration': workflow.item.uuid});
        await workflow.actor.setFlag('midi-qol', 'concentration-data.uuid', workflow.item.uuid);

    }
    queue_queue.remove(workflow.item.uuid);

}
async function bestowCurse_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (workflow.actor.flags['chris-premades']?.spell?.bestowCurse?.damage?.target != workflow.hitTargets.first().id) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'bestowCurse', 250);
    if (!queueSetup) return;
    let oldFormula = workflow.damageRoll._formula;
    let bonusDamageFormula = '1d8[necrotic]';
    if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
    let damageFormula = oldFormula + ' + ' + bonusDamageFormula;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function damageApplication({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size < 2) return;
    let targetId = workflow.actor.flags['chris-premades']?.spell?.bestowCurse?.damage.target;
    if (!targetId) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'bestowCurse', 250);
    if (!queueSetup) return;
    let targetDamage = workflow.damageList.find(i => i.tokenId === targetId);
    if (!targetDamage) return;
    let targetActor = canvas.scene.tokens.get(targetDamage.tokenId).actor;
    if (!targetActor) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let damageRoll = await new Roll('1d8[necrotic]').roll({async: true});
    damageRoll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: 'Bestow Curse Damage'
    });
    let hasDI = chris.checkTrait(targetActor, 'di', 'necrotic');
    if (hasDI) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let damageTotal = damageRoll.total;
    let hasDR = chris.checkTrait(targetActor, 'dr', 'necrotic');
    if (hasDR) damageTotal = Math.floor(damageTotal / 2);
    targetDamage.damageDetail[0].push(
        {
            'damage': damageTotal,
            'type': 'necrotic'
        }
    );
    targetDamage.totalDamage += damageTotal;
    targetDamage.appliedDamage += damageTotal;
    targetDamage.hpDamage += damageTotal;
    if (targetDamage.oldTempHP > 0) {
        if (targetDamage.oldTempHP >= damageTotal) {
            targetDamage.newTempHP -= damageTotal;
        } else {
            let leftHP = damageTotal - targetDamage.oldTempHP;
            targetDamage.newTempHP = 0;
            targetDamage.newHP -= leftHP;
        }
    } else {
        targetDamage.newHP -= damageTotal;
    }
    queue_queue.remove(workflow.item.uuid);
}
async function bestowCurse_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1 || workflow.disadvantage) return;
    let targetUuid = workflow.actor.flags['chris-premades']?.spell?.bestowCurse?.attack.target;
    if (!targetUuid) return;
    if (targetUuid != workflow.targets.first().actor.uuid) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'bestowCurse', 50);
    if (!queueSetup) return;
    workflow.disadvantage = true;
    workflow.attackAdvAttribution.add('Disadvantage: Bestow Curse');
    queue_queue.remove(workflow.item.uuid);
}
async function bestowCurse_remove(effect, origin, token) {
    let curseFlags = effect.flags['chris-premades']?.spell?.bestowCurse
    if (!curseFlags) return;
    await warpgate.wait(200);
    if (curseFlags.type === 'Damage') {
        let damageEffect = origin.actor.effects.find(eff => eff.name === 'Bestow Curse - Damage' && eff.changes?.[2]?.value === token.id);
        if (damageEffect) await chris.removeEffect(damageEffect);
    }
    if (curseFlags.level < 5) {
        let effect2 = chris.findEffect(origin.actor, 'Concentrating');
        if (effect2) await chris.removeEffect(effect2);
    }
}
let bestowCurse = {
    'item': bestowCurse_item,
    'damage': bestowCurse_damage,
    'damageApplication': damageApplication,
    'attack': bestowCurse_attack,
    'remove': bestowCurse_remove
}
;// CONCATENATED MODULE: ./scripts/macros/homebrew/bg3/backbreaker.js



async function backbreaker({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || workflow.item.system.actionType != 'mwak') return;
    let validTypes = [
        'maul',
        'warhammer'
    ];
    if (!validTypes.includes(workflow.item.system.baseItem)) return;
    let feature = chris.getItem(workflow.actor, 'Backbreaker');
    if (!feature) return;
    if (!feature.system.uses.value) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'backbreaker', 250);
    if (!queueSetup) return;
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Use Backbreaker?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await feature.update({'system.uses.value': 0});
    let featureData = duplicate(feature.toObject());
    delete (featureData._id);
    let feature2 = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature2, config, options);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/homebrew/bg3/brace.js

async function brace({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let validTypes = [
        'glaive',
        'heavycrossbow',
        'longbow',
        'pike',
        'dart'
    ];
    if (!validTypes.includes(workflow.item.system.baseItem)) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'brace', 350);
    if (!queueSetup) return;
    let damageFormula = 'max(' + workflow.damageRoll._formula + ', ' + workflow.damageRoll._formula + ')';
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/homebrew/bg3/cleave.js


async function cleave({speaker, actor, token, character, item, args, scope, workflow}) {
    let validTypes = [
        'battleaxe',
        'greataxe',
        'halberd',
        'greatsword'
    ];
    let validWeapons = workflow.actor.items.filter(i => i.type === 'weapon' && validTypes.includes(i.system.baseItem) && i.system.equipped);
    if (!validWeapons.length) {
        ui.notifications.info('No valid equipped weapons!');
        return;
    }
    let weapon;
    if (validWeapons.length === 1) weapon = validWeapons[0];
    if (!weapon) [weapon] = await chris.selectDocument('What weapon?', validWeapons);
    if (!weapon) return;
    let nearbyFoes = chris.findNearby(workflow.token, weapon.system.range.value, 'enemy', true);
    if (!nearbyFoes.length) {
        ui.notifications.info('No nearby enemies found!');
        return;
    }
    let targets;
    if (nearbyFoes.length > 3) {
        let selectedTargets = await chris.selectTarget('Choose your targets (Max: 3)', constants_constants.okCancel, nearbyFoes, true, 'multiple');
        if (!selectedTargets.buttons) return;
        if (selectedTargets.inputs.filter(i => !!i).length > 3) {
            ui.notifications.info('Too many targets selected!');
            return;
        }
        targets = selectedTargets.inputs;
    } else {
        targets = nearbyFoes.map(i => i.document.uuid);
    }
    let featureData = duplicate(weapon.toObject());
    featureData.system.target.value = 3;
    delete featureData._id;
    for (let i = 0; i < featureData.system.damage.parts.length; i++) {
        featureData.system.damage.parts[i][0] = 'floor((' + featureData.system.damage.parts[i][0] + ') / 2)';
    }
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions(targets);
    await MidiQOL.completeItemUse(feature, config, options);
}
;// CONCATENATED MODULE: ./scripts/macros/homebrew/bg3/concussiveSmash.js



async function concussiveSmash_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'concussiveSmash', 50);
    if (!queueSetup) return;
    if (workflow.actor.system.abilities.dex.save > workflow.actor.system.abilities.str.save) {
        workflow.item = workflow.item.clone({'system.save.scaling': 'dex'}, {'keepId': true});
        workflow.item.prepareData();
        workflow.item.prepareFinalAttributes();
    }
    queue_queue.remove(workflow.item.uuid);
}
async function save({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size != 1) return;
    let effectData = {
        'label': 'Dazed',
        'icon': workflow.item.img,
        'changes': [
            {
                'key': 'flags.midi-qol.disadvantage.ability.save.wis',
                'mode': 0,
                'value': '1',
                'priority': 20
            }
        ],
        'duration': {
            'seconds': 18
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onTurnEnd': {
                    'script': 'await chrisPremades.macros.bg3.concussiveSmash.turn(effect);'
                }
            },
            'chris-premades': {
                'feature': {
                    'concussiveSmash': 0
                }
            }
        }
    };
    let armorTypes = [
        'light',
        'medium',
        'heavy'
    ];
    let armor = workflow.targets.first().actor.items.find(i => armorTypes.includes(i.system.armor?.type) && i.system.equipped);
    let dex = armor?.system?.armor?.dex ?? workflow.targets.first().actor.system.abilities.dex.mod
    if (dex > 0) {
        effectData.changes.push({
            'key': 'system.attributes.ac.bonus',
            'mode': 2,
            'value': -dex,
            'priority': 20
        });
    }
    await chris.createEffect(workflow.targets.first().actor, effectData);
}
async function concussiveSmash_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || workflow.item.system.actionType != 'mwak') return;
    let validTypes = [
        'flail',
        'greatclub',
        'lighthammer',
        'mace',
        'maul',
        'morningstar',
        'warhammer',
        'club'
    ];
    if (!validTypes.includes(workflow.item.system.baseItem)) return;
    let feature = chris.getItem(workflow.actor, 'Concussive Smash');
    if (!feature) return;
    if (!feature.system.uses.value) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'concussiveSmash', 250);
    if (!queueSetup) return;
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Use Concussive Smash?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await feature.update({'system.uses.value': 0});
    let featureData = duplicate(feature.toObject());
    delete (featureData._id);
    let feature2 = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature2, config, options);
    queue_queue.remove(workflow.item.uuid);
}
async function turn(effect) {
    let turn = effect.flags['chris-premades']?.feature?.concussiveSmash ?? 0;
    if (turn >= 1) {
        await chris.removeEffect(effect);
        return;
    } 
    let updates = {
        'flags.chris-premades.feature.concussiveSmash': turn + 1
    };
    await chris.updateEffect(effect, updates);
}
let concussiveSmash = {
    'item': concussiveSmash_item,
    'save': save,
    'attack': concussiveSmash_attack,
    'turn': turn
}
;// CONCATENATED MODULE: ./scripts/macros/homebrew/bg3/maimingStrike.js



async function maimingStrike_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'maimingStrike', 50);
    if (!queueSetup) return;
    if (workflow.actor.system.abilities.dex.save > workflow.actor.system.abilities.str.save) {
        workflow.item = workflow.item.clone({'system.save.scaling': 'dex'}, {'keepId': true});
        workflow.item.prepareData();
        workflow.item.prepareFinalAttributes();
    }
    queue_queue.remove(workflow.item.uuid);
    if (workflow.targets.size != 1) return;
    if (!workflow.targets.first().actor.system.attributes.movement.fly) return;
    let effectData = {
        'label': 'Flying Creature',
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 1
        },
        'changes': [
            {
                'key': 'flags.midi-qol.min.ability.save.con',
                'mode': 2,
                'value': '99',
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    'isSave.con'
                ]
            }
        }
    };
    await chris.createEffect(workflow.targets.first().actor, effectData);
}
async function maimingStrike_save({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size != 1) return;
    let effectData = {
        'label': 'Maimed',
        'icon': workflow.item.img,
        'changes': [
            {
                'key': 'flags.midi-qol.disadvantage.ability.save.dex',
                'mode': 0,
                'value': '1',
                'priority': 20
            },
            {
                'key': 'system.attributes.movement.all',
                'mode': 0,
                'value': '*0',
                'priority': 20
            }
        ],
        'duration': {
            'seconds': 18
        },
        'origin': null,
        'flags': {
            'chris-premades': {
                'feature': {
                    'maimingStrike': 0
                }
            },
            'effectmacro': {
                'onTurnEnd': {
                    'script': 'await chrisPremades.macros.bg3.maimingStrike.turn(effect);'
                }
            },
        }
    };
    await chris.createEffect(workflow.targets.first().actor, effectData);
}
async function maimingStrike_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || workflow.item.system.actionType != 'mwak') return;
    let validTypes = [
        'warpick',
        'battleaxe',
        'trident'
    ];
    if (!validTypes.includes(workflow.item.system.baseItem)) return;
    let feature = chris.getItem(workflow.actor, 'Maiming Strike');
    if (!feature) return;
    if (!feature.system.uses.value) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'maimingStrike', 250);
    if (!queueSetup) return;
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Use Maiming Strike?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await feature.update({'system.uses.value': 0});
    let featureData = duplicate(feature.toObject());
    delete (featureData._id);
    let feature2 = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature2, config, options);
    queue_queue.remove(workflow.item.uuid);
}
async function maimingStrike_turn(effect) {
    let turn = effect.flags['chris-premades']?.feature?.maimingStrike ?? 0;
    if (turn >= 1) {
        await chris.removeEffect(effect);
        return;
    } 
    let updates = {
        'flags.chris-premades.feature.maimingStrike': turn + 1
    };
    await chris.updateEffect(effect, updates);
}
let maimingStrike = {
    'item': maimingStrike_item,
    'save': maimingStrike_save,
    'attack': maimingStrike_attack,
    'turn': maimingStrike_turn
}
;// CONCATENATED MODULE: ./scripts/macros/homebrew/bg3/flourish.js


async function flourish_effect(effect) {
    if (effect.flags['chris-premades']?.feature?.flourish) {
        await chris.removeEffect(effect);
        return;
    } 
    let updates = {
        'flags.chris-premades.feature.flourish': true
    };
    await chris.updateEffect(effect, updates);
}
async function flourish_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'flourish', 50);
    if (!queueSetup) return;
    if (workflow.actor.system.abilities.dex.save > workflow.actor.system.abilities.str.save) {
        workflow.item = workflow.item.clone({'system.save.scaling': 'dex'}, {'keepId': true});
        workflow.item.prepareData();
        workflow.item.prepareFinalAttributes();
    }
    queue_queue.remove(workflow.item.uuid);
}
let flourish = {
    'effect': flourish_effect,
    'item': flourish_item
}
;// CONCATENATED MODULE: ./scripts/macros/homebrew/bg3/hamstringShot.js



async function hamstringShot_turn(effect) {
    let turn = effect.flags['chris-premades']?.feature?.hamstringShot ?? 0;
    if (turn >= 1) {
        await chris.removeEffect(effect);
        return;
    } 
    let updates = {
        'flags.chris-premades.feature.hamstringShot': turn + 1
    };
    await chris.updateEffect(effect, updates);
}
async function hamstringShot_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || workflow.item.system.actionType != 'rwak') return;
    let validTypes = [
        'shortbow',
        'longbow'
    ];
    if (!validTypes.includes(workflow.item.system.baseItem)) return;
    let feature = chris.getItem(workflow.actor, 'Hamstring Shot');
    if (!feature) return;
    if (!feature.system.uses.value) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'hamstringShot', 450);
    if (!queueSetup) return;
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Use Hamstring Shot?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await feature.update({'system.uses.value': 0});
    let featureData = duplicate(feature.toObject());
    delete (featureData._id);
    let feature2 = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
    await warpgate.wait(100);
    let targetWorkflow = await MidiQOL.completeItemUse(feature2, config, options);
    if (targetWorkflow.failedSaves.size != 1) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let effect = chris.findEffect(workflow.targets.first().actor, 'Hamstrung');
    if (effect) await chris.updateEffect(effect, {'origin': feature.uuid});
    queue_queue.remove(workflow.item.uuid);
}
let hamstringShot = {
    'attack': hamstringShot_attack,
    'turn': hamstringShot_turn
}
;// CONCATENATED MODULE: ./scripts/macros/homebrew/bg3/heartstopper.js



async function heartstopper_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'heartstopper', 50);
    if (!queueSetup) return;
    if (workflow.actor.system.abilities.dex.save > workflow.actor.system.abilities.str.save) {
        workflow.item = workflow.item.clone({'system.save.scaling': 'dex'}, {'keepId': true});
        workflow.item.prepareData();
        workflow.item.prepareFinalAttributes();
    }
    queue_queue.remove(workflow.item.uuid);
    if (workflow.targets.size != 1) return;
    let race = chris.raceOrType(workflow.targets.first().actor);
    if (!(race === 'undead' || race === 'construct')) return;
    let effectData = {
        'label': 'Invalid Creature',
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 1
        },
        'changes': [
            {
                'key': 'flags.midi-qol.min.ability.save.str',
                'mode': 2,
                'value': '99',
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    'isSave.con'
                ]
            }
        }
    };
    await chris.createEffect(workflow.targets.first().actor, effectData);
}
async function heartstopper_turn(effect) {
    let turn = effect.flags['chris-premades']?.feature?.heartstopper ?? 0;
    if (turn >= 1) {
        await chris.removeEffect(effect);
        return;
    } 
    let updates = {
        'flags.chris-premades.feature.heartstopper': turn + 1
    };
    await chris.updateEffect(effect, updates);
}
async function heartstopper_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || workflow.item.system.actionType != 'mwak') return;
    let validTypes = [
        'morningstar'
    ];
    if (!validTypes.includes(workflow.item.system.baseItem)) return;
    let feature = chris.getItem(workflow.actor, 'Heartstopper');
    if (!feature) return;
    if (!feature.system.uses.value) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'heartstopper', 250);
    if (!queueSetup) return;
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Use Heartstopper?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await feature.update({'system.uses.value': 0});
    let featureData = duplicate(feature.toObject());
    delete (featureData._id);
    let feature2 = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature2, config, options);
    queue_queue.remove(workflow.item.uuid);
}
let heartstopper = {
    'item': heartstopper_item,
    'turn': heartstopper_turn,
    'attack': heartstopper_attack
}
;// CONCATENATED MODULE: ./scripts/macros/homebrew/bg3/lacerate.js



async function lacerate_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'lacerate', 50);
    if (!queueSetup) return;
    if (workflow.actor.system.abilities.dex.save > workflow.actor.system.abilities.str.save) {
        workflow.item = workflow.item.clone({'system.save.scaling': 'dex'}, {'keepId': true});
        workflow.item.prepareData();
        workflow.item.prepareFinalAttributes();
    }
    queue_queue.remove(workflow.item.uuid);
    if (workflow.targets.size != 1) return;
    let race = chris.raceOrType(workflow.targets.first().actor);
    if (!(race === 'undead' || race === 'construct')) return;
    let effectData = {
        'label': 'Invalid Creature',
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 1
        },
        'changes': [
            {
                'key': 'flags.midi-qol.min.ability.save.str',
                'mode': 2,
                'value': '99',
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    'isSave.con'
                ]
            }
        }
    };
    await chris.createEffect(workflow.targets.first().actor, effectData);
}
async function turnStart(origin, token) {
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Homebrew Feature Items', 'Bleeding', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Bleeding');
    delete (featureData._id);
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': origin.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.document.uuid]);
    await MidiQOL.completeItemUse(feature, config, options);
}
async function turnEnd(effect) {
    let turn = effect.flags['chris-premades']?.feature?.lacerate ?? 0;
    if (turn >= 1) {
        await chris.removeEffect(effect);
        return;
    } 
    let updates = {
        'flags.chris-premades.feature.lacerate': turn + 1
    };
    await chris.updateEffect(effect, updates);
}
async function lacerate_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || workflow.item.system.actionType != 'mwak') return;
    let validTypes = [
        'handaxe',
        'scimitar',
        'battleaxe',
        'longsword',
        'glaive',
        'greataxe',
        'greatsword',
        'halberd',
        'sickle'
    ];
    if (!validTypes.includes(workflow.item.system.baseItem)) return;
    let feature = chris.getItem(workflow.actor, 'Lacerate');
    if (!feature) return;
    if (!feature.system.uses.value) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'lacerate', 250);
    if (!queueSetup) return;
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Use Lacerate?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await feature.update({'system.uses.value': 0});
    let featureData = duplicate(feature.toObject());
    delete (featureData._id);
    let feature2 = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
    await warpgate.wait(100);
    let targetWorkflow = await MidiQOL.completeItemUse(feature2, config, options);
    if (targetWorkflow.failedSaves.size != 1) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let effect = chris.findEffect(workflow.targets.first().actor, 'Bleeding');
    if (effect) await chris.updateEffect(effect, {'origin': feature.uuid});
    queue_queue.remove(workflow.item.uuid);
}
let lacerate = {
    'item': lacerate_item,
    'turnStart': turnStart,
    'turnEnd': turnEnd,
    'attack': lacerate_attack
}
;// CONCATENATED MODULE: ./scripts/macros/homebrew/bg3/piercingStrike.js




async function piercingStrike_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'piercingStrike', 50);
    if (!queueSetup) return;
    if (workflow.actor.system.abilities.dex.save > workflow.actor.system.abilities.str.save) {
        workflow.item = workflow.item.clone({'system.save.scaling': 'dex'}, {'keepId': true});
        workflow.item.prepareData();
        workflow.item.prepareFinalAttributes();
    }
    queue_queue.remove(workflow.item.uuid);
    if (workflow.targets.size != 1) return;
    let race = chris.raceOrType(workflow.targets.first().actor);
    if (!(race === 'undead' || race === 'construct')) return;
    let effectData = {
        'label': 'Invalid Creature',
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 1
        },
        'changes': [
            {
                'key': 'flags.midi-qol.min.ability.save.str',
                'mode': 2,
                'value': '99',
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    'isSave.con'
                ]
            }
        }
    };
    await chris.createEffect(workflow.targets.first().actor, effectData);
}
async function piercingStrike_turn(effect) {
    let turn = effect.flags['chris-premades']?.feature?.piercingStrike ?? 0;
    if (turn >= 1) {
        await chris.removeEffect(effect);
        return;
    } 
    let updates = {
        'flags.chris-premades.feature.piercingStrike': turn + 1
    };
    await chris.updateEffect(effect, updates);
}
async function strike({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || workflow.item.system.actionType != 'mwak') return;
    let validTypes = [
        'rapier',
        'shortsword',
        'trident',
        'pike',
        'dagger'
    ];
    if (!validTypes.includes(workflow.item.system.baseItem)) return;
    let feature = chris.getItem(workflow.actor, 'Piercing Strike');
    if (!feature) return;
    if (!feature.system.uses.value) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'piercingstrike', 250);
    if (!queueSetup) return;
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Use Piercing Strike?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await feature.update({'system.uses.value': 0});
    let featureData = duplicate(feature.toObject());
    delete (featureData._id);
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
    let feature2 = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let targetWorkflow = await MidiQOL.completeItemUse(feature2, config, options);
    if (targetWorkflow.failedSaves.size != 1) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let effect = chris.findEffect(workflow.targets.first().actor, 'Gaping Wounds');
    if (effect) await chris.updateEffect(effect, {'origin': feature.uuid});
    queue_queue.remove(workflow.item.uuid);
}
async function shot({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || workflow.item.system.actionType != 'rwak') return;
    let validTypes = [
        'lightcrossbow',
        'handcrossbow',
        'heavycrossbow'
    ];
    if (!validTypes.includes(workflow.item.system.baseItem)) return;
    let feature = chris.getItem(workflow.actor, 'Piercing Shot');
    if (!feature) return;
    if (!feature.system.uses.value) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'piercingShot', 250);
    if (!queueSetup) return;
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Use Piercing Shot?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await feature.update({'system.uses.value': 0});
    let featureData = duplicate(feature.toObject());
    delete (featureData._id);
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
    let feature2 = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let targetWorkflow = await MidiQOL.completeItemUse(feature2, config, options);
    if (targetWorkflow.failedSaves.size != 1) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let effect = chris.findEffect(workflow.targets.first().actor, 'Gaping Wounds');
    if (effect) await chris.updateEffect(effect, {'origin': feature.uuid});
    queue_queue.remove(workflow.item.uuid);
}
async function piercingStrike_damage(workflow) {
    if (workflow.hitTargets.size != 1) return;
    if (!constants_constants.attacks.includes(workflow.item.system.actionType)) return;
    let effect = chris.findEffect(workflow.targets.first().actor, 'Gaping Wounds');
    if (!effect) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'piercingStrike', 250);
    if (!queueSetup) return;
    let oldFormula = workflow.damageRoll._formula;
    let bonusDamageFormula = '2[' + translate.damageType('piercing') + ']';
    if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
    let damageFormula = oldFormula + ' + ' + bonusDamageFormula;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
let piercingStrike = {
    'item': piercingStrike_item,
    'turn': piercingStrike_turn,
    'strike': strike,
    'shot': shot,
    'damage': piercingStrike_damage
}
;// CONCATENATED MODULE: ./scripts/macros/homebrew/bg3/pommelStrike.js


async function pommelStrike_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'pommelStrike', 50);
    if (!queueSetup) return;
    if (workflow.actor.system.abilities.dex.save > workflow.actor.system.abilities.str.save) {
        workflow.item = workflow.item.clone({'system.save.scaling': 'dex'}, {'keepId': true});
        workflow.item.prepareData();
        workflow.item.prepareFinalAttributes();
    }
    queue_queue.remove(workflow.item.uuid);
}
async function pommelStrike_save({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size === 1 && workflow.hitTargets.size === 1) {
        let effectData = {
            'label': 'Dazed',
            'icon': workflow.item.img,
            'changes': [
                {
                    'key': 'flags.midi-qol.disadvantage.ability.save.wis',
                    'mode': 0,
                    'value': '1',
                    'priority': 20
                }
            ],
            'duration': {
                'seconds': 12
            },
            'origin': workflow.item.uuid,
            'flags': {
                'effectmacro': {
                    'onTurnEnd': {
                        'script': 'await chrisPremades.macros.bg3.pommelStrike.turn(effect);'
                    }
                },
                'chris-premades': {
                    'feature': {
                        'pommelStrike': 0
                    }
                }
            }
        };
        let armorTypes = [
            'light',
            'medium',
            'heavy'
        ];
        let armor = workflow.targets.first().actor.items.find(i => armorTypes.includes(i.system.armor?.type) && i.system.equipped);
        let dex = armor?.system?.armor?.dex ?? workflow.targets.first().actor.system.abilities.dex.mod
        if (dex > 0) {
            effectData.changes.push({
                'key': 'system.attributes.ac.bonus',
                'mode': 2,
                'value': -dex,
                'priority': 20
            });
        }
        await chris.createEffect(workflow.targets.first().actor, effectData);
    }
    if (workflow.hitTargets.size != 1 || workflow.damageList[0].newHP != 0 || workflow.damageList[0].oldHP === 0) return;
    let effect = chris.findEffect(workflow.targets.first().actor, 'Dead');
    if (!effect) return;
    await chris.removeEffect(effect);
    await chris.addCondition(workflow.targets.first().actor, 'Unconscious', true);
}
async function pommelStrike_turn(effect) {
    let turn = effect.flags['chris-premades']?.feature?.pommelStrike ?? 0;
    if (turn >= 1) {
        await chris.removeEffect(effect);
        return;
    } 
    let updates = {
        'flags.chris-premades.feature.pommelStrike': turn + 1
    };
    await chris.updateEffect(effect, updates);
}
let pommelStrike = {
    'item': pommelStrike_item,
    'save': pommelStrike_save,
    'turn': pommelStrike_turn
}
;// CONCATENATED MODULE: ./scripts/macros/homebrew/bg3/prepare.js


async function prepare({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (workflow.item.system.baseItem != 'greataxe') return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'prepare', 250);
    if (!queueSetup) return;
    let oldFormula = workflow.damageRoll._formula;
    let bonusDamageFormula = workflow.actor.system.abilities.str.mod + '[' + workflow.defaultDamageType + ']';
    if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
    let damageFormula = oldFormula + ' + ' + bonusDamageFormula;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/homebrew/bg3/rushAttack.js


async function rushAttack_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'rushAttack', 50);
    if (!queueSetup) return;
    if (workflow.actor.system.abilities.dex.save > workflow.actor.system.abilities.str.save) {
        workflow.item = workflow.item.clone({'system.save.scaling': 'dex'}, {'keepId': true});
        workflow.item.prepareData();
        workflow.item.prepareFinalAttributes();
    }
    queue_queue.remove(workflow.item.uuid);
}
async function rushAttack_turn(effect) {
    let turn = effect.flags['chris-premades']?.feature?.rushAttack ?? 0;
    if (turn >= 1) {
        await chris.removeEffect(effect);
        return;
    } 
    let updates = {
        'flags.chris-premades.feature.rushAttack': turn + 1
    };
    await chris.updateEffect(effect, updates);
}
let rushAttack = {
    'item': rushAttack_item,
    'turn': rushAttack_turn
}
;// CONCATENATED MODULE: ./scripts/macros/homebrew/bg3/tenacity.js



async function tenacity({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!(workflow.targets.size === 1 && !workflow.hitTargets.size) || workflow.item.system.actionType != 'mwak') return;
    let validTypes = [
        'morningstar',
        'greatclub',
        'moul'
    ];
    if (!validTypes.includes(workflow.item.system.baseItem)) return;
    let feature = chris.getItem(workflow.actor, 'Tenacity');
    if (!feature) return;
    if (!feature.system.uses.value) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'rushAttack', 450);
    if (!queueSetup) return;
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Use Tenacity?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await feature.update({'system.uses.value': 0});
    let featureData = duplicate(feature.toObject());
    delete (featureData._id);
    let feature2 = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature2, config, options);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/homebrew/bg3/topple.js



async function topple_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'topple', 50);
    if (!queueSetup) return;
    if (workflow.actor.system.abilities.dex.save > workflow.actor.system.abilities.str.save) {
        workflow.item = workflow.item.clone({'system.save.scaling': 'dex'}, {'keepId': true});
        workflow.item.prepareData();
        workflow.item.prepareFinalAttributes();
    }
    queue_queue.remove(workflow.item.uuid);
}
async function topple_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1 || workflow.item.system.actionType != 'mwak') return;
    let validTypes = [
        'quarterstaff'
    ];
    if (!validTypes.includes(workflow.item.system.baseItem)) return;
    let feature = chris.getItem(workflow.actor, 'Topple');
    if (!feature) return;
    if (!feature.system.uses.value) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'topple', 450);
    if (!queueSetup) return;
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Use Topple?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await feature.update({'system.uses.value': 0});
    let featureData = duplicate(feature.toObject());
    featureData.system.damage.parts = [];
    delete (featureData._id);
    let feature2 = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature2, config, options);
    queue_queue.remove(workflow.item.uuid);
}
let topple = {
    'item': topple_item,
    'attack': topple_attack
}
;// CONCATENATED MODULE: ./scripts/macros/homebrew/bg3/weakeningStrike.js


async function weakeningStrike_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'topple', 50);
    if (!queueSetup) return;
    if (workflow.actor.system.abilities.dex.save > workflow.actor.system.abilities.str.save) {
        workflow.item = workflow.item.clone({'system.save.scaling': 'dex'}, {'keepId': true});
        workflow.item.prepareData();
        workflow.item.prepareFinalAttributes();
    }
    queue_queue.remove(workflow.item.uuid);
    if (workflow.targets.size != 1) return;
    let weapons = workflow.targets.first().actor.items.filter(i => i.system.equipped && i.type === 'weapon');
    if (weapons.length) return;
    let effectData = {
        'label': 'Invalid Creature',
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 1
        },
        'changes': [
            {
                'key': 'flags.midi-qol.min.ability.save.str',
                'mode': 2,
                'value': '99',
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    'isSave.con'
                ]
            }
        }
    };
    await chris.createEffect(workflow.targets.first().actor, effectData);
}
async function weakeningStrike_turn(effect) {
    let turn = effect.flags['chris-premades']?.feature?.weakeningStrike ?? 0;
    if (turn >= 1) {
        await chris.removeEffect(effect);
        return;
    } 
    let updates = {
        'flags.chris-premades.feature.weakeningStrike': turn + 1
    };
    await chris.updateEffect(effect, updates);
}
let weakeningStrike = {
    'item': weakeningStrike_item,
    'turn': weakeningStrike_turn
}
;// CONCATENATED MODULE: ./scripts/macros/homebrew/bg3/mobileShot.js

async function mobileShot({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let validTypes = [
        'handcrossbow'
    ];
    let validWeapons = workflow.actor.items.filter(i => i.type === 'weapon' && validTypes.includes(i.system.baseItem) && i.system.equipped);
    if (!validWeapons.length) {
        ui.notifications.info('No valid equipped weapons!');
        return;
    }
    let weapon;
    if (validWeapons.length === 1) weapon = validWeapons[0];
    if (!weapon) [weapon] = await chris.selectDocument('What weapon?', validWeapons);
    if (!weapon) return;
    await weapon.use();
}
;// CONCATENATED MODULE: ./scripts/macros/homebrew/bg3/bg3.js


















let weapons = {
    'warhammer': [
        'Backbreaker',
        'Concussive Smash',
        'Weakening Strike'
    ],
    'maul': [
        'Backbreaker',
        'Concussive Smash',
        'Tenacity'
    ],
    'glaive': [
        'Brace',
        'Lacerate',
        'Rush Attack'
    ],
    'pike': [
        'Brace',
        'Piercing Strike',
        'Rush Attack'
    ],
    'longbow': [
        'Brace',
        'Hamstring Shot'
    ],
    'battleaxe': [
        'Cleave',
        'Lacerate',
        'Maiming Strike'
    ],
    'greataxe': [
        'Cleave',
        'Lacerate',
        'Prepare'
    ],
    'halberd': [
        'Cleave',
        'Lacerate',
        'Rush Attack'
    ],
    'greatsword': [
        'Cleave',
        'Lacerate',
        'Pommel Strike'
    ],
    'morningstar': [
        'Concussive Smash',
        'Heartstopper',
        'Tenacity'
    ],
    'club': [
        'Concussive Smash'
    ],
    'lighthammer': [
        'Concussive Smash'
    ],
    'mace': [
        'Concussive Smash'
    ],
    'greatclub': [
        'Concussive Smash',
        'Tenacity'
    ],
    'scimitar': [
        'Flourish',
        'Lacerate'
    ],
    'shortsword': [
        'Flourish',
        'Piercing Strike'
    ],
    'rapier': [
        'Flourish',
        'Piercing Strike',
        'Weakening Strike'
    ],
    'shortbow': [
        'Hamstring Shot'
    ],
    'handaxe': [
        'Lacerate'
    ],
    'longsword': [
        'Lacerate',
        'Pommel Strike',
        'Rush Attack'
    ],
    'handcrossbow': [
        'Mobile Shot',
        'Piercing Shot'
    ],
    'warpick': [
        'Maiming Strike',
        'Weakening Strike'
    ],
    'trident': [
        'Maiming Strike',
        'Piercing Strike',
        'Rush Attack'
    ],
    'lightcrossbow': [
        'Piercing Shot'
    ],
    'heavycrossbow': [
        'Piercing Shot'
    ],
    'spear': [
        'Rush Attack'
    ],
    'quarterstaff': [
        'Topple'
    ],
    'sickle': [
        'Lacerate'
    ],
    'dagger': [
        'Piercing Strike'
    ]
};
let simpleWeapons = [
    'club',
    'dagger',
    'greatclub',
    'handaxe',
    'javelin',
    'lightcrossbow',
    'lighthammer',
    'mace',
    'quarterstaff',
    'shortbow',
    'sickle',
    'sling',
    'spear'
];
let martialWeapons = [
    'battleaxe',
    'blowgun',
    'flail',
    'glaive',
    'greataxe',
    'greatsword',
    'halberd',
    'handcrossbow',
    'heavycrossbow',
    'lance',
    'longbow',
    'longsword',
    'maul',
    'morningstar',
    'net',
    'pike',
    'rapier',
    'scimitar',
    'shortsword',
    'trident',
    'warpick',
    'warhammer',
    'whip'
];
async function addFeatures(item, updates, options, id) {
    if (item.type != 'weapon') return;
    let actor = item.actor;
    if (!actor) return;
    let baseItem = item.system.baseItem;
    let proficient = item.system.proficient || item.actor.system.traits.weaponProf.value.has(baseItem);
    if (!baseItem) return;
    if (!proficient) {
        if (simpleWeapons.includes(baseItem) && item.actor.system.traits.weaponProf.value.has('sim')) proficient = true;
        if (martialWeapons.includes(baseItem) && item.actor.system.traits.weaponProf.value.has('mar')) proficient = true;
    }
    if (!proficient) return;
    let currentlyEquipped = updates.system?.equipped ?? item.system.equipped;
    let previouslyEquipped = item.system?.equipped;
    if (currentlyEquipped === previouslyEquipped) return;
    if (!currentlyEquipped) {
        await removeFeatures(item);
        return;
    }
    if (!weapons[baseItem]) return;
    let items = [];
    for (let i of weapons[baseItem]) {
        if (chris.getItem(actor, i)) continue;
        let featureData = await chris.getItemFromCompendium('chris-premades.CPR Homebrew Feature Items', i, false);
        if (!featureData) continue;
        featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', i);
        featureData.system.uses.value = getProperty(actor, 'flags.chris-premades.homebrew.bg3.' + i) ?? 1;
        items.push(featureData);
    }
    if (item.length === 0) return;
    await actor.createEmbeddedDocuments('Item', items);
}
async function removeFeatures(item, options, id) {
    if (item.type != 'weapon') return;
    let actor = item.actor;
    if (!actor) return;
    let baseItem = item.system.baseItem;
    if (!weapons[baseItem]) return;
    let otherItems = actor.items.filter(i => i.system.baseItem === baseItem && i.system.equipped);
    if (otherItems.length > 1) return;
    let items = [];
    let updates = {};
    for (let i of weapons[baseItem]) {
        let feature = chris.getItem(actor, i);
        if (!feature) continue;
        items.push(feature.id);
        setProperty(updates, 'flags.chris-premades.homebrew.bg3.' + i, feature.system.uses.value);
    }
    if (!items.length) return;
    await actor.deleteEmbeddedDocuments('Item', items);
    await actor.update(updates);
}
async function rest(actor, data) {
    let updates = {
        'flags': {
            'chris-premades': {
                'homebrew': {
                    'bg3': {
                        'Backbreaker': 1,
                        'Brace': 1,
                        'Cleave': 1,
                        'Concussive Smash': 1,
                        'Flourish': 1,
                        'Hamstring Shot': 1,
                        'Heartstopper': 1,
                        'Lacerate': 1,
                        'Maiming Strike': 1,
                        'Mobile Shot': 1,
                        'Piercing Strike': 1,
                        'Piercing Shot': 1,
                        'Pommel Strike': 1,
                        'Prepare': 1,
                        'Rush Attack': 1,
                        'Tenacity': 1,
                        'Topple': 1,
                        'Weakening Strike': 1
                    }
                }
            }
        }
    };
    await actor.update(updates);
}
let effects = [
    'Crippled',
    'Off Balance',
    'Hamstrung',
    'Bleeding',
    'Gaping Wounds',
];
async function healing(workflow) {
    if (!workflow.targets.size) return;
    if (workflow.defaultDamageType != 'healing') return;
    for (let i of Array.from(workflow.targets)) {
        for (let j of effects) {
            let effect = chris.findEffect(i.actor, j);
            if (effect) await chris.removeEffect(effect);
        }
    }
}
let bg3 = {
    'backbreaker': backbreaker,
    'brace': brace,
    'cleave': cleave,
    'concussiveSmash': concussiveSmash,
    'maimingStrike': maimingStrike,
    'flourish': flourish,
    'heartstopper': heartstopper,
    'lacerate': lacerate,
    'piercingStrike': piercingStrike,
    'pommelStrike': pommelStrike,
    'prepare': prepare,
    'rushAttack': rushAttack,
    'tenacity': tenacity,
    'topple': topple,
    'weakeningStrike': weakeningStrike,
    'hamstringShot': hamstringShot,
    'mobileShot': mobileShot,
    'removeFeatures': removeFeatures,
    'addFeatures': addFeatures,
    'rest': rest,
    'healing': healing
}
;// CONCATENATED MODULE: ./scripts/macros/spells/bigbysHand.js


async function bigbysHand_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let sourceActor = game.actors.getName('CPR - Bigby\'s Hand');
    if (!sourceActor) return;
    let damageScale = ((workflow.castData.castLevel - 5) * 2)
    let clenchedFistData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Clenched Fist', false);
    if (!clenchedFistData) return;
    clenchedFistData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Clenched Fist');
    clenchedFistData.system.damage.parts[0][0] = (4 + damageScale) + 'd8[force]';
    let forcefulHandData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Forceful Hand', false);
    if (!forcefulHandData) return;
    forcefulHandData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Forceful Hand');
    forcefulHandData.name = 'Forceful Hand (' + ((chris.getSpellMod(workflow.item) * 5) + 5) + ' feet)';
    let graspingHandData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Grasping Hand', false);
    if (!graspingHandData) return;
    graspingHandData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Grasping Hand');
    let interposingHandData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Interposing Hand', false);
    if (!interposingHandData) return;
    interposingHandData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Interposing Hand');
    let hpFormula = workflow.actor.system.attributes.hp.max;
    let name = chris.getConfiguration(workflow.item, 'name') ?? 'Bigby\'s Hand';
    if (name === '') name = 'Bigby\'s Hand';
    let meleeAttackBonus = await new Roll(workflow.actor.system.bonuses.msak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let rangedAttackBonus = await new Roll(workflow.actor.system.bonuses.rsak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'details': {
                    'cr': tashaSummon.getCR(workflow.actor.system.attributes.prof)
                },
                'attributes': {
                    'hp': {
                        'formula': hpFormula,
                        'max': hpFormula,
                        'value': hpFormula
                    }
                }
            },
            'prototypeToken': {
                'name': name
            },
            'flags': {
                'chris-premades': {
                    'summon': {
                        'attackBonus': {
                            'melee': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.int.mod + meleeAttackBonus.total,
                            'ranged': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.int.mod + rangedAttackBonus.total
                        }
                    },
                    'spell': {
                        'damageScale': damageScale,
                        'casterSpellMod': chris.getSpellMod(workflow.item)
                    }
                }
            }
        },
        'token': {
            'name': name
        },
        'embedded': {
            'Item': {
                [clenchedFistData.name]: clenchedFistData,
                [forcefulHandData.name]: forcefulHandData,
                [graspingHandData.name]: graspingHandData,
                [interposingHandData.name]: interposingHandData
            }
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar');
    if (avatarImg) updates.actor.img = avatarImg;
    let tokenImg = chris.getConfiguration(workflow.item, 'token');
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? 'earth';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await tashaSummon.spawn(sourceActor, updates, 60, workflow.item, 120, workflow.token, animation);
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Bigby\'s Hand - Move', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Bigby\'s Hand - Move');
    let updates2 = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Bigby\'s Hand',
        'description': featureData.name
    };
    await warpgate.mutate(workflow.token.document, updates2, {}, options);
    let effect = chris.findEffect(workflow.actor, 'Bigby\'s Hand');
    if (!effect) return;
    let currentScript = effect.flags.effectmacro?.onDelete?.script;
    if (!currentScript) return;
    let effectUpdates = {
        'flags': {
            'effectmacro': {
                'onDelete': { 
                    'script': currentScript + ' await warpgate.revert(token.document, "Bigby\'s Hand");'
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    await chris.updateEffect(effect, effectUpdates);
}
async function forcefulHand({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetActor = workflow.targets.first().actor;
    let hasAdvantage = (chris.getSize(targetActor) <= (chris.sizeStringValue('medium')));
    await workflow.actor.rollSkill('ath', {advantage: hasAdvantage});
    await targetActor.rollSkill('ath');
}
async function graspingHand({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetActor = workflow.targets.first().actor;
    if (chris.getSize(targetActor) > chris.sizeStringValue('huge')) {
        ui.notifications.info('Target is too big!');
        return;
    }
    let hasAdvantage = (chris.getSize(targetActor) <=  (chris.sizeStringValue('medium')));
    let sourceRoll = await workflow.actor.rollSkill('ath', {'advantage': hasAdvantage});
    let targetRoll;
    if (targetActor.system.skills.acr.total >= targetActor.system.skills.ath.total) {
        targetRoll = await targetActor.rollSkill('acr');
    }
    else {
        targetRoll = await targetActor.rollSkill('ath');
    }
    if (targetRoll.total > sourceRoll.total) return;
    await chris.addCondition(targetActor, 'Grappled', false, workflow.item.uuid);
    let ghcFeatureData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Grasping Hand - Crush', false);
    if (!ghcFeatureData) return;
    let damageScale = workflow.actor.flags['chris-premades']?.spell?.damageScale;
    if (!damageScale === undefined) return;
    let spellMod = workflow.actor.flags['chris-premades']?.spell?.casterSpellMod;
    if (!spellMod) return;
    ghcFeatureData.system.damage.parts[0][0] = (2 + (damageScale)) + 'd6[bludgeoning] + ' + spellMod;
    ghcFeatureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Grasping Hand - Crush');
    async function effectMacro () {
        await warpgate.revert(token.document, 'Grasping Hand - Crush');
    }
    let ghcEffectData = {
        'label': ghcFeatureData.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': ghcFeatureData.name
                }
            }
        }
    };
    let ghcUpdates = {
        'embedded': {
            'Item': {
                [ghcFeatureData.name]: ghcFeatureData
            },
            'ActiveEffect': {
                [ghcFeatureData.name]: ghcEffectData
            }
        }
    };
    let ghcOptions = {
        'permanent': false,
        'name': ghcFeatureData.name,
        'description': ghcFeatureData.name
    };
    await warpgate.mutate(workflow.token.document, ghcUpdates, {}, ghcOptions);
}
async function interposingHandOn({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1 || workflow.disadvantage) return;
    let effect = chris.findEffect(workflow.actor, 'Interposing Hand');
    if (!effect) return;
    let origin = await fromUuid(effect.origin);
    if (!origin) return;
    let originActor = origin.actor;
    let originActorUuid = originActor.uuid;
    let targetActor = workflow.targets.first().actor;
    let targetActorUuid = targetActor.uuid;
    if (originActorUuid === targetActorUuid) return;
    await chris.addCondition(targetActor, 'Cover (Half)');
}
async function interposingHandOff({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1 || workflow.disadvantage) return;
    await chris.removeCondition(workflow.targets.first().actor, 'Cover (Half)');
}
let bigbysHand = {
    'item': bigbysHand_item,
    'forcefulHand': forcefulHand,
    'graspingHand': graspingHand,
    'interposingHandOn': interposingHandOn,
    'interposingHandOff': interposingHandOff
}

;// CONCATENATED MODULE: ./scripts/macros/classFeatures/bloodHunter/bloodCurses/binding.js

async function binding({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let amplify = await chris.dialog('Amplify Blood Curse?', [['Yes', true], ['No', false]]);
    if (!amplify) {
        if (chris.getSize(workflow.targets.first()) > chris.sizeStringValue('large')) {
            ui.notifications.info('Target is too big!');
        }
        return;
    }
    let damageDice = workflow.actor.system.scale['blood-hunter']['crimson-rite'];
    if (!damageDice) {
        ui.notifications.warn('Source actor does not appear to have a Crimson Rite scale!');
        return;
    }
    let roll = await new Roll(damageDice + '[none]').roll({async: true});
    roll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: workflow.item.name
    });
    await chris.applyDamage(workflow.token, roll.total, 'none');
    let effect = chris.findEffect(workflow.targets.first().actor, 'Blood Curse of Binding');
    if (!effect) return;
    let saveDC = chris.getSpellDC(workflow.item);
    let updates = {
        'changes': [
            {
                'key': 'system.attributes.movement.all',
                'mode': 0,
                'priority': 20,
                'value': 0
            },
            {
                'key': 'flags.midi-qol.overTime',
                'mode': 0,
                'priority': 20,
                'value': 'turn=end, rollType=save, saveAbility=str, saveDC=' + saveDC + ', label=Blood Curse of Binding (End of Turn)'
            }
        ],
        'duration': {
            'duration': 60,
            'label': '60 Seconds',
            'remaining': 60,
            'seconds': 60,
            'type': 'seconds'
        },
        'flags': {
            'dae': {
                'specialDuration': []
            }
        }
    };
    await chris.updateEffect(effect, updates);
}
;// CONCATENATED MODULE: ./scripts/macros/items/blackrazor.js


async function blackrazor_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || !workflow.damageList) return;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    let targetRace = chris.raceOrType(targetActor);
    if (targetRace != 'undead') {
        if (targetRace === 'construct') return;
        let doHealing = false;
        for (let i of workflow.damageList) {
            if (i.oldHP != 0 && i.newHP === 0) {
                doHealing = true;
                break;
            }
        }
        if (!doHealing) return;
        let maxHP = targetActor.system.attributes.hp.max;
        let currentTempHP = workflow.actor.system.attributes.hp.temp;
        if (currentTempHP <= maxHP) await chris.applyDamage([workflow.token], maxHP, 'temphp');
        let effect = chris.findEffect(workflow.actor, 'Devoured Soul');
        if (effect) return;
        let effectData = {
            'label': 'Devoured Soul',
            'icon': workflow.item.img,
            'origin': workflow.item.uuid,
            'duration': {
                'seconds': 86400
            },
            'changes': [
                {
                    'key': 'flags.midi-qol.advantage.attack.all',
                    'mode': 0,
                    'value': '1',
                    'priority': 20
                },
                {
                    'key': 'flags.midi-qol.advantage.ability.save.all',
                    'mode': 0,
                    'value': '1',
                    'priority': 20
                },
                {
                    'key': 'flags.midi-qol.advantage.ability.check.all',
                    'mode': 0,
                    'value': '1',
                    'priority': 20
                },
                {
                    'key': 'flags.chris-premades.feature.onHit.blackrazor',
                    'mode': 5,
                    'value': 'true',
                    'priority': 20
                }
            ],
            'transfer': true
        };
        await chris.createEffect(workflow.actor, effectData);
    } else {
        let damageRoll = await new Roll('1d10[necrotic]').roll({async: true});
        await chris.applyWorkflowDamage(workflow.token, damageRoll, 'necrotic', [workflow.token], workflow.item.name, workflow.itemCardId);
        return;
    }
}
async function blackrazor_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let targetActor = workflow.targets.first().actor;
    if (chris.raceOrType(targetActor) != 'undead') return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'blackrazor', 50);
    if (!queueSetup) return;
    let damageFormula = '1d10[healing]';
    if (workflow.isCritical) damageFormula = chris.getCriticalFormula(damageFormula);
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function blackrazor_onHit(workflow, targetToken) {
    if (targetToken.actor.system.attributes.hp.temp != 0) return;
    let effect = chris.findEffect(targetToken.actor, 'Devoured Soul');
    if (!effect) return;
    await chris.removeEffect(effect);
}
let blackrazor = {
    'item': blackrazor_item,
    'damage': blackrazor_damage,
    'onHit': blackrazor_onHit
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/bard/collegeOfSwords/bladeFlourish.js


async function bladeFlourish({speaker, actor, token, character, item, args, scope, workflow}) {
    let itemName = workflow.item.name.toLowerCase()
    if (itemName.includes('booming blade') || itemName.includes('green-flame blade')) return;
    let sourceActor = workflow.actor;
    let effect1 = chris.findEffect(sourceActor, 'Blade Flourish Movement');
    if (workflow.item.type === 'weapon' && !effect1) {
        let feature0 = sourceActor.items.getName('Blade Flourish Movement');
        if (feature0) feature0.use();
    }
    if (workflow.item.type === 'weapon' && workflow.hitTargets.size === 1) {
        let effect2 = chris.findEffect(sourceActor, 'Blade Flourish');
        if (effect2) return;
        let bardicInspiration = sourceActor.items.getName('Bardic Inspiration');
        if (!bardicInspiration) bardicInspiration = sourceActor.items.getName('Bardic Inspiration & Magical Inspiration');
        if (!bardicInspiration) {
            ui.notifications.warn('Source actor does not appear to have a Bardic Inspiration feature!');
            return;
        }
        let queueSetup = await queue_queue.setup(workflow.item.uuid, 'bladeFlourish', 151);
        if (!queueSetup) return;
        let bardicInspirationUses = bardicInspiration.system.uses.value;
        let classFeature = sourceActor.items.getName('Bard');
        let skipUses = false;
        if (classFeature) {
            let levels = classFeature.system.levels;
            if (levels >= 14) skipUses = await chris.dialog('Use d6 instead of Bardic Inspiration for Blade Flourish?', [['Yes', true], ['No', false]]);
        }
        if (bardicInspirationUses <= 0 && !skipUses) {
            queue_queue.remove(workflow.item.uuid);
            return;
        }
        let options = [
            ['Defensive Flourish', 'DF'],
            ['Mobile Flourish', 'MF'],
            ['Slashing Flourish', 'SF'],
            ['No', false]
        ];
        let selectedOption = await chris.dialog('Use a Blade Flourish?', options);
        if (!selectedOption) {
            queue_queue.remove(workflow.item.uuid);
            return;
        }
        let effectData1 = {
            'label': 'Blade Flourish',
            'icon': 'icons/skills/melee/maneuver-sword-katana-yellow.webp',
            'duration': {'turns': 1},
            'origin': workflow.item.uuid,
            'flags': {
                'dae': {
                    'specialDuration': [
                        'combatEnd'
                    ]
                }
            }
        };
        await chris.createEffect(sourceActor, effectData1);
        if (!skipUses) bardicInspiration.update({'system.uses.value': bardicInspirationUses - 1});
        let bardicInspirationDie = sourceActor.system.scale.bard['bardic-inspiration'];
        if (skipUses) bardicInspirationDie = {'formula': '1d6'};
        if (!bardicInspirationDie) {
            ui.notifications.warn('Source actor does not appear to have a Bardic Inspiration scale!');
            queue_queue.remove(workflow.item.uuid);
            return;
        }
        let damageType = workflow.item.system.damage.parts[0][1];
        let bonusDamageFormula = bardicInspirationDie.formula + '[' + damageType + ']'
        if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
        let damageFormula = workflow.damageRoll._formula + ' + ' + bonusDamageFormula;
        let damageRoll = await new Roll(damageFormula).roll({async: true});
        let bardicInspirationDieRoll = damageRoll.dice[damageRoll.dice.length - 1].total;
        await workflow.setDamageRoll(damageRoll);
        switch (selectedOption) {
            case 'DF':
                let feature2 = sourceActor.items.getName('Defensive Flourish');
                if (feature2) feature2.use();
                let effectData2 = {
                    'label': 'Defensive Flourish',
                    'icon': 'icons/skills/melee/swords-parry-block-blue.webp',
                    'duration': {'rounds': 1},
                    'changes': [
                        {
                            'key': 'system.attributes.ac.bonus',
                            'mode': 2,
                            'value': '+' + bardicInspirationDieRoll,
                            'priority': 20
                        }
                    ],
                    'origin': workflow.item.uuid,
                    'flags': {
                        'dae': {
                            'specialDuration': [
                                'combatEnd'
                            ]
                        }
                    }
                };
                await chris.createEffect(sourceActor, effectData2);
                break;
            case 'MF':
                let feature3 = sourceActor.items.getName('Mobile Flourish');
                if (feature3) feature3.use();
                break;
            case 'SF':
                let feature4 = await sourceActor.items.getName('Slashing Flourish');
                if (feature4) feature4.use();
                let nearbyTargets = chris.findNearby(workflow.token, 5, 'enemy');
                let hitTokenId = workflow.hitTargets.first().id;
                let removeIndex = nearbyTargets.findIndex(tok => tok.id === hitTokenId);
                if (removeIndex != -1) nearbyTargets.splice(removeIndex, 1);
                await chris.applyDamage([nearbyTargets], bardicInspirationDieRoll, damageType);
                break;
        }
        queue_queue.remove(workflow.item.uuid);
    }
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/wizard/bladesinging/bladesong.js

async function bladesong({speaker, actor, token, character, item, args, scope, workflow}) {
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 60
        },
        'changes': [
            {
                'key': 'system.attributes.ac.bonus',
                'mode': 2,
                'value': '+' + workflow.actor.system.abilities.int.mod,
                'priority': 20
            },
            {
                'key': 'system.attributes.movement.walk',
                'mode': 2,
                'value': '+10',
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.advantage.skill.acr',
                'mode': 0,
                'value': '1',
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.concentrationSaveBonus',
                'mode': 2,
                'value': '+' + workflow.actor.system.abilities.int.mod,
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'feature': {
                    'bladesong': true
                }
            },
            'dae': {
                'specialDuration': [
                    'zeroHP',
                    'combatEnd'
                ]
            }
        }
    };
    let songOfVictory = chris.getItem(workflow.actor, 'Song of Victory');
    if (songOfVictory) {
        effectData.changes.push(
            {
                'key': 'system.bonuses.mwak.damage',
                'mode': 2,
                'value': '+' + workflow.actor.system.abilities.int.mod,
                'priority': 20
            }
        );
    }
    await chris.createEffect(workflow.actor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/cleric/blessedStrikes.js



async function onUse({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.hitTargets.size || !workflow.damageRoll) return;
    let itemType = workflow.item.type;
    if (!(itemType === 'weapon' || (itemType === 'spell' && workflow.castData.castLevel === 0))) return;
    let originItem = chris.getItem(workflow.actor, 'Blessed Strikes');
    if (!originItem) return;
    if (chris.inCombat()) {
        let featureUsed = originItem.flags['chris-premades']?.feature?.blessedStrikes?.used;
        if (featureUsed) return;
    }
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'blessedStrikes', 150);
    if (!queueSetup) return;
    let selection = await chris.dialog(originItem.name, constants_constants.yesNo, 'Use Blessed Strikes?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let damageFormula = workflow.damageRoll._formula + ' + 1d8[radiant]';
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    if (chris.inCombat()) await originItem.setFlag('chris-premades', 'feature.blessedStrikes.used', true);
    queue_queue.remove(workflow.item.uuid);
}
async function blessedStrikes_turnStart(origin) {
    await origin.setFlag('chris-premades', 'feature.blessedStrikes.used', false);
}
let blessedStrikes = {
    'onUse': onUse,
    'turnStart': blessedStrikes_turnStart
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/cleric/forgeDomain/blessingOfTheForge.js

async function blessingOfTheForge({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    let generatedMenu = [];
    targetActor.items.forEach(item => {
        if (!item.system.equipped ) return;
        if (item.type === 'weapon' || item.system.armor) generatedMenu.push([item.name, item.id]);
    });
    if (generatedMenu.length === 0) return;
    let selection = await chris.dialog('What item do you imbue?', generatedMenu);
    if (!selection) return;
    async function effectMacro() {
        warpgate.revert(token.document, 'Blessing of the Forge');
    }
    let itemData = targetActor.items.get(selection).toObject();
    if (itemData.type === 'weapon') {
        itemData.system.attackBonus = Number(itemData.system.attackBonus) + 1;
        itemData.system.damage.parts[0][0] += ' + 1';
    } else {
        itemData.system.armor.value += 1;
    }
    let effectData = {
        'label': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 604800
        },
        'flags': {
            'dae': {
                'specialDuration': [
                    'longRest'
                ]
            },
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [itemData.name]: itemData
            },
            'ActiveEffect': {
                [workflow.item.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Blessing of the Forge',
        'description': 'Blessing of the Forge'
    };
    await warpgate.mutate(targetToken.document, updates, {}, options);
}
;// CONCATENATED MODULE: ./scripts/macros/raceFeatures/shadarKai/blessingOfTheRavenQueen.js

async function blessingOfTheRavenQueen({speaker, actor, token, character, item, args, scope, workflow}) {
    let level = workflow.actor.system?.details?.level;
    if (level < 3) return;
    let effect = chris.findEffect(workflow.actor, 'Blessing of the Raven Queen Resistance');
    if (effect) await chris.removeEffect(effect);
    let effectData = {
        'label': 'Blessing of the Raven Queen Resistance',
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'rounds': 1
        },
        'changes': [
            {
                'key': 'system.traits.dr.all',
                'mode': 0,
                'value': 1,
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    'turnStartSource'
                ],
                'stackable': 'none',
                'macroRepeat': 'none'
            }
        }
    }
    await chris.createEffect(workflow.actor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/blight.js


async function blight_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'blight', 50);
    if (!queueSetup) return;
    let creatureType = chris.raceOrType(workflow.targets.first().actor);
    let newDamageRoll = '';
    if (creatureType === 'plant') {
        let oldDamageRoll = workflow.damageRoll;
        for (let i = 0; oldDamageRoll.terms.length > i; i++) {
            let flavor = oldDamageRoll.terms[i].flavor;
            let isDeterministic = oldDamageRoll.terms[i].isDeterministic;
            if (isDeterministic === true) {
                newDamageRoll += oldDamageRoll.terms[i].formula;
            } else {
                newDamageRoll += '(' + oldDamageRoll.terms[i].number + '*' + oldDamageRoll.terms[i].faces + ')[' + flavor + ']';
            }
        }
    } else if (creatureType === 'undead' || creatureType === 'construct') {
        newDamageRoll = '0[' + workflow.defaultDamageType + ']';
    } else {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let damageRoll = await new Roll(newDamageRoll).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function blight_early({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let creatureType = chris.raceOrType(workflow.targets.first().actor);
    if (creatureType != 'plant') return;
    let effectData = {
        'label': 'Condition Disadvantage',
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'duration': {
            'turns': 1
        },
        'changes': [
            {
                'key': 'flags.midi-qol.disadvantage.ability.save.all',
                'value': '1',
                'mode': 5,
                'priority': 120
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    'isSave'
                ]
            }
        }
    };
    await chris.createEffect(workflow.targets.first().actor, effectData);
}
let blight = {
    'early': blight_early,
    'damage': blight_damage
}
;// CONCATENATED MODULE: ./scripts/macros/spells/blink.js


async function blinkTurnStart(token, actor, origin, effect) {
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Blink Landing', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Blink Landing');
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.uuid]);
    await MidiQOL.completeItemUse(feature, config, options);
    await chris.removeEffect(effect);
}
async function blinkTurnEnd(actor) {
    let blinkRoll = await new Roll('1d20').roll({async: true});
    blinkRoll.toMessage({
        'rollMode': 'roll',
        'speaker': {'alias': name},
        'flavor': 'Blink'
    });
    if (blinkRoll.total < 11) return;
    async function effectMacro() {
        await chrisPremades.macros.blink.start(token, actor, origin, effect);
    }
    let blinkEffect = chris.findEffect(actor, 'Blink');
    let originUuid = blinkEffect.origin;
    let effectData = {
        'name': 'Blinked Away',
        'icon': origin.img,
        'duration': {
            'rounds': 2
        },
        'origin': originUuid,
        'changes': [
            {
                'key': 'flags.midi-qol.superSaver.all',
                'value': '1',
                'mode': 5,
                'priority': 20
            },
            {
                'key': 'system.attributes.ac.bonus',
                'value': '100',
                'mode': 5,
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.min.ability.save.all',
                'value': '100',
                'mode': 5,
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.fail.critical.all',
                'value': '1',
                'mode': 5,
                'priority': 20
            },
            {
                'key': 'macro.tokenMagic',
                'value': 'spectral-body',
                'mode': 0,
                'priority': 20
            }
        ],
        'flags': {
            'effectmacro': {
                'onTurnStart': {
                    'script': chris.functionToString(effectMacro)
                }
            }
        }
    };
    if (chris.vision5e()) effectData.changes.push(
        {
            'key': 'macro.CE',
            'value': 'Ethereal',
            'mode': 0,
            'priority': 20
        }
    );
    await chris.createEffect(actor, effectData);
}
let blink = {
    'start': blinkTurnStart,
    'end': blinkTurnEnd
}
;// CONCATENATED MODULE: ./scripts/macros/items/bloodSpear.js

async function bloodSpear({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let newHP = workflow.damageList[0].newHP;
    if (newHP != 0) return;
    let oldHP = workflow.damageList[0].oldHP;
    if (newHP === oldHP) return;
    let damageRoll = await new Roll('2d6[temphp]').roll({async: true});
    damageRoll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: workflow.item.name
    });
    await chris.applyDamage(workflow.token, damageRoll.total, 'temphp');
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/bodak/auraOfAnnihilation.js


async function auraOfAnnihilation(token, origin) {
    if (token.actor.system.attributes.hp.value === 0) return;
    if (!game.combat.previous.tokenId) return;
    let targetToken = game.canvas.tokens.get(game.combat.previous.tokenId);
    if (!targetToken) return;
    if (targetToken.id === token.id) return;
    let type = chris.raceOrType(targetToken.actor);
    if (type === 'fiend' || type === 'undead') return;
    let distance = chris.getDistance(token, targetToken);
    if (distance > 30) return;
    let featureData = duplicate(origin.toObject());
    featureData.system.activation.type = 'special';
    featureData.system.target.type = 'creature';
    featureData.system.damage.parts = [
        [
            '5[necrotic]',
            'necrotic'
        ]
    ];
    delete(featureData.effects);
    featureData.system.duration = {
        'units': 'inst',
        'value': ''
    };
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': token.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.document.uuid]);
    await MidiQOL.completeItemUse(feature, config, options);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/bodak/deathGaze.js

async function deathGaze({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size != 1) return;
    let targetToken = workflow.targets.first();
    if (chris.checkTrait(targetToken.actor, 'ci', 'frightened')) return;
    if ((workflow.saveResults[0].total + 5) > chris.getSpellDC(workflow.item)) return;
    let targetHP = targetToken.actor.system.attributes.hp.value;
    await chris.applyDamage([targetToken], targetHP, 'none');
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/bodak/bodak.js


let bodak = {
    'deathGaze': deathGaze,
    'auraOfauraOfAnnihilation': auraOfAnnihilation
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/barbarian/wildMagic/bolsteringMagic.js

async function bolsteringMagic({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.targets.size) return;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    let selection = await chris.dialog(workflow.item.name, [['Attack and Ability Bonus', 'd3'], ['Regain Spell Slot', 'spell']], 'Which option?');
    if (!selection) return;
    if (selection === 'd3') {
        let effectData = {
            'icon': workflow.item.img,
            'origin': workflow.item.uuid,
            'duration': {
                'seconds': 600
            },
            'name': workflow.item.name,
            'changes': [
                {
                    'key': 'system.bonuses.All-Attacks',
                    'mode': 2,
                    'value': '+1d3',
                    'priority': 20
                },
                {
                    'key': 'system.bonuses.abilities.check',
                    'mode': 2,
                    'value': '+1d3',
                    'priority': 20
                }
            ]
        };
        await chris.createEffect(targetActor, effectData);
    } else {
        let roll = await new Roll('1d3').roll({async: true});
        roll.toMessage({
            rollMode: 'roll',
            speaker: {'alias': name},
            flavor: workflow.item.name
        });
        let checkNumber = roll.total;
        while (checkNumber > 0) {
            let value = targetActor.system.spells['spell' + checkNumber].value;
            let max = targetActor.system.spells['spell' + checkNumber].max;
            if (value < max) {
                let updates = {
                    'actor': {
                        'system': {
                            'spells': {
                                ['spell' + checkNumber]: {
                                    'value': value + 1
                                }
                            }
                        }
                    }
                }
                let options = {
                    'permanent': true,
                    'name': workflow.item.name,
                    'description': workflow.item.name
                };
                await warpgate.mutate(targetToken.document, updates, {}, options);
                ui.notifications.info('Spell slot regained!');
                return;
            } else {
                checkNumber -= 1;
            }
            if (checkNumber === 0) ui.notifications.info('No spell slots to regain!');
        }
    }
}
;// CONCATENATED MODULE: ./scripts/macros/spells/boomingBlade.js



async function boomingBlade_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let weapons = workflow.actor.items.filter(i => i.type === 'weapon' && i.system.equipped && i.system.actionType === 'mwak');
    if (!weapons.length) {
        ui.notifications.info('No equipped weapons found!');
        return;
    }
    let selection;
    if (weapons.length === 1) selection = weapons[0];
    if (!selection) [selection] = await chris.selectDocument('Attack with what weapon?', weapons);
    if (!selection) return;
    let level = chris.levelOrCR(workflow.actor);
    let diceNumber = Math.floor((level + 1) / 6);
    let weapon;
    if (level > 4) {
        let weaponData = duplicate(selection.toObject());
        delete weaponData._id;
        weaponData.system.damage.parts.push([diceNumber + 'd8[' + translate.damageType('thunder') + ']', 'thunder']);
        weaponData.system.properties.mgc = true;
        weapon = new CONFIG.Item.documentClass(weaponData, {'parent': workflow.actor});
        weapon.prepareData();
        weapon.prepareFinalAttributes();
    } else {
        weapon = selection;
    }
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
    await warpgate.wait(100);
    let attackWorkflow = await MidiQOL.completeItemUse(weapon, config, options);
    if (!attackWorkflow) return;
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? 'blue';
    if (chris.jb2aCheck() != 'patreon' && animation != 'none') animation = 'blue';
    if (animation != 'none') {
        if (animation === 'random') {
            let colors = [
                'blue',
                'blue02',
                'dark_purple',
                'dark_red',
                'green',
                'green02',
                'orange',
                'red',
                'purple',
                'yellow',
                'blue'
            ]
            animation = colors[Math.floor(Math.random() * colors.length)];
        }
        new Sequence()
            .effect()
            .file('jb2a.static_electricity.01.' + animation)
            .atLocation(workflow.targets.first())
            .scaleToObject(1.5)
            .play();
    }
    if (!attackWorkflow.hitTargets.size) return;
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 12
        },
        'origin': workflow.item.uuid,
        'flags': {
            'dae': {
                'specialDuration': [
                    'turnStartSource'
                ]
            },
            'chris-premades': {
                'spell': {
                    'boomingBlade': {
                        'diceNumber': diceNumber + 1
                    }
                }
            }
        }
    };
    let effect = chris.findEffect(attackWorkflow.targets.first().actor, effectData.name);
    if (effect) {
        if (effect.flags['chris-premades']?.spell?.boomingBlade?.diceNumber > diceNumber) {
            return;
        } else {
            await chris.removeEffect(effect);
        }
    }
    await chris.createEffect(attackWorkflow.targets.first().actor, effectData);
}
async function moved(token, changes) {
    if (!chris.isLastGM()) return;
    if (token.parent.id != canvas.scene.id) return;
    if (!changes.x && !changes.y && !changes.elevation) return;
    let effect = token.actor.effects.find(i => i.flags['chris-premades']?.spell?.boomingBlade);
    if (!effect) return;
    await token.object?._animation;
    let selection = await chris.dialog(effect.name, constants_constants.yesNo, 'Did ' + token.actor.name + ' move willingly?');
    if (!selection) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Booming Blade - Movement', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Booming Blade - Movement');
    delete featureData._id;
    featureData.system.damage.parts = [
        [
            effect.flags['chris-premades'].spell.boomingBlade.diceNumber + 'd8[' + translate.damageType('thunder') + ']',
            'thunder'
        ]
    ];
    if (!effect.origin) return;
    let originItem = await fromUuid(effect.origin);
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': originItem.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.uuid]);
    await MidiQOL.completeItemUse(feature, config, options);
    await chris.removeEffect(effect);
}
let boomingBlade = {
    'item': boomingBlade_item,
    'moved': moved
}
;// CONCATENATED MODULE: ./scripts/macros/items/bootsOfElvenkind.js
function bootsOfElvenkind(skillId, options) {
    return skillId != 'ste' ? false : {'label': 'This check relies on moving silently.', 'type': 'advantage'};
}
;// CONCATENATED MODULE: ./scripts/macros/spells/borrowedKnowledge.js


async function borrowedKnowledge({speaker, actor, token, character, item, args, scope, workflow}) {
    function dialogRender(html) {
        let ths = html[0].getElementsByTagName('th');
        for (let t of ths) {
            t.style.width = 'auto';
            t.style.textAlign = 'left';
        }
        let tds = html[0].getElementsByTagName('td');
        for (let t of tds) {
            t.style.width = '50px';
            t.style.textAlign = 'center';
            t.style.paddingRight = '5px';
        }
    }
    let selection = await warpgate.menu({
    'inputs': [
        {
            'label': 'Skill:',
            'type': 'select',
            'options': Object.entries(CONFIG.DND5E.skills).filter(([key, value]) => workflow.actor.system.skills[key].value < 1).map(([i, j]) => ({'value': i, 'html': j.label}))
        },
    ],
    'buttons': constants_constants.okCancel
    }, {
        'title': workflow.item.name,
        'render': dialogRender
    });
    if (!selection.buttons) return;
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 3600
        },
        'changes': [
            {
                'key': 'system.skills.' + selection.inputs[0] +'.value',
                'mode': 4,
                'value': 1,
                'priority': 20
            }
        ]
    };
    let effect = chris.findEffect(workflow.actor, workflow.item.name);
    if (effect) await chris.removeEffect(effect);
    await chris.createEffect(workflow.actor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/bloodHunter/brandOfCastigation/brandOfCastigation.js

async function brandOfCastigation({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let effect = chris.findEffect(workflow.actor, 'Brand of Castigation');
    if (!effect) return;
    let originItem = await fromUuid(effect.origin);
    if (!originItem) return;
    let damage = chris.getSpellMod(originItem);
    if (originItem.actor.classes['blood-hunter'].system.levels >= 13) damage = damage * 2;
    let applySelfDamage = false;
    let targetToken = workflow.hitTargets.first();
    if (!targetToken) return;
    if (targetToken.actor.id === originItem.actor.id) {
        applySelfDamage = true;
    } else {
        let nearbyTargets = chris.findNearby(targetToken, 5, null)
        for (let i = 0; nearbyTargets.length > i; i++) {
            if (nearbyTargets[i].actor.id === originItem.actor.id) {
                applySelfDamage = true;
                break;
            }
        }
    }
    if (!applySelfDamage) return;
    await chris.applyDamage(workflow.token, damage, 'psychic')
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/monk/wayOfTheAscendantDragon/breathOfTheDragon.js



async function breathOfTheDragon({speaker, actor, token, character, item, args, scope, workflow}) {
    let ki = chris.getItem(workflow.actor, 'Ki Points');
    let augmentBreath = chris.getItem(workflow.actor, 'Augment Breath');
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'breathOfTheDragon', 50);
    if (!queueSetup) return;
    let inputs = [
        {
            'type': 'select',
            'label': 'Type:',
            'options': [
                {
                    'html': 'Cone',
                    'value': 'cone'
                },
                {
                    'html': 'Line',
                    'value': 'line'
                }
            ]
        },
        {
            'type': 'select',
            'label': 'Damage Type:',
            'options': [
                {
                    'html': '🧪 Acid',
                    'value': 'acid'
                },
                {
                    'html': '❄️ Cold',
                    'value': 'cold'
                },
                {
                    'html': '🔥 Fire',
                    'value': 'fire'
                },
                {
                    'html': '⚡ Lightning',
                    'value': 'lightning'
                },
                {
                    'html': '☠️ Poison',
                    'value': 'poison'
                }
            ]
        }
    ];
    if (augmentBreath && ki?.system?.uses?.value) {
        inputs.push(
            {
                'label': 'Augment (1 Ki):',
                'type': 'checkbox',
                'options': false
            }
        );
    }
    let selection = await chris.menu(workflow.item.name, constants_constants.okCancel, inputs, true);
    if (!selection.buttons) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let type = selection.inputs[0];
    let damageType = selection.inputs[1];
    let augment = augmentBreath ? selection.inputs[2] : false;
    let parts = duplicate(workflow.item.system.damage.parts);
    let target = duplicate(workflow.item.system.target);
    parts[0][0] += '[' + damageType + ']';
    parts[0][1] = damageType;
    if (type === 'line') {
        target.type = 'line';
        target.value = augment ? 90 : 30;
        target.width = 5;
    } else if (type === 'cone') {
        target.value = augment ? 60 : 20;
        target.type = 'cone'
    }
    target.units = 'ft';
    if (augment) {
        let scale = workflow.actor.system.scale['way-of-the-ascendant-dragon']?.['breath-of-the-dragon'];
        if (!scale) {
            queue_queue.remove(workflow.item.uuid);
            return;
        }
        parts[0][0] = (scale.number + 1) + 'd' + scale.faces + '[' + damageType + ']';
        await augmentBreath.displayCard();
        await ki.update({'system.uses.value': ki.system.uses.value - 1});
    }
    workflow.item = workflow.item.clone({'system.damage.parts': parts}, {'keepId': true});
    workflow.item.prepareData();
    workflow.item.prepareFinalAttributes();
    let templateData = {
        'user': game.user,
        't': target.type === 'cone' ? 'cone' : 'ray',
        'distance': target.value,
        'width': target.type === 'cone' ? null : 5,
        'fillColor': game.user.color,
        'flags': {
            'dnd5e': {
                'origin': workflow.item.uuid
            },
            'midi-qol': {
                'originUuid': workflow.item.uuid
            }
        }
    };
    let {template, tokens} = await chris.placeTemplate(templateData, true);
    let targetIds = tokens.filter(i => i.uuid != workflow.token.document.uuid).map(i => i.id);
    chris.updateTargets(targetIds);
    let effectData = {
        'origin': workflow.item.uuid,
        'icon': workflow.item.img,
        'label': workflow.item.name + ' Template',
        'duration': {
            'seconds': 1
        },
        'changes': [
            {
                'key': 'flags.dae.deleteUuid',
                'value': template.uuid,
                'mode': 5,
                'priority': 20
            }
        ]
    };
    await chris.createEffect(workflow.actor, effectData);
    queue_queue.remove(workflow.item.uuid);
    if (!chris.getConfiguration(workflow.item, 'animation') ?? true) return;
    let file = '';
    if (type === 'cone') {
        switch (damageType) {
            case 'acid':
            case 'poison':
                file = 'jb2a.breath_weapons.poison.cone.green';
                break;
            case 'cold':
                file = 'jb2a.breath_weapons.cold.cone.blue';
                break;
            case 'fire':
                file = 'jb2a.breath_weapons.fire.cone.orange.01';
            case 'lightning':
                if (chris.jb2aCheck() != 'patreon') return;
                file = 'jb2a.breath_weapons.fire.cone.blue.02';
                break;
        }
    } else {
        switch (damageType) {
            case 'acid':
            case 'poison':
                file = 'jb2a.breath_weapons.acid.line.green';
                break;
            case 'fire':
                file = 'jb2a.breath_weapons.fire.line.orange';
                break;
            case 'lightning':
                file = 'jb2a.breath_weapons.lightning.line.blue';
                break;
            case 'cold':
                if (chris.jb2aCheck() != 'patreon') return;
                file = 'jb2a.breath_weapons.fire.line.blue';
                break;
        }
    }
    new Sequence()
        .effect()
        .file(file)
        .atLocation(template.object.position)
        .stretchTo(template.object)
        .play();
}
;// CONCATENATED MODULE: ./scripts/macros/raceFeatures/dragonborn/chromatic/breathWeapon.js


async function breathWeapon({speaker, actor, token, character, item, args, scope, workflow}) {
    let level = Math.max(chris.levelOrCR(workflow.actor), 1);
    if (level < 5) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'breathWeapon', 50);
    if (!queueSetup) return;
    let dice = level >= 17 ? 4 : level >= 11 ? 3 : 2;
    let parts = duplicate(workflow.item.system.damage.parts);
    parts[0][0] = dice + 'd10[' + parts[0][1] + ']';
    workflow.item = workflow.item.clone({'system.damage.parts': parts}, {'keepId': true});
    workflow.item.prepareData();
    workflow.item.prepareFinalAttributes();
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/bugBear/brute.js

async function brute({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.item.system.actionType != 'mwak') return;
    if (!workflow.damageRoll) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'brute', 101);
    if (!queueSetup) return;
    let damageFormula = workflow.damageRoll._formula;
    let diceNum = Number(damageFormula.substring(0,1)) + 1;
    let restOfFormula = damageFormula.substring(1);
    let newFormula = diceNum + restOfFormula;
    let damageRoll = await new Roll(newFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/bugBear/surpriseAttack.js


async function surpriseAttack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (!chris.inCombat()) return;
    if (game.combat.round != 1) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'surpriseAttack', 102);
    if (!queueSetup) return;
    let selection = await chris.dialog('Is the target surpised?', [['Yes', true], ['No', false]]);
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let damageFormula = workflow.damageRoll._formula + ' + 2d6[' + workflow.defaultDamageType + ']';
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/bugBear/bugbear.js


let bugbear = {
    'brute': brute,
    'surpriseAttack': surpriseAttack
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/bulette/deadlyLeap.js


async function deadlyLeap({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size === 0) return;
    let dexSaves = [];
    let strSaves = [];
    for (let targetToken of workflow.targets.values()) {
        let targetActor = targetToken.actor;
        if (targetActor.system.abilities.dex.save >= targetActor.system.abilities.str.save) {
            dexSaves.push(targetToken.document.uuid);
        } else {
            strSaves.push(targetToken.document.uuid);
        }
    }
    let areaFeatureData = duplicate(workflow.item.toObject());
    delete(areaFeatureData.effects);
    delete(areaFeatureData._id);
    delete(areaFeatureData.flags['midi-qol'].onUseMacroName);
    delete(areaFeatureData.flags['midi-qol'].onUseMacroParts);
    delete(areaFeatureData.flags.itemacro);
    areaFeatureData.system.actionType = 'save';
    areaFeatureData.name = workflow.item.name + ': Dexterity';
    areaFeatureData.system.damage.parts = [
        ['3d6[bludgeoning] + 4', 'bludgeoning'],
        ['3d6[slashing] + 4', 'slashing']
    ];
    areaFeatureData.system.save = {
        'ability': 'dex',
        'dc': 16,
        'scaling': 'flat'
    };
    areaFeatureData.system.description.value = '';
    areaFeatureData.effects = [
        {
            'changes': [
                {
                    'key': 'macro.CE',
                    'mode': 0,
                    'priority': 20,
                    'value': 'Prone'
                }
            ],
            'icon': workflow.item.img,
            'label': workflow.item.name,
            'transfer': false
        }
    ];
    let areaFeatureData2 = duplicate(areaFeatureData);
    areaFeatureData2.name = workflow.item.name + ': Strength';
    areaFeatureData2.system.save.ability = 'str';
    let areaFeature = new CONFIG.Item.documentClass(areaFeatureData, {'parent': workflow.actor});
    let areaFeature2 = new CONFIG.Item.documentClass(areaFeatureData2, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions(dexSaves);
    if (dexSaves.length > 0) await MidiQOL.completeItemUse(areaFeature, config, options);
    options.targetUuids = strSaves;
    if (strSaves.length > 0) await MidiQOL.completeItemUse(areaFeature2, config, options);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/bulette/bulette.js

let bulette = {
    'deadlyLeap': deadlyLeap
}
;// CONCATENATED MODULE: ./scripts/macros/spells/burningHands.js

async function burningHands({speaker, actor, token, character, item, args, scope, workflow}) {
	//Animations by: eskiemoh
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? 'default';
    if (animation === 'none' || chris.jb2aCheck() === 'free') return;
    if (!workflow.templateUuid) return;
    let sourceToken = workflow.token;
    let templateDoc = await fromUuid(workflow.templateUuid);
    if (!templateDoc) return;
    let template = templateDoc.object;
    new Sequence()
	.effect()
	.file('jb2a.energy_strands.in.yellow.01.0')
	.atLocation(sourceToken) 
	.anchor({'x':0.15})
	.scaleToObject(1.1) 
	.rotateTowards(template, {'cacheLocation': true})
	.zIndex(1)

	.effect()
	.file('jb2a.magic_signs.circle.02.evocation.loop.yellow')
	.atLocation(sourceToken)
	.fadeIn(500)
	.fadeOut(500)
	.anchor({x:0.15})
	.scaleToObject(1.1)
	.duration(5000)
	.rotateTowards(template, {'cacheLocation': true})
	.loopProperty('sprite', 'rotation', {'from': 0, 'to': 360, 'duration': 1000})
	.scaleOut(0.1, 2000, {'ease': 'easeOutQuint', 'delay': -3000})
	.zIndex(2)

	.effect()
	.file('jb2a.particles.outward.orange.01.04')
	.atLocation(sourceToken)
	.fadeIn(500)
	.fadeOut(500)
	.anchor({x:0.15})
	.scaleToObject(1.1)
	.duration(5000)
	.rotateTowards(template, {'cacheLocation': true})
	.loopProperty('sprite', 'rotation', {'from': 0, 'to': 360, 'duration': 3000})
	.scaleOut(0.175, 5000, {'ease': 'easeOutQuint', 'delay': -3000})
	.waitUntilFinished(-4000)
	.zIndex(1)

	.effect()
	.file('jb2a.impact.010.orange')
	.atLocation(sourceToken) 
	.anchor({x:0.15})
	.scaleToObject(1.1) 
	.rotateTowards(template, {'cacheLocation': true})
	.zIndex(3)

	.effect()
	.file('jb2a.burning_hands.02.orange')
	.atLocation(template.position, {'cacheLocation': true})
	.stretchTo(template, {'cacheLocation': true})
	.zIndex(3)
	.play();
}
;// CONCATENATED MODULE: ./scripts/macros/spells/callLightning.js

async function callLightning({speaker, actor, token, character, item, args, scope, workflow}) {
    let storming = await chris.dialog('Is it already storming?', [['Yes', true], ['No', false]]);
    let spellLevel = workflow.castData.castLevel;
    if (storming) spellLevel += 1;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Storm Bolt', false);
    if (!featureData) return;
    featureData.system.damage.parts = [
        [
            spellLevel + 'd10[lightning]',
            'lightning'
        ]
    ];
    featureData.system.save.dc = chris.getSpellDC(workflow.item);
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Storm Bolt');
    featureData.flags['chris-premades'] = {
        'spell': {
            'castData': workflow.castData
        }
    }
    featureData.flags['chris-premades'].spell.castData.school = workflow.item.system.school;
    async function effectMacro () {
        await warpgate.revert(token.document, 'Storm Bolt');
    }
    let effectData = {
        'label': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 600
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [workflow.item.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': featureData.name,
        'description': featureData.name
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/barbarian/beast/callTheHunt.js




async function callTheHunt_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.targets.size) return;
    let max = Math.max(workflow.actor.system.abilities.con.mod, 1);
    if (workflow.targets.size > max) {
        let buttons = [
            {
                'label': 'Ok',
                'value': true
            }, {
                'label': 'Cancel',
                'value': false
            }
        ];
        let selection = await chris.selectTarget(workflow.item.name, buttons, Array.from(workflow.targets), false, 'multiple');
        if (!selection.buttons) return;
        let newTargets = selection.inputs.filter(i => i);
        if (newTargets.length > max) {
            ui.notifications.info('Too many targets selected!');
            chris.updateTargets([]);
            return;
        }
        chris.updateTargets(newTargets);
    }
}
async function callTheHunt_late({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.targets.size || !workflow.token) return;
    let damageRoll = await new Roll(workflow.targets.size * 5 + '[temphp]').roll({async: true});
    await chris.applyWorkflowDamage(workflow.token, damageRoll, 'temphp', [workflow.token], workflow.item.name, workflow.itemCardId);
    let effect = chris.findEffect(workflow.actor, 'Rage');
    if (!effect) return;
    let updates = {
        'flags': {
            'chris-premades': {
                'feature': {
                    'callTheHunt': {
                        'tokens': Array.from(workflow.targets).map(i => i.document.uuid)
                    }
                }
            }
        }
    };
    await chris.updateEffect(effect, updates);
}
async function callTheHunt_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || !workflow.token) return;
    if (!constants_constants.attacks.includes(workflow.item.system.actionType)) return;
    let effect = chris.findEffect(workflow.actor, 'Call the Hunt');
    if (!effect) return;
    let turnCheck = chris.perTurnCheck(effect, 'feature', 'callTheHunt', true, workflow.token.id);
    if (!turnCheck) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'callTheHuntAttack', 250);
    if (!queueSetup) return;
    let selection = await chris.dialog('Call the Hunt', constants_constants.yesNo, 'Apply Call the Hunt bonus damage?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    if (chris.inCombat()) {
        let updates = {
            'flags': {
                'chris-premades': {
                    'feature': {
                        'callTheHunt': {
                            'turn': game.combat.round + '-' + game.combat.turn
                        }
                    }
                }
            }
        };
        await chris.updateEffect(effect, updates);
    }
    let bonusDamageFormula = '1d8[' + workflow.defaultDamageType + ']';
    if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
    let oldFormula = workflow.damageRoll._formula;
    let damageFormula = oldFormula + ' + ' + bonusDamageFormula;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function rageEnd(effect) {
    let tokens = effect.flags['chris-premades']?.feature?.callTheHunt?.tokens;
    if (!tokens) return;
    for (let i of tokens) {
        let targetToken = await fromUuid(i);
        if (!targetToken) continue;
        let effect2 = chris.findEffect(targetToken.actor, 'Call the Hunt');
        if (!effect2) continue;
        await chris.removeEffect(effect2);
    }
}
async function callTheHunt_combatEnd(effect) {
    await effect.setFlag('chris-premades', 'feature.callTheHunt.turn', '');
}
let callTheHunt = {
    'item': callTheHunt_item,
    'late': callTheHunt_late,
    'attack': callTheHunt_attack,
    'rageEnd': rageEnd,
    'combatEnd': callTheHunt_combatEnd
}
;// CONCATENATED MODULE: ./scripts/macros/feats/cartomancer.js

async function cartomancer({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.token || !workflow.actor) return;
    let validTypes = [
        'prepared',
        'pact',
        'always'
    ]
    let spells = workflow.actor.items.filter(i => i.type === 'spell' && i.system.activation.type === 'action' && validTypes.includes(i.system.preparation?.mode));
    console.log(spells);
    if (!spells.length) return;
    let [selection] = await chris.selectDocument(workflow.item.name, spells);
    if (!selection) return;
    let spellData = duplicate(selection.toObject());
    delete spellData._id;
    setProperty(spellData, 'system.activation.type', 'bonus');
    setProperty(spellData, 'system.uses', {'max': 1, 'per': 'lr', 'recovery': '', 'value': 1});
    setProperty(spellData, 'system.preparation.mode', 'atwill');
    setProperty(spellData, 'name', spellData.name + ' (' + workflow.item.name + ')');
    async function effectMacro() {
        await warpgate.revert(token.document, 'Cartomancer');
    }
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 604800
        },
        'flags': {
            'dae': {
                'specialDuration': [
                    'longRest'
                ]
            },
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': spellData.name
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [spellData.name]: spellData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Cartomancer',
        'description': 'Cartomancer'
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/troglodyte/stench.js



async function stench(token, origin, range, duration, monsterName, originItem) {
    let targetToken = game.combat.scene.tokens.get(game.combat.current.tokenId);
    if (!targetToken) return;
    let distance = chris.getDistance(token, targetToken);
    if (distance > range) return;
    let sourceActor = game.actors.get(token.document.actorId);
    if (!sourceActor) return;
    if (!monsterName) monsterName = sourceActor.name.split(' ').join('-').toLowerCase();
    if (!originItem) originItem = origin;
    let originEffectName = originItem.name;
    let queueSetup = await queue_queue.setup(origin.uuid, 'stench', 50);
    if (!queueSetup) return;
    if (targetToken.actor.flags['chris-premades']?.monster?.[monsterName]?.feature?.stenchImmune) {
        queue_queue.remove(origin.uuid);
        return;
    }
    if (chris.findEffect(targetToken.actor, originEffectName)) {
        queue_queue.remove(origin.uuid);
        return;
    }
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.uuid]);
    let featureWorkflow = await MidiQOL.completeItemUse(originItem, config, options);
    if (featureWorkflow.failedSaves.size != 0) {
        queue_queue.remove(origin.uuid);
        return;
    }
    let effectData = {
        'label': originItem.name + ' Immune',
        'icon': originItem.img,
        'origin': originItem.uuid,
        'duration': {
            'seconds': duration
        },
        'changes': [
            {
                'key': 'flags.chris-premades.monster.' + monsterName + '.feature.stenchImmune',
                'mode': 5,
                'value': true,
                'priority': 20
            }
        ]
    }
    await chris.createEffect(targetToken.actor, effectData);
    queue_queue.remove(origin.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/catoblepas/catoblepas.js

let catoblepas = {
    'stench': stench
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/celestialSpirit/radiantMace.js

async function radiantMace({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let nearbyTargets = chris.findNearby(workflow.targets.first(), 10, 'enemy');
    if (nearbyTargets.length === 0) return;
    let targetToken;
    if (nearbyTargets.length === 1) targetToken = nearbyTargets[0];
    if (!targetToken) {
        let buttons = [
            {
                'label': 'Ok',
                'value': true
            }, {
                'label': 'Cancel',
                'value': false
            }
        ];
        let selection = await chris.selectTarget('Who gets temporary hit points?', buttons, nearbyTargets, true, 'one');
        if (selection.buttons === false) return;
        let targetTokenID = selection.inputs.find(id => id != false);
        if (!targetTokenID) return;
        targetToken = await fromUuid(targetTokenID);
    }
    let roll = await new Roll('1d10[temphp]').roll({async: true});
    roll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: workflow.item.name
    });
    await chris.applyDamage([targetToken], roll.total, 'temphp');
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/celestialSpirit/celestialSpirit.js

let celestialSpirit = {
    'radiantMace': radiantMace
}
;// CONCATENATED MODULE: ./scripts/macros/spells/chainLightning.js



async function chainLightning({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let maxTargets = workflow.castData.castLevel - 3;
    let targetToken = workflow.targets.first();
    let nearbyTokens = chris.findNearby(targetToken, 30, 'ally');
    if (nearbyTokens.length === 0) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'chainLightning', 450);
    if (!queueSetup) return;
    let addedTargets = [];
    let addedTargetUuids = [];
    if (nearbyTokens.length > maxTargets) {
        let buttons = [
            {
                'label': 'OK',
                'value': true
            }, {
                'label': 'Cancel',
                'value': false
            }
        ];
        let selection = await chris.selectTarget('Where should the lightning bounce? Max: ' + maxTargets, buttons, nearbyTokens, true, 'multiple');
        if (!selection.buttons) {
            queue_queue.remove(workflow.item.uuid);
            return;
        }
        for (let i of selection.inputs) {
            if (i) {
                addedTargets.push(await fromUuid(i));
                addedTargetUuids.push(i);
            }
        }
        if (addedTargets.length > maxTargets) {
            ui.notifications.info('Too many targets selected!');
            queue_queue.remove(workflow.item.uuid);
            return;
        }
    } else {
        for (let i of nearbyTokens) {
            addedTargets.push(i);
            addedTargetUuids.push(i.document.uuid);
        }
    }
    new Sequence().effect().atLocation(workflow.token).stretchTo(targetToken).file('jb2a.chain_lightning.secondary.blue').play();
    let previousToken = targetToken;
    for (let i of addedTargets) {
        new Sequence().effect().atLocation(previousToken).stretchTo(i).file('jb2a.chain_lightning.secondary.blue').play();
        previousToken = i;
    }
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Chain Lightning Leap', false);
    if (!featureData) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Chain Lightning Leap');
    featureData.system.save.dc = chris.getSpellDC(workflow.item);
    featureData.system.damage.parts = [
        [
            workflow.damageTotal + '[lightning]',
            'lightning'
        ]
    ];
    featureData.flags['chris-premades'] = {
        'spell': {
            'castData': workflow.castData
        }
    }
    featureData.flags['chris-premades'].spell.castData.school = workflow.item.system.school;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions(addedTargetUuids);
    await MidiQOL.completeItemUse(feature, config, options);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/cleric/natureDomain/charmAnimalsAndPlants.js

async function charmAnimalsAndPlants({speaker, actor, token, character, item, args, scope, workflow}) {
    let validTargets = Array.from(workflow.targets).filter(i => ['beast', 'plant'].includes(chris.raceOrType(i.actor))).map(i => i.id);
    chris.updateTargets(validTargets);
}

;// CONCATENATED MODULE: ./scripts/macros/spells/charmPerson.js

async function charmPerson({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.targets.size) return;
    if (!chris.inCombat()) return;
    let effectData = {
        'name': 'Condition Advantage',
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'duration': {
            'turns': 1
        },
        'changes': [
            {
                'key': 'flags.midi-qol.advantage.ability.save.all',
                'value': '1',
                'mode': 5,
                'priority': 120
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    'isSave'
                ]
            },
            'chris-premades': {
                'effect': {
                    'noAnimation': true
                }
            }
        }
    };
    let targets = Array.from(workflow.targets);
    for (let i of targets) await chris.createEffect(i.actor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/chasme/proboscis.js

async function proboscis({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let targetActor = workflow.targets.first().actor;
    let damage = -chris.totalDamageType(targetActor, workflow.damageDetail, 'necrotic');
    if (damage === 0) return;
    let targetMaxHP = targetActor.system.attributes.hp.max;
    let effect = chris.findEffect(targetActor, 'Proboscis');
    if (!effect) {
        let effectData = {
            'label': 'Proboscis',
            'icon': workflow.item.img,
            'duration': {
                'seconds': 2628000
            },
            'changes': [
                {
                    'key': 'system.attributes.hp.tempmax',
                    'mode': 2,
                    'value': Math.max(damage, -targetMaxHP),
                    'priority': 20
                }
            ],
            'flags': {
                'dae': {
                    'specialDuration': [
                        'longRest'
                    ]
                }
            }
        };
        await chris.createEffect(targetActor, effectData);
    } else {
        let oldDamage = parseInt(effect.changes[0].value);
        damage += oldDamage;
        let updates = {
            'changes': [
                {
                    'key': 'system.attributes.hp.tempmax',
                    'mode': 2,
                    'value': Math.max(damage, -targetMaxHP),
                    'priority': 20
                }
            ]
        };
        await chris.updateEffect(effect, updates);
    }
    if (Math.abs(damage) >= targetMaxHP) {
        let unconscious = chris.findEffect(targetActor, 'Unconscious');
        if (!unconscious) return;
        await chris.removeCondition(targetActor, 'Unconscious');
        await chris.addCondition(targetActor, 'Dead', true, null)
    }
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/chasme/chasme.js

let chasme = {
    'proboscis': proboscis
}
;// CONCATENATED MODULE: ./scripts/macros/spells/chillTouch.js


async function chillTouch({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let type = chris.raceOrType(workflow.actor);
    if (type.toLowerCase() != 'undead') return;
    let effect = chris.findEffect(workflow.actor, 'Chill Touch');
    if (!effect) return;
    let sourceActor = await fromUuid(effect.origin);
    let sourceActorId = sourceActor.actor.id;
    if (workflow.targets.first().actor.id != sourceActorId) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'chillTouch', 50);
    if (!queueSetup) return;
    workflow.disadvantage = true;
    workflow.attackAdvAttribution.add('Disadvantage: Chill Touch');
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/chromaticOrb.js


async function chromaticOrb({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'chromaticOrb', 50);
    if (!queueSetup) return;
    let selection = await chris.dialog('What damage type?', [['🧪 Acid', 'acid'], ['❄️ Cold', 'cold'], ['🔥 Fire', 'fire'], ['⚡ Lightning', 'lightning'], ['☠️ Poison', 'poison'], ['☁️ Thunder', 'thunder']]);
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let damageFormula = workflow.damageRoll._formula.replace('none', selection);
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
    let animation;
    if (chris.jb2aCheck() === 'patreon') {
        animation = 'jb2a.guiding_bolt.02.';
        switch(selection) {
            case 'acid':
            case 'poison':
                animation += 'greenorange';
                break;
            case 'cold':
                animation += 'dark_bluewhite';
                break;
            case 'lightning':
                animation +='yellow';
                break;
            case 'thunder':
                animation += 'blueyellow';
                break;
            case 'fire':
                animation += 'red';
                break;
            case 'lightning':
                animation += 'yellow'
        }
    } else {
        animation = 'jb2a.guiding_bolt.01.blueyellow';
    }
    new Sequence().effect().atLocation(workflow.token).stretchTo(workflow.targets.first()).file(animation).play();
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/cleric/graveDomain/circleOfMortality.js

async function circleOfMortality({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size === 0 || !workflow.damageRoll) return;
    for (let i of workflow.damageList) {
        if (i.oldHP != 0) continue;
        let targetActor = game.scenes.get(i.sceneId).tokens.get(i.tokenId).actor;
        if (chris.checkTrait(targetActor, 'di', 'healing')) continue;
        let newHealingTotal = 0;
        for (let i = 0; workflow.damageRoll.terms.length > i; i++) {
            let flavor = workflow.damageRoll.terms[i].flavor;
            let isDeterministic = workflow.damageRoll.terms[i].isDeterministic;
            if (flavor.toLowerCase() === 'healing' && !isDeterministic) {
                newHealingTotal += workflow.damageRoll.terms[i].faces * workflow.damageRoll.terms[i].results.length;
            } else {
                if (!isNaN(workflow.damageRoll.terms[i].total)) {
                    newHealingTotal += workflow.damageRoll.terms[i].total;
                }
            }
        }
        if (chris.checkTrait(targetActor, 'dr', 'healing')) newHealingTotal = Math.floor(newHealingTotal / 2);
        let maxHP = targetActor.system.attributes.hp.max;
        i.hpDamage = -Math.clamped(newHealingTotal, 0, maxHP - i.oldHP);
        i.newHP = Math.clamped(i.oldHP + newHealingTotal, 0, maxHP);
        i.totalDamage = newHealingTotal;
    }
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/clayGolem/berserk.js

async function berserk(actor, origin, hp) {
    if (!hp) hp = 60;
    if (actor.system.attributes.hp.value > hp) return;
    let effect = chris.findEffect(actor, 'Beserk');
    if (effect) return;
    let workflow = await MidiQOL.completeItemUse(origin);
    if (workflow.damageTotal != 6) return;
    let effectData = {
        'label': 'Beserk',
        'icon': origin.img,
        'duration': {
            'seconds': 86400
        },
        'flags': {
            'dae': {
                'specialDuration': [
                    'longRest'
                ]
            }
        }
    };
    await chris.createEffect(actor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/clayGolem/slam.js

async function slam({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || workflow.failedSaves.size != 1) return;
    let damage = -workflow.damageList[0].appliedDamage;
    if (damage === 0) return;
    let targetActor = workflow.targets.first().actor;
    let targetMaxHP = targetActor.system.attributes.hp.max;
    let effectName = targetActor.name + ' - ' + workflow.item.name;
    let effect = chris.findEffect(targetActor, effectName);
    if (!effect) {
        let effectData = {
            'label': effectName,
            'icon': workflow.item.img,
            'duration': {
                'seconds': 2628000
            },
            'changes': [
                {
                    'key': 'system.attributes.hp.tempmax',
                    'mode': 2,
                    'value': Math.max(damage, -targetMaxHP),
                    'priority': 20
                }
            ]
        };
        await chris.createEffect(targetActor, effectData);
    } else {
        let oldDamage = parseInt(effect.changes[0].value);
        damage += oldDamage;
        let updates = {
            'changes': [
                {
                    'key': 'system.attributes.hp.tempmax',
                    'mode': 2,
                    'value': Math.max(damage, -targetMaxHP),
                    'priority': 20
                }
            ]
        };
        await chris.updateEffect(effect, updates);
    }
    if (Math.abs(damage) >= targetMaxHP) {
        let unconscious = chris.findEffect(targetActor, 'Unconscious');
        if (!unconscious) return;
        await chris.removeCondition(targetActor, 'Unconscious');
        await chris.addCondition(targetActor, 'Dead', true, null)
    }
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/clayGolem/clayGolem.js


let clayGolem = {
    'slam': slam,
    'berserk': berserk
}
;// CONCATENATED MODULE: ./scripts/macros/mechanics/cleave.js


async function hit(workflow) {
    if (workflow.hitTargets.size != 1 || workflow.item?.system?.actionType != 'mwak' || !workflow.damageList || !workflow.item) return;
    let newHP = workflow.damageList[0].newHP;
    if (newHP != 0) return;
    if (workflow.targets.first().actor.items.getName('Minion')) return;
    let oldHP = workflow.damageList[0].oldHP;
    let leftoverDamage = workflow.damageList[0].totalDamage - (oldHP - newHP);
    if (!leftoverDamage) return;
    let fullHealthSetting = game.settings.get('chris-premades', 'DMG Cleave Full Health');
    if (!fullHealthSetting) {
        let targetMaxHP = workflow.targets.first().actor.system.attributes.hp.max;
        if (oldHP != targetMaxHP) return;
    }
    let nearbyTargets = chris.findNearby(workflow.token, workflow.rangeDetails.range ?? 5, 'enemy');
    if (!nearbyTargets.length) return;
    let selection = await chris.selectTarget('Cleave', constants_constants.yesNoButton, nearbyTargets, true, 'one', false, false, 'Cleave a nearby target?');
    if (!selection.buttons) return;
    let targetTokenID = selection.inputs.find(i => i);
    if (!targetTokenID) return;
    let weaponData = duplicate(workflow.item.toObject());
    delete(weaponData._id);
    if (!workflow.item.flags['chris-premades']?.mechanic?.cleave?.named) weaponData.name = workflow.item.name + ': Cleave';
    weaponData.system.damage.parts = [[leftoverDamage + '[' + workflow.defaultDamageType + ']', workflow.defaultDamageType]];
    weaponData.system.consume.amount = 0;
    weaponData.flags['chris-premades'] = {
        'mechanic': {
            'cleave': {
                'attack': workflow.attackRoll.total,
                'damage': leftoverDamage + '[' + workflow.defaultDamageType + ']',
                'named': true
            }
        }
    };
    let weaponAttack = new CONFIG.Item.documentClass(weaponData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetTokenID]);
    await MidiQOL.completeItemUse(weaponAttack, config, options);
}
async function cleave_attack(workflow) {
    let flag = workflow.item?.flags?.['chris-premades']?.mechanic?.cleave;
    if (!flag) return;
    if (!flag.attack) return;
    let roll = await new Roll(String(flag.attack)).evaluate({async: true});
    await workflow.setAttackRoll(roll);
}
async function cleave_damage(workflow) {
    if (!workflow.damageRoll) return;
    let flag = workflow.item?.flags?.['chris-premades']?.mechanic?.cleave;
    if (!flag) return;
    if (!flag.damage) return;
    let roll = await new Roll(String(flag.damage)).evaluate({async: true});
    await workflow.setDamageRoll(roll);
}
let cleave_cleave = {
    'hit': hit,
    'attack': cleave_attack,
    'damage': cleave_damage
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/clockworkDefender/electrifiedBite.js

async function electrifiedBite(origin, token) {
    let turnToken = game.combat.scene.tokens.get(game.combat.current.tokenId);
    let turnActor = turnToken.actor;
    let originActor = origin.actor;
    if (originActor.id != turnActor.id) return;
    let damageRoll = await new Roll('1d8[piercing] + 3 + 2d6[lightning]').roll({async: true});
    damageRoll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: origin.name
    });
    await chris.applyDamage(token, damageRoll.total);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/clockworkDefender/clockworkDefender.js

let clockworkDefender = {
    'electrifiedBite': electrifiedBite
}
;// CONCATENATED MODULE: ./scripts/macros/feats/strikeOfTheGiants/cloudStrike.js




async function cloudStrike_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (workflow.item.system.actionType != 'mwak') return;
    let originFeature = chris.getItem(workflow.actor, 'Strike of the Giants: Cloud Strike');
    if (!originFeature) return;
    if (!originFeature.system.uses.value) return;
    let turnCheck = chris.perTurnCheck(originFeature, 'feat', 'cloudStrike', false, workflow.token.id);
    if (!turnCheck) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'cloudStrike', 150);
    if (!queueSetup) return;
    let selection = await chris.dialog(originFeature.name, constants_constants.yesNo, 'Use ' + originFeature.name + '?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await originFeature.update({'system.uses.value': originFeature.system.uses.value - 1});
    if (chris.inCombat()) await originFeature.setFlag('chris-premades', 'feat.cloudStrike.turn', game.combat.round + '-' + game.combat.turn);
    let damageFormula = workflow.damageRoll._formula;
    let bonusDamage = '1d4[' + translate.damageType('thunder') + ']';
    if (workflow.isCritical) bonusDamage = chris.getCriticalFormula(bonusDamage);
    let damageRoll = await new Roll(damageFormula + ' + ' + bonusDamage).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    let saveDC = Math.max(workflow.actor.system.abilities.con.dc, workflow.actor.system.abilities.str.dc);
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Feat Features', 'Strike of the Giants: Cloud Strike', false);
    if (!featureData) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Strike of the Giants: Cloud Strike');
    featureData.system.save.dc = saveDC;
    delete featureData._id;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    feature.prepareData();
    feature.prepareFinalAttributes();
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.hitTargets.first().document.uuid]);
    await warpgate.wait(100);
    let targetWorkflow = await MidiQOL.completeItemUse(feature, config, options);
    if (targetWorkflow.failedSaves.size === 0) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let targetEffect = chris.findEffect(targetWorkflow.failedSaves.first().actor, 'Strike of the Giants: Cloud Strike');
    if (!targetEffect) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await chris.updateEffect(targetEffect, {'origin': originFeature.uuid});
    let effectData = {
        'label': 'Strike of the Giants: Cloud Strike - Invisible',
        'icon': originFeature.img,
        'origin': originFeature.uuid,
        'duration': {
            'seconds': 12
        },
        'changes': [
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.cloudStrike.selfAttack,postActiveEffects',
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    'turnStart'
                ],
                'macroRepeat': 'none'
            },
            'effectmacro': {
                'onDelete': {
                    'script': 'await chrisPremades.macros.cloudStrike.remove(effect);'
                }
            },
            'chris-premades': {
                'feat': {
                    'cloudStrike': {
                        'targetEffectUuid': targetEffect.uuid,
                        'ignore': true
                    }
                }
            }
        }
    };
    await chris.createEffect(workflow.actor, effectData);
    queue_queue.remove(workflow.item.uuid);
}
async function cloudStrike_end(origin) {
    await origin.setFlag('chris-premades', 'feat.cloudStrike.turn', '');
}
async function cloudStrike_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1 || workflow.disadvantage) return;
    let validTypes = ['mwak', 'rwak', 'msak', 'rsak'];
    if (!validTypes.includes(workflow.item.system.actionType)) return;
    let effect = chris.findEffect(workflow.actor, 'Strike of the Giants: Cloud Strike');
    if (!effect) return;
    if (!effect.origin) return;
    let originItem = await fromUuid(effect.origin);
    if (originItem.actor.uuid != workflow.targets.first().actor.uuid) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'cloudStrike', 150);
    if (!queueSetup) return;
    workflow.disadvantage = true;
    workflow.attackAdvAttribution.add('Disadvantage: ' + originItem.name);
    queue_queue.remove(workflow.item.uuid);
}
async function cloudStrike_remove(effect) {
    let targetEffectUuid = effect.flags?.['chris-premades']?.feat?.cloudStrike?.targetEffectUuid;
    if (!targetEffectUuid) return;
    let effect2 = await fromUuid(targetEffectUuid);
    if (!effect2) return;
    await chris.removeEffect(effect2);
}
async function selfAttack({speaker, actor, token, character, item, args, scope, workflow}) {
    let validTypes = ['mwak', 'rwak', 'msak', 'rsak'];
    if (!validTypes.includes(workflow.item.system.actionType)) return;
    let effect = chris.findEffect(workflow.actor, 'Strike of the Giants: Cloud Strike - Invisible');
    if (!effect) return;
    let ignore = effect.flags?.['chris-premades']?.feat?.cloudStrike?.ignore;
    if (ignore) {
        await effect.setFlag('chris-premades', 'feat.cloudStrike.ignore', false);
        return;
    }
    await chris.removeEffect(effect);
}
let cloudStrike = {
    'damage': cloudStrike_damage,
    'end': cloudStrike_end,
    'attack': cloudStrike_attack,
    'remove': cloudStrike_remove,
    'selfAttack': selfAttack
}
;// CONCATENATED MODULE: ./scripts/macros/spells/cloudkill.js



async function cloudkill_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let template = canvas.scene.collections.templates.get(workflow.templateId);
    if (!template) return;
    await template.setFlag('chris-premades', 'template', {
        'name': 'cloudkill',
        'castLevel': workflow.castData.castLevel,
        'saveDC': chris.getSpellDC(workflow.item),
        'macroName': 'cloudkill',
        'templateUuid': template.uuid,
        'turn': 'start',
        'ignoreMove': false
    });
    async function effectMacro() {
        await chrisPremades.macros.cloudkill.move(effect, token);
    }
    let effectData = {
        'label': 'Cloudkill',
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 86400
        },
        'flags': {
            'effectmacro': {
                'onTurnStart': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'spell': {
                    'cloudkill': {
                        'templateUuid': template.uuid
                    }
                }
            }
        }
    };
    await chris.createEffect(workflow.actor, effectData);
}
async function trigger(token, trigger) {
    let template = await fromUuid(trigger.templateUuid);
    if (!template) return;
    if (chris.inCombat()) {
        let turn = game.combat.round + '-' + game.combat.turn;
        let lastTurn = template.flags['chris-premades']?.spell?.cloudkill?.[token.id]?.turn;
        if (turn === lastTurn) return;
        await template.setFlag('chris-premades', 'spell.cloudkill.' + token.id + '.turn', turn);
    }
    let originUuid = template.flags.dnd5e?.origin;
    if (!originUuid) return;
    let originItem = await fromUuid(originUuid);
    if (!originItem) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Cloudkill - Damage', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Cloudkill - Damage');
    featureData.system.save.dc = trigger.saveDC;
    featureData.system.damage.parts = [
        [
            trigger.castLevel + 'd8[' + translate.damageType('poison') + ']',
            'poison'
        ]
    ];
    delete featureData._id;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': originItem.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.uuid]);
    await MidiQOL.completeItemUse(feature, config, options);
}
async function cloudkill_move(effect, token) {
    function getAllowedMoveLocation(casterToken, template, maxSquares) {
        for (let i = maxSquares; i > 0; i--) {
            let movePixels = i * canvas.grid.size;
            let ray = new Ray(casterToken.center, template.object.center);
            let newCenter = ray.project((ray.distance + movePixels)/ray.distance);
            let isAllowedLocation = canvas.effects.visibility.testVisibility({'x': newCenter.x, 'y': newCenter.y}, {'object': template.Object});
            if (isAllowedLocation) return newCenter;
        }
        return false;
    }
    let templateUuid = effect.flags['chris-premades']?.spell?.cloudkill?.templateUuid;
    if (!templateUuid) return;
    let template = await fromUuid(templateUuid);
    if (!template) return;
    let newCenter = getAllowedMoveLocation(token, template, 2);
    if(!newCenter) {
        ui.notifications.info('No room to move cloudkill!');
        return;
    }
    newCenter = canvas.grid.getSnappedPosition(newCenter.x, newCenter.y, 1);
    await template.update({x: newCenter.x, y: newCenter.y});
}
let cloudkill = {
    'item': cloudkill_item,
    'trigger': trigger,
    'move': cloudkill_move
}
;// CONCATENATED MODULE: ./scripts/macros/spells/compelledDuel.js



async function compelledDuel_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    if (!constants_constants.attacks.includes(workflow.item.system.actionType)) return;
    let effect = chris.findEffect(workflow.actor, 'Compelled Duel - Target');
    if (!effect) return;
    if (!effect.origin) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'compelledDuel', 50);
    if (!queueSetup) return;
    let origin = await fromUuid(effect.origin);
    if (!origin) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let targetUuid = workflow.targets.first().document.uuid;
    let sourceUuid = effect.flags['chris-premades']?.spell?.compelledDuel?.sourceUuid;
    if (!sourceUuid) return;
    if (targetUuid === sourceUuid) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    workflow.disadvantage = true;
    workflow.attackAdvAttribution.add('Disadvantage: ' + origin.name);
    queue_queue.remove(workflow.item.uuid);
}
async function attacker({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.token);
    if (!workflow.targets.size) return;
    let effect = chris.findEffect(workflow.actor, 'Compelled Duel - Source');
    if (!effect) return;
    let targetUuid = effect.flags['chris-premades']?.spell?.compelledDuel?.targetUuid;
    if (!targetUuid) return;
    let endSpell = false;
    for (let i of Array.from(workflow.targets)) {
        if (constants_constants.attacks.includes(workflow.item.actionType)) {
            if (i.document.uuid != targetUuid) {
                endSpell = true;
                break;
            } else {
                continue;
            }
        }
        let disposition = i.document.disposition;
        if (disposition != workflow.token.document.disposition) {
            if (i.document.uuid != targetUuid) {
                endSpell = true;
                break;
            }
        }
    }
    if (!endSpell) return;
    await chris.removeEffect(effect);
    let targetToken = await fromUuid(targetUuid);
    if (!targetToken) return;
    let effect2 = chris.findEffect(targetToken.actor, 'Compelled Duel - Target');
    if (!effect2) return;
    await chris.removeEffect(effect2);
}
async function attacked(workflow) {
    if (!workflow.token || !workflow.targets.size) return;
    for (let token of Array.from(workflow.targets)) {
        let effect = chris.findEffect(token.actor, 'Compelled Duel - Target');
        if (!effect) continue;
        if (token.document.disposition === workflow.token.document.disposition) continue;
        let sourceUuid = effect.flags['chris-premades']?.spell?.compelledDuel?.sourceUuid;
        if (!sourceUuid) continue;
        if (workflow.token.document.uuid === sourceUuid) continue;
        await chris.removeEffect(effect);
        let sourceToken = await fromUuid(sourceUuid);
        if (!sourceToken) continue;
        let effect2 = chris.findEffect(sourceToken.actor, 'Compelled Duel - Source');
        if (!effect2) continue;
        await chris.removeEffect(effect2);
    }
}
async function movement(token, updates, diff, id) {
    if (!chris.isLastGM()) return;
    if (token.parent.id != canvas.scene.id) return;
    if (!updates.x && !updates.y && !updates.elevation || !diff.animate) return;
    let effect = chris.findEffect(token.actor, 'Compelled Duel - Target');
    if (!effect) return;
    let sourceUuid = effect.flags['chris-premades']?.spell?.compelledDuel?.sourceUuid;
    if (!sourceUuid) return;
    let sourceToken = fromUuidSync(sourceUuid);
    if (!sourceToken) return;
    let fakeTargetToken = {
        'width': token.width,
        'height': token.height,
        'x': diff['chris-premades'].coords.previous.x,
        'y': diff['chris-premades'].coords.previous.y,
        'elevation': diff['chris-premades'].coords.previous.elevation
    };
    let oldDistance = chris.getCoordDistance(sourceToken.object, fakeTargetToken);
    await token.object?._animation;
    let distance = chris.getDistance(sourceToken, token);
    if (oldDistance >= distance || distance <= 30) return;
    let turnCheck = chris.perTurnCheck(effect, 'spell', 'compelledDuel');
    if (!turnCheck) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Compelled Duel - Moved', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Compelled Duel - Moved');
    delete featureData._id;
    let originItem = await fromUuid(effect.origin);
    if (!originItem) return;
    featureData.system.save.dc = chris.getSpellDC(originItem);
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.uuid]);
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': originItem.actor});
    let spellWorkflow = await MidiQOL.completeItemUse(feature, config, options);
    if (!spellWorkflow.failedSaves.size) {
        await chris.setTurnCheck(effect, 'spell', 'compelledDuel');
        return;
    }
    await new Sequence()
        .effect()
            .file('jb2a.misty_step.01.blue')
            .atLocation(token)
            .randomRotation()
            .scaleToObject(2)
            .wait(750)
        .animation()
            .on(token)
            .opacity(0.0)
            .teleportTo(fakeTargetToken)
            .wait(50)
        .effect()
            .file('jb2a.misty_step.02.blue')
            .atLocation(token)
            .randomRotation()
            .scaleToObject(2)
            .wait(1500)
        .animation()
            .on(token)
            .opacity(1.0)
        .play();
}
async function compelledDuel_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size != 1) return;
    async function effectMacro() {
        await chrisPremades.macros.compelledDuel.end(effect);
    }
    async function effectMacro2() {
        await chrisPremades.macros.compelledDuel.turnEnd(effect, token, origin);
    }
    let effectDataTarget = {
        'label': 'Compelled Duel - Target',
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'changes': [
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.compelledDuel.attack,preAttackRoll',
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'spell': {
                    'compelledDuel': {
                        'sourceUuid': workflow.token.document.uuid
                    }
                }
            },
            'effectmacro': {
                'onCombatEnd': {
                    'script': chris.functionToString(effectMacro)
                }
            }
        }
    };
    let effectDataSource ={
        'label': 'Compelled Duel - Source',
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'changes': [
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.compelledDuel.attacker,postActiveEffects',
                'priority': 20
            }
        ],
        'origin': workflow.item.uuid,
        'flags': {
            'chris-premades': {
                'spell': {
                    'compelledDuel': {
                        'targetUuid': workflow.targets.first().document.uuid
                    }
                }
            },
            'effectmacro': {
                'onTurnEnd': {
                    'script': chris.functionToString(effectMacro2)
                }
            }
        }
    };
    await chris.createEffect(workflow.actor, effectDataSource);
    await chris.createEffect(workflow.targets.first().actor, effectDataTarget);
}
async function compelledDuel_end(effect) {
    await chris.setTurnCheck(effect, 'spell', 'compelledDuel', true);
}
async function compelledDuel_turnEnd(effect, token, origin) {
    let targetUuid = effect.flags['chris-premades']?.spell?.compelledDuel?.targetUuid
    if (!targetUuid) return;
    let targetToken = await fromUuid(targetUuid);
    if (!targetToken) return;
    let distance = chris.getDistance(token, targetToken);
    if (distance <= 30) return;
    let selection = await chris.remoteDialog(origin.name, constants_constants.yesNo, chris.lastGM(), 'Caster has ended their turn more than 30 feet away from their target. Remove effect?');
    if (!selection) return;
    await chris.removeEffect(effect);
    let targetEffect = chris.findEffect(targetToken.actor, 'Compelled Duel - Target');
    if (!targetEffect) return;
    await chris.removeEffect(targetEffect);
}
let compelledDuel = {
    'attack': compelledDuel_attack,
    'attacker': attacker,
    'attacked': attacked,
    'movement': movement,
    'item': compelledDuel_item,
    'end': compelledDuel_end,
    'turnEnd': compelledDuel_turnEnd
}
;// CONCATENATED MODULE: ./scripts/macros/mechanics/conditionResistance.js

let effectData = {
    'name': 'Condition Advantage',
    'icon': 'icons/magic/time/arrows-circling-green.webp',
    'duration': {
        'turns': 1
    },
    'changes': [
        {
            'key': 'flags.midi-qol.advantage.ability.save.all',
            'value': '1',
            'mode': 5,
            'priority': 120
        }
    ],
    'flags': {
        'chris-premades': {
            'effect': {
                'noAnimation': true
            }
        }
    }
};
let cleanUpList =[];
async function conditionResistanceEarly(workflow) {
    if (!workflow.targets.size) return;
    if (workflow.item.system.save?.dc === null || workflow.item.system.save === undefined) return;
    if (!workflow.item.effects.size) return;
    let itemConditions = new Set();
    workflow.item.effects.forEach(effect => {
        effect.changes.forEach(element => {
            if (element.key === 'macro.CE') itemConditions.add(element.value.toLowerCase());
        });
    });
    if (!itemConditions.size) return;
    workflow.targets.forEach(tokenDoc => {
        itemConditions.forEach(async condition => {
            if (tokenDoc.document.actor.flags['chris-premades']?.CR?.[condition] === 1) {
                await chris.createEffect(tokenDoc.document.actor, effectData);
                cleanUpList.push(tokenDoc.document.actor);
            }
        });
    });
}
async function conditionResistanceLate(workflow) {
    for (let i of cleanUpList) {
        let effect = chris.findEffect(i, 'Condition Advantage');
        if (effect) await chris.removeEffect(effect);
    }
    cleanUpList = [];
}
;// CONCATENATED MODULE: ./scripts/macros/mechanics/conditionVulnerability.js

let conditionVulnerability_effectData = {
    'name': 'Condition Disadvantage',
    'icon': 'icons/magic/time/arrows-circling-green.webp',
    'duration': {
        'turns': 1
    },
    'changes': [
        {
            'key': 'flags.midi-qol.disadvantage.ability.save.all',
            'value': '1',
            'mode': 5,
            'priority': 120
        }
    ]
};
let conditionVulnerability_cleanUpList =[];
async function conditionVulnerabilityEarly(workflow) {
    if (!workflow.targets.size) return;
    if (workflow.item.system.save?.dc === null || workflow.item.system.save === undefined) return;
    if (!workflow.item.effects.size) return;
    let itemConditions = new Set();
    workflow.item.effects.forEach(effect => {
        effect.changes.forEach(element => {
            if (element.key === 'macro.CE') itemConditions.add(element.value.toLowerCase());
        });
    });
    if (!itemConditions.size) return;
    workflow.targets.forEach(tokenDoc => {
        itemConditions.forEach(async condition => {
            if (tokenDoc.document.actor.flags['chris-premades']?.CV?.[condition] === 1) {
                await chris.createEffect(tokenDoc.document.actor, conditionVulnerability_effectData);
                conditionVulnerability_cleanUpList.push(tokenDoc.document.actor);
            }
        });
    });
}
async function conditionVulnerabilityLate(workflow) {
    for (let i of conditionVulnerability_cleanUpList) {
        let effect = chris.findEffect(i, 'Condition Disadvantage');
        if (effect) await chris.removeEffect(effect);
    }
    conditionVulnerability_cleanUpList = [];
}
;// CONCATENATED MODULE: ./scripts/macros/spells/conjureAnimals.js


async function conjureAnimals({speaker, actor, token, character, item, args, scope, workflow}) {
    let spellLevel = workflow.castData?.castLevel;
    if (!spellLevel) return;
    let totalSummons = Math.floor(1 * ((spellLevel - 1) / 2));
    if (!totalSummons || totalSummons < 1) return;
    let selection = await chris.dialog('How many beasts?', [
        [totalSummons + ' beasts of CR 2 or lower', 2], 
        [(totalSummons * 2) + ' beasts of CR 1 or lower', 1], 
        [(totalSummons * 4) + ' beasts of CR 1/2 or lower', 0.5], 
        [(totalSummons * 8) + ' beasts of CR 1/4 or lower', 0.25]
    ]);
    if (!selection) return;
    let folder = chris.getConfiguration(workflow.item, 'folder') ?? game.settings.get('chris-premades', 'Summons Folder');
    if (!folder && folder === '') folder = 'Chris Premades';
    let actors = game.actors.filter(i => i.folder?.name === folder).filter(i => i.system?.details?.type?.value.toLowerCase() === 'beast').filter(i => i.system?.details?.cr <= selection);
    if (actors.length < 1) {
        ui.notifications.warn('No matching actors found in specified folder!');
        return;
    }
    let userId = game.settings.get('chris-premades', 'LastGM');
    if (game.settings.get('chris-premades', 'Player Chooses Conjures')) userId = game.userId;
    if (!userId) return;
    let sourceActors = await chris.remoteDocumentsDialog(userId, 'Select Summons (Max ' + (totalSummons * 2 / selection) + ')', actors);
    if (!sourceActors) return;
    if (sourceActors.length > (totalSummons * 2 / selection)) {
        ui.notifications.info('Too many selected, try again!');
        return;
    }
    let updates = {
        'actor': {
            'system': {
                'details': {
                    'type': {
                        'value': 'fey'
                    }
                }
            }
        },
        'token': {
            'disposition': workflow.token.document.disposition 
        }
    };
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? 'nature';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await summons.spawn(sourceActors, updates, 3600, workflow.item, undefined, undefined, 60, workflow.token, animation);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/conjureCelestial.js


async function conjureCelestial({speaker, actor, token, character, item, args, scope, workflow}) {
    let spellLevel = workflow.castData?.castLevel;
    if (!spellLevel) return;
    let cr = 4;
    if (spellLevel === 9) cr = 5;
    let folder = chris.getConfiguration(workflow.item, 'folder') ?? game.settings.get('chris-premades', 'Summons Folder');
    if (!folder && folder === '') folder = 'Chris Premades';
    let actors = game.actors.filter(i => i.folder?.name === folder).filter(i => i.system?.details?.type?.value.toLowerCase() === 'celestial').filter(i => i.system?.details?.cr <= cr);
    if (actors.length < 1) {
        ui.notifications.warn('No matching actors found in specified folder!');
        return;
    }
    let userId = game.settings.get('chris-premades', 'LastGM');
    if (game.settings.get('chris-premades', 'Player Chooses Conjures')) userId = game.userId;
    if (!userId) return;
    let sourceActors = await chris.remoteDocumentDialog(userId, 'Select Summon', actors);
    if (!sourceActors) return;
    let updates = {
        'token': {
            'disposition': workflow.token.document.disposition
        }
    };
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? 'celestial';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await summons.spawn(sourceActors, updates, 3600, workflow.item, undefined, undefined, 90, workflow.token, animation);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/conjureElemental.js


async function conjureElemental({speaker, actor, token, character, item, args, scope, workflow}) {
    let spellLevel = workflow.castData?.castLevel;
    if (!spellLevel) return;
    let cr = spellLevel;
    let folder = chris.getConfiguration(workflow.item, 'folder') ?? game.settings.get('chris-premades', 'Summons Folder');
    if (!folder && folder === '') folder = 'Chris Premades';
    let actors = game.actors.filter(i => i.folder?.name === folder).filter(i => i.system?.details?.type?.value.toLowerCase() === 'elemental').filter(i => i.system?.details?.cr <= cr);
    if (actors.length < 1) {
        ui.notifications.warn('No matching actors found in specified folder!');
        return;
    }
    let userId = game.settings.get('chris-premades', 'LastGM');
    if (game.settings.get('chris-premades', 'Player Chooses Conjures')) userId = game.userId;
    if (!userId) return;
    let sourceActors = await chris.remoteDocumentDialog(userId, 'Select Summon', actors);
    if (!sourceActors) return;
    let updates = {
        'token': {
            'disposition': workflow.token.document.disposition
        }
    };
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? 'default';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await summons.spawn(sourceActors, updates, 3600, workflow.item, true, undefined, undefined, workflow.token, animation);
    let effect = chris.findEffect(workflow.actor, 'Concentrating');
    if (!effect) return;
    async function effectMacro () {
        let targetEffect = chrisPremades.helpers.findEffect(effect.parent, 'Conjure Elemental');
        if (!targetEffect) return;
        let summons = targetEffect.flags['chris-premades']?.summons?.ids['Conjure Elemental'];
        if (!summons) return;
        let updates = {
            'token': {
                'disposition': token.document.disposition * -1 
            }
        };
        let options = {
            'permanent': true,
            'name': 'Conjure Elemental - Hostile',
            'description': 'Conjure Elemental - Hostile'
        };
        for (let i of summons) {
            let token = canvas.scene.tokens.get(i);
            if (token) await warpgate.mutate(token, updates, {}, options);
        }
    }
    let effectUpdates = {
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            }
        }
    };
    await chris.updateEffect(effect, effectUpdates);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/conjureFey.js


async function conjureFey({speaker, actor, token, character, item, args, scope, workflow}) {
    let spellLevel = workflow.castData?.castLevel;
    if (!spellLevel) return;
    let cr = spellLevel;
    let folder = chris.getConfiguration(workflow.item, 'folder') ?? game.settings.get('chris-premades', 'Summons Folder');
    if (!folder && folder === '') folder = 'Chris Premades';
    let actors = game.actors.filter(i => i.folder?.name === folder).filter(i => i.system?.details?.type?.value.toLowerCase().includes(['fey', 'beast'])).filter(i => i.system?.details?.cr <= cr);
    if (actors.length < 1) {
        ui.notifications.warn('No matching actors found in specified folder!');
        return;
    }
    let userId = game.settings.get('chris-premades', 'LastGM');
    if (game.settings.get('chris-premades', 'Player Chooses Conjures')) userId = game.userId;
    if (!userId) return;
    let sourceActors = await chris.remoteDocumentDialog(userId, 'Select Summon', actors);
    if (!sourceActors) return;
    let updates = {
        'token': {
            'disposition': workflow.token.document.disposition
        }
    };
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? 'nature';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await summons.spawn(sourceActors, updates, 3600, workflow.item, true, undefined, 90, workflow.token, animation);
    let effect = chris.findEffect(workflow.actor, 'Concentrating');
    if (!effect) return;
    async function effectMacro () {
        let targetEffect = chrisPremades.helpers.findEffect(effect.parent, 'Conjure Fey');
        if (!targetEffect) return;
        let summons = targetEffect.flags['chris-premades']?.summons?.ids['Conjure Fey'];
        if (!summons) return;
        let updates = {
            'token': {
                'disposition': token.document.disposition * -1 
            }
        };
        let options = {
            'permanent': true,
            'name': 'Conjure Fey - Hostile',
            'description': 'Conjure Fey - Hostile'
        };
        for (let i of summons) {
            let token = canvas.scene.tokens.get(i);
            if (token) await warpgate.mutate(token, updates, {}, options);
        }
    }
    let effectUpdates = {
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            }
        }
    };
    await chris.updateEffect(effect, effectUpdates);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/conjureMinorElementals.js


async function conjureMinorElementals({speaker, actor, token, character, item, args, scope, workflow}) {
    let spellLevel = workflow.castData?.castLevel;
    if (!spellLevel) return;
    let totalSummons = Math.floor(1 * ((spellLevel - 2) / 2));
    if (!totalSummons || totalSummons < 1) return;
    let selection = await chris.dialog('How many elementals?', [
        [totalSummons + ' elementals of CR 2 or lower', 2], 
        [(totalSummons * 2) + ' elementals of CR 1 or lower', 1], 
        [(totalSummons * 4) + ' elementals of CR 1/2 or lower', 0.5], 
        [(totalSummons * 8) + ' elementals of CR 1/4 or lower', 0.25]
    ]);
    if (!selection) return;
    let folder = chris.getConfiguration(workflow.item, 'folder') ?? game.settings.get('chris-premades', 'Summons Folder');
    if (!folder && folder === '') folder = 'Chris Premades';
    let actors = game.actors.filter(i => i.folder?.name === folder).filter(i => i.system?.details?.type?.value.toLowerCase() === 'elemental').filter(i => i.system?.details?.cr <= selection);
    if (actors.length < 1) {
        ui.notifications.warn('No matching actors found in specified folder!');
        return;
    }
    let userId = game.settings.get('chris-premades', 'LastGM');
    if (game.settings.get('chris-premades', 'Player Chooses Conjures')) userId = game.userId;
    if (!userId) return;
    let sourceActors = await chris.remoteDocumentsDialog(userId, 'Select Summons (Max ' + (totalSummons * 2 / selection) + ')', actors);
    if (!sourceActors) return;
    if (sourceActors.length > (totalSummons * 2 / selection)) {
        ui.notifications.info('Too many selected, try again!');
        return;
    }
    let updates = {
        'token': {
            'disposition': workflow.token.document.disposition 
        }
    };
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? 'default';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await summons.spawn(sourceActors, updates, 3600, workflow.item, undefined, undefined, 90, workflow.token, animation);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/conjureWoodlandBeings.js


async function conjureWoodlandBeings({speaker, actor, token, character, item, args, scope, workflow}) {
    let spellLevel = workflow.castData?.castLevel;
    if (!spellLevel) return;
    let totalSummons = Math.floor(1 * ((spellLevel - 2) / 2));
    if (!totalSummons || totalSummons < 1) return;
    let selection = await chris.dialog('How many fey creatures?', [
        [totalSummons + ' fey creatures of CR 2 or lower', 2], 
        [(totalSummons * 2) + ' fey creatures of CR 1 or lower', 1], 
        [(totalSummons * 4) + ' fey creatures of CR 1/2 or lower', 0.5], 
        [(totalSummons * 8) + ' fey creatures of CR 1/4 or lower', 0.25]
    ]);
    if (!selection) return;
    let folder = chris.getConfiguration(workflow.item, 'folder') ?? game.settings.get('chris-premades', 'Summons Folder');
    if (!folder && folder === '') folder = 'Chris Premades';
    let actors = game.actors.filter(i => i.folder?.name === folder).filter(i => i.system?.details?.type?.value.toLowerCase() === 'fey').filter(i => i.system?.details?.cr <= selection);
    if (actors.length < 1) {
        ui.notifications.warn('No matching actors found in specified folder!');
        return;
    }
    let userId = game.settings.get('chris-premades', 'LastGM');
    if (game.settings.get('chris-premades', 'Player Chooses Conjures')) userId = game.userId;
    if (!userId) return;
    let sourceActors = await chris.remoteDocumentsDialog(userId, 'Select Summons (Max ' + (totalSummons * 2 / selection) + ')', actors);
    if (!sourceActors) return;
    if (sourceActors.length > (totalSummons * 2 / selection)) {
        ui.notifications.info('Too many selected, try again!');
        return;
    }
    let updates = {
        'token': {
            'disposition': workflow.token.document.disposition
        }
    };
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? 'nature';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await summons.spawn(sourceActors, updates, 3600, workflow.item, undefined, undefined, 60, workflow.token, animation);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/constructSpirit/stonyLethargy.js


async function stonyLethargy_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size != 1) return;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    await chris.addCondition(targetActor, 'Reaction', false, workflow.item.uuid);
}
async function stonyLethargy_turnStart(token, origin) {
    let targetToken = game.canvas.tokens.get(game.combat.current.tokenId);
    if (!targetToken) return;
    if (targetToken.document.disposition === token.document.disposition) return;
    let distance = chris.getDistance(token, targetToken);
    if (distance > 10) return;
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.document.uuid]);
    await MidiQOL.completeItemUse(origin, config, options);
}
let stoneLethargy = {
    'item': stonyLethargy_item,
    'turnStart': stonyLethargy_turnStart
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/constructSpirit/constructSpirit.js

let constructSpirit = {
    'stoneLethargy': stoneLethargy
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/paladin/oathbreaker/controlUndead.js

async function controlUndead_early({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.targets.size) return;
    let effectData = {
        'name': 'Invalid Target',
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'duration': {
            'turns': 1
        },
        'changes': [
            {
                'key': 'flags.midi-qol.min.ability.save.all',
                'value': 99,
                'mode': 5,
                'priority': 120
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    'isSave'
                ]
            },
            'chris-premades': {
                'effect': {
                    'noAnimation': true
                }
            }
        }
    };
    for (let i of Array.from(workflow.targets)) if (chris.raceOrType(i.actor) != 'undead') await chris.createEffect(i.actor, effectData);
}
async function controlUndead_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let animation = chris.getConfiguration(workflow.item, 'animation');
    if (chris.jb2aCheck() != 'patreon' || !animation) return;
    //Animation by Eskimoh
    if (!workflow.targets.size) return;
    let targetToken = workflow.targets.first();
    let failedSave = workflow.failedSaves.size;
    new Sequence()
        .effect()
        .attachTo(workflow.token)
        .file('jb2a.extras.tmfx.outflow.circle.01')
        .scaleToObject(1.5 * workflow.token.document.texture.scaleX)
        .opacity(1)
        .belowTokens()
        .randomRotation()
        .filter('ColorMatrix', {'brightness': 0})
        .fadeIn(500)
        .fadeOut(500)

        .effect()
        .file('jb2a.magic_signs.rune.necromancy.intro.red')
        .attachTo(targetToken)
        .scaleToObject(0.5)
        .scaleOut(0, 1000, {'ease': 'easeInBack'})
        .fadeOut(500, {'ease': 'easeInCubic'})
        .zIndex(1)

        .effect()
        .file('jb2a.markers.02.red')
        .atLocation(workflow.token)
        .rotateTowards(targetToken)
        .spriteOffset({'x': -0.2}, {'gridUnits': true})
        .spriteScale({'x': 0.8, 'y': 1})
        .filter('ColorMatrix', {'saturate': 0.5, 'hue': -2})
        .rotate(0)
        .scaleToObject(1)
        .scaleIn(0, 1500, {'ease': 'easeOutCubic'})
        .animateProperty('sprite', 'position.x', {'from': -0.5, 'to': 0.05, 'duration': 1000, 'gridUnits': true, 'ease': 'easeOutBack', 'delay': 0})
        .animateProperty('sprite', 'width', {'from': 0.8, 'to': 0.25, 'duration': 500, 'gridUnits': true, 'ease': 'easeOutBack', 'delay': 1500})
        .animateProperty('sprite', 'height', {'from': 1, 'to': 0.25, 'duration': 500, 'gridUnits': true, 'ease': 'easeOutBack', 'delay': 1500})
        .filter('Glow', {'color': 0x000000 })
        .fadeOut(1000)
        .zIndex(1)

        .effect()
        .file('jb2a.particle_burst.01.circle.bluepurple')
        .atLocation(workflow.token)
        .rotateTowards(targetToken)
        .spriteOffset({x:-0.2}, {'gridUnits': true})
        .spriteScale({x:0.8,y:1})
        .filter('ColorMatrix', {'saturate': 0.5, 'hue': -2})
        .rotate(0)
        .scaleToObject(1)
        .scaleIn(0, 1500, {'ease': 'easeOutCubic'})
        .animateProperty('sprite', 'position.x', {'from': -0.5, 'to': 0.05, 'duration': 1000, 'gridUnits': true, 'ease':'easeOutBack', 'delay': 0})
        .tint('#e51e19')
        .zIndex(0)

        .effect()
        .file('jb2a.particle_burst.01.circle.bluepurple')
        .attachTo(targetToken)
        .scaleToObject(1.5)
        .filter('ColorMatrix', {'saturate': 0.5, 'hue': -2})
        .tint('#e51e19')
        .belowTokens()
        .zIndex(0)

        .effect()
        .delay(550)
        .file('jb2a.smoke.puff.centered.dark_black')
        .attachTo(targetToken)
        .scaleToObject(1.8)
        .scaleOut(0, 1000, {'ease': 'easeInBack'})
        .randomRotation()
        .belowTokens()

        .effect()
        .delay(750)
        .file('jb2a.particles.outward.red.01.03')
        .atLocation(workflow.token)
        .rotateTowards(targetToken)
        .spriteOffset({'x': -0.5, 'y': -0.1}, {'gridUnits': true})
        .filter('ColorMatrix', {'saturate':1, 'hue': -2})
        .spriteScale({'x': 0.8,'y': 1})
        .scaleToObject(2.5)
        .scaleIn(0, 1500, {'ease': 'easeOutCubic'})
        .tint('#e51e19')
        .duration(1500)
        .fadeOut(1500)
        .waitUntilFinished(-1500)

        .effect()
        .name('Control Undead')
        .from(targetToken)
        .attachTo(targetToken,{'bindAlpha': false})
        .opacity(0.75)
        .mirrorX(targetToken.document.texture.scaleX != 0)
        .scaleToObject(1, {'considerTokenScale': true})
        .tint('#e51e19')
        .fadeIn(500)
        .fadeOut(500)
        .duration(1000)
        .playIf(failedSave)

        .effect()
        .delay(100)
        .file('jb2a.particles.outward.white.01.03')
        .attachTo(targetToken, {'offset': {'y': 0.2}, 'gridUnits': true, 'followRotation': false})
        .scaleToObject()
        .duration(1000)
        .fadeOut(800)
        .scaleIn(0, 1000, {'ease': 'easeOutCubic'})
        .animateProperty('sprite', 'width', {'from': 0, 'to': 0.25, 'duration': 500, 'gridUnits': true, 'ease':'easeOutBack'})
        .animateProperty('sprite', 'height', {'from': 0, 'to': 1.0, 'duration': 1000, 'gridUnits': true, 'ease':'easeOutBack'})
        .animateProperty('sprite', 'position.y', {'from': -0, 'to': -0.6, 'duration': 1000, 'gridUnits': true})
        .tint('#e51e19')
        .filter('Blur', {'blurX': 0, 'blurY': 5})
        .opacity(0.8)
        .zIndex(0.3)
        .playIf(failedSave)

        .effect()
        .delay(750)
        .file('jb2a.static_electricity.03.dark_red')
        .atLocation(targetToken)
        .size(1.25, {'gridUnits': true})
        .opacity(1)
        .playbackRate(1)
        .randomRotation()
        .zIndex(0.3)
        .playIf(failedSave)

        .effect()
        .delay(500)
        .name('Control Undead')
        .file('jb2a.extras.tmfx.outflow.circle.01')
        .attachTo(targetToken, {'cacheLocation': true, 'offset': {'y':0}, 'gridUnits': true, 'bindAlpha': false})
        .scaleToObject(1.45, {'considerTokenScale': true})
        .randomRotation()
        .fadeIn(1000)
        .fadeOut(500)
        .belowTokens()
        .opacity(0.45)
        .loopProperty('alphaFilter', 'alpha', {'from': 0.75, 'to': 1, 'duration': 1500, 'pingPong': true, 'ease': 'easeOutSine'})
        .filter('ColorMatrix', { 'brightness':0 })
        .persist()
        .playIf(failedSave)

        .effect()
        .delay(500)
        .name('Control Undead')
        .from(targetToken)
        .attachTo(targetToken,{'bindAlpha': false})
        .belowTokens()
        .mirrorX(targetToken.document.texture.scaleX < 0)
        .scaleToObject(1, {'considerTokenScale': true})
        .loopProperty('alphaFilter', 'alpha', {'from': 0.75, 'to': 1, 'duration': 1500, 'pingPong': true, 'ease': 'easeOutSine'})
        .filter('Glow', {'color': 0xe51e19, 'distance': 5, 'outerStrength':4, 'innerStrength': 0 })
        .fadeIn(1000)
        .fadeOut(500)
        .persist()
        .zIndex(0.1)
        .playIf(failedSave)

        .play()
}
async function controlUndead_end(token, origin) {
    let animation = chris.getConfiguration(origin, 'animation');
    if (!animation) return;
    await Sequencer.EffectManager.endEffects({'name': 'Control Undead', 'object': token});
}
let controlUndead = {
    'early': controlUndead_early,
    'item': controlUndead_item,
    'end': controlUndead_end
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/corpseFlower/reanimate.js

async function reanimate(token, origin) {
    let originActor = origin.actor;
    if (!originActor) return;
    let stenchEffect = chris.findEffect(originActor, 'Stench of Death Immunity');
    if (!stenchEffect) return;
    let originItem = await fromUuid(stenchEffect.origin);
    await chrisPremades.macros.monster.hezrou.stench(token, origin, 10, 86400, 'corpse-flower', originItem);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/corpseFlower/corpseFlower.js

let corpseFlower = {
    'reanimate': reanimate
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/warlock/boons/pactOfTheBlade/createPactWeapon.js

async function create({speaker, actor, token, character, item, args, scope, workflow}) {
    let items = workflow.actor.items.filter(i => i.flags['chris-premades']?.feature?.createPactWeapon).map(j => j.id);
    if (items.length) await dismiss({'workflow': workflow});
    let pack = game.settings.get('chris-premades', 'Item Compendium');
    if (!game.packs.get(pack)) {
        ui.notifications.warn('Personal Item Compendium setting must be set!');
        return
    }
    let weapons = [
        'Club',
        'Dagger',
        'Greatclub',
        'Handaxe',
        'Javelin',
        'Light Hammer',
        'Mace',
        'Quarterstaff',
        'Sickle',
        'Spear',
        'Battleaxe',
        'Flail',
        'Glaive',
        'Greataxe',
        'Greatsword',
        'Halberd',
        'Lance',
        'Longsword',
        'Maul',
        'Morningstar',
        'Pike',
        'Rapier',
        'Scimitar',
        'Shortsword',
        'Trident',
        'War Pick',
        'Warhammer',
        'Whip'
    ];
    let improvedPactWeapon = chris.getItem(workflow.actor, 'Eldritch Invocations: Improved Pact Weapon');
    if (improvedPactWeapon) {
        weapons = weapons.concat([
            'Shortbow',
            'Longbow',
            'Crossbow, light',
            'Crossbow, heavy'
        ]);
    }
    let documents;
    try {
        documents = await Promise.all(weapons.map(async i => await chris.getItemFromCompendium(pack, i, true)));
    } catch {
        ui.notifications.warn('Personal Item Compendium is missing a required weapon for this feature!');
        return;
    }
    if (!documents.length) {
        ui.notifications.warn('Personal Item Compendium is missing the required weapons for this feature!');
        return;
    }
    let selection = await chris.selectDocument('Select a Pact Weapon', documents, false);
    if (!selection) return;
    selection[0].name += ' (Pact Weapon)';
    selection[0].system.proficient = true;
    selection[0].system.properties.mgc = true;
    let hexWarrior = chris.getItem(workflow.actor, 'Hex Warrior');
    if (hexWarrior) {
        let cha = workflow.actor.system.abilities.cha.mod;
        let ability = (selection[0].system.ability === '' || selection[0].system.ability === null) ? 'str' : selection[0].system.ability;
        let score = workflow.actor.system.abilities[ability].mod;
        let dex = workflow.actor.system.abilities.dex.mod;
        let changed = false;
        if (selection[0].system.properties.fin) {
            let mod = dex > score ? dex : score;
            if (mod <= cha) {
                ability = 'cha';
                changed = true;
            }
        } else {
            if (score <= cha) {
                ability = 'cha';
                changed = true;
            }
        }
        if (changed) selection[0].system.ability = ability;
    }
    if (improvedPactWeapon) {
        selection[0].system.attackBonus = 1;
        selection[0].system.damage.parts[0][0] += ' + 1';
    }
    selection[0].system.equipped = true;
    setProperty(selection[0], 'flags.chris-premades.feature.createPactWeapon', true);
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Dismiss Pact Weapon');
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Dismiss Pact Weapon');
    setProperty(featureData, 'flags.chris-premades.feature.createPactWeapon', true);
    selection.push(featureData);
    await workflow.actor.createEmbeddedDocuments('Item', selection);
}
async function dismiss({speaker, actor, token, character, item, args, scope, workflow}) {
    let items = workflow.actor.items.filter(i => i.flags['chris-premades']?.feature?.createPactWeapon).map(j => j.id);
    if (!items.length) return;
    await workflow.actor.deleteEmbeddedDocuments('Item', items);
}
let createPactWeapon = {
    'create': create,
    'dismiss': dismiss
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/bloodHunter/crimsonRite/crimsonRite.js

async function crimsonRite({speaker, actor, token, character, item, args, scope, workflow}) {
    let tokenDoc = workflow.token.document;
    let targetActor = workflow.actor;
    if (workflow.targets.size != 1) return;
    let damageDice = targetActor.system.scale['blood-hunter']['crimson-rite'];
    if (!damageDice) {
        ui.notifications.warn('Source actor does not appear to have a Crimson Rite scale!');
        return;
    }
    let generatedMenu = [];
    let mutationStack = warpgate.mutationStack(tokenDoc);
    targetActor.items.forEach(item => {
        if (item.type === 'weapon' && item.system.equipped === true) {
            let mutateItem = mutationStack.getName('Crimson Rite: ' + item.id);
            if (!mutateItem) generatedMenu.push([item.name, item.id]);
        }
    });
    let selection;
    if (generatedMenu.length === 0) return;
    if (generatedMenu.length === 1) selection = generatedMenu[0][1];
    if (!selection) selection = await chris.dialog('What weapon?', generatedMenu);
    if (!selection) return;
    let riteMenu = [];
    if (targetActor.items.getName('Crimson Rite: Rite of the Flame')) riteMenu.push(['Rite of the Flame', 'fire']);
    if (targetActor.items.getName('Crimson Rite: Rite of the Frozen')) riteMenu.push(['Rite of the Frozen', 'cold']);
    if (targetActor.items.getName('Crimson Rite: Rite of the Storm')) riteMenu.push(['Rite of the Storm', 'lightning']);
    if (targetActor.items.getName('Crimson Rite: Rite of the Dead')) riteMenu.push(['Rite of the Dead', 'necrotic']);
    if (targetActor.items.getName('Crimson Rite: Rite of the Oracle')) riteMenu.push(['Rite of the Oracle', 'psychic']);
    if (targetActor.items.getName('Crimson Rite: Rite of the Roar')) riteMenu.push(['Rite of the Roar', 'thunder']);
    if (targetActor.items.getName('Rite of the Dawn')) riteMenu.push(['Rite of the Dawn', 'radiant']);
    let damageType;
    if (riteMenu.length === 0) return;
    if (riteMenu.length === 1) damageType = riteMenu[0][1];
    if (!damageType) damageType = await chris.dialog('What Crimson Rite?', riteMenu);
    if (!damageType) return;
    let weaponData = targetActor.items.get(selection).toObject();
    weaponData.system.damage.parts.push([damageDice + '[' + damageType + ']', damageType]);
    weaponData.system.properties.mgc = true;
    let effectData = {
        'label': 'Crimson Rite: ' + weaponData.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 604800
        },
        'flags': {
            'dae': {
                'specialDuration': [
                    'zeroHP',
                    'longRest',
                    'shortRest'
                ],
                'stackable': 'multi',
                'macroRepeat': 'none'
            },
            'effectmacro': {
                'onDelete': {
                    'script': "warpgate.revert(token.document, '" + 'Crimson Rite: ' + weaponData._id + "');"
                }
            }
        }
    };
    if (damageType === 'radiant') {
        effectData.changes = [
            {
                'key': 'system.traits.dr.value',
                'mode': 2,
                'value': 'necrotic',
                'priority': 20
            },
            {
                'key': 'ATL.light.bright',
                'mode': 4,
                'value': '20',
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.riteOfTheDawn,postDamageRoll',
                'priority': 20
            }
        ];
        weaponData.flags['chris-premades'] = {
            'feature': {
                'rotd': true
            }
        };
    }
    let updates = {
        'embedded': {
            'Item': {
                [weaponData.name]: weaponData
            },
            'ActiveEffect': {
                ['Crimson Rite: ' + weaponData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Crimson Rite: ' + weaponData._id,
        'description': 'Crimson Rite: ' + weaponData.name
    };
    await warpgate.mutate(tokenDoc, updates, {}, options);
}
;// CONCATENATED MODULE: ./scripts/macros/feats/crusher.js




async function critical({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || !workflow.damageRoll || !workflow.isCritical) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'crusherCritical', 450);
    if (!queueSetup) return;
    if (!chris.getRollDamageTypes(workflow.damageRoll).has('bludgeoning')) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let feature = chris.getItem(workflow.actor, 'Crusher: Critical');
    if (!feature) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let effetData = {
        'name': feature.name,
        'icon': feature.img,
        'origin': feature.uuid,
        'duration': {
            'seconds': 12
        },
        'changes': [
            {
                'key': 'flags.midi-qol.grants.advantage.attack.all',
                'mode': 0,
                'value': '1',
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    'turnStartSource'
                ],
                'stackable': 'multi',
                'macroRepeat': 'none'
            }
        }
    }
    await chris.createEffect(workflow.targets.first().actor, effetData);
    await feature.use();
    queue_queue.remove(workflow.item.uuid);
}
async function crusher_move({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1 || !workflow.damageRoll) return;
    let targetToken = workflow.targets.first();
    let targetSize = chris.getSize(targetToken.actor, false);
    if (targetSize > (chris.getSize(workflow.actor, false) + 1)) return;
    let feature = chris.getItem(workflow.actor, 'Crusher');
    if (!feature) return;
    let turnCheck = chris.perTurnCheck(feature, 'feat', 'crusher', false);
    if (!turnCheck) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'crusherCritical', 450);
    if (!queueSetup) return;
    let damageTypes = chris.getRollDamageTypes(workflow.damageRoll);
    if (!damageTypes.has(translate.damageType('bludgeoning'))) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Move target?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await workflow.actor.sheet.minimize();
    let icon = targetToken.document.texture.src;
    let interval = targetToken.document.width % 2 === 0 ? 1 : -1;
    let position = await chris.aimCrosshair(targetToken, 5, icon, interval, targetToken.document.width);
    if (position.cancelled) {
        await workflow.actor.sheet.maximize();
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let newCenter = canvas.grid.getSnappedPosition(position.x - targetToken.w / 2, position.y - targetToken.h / 2, 1);
    let targetUpdate = {
        'token': {
            'x': newCenter.x,
            'y': newCenter.y
        }
    };
    let options = {
        'permanent': true,
        'name': feature.name,
        'description': feature.name
    };
    await warpgate.mutate(targetToken.document, targetUpdate, {}, options);
    await workflow.actor.sheet.maximize();
    await feature.displayCard();
    queue_queue.remove(workflow.item.uuid);
}
let crusher = {
    'critical': critical,
    'move': crusher_move
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/barbarian/giant/crushingThrow.js


async function crushingThrow({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || !workflow.item.system.properties.thr) return;
    if (!(workflow.item.system.ability === '' || workflow.item.system.ability === 'str')) return;
    if (workflow.item.system.properties.fin && workflow.item.system.ability === '') {
        if (workflow.actor.system.abilities.dex.mod > workflow.actor.system.abilities.str.mod) return;
    }
    let distance = chris.getDistance(workflow.token, workflow.targets.first());
    let demiurgicColossus = chris.getItem(workflow.actor, 'Demiurgic Colossus');
    if (distance <= (demiurgicColossus ? 15 : 10)) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'crushingThrow', 250);
    if (!queueSetup) return;
    let bonusDamageFormula = workflow.actor.system.scale.barbarian?.['rage-damage']?.value;
    if (!bonusDamageFormula) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let oldFormula = workflow.damageRoll._formula;
    if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
    let damageFormula = oldFormula + ' + ' + bonusDamageFormula;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    let feature = chris.getItem(workflow.actor, 'Giant\'s Havoc: Crushing Throw');
    if (feature) await feature.displayCard();
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/items/crystalBlade.js



async function heal({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.item.system.damage.parts[0][0] != '0[healing') return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'crystalBladeHealing', 50);
    if (!queueSetup) return;
    function dialogRender(html) {
        let ths = html[0].getElementsByTagName('th');
        for (let t of ths) {
            t.style.width = 'auto';
            t.style.textAlign = 'left';
        }
        let tds = html[0].getElementsByTagName('td');
        for (let t of tds) {
            t.style.width = '50px';
            t.style.textAlign = 'center';
            t.style.paddingRight = '5px';
        }
    }
    let selection = await warpgate.menu({
        'inputs': [
            {
                'label': 'Healing:',
                'type': 'number'
            }
        ],
        'buttons': [
            {
                'label': 'Cancel',
                'value': false
            },
            {
                'label': 'Ok',
                'value': true
            }
        ]
    },
    {
        'title': workflow.item.name,
        'render': dialogRender,
        'options': {
            'width': '400px'
        }
    });
    if (!selection.buttons) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    if (isNaN(selection.inputs[0])) {
        queue_queue.remove(workflow.uuid);
        return;
    }
    let damageRoll = await new Roll(selection.inputs[0] + '[healing]').roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function crystalBlade_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (!chris.getConfiguration(workflow.item, 'healprompt') ?? true) return;
    let healItem = workflow.actor.items.find(i => i.flags?.['chris-premades']?.equipmentFeature?.uniqueName === 'crystalBladeHeal');
    if (!healItem) return;
    let uses = healItem.system.uses.value;
    if (!uses) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'crystalBlade', 50);
    if (!queueSetup) return;
    let selection = await chris.dialog(workflow.item.name, [['Yes,', true], ['No', false]], 'Use a charge to heal yourself?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let featureData = duplicate(healItem.toObject());
    delete featureData._id;
    featureData.system.damage.parts[0][0] = workflow.damageRoll.terms[4].total + '[healing]';
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.token.document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature, config, options);
    await healItem.update({'system.uses.value': uses - 1});
    queue_queue.remove(workflow.item.uuid);
}
async function light({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect1 = chris.findEffect(workflow.actor, 'Crystal Blade - Bright Light');
    let effect2 = chris.findEffect(workflow.actor, 'Crystal Blade - Dim Light');
    let options = [];
    if (!effect1) options.push(['Bright Light', 'bright']);
    if (!effect2) options.push(['Dim Light', 'dim']);
    if (effect1 || effect2) options.push(['Douse Light', 'douse']);
    let selection = await chris.dialog(workflow.item.name, options, 'What type of light do you want?');
    if (!selection) return;
    let effectData;
    switch (selection) {
        case 'bright':
            if (effect2) await chris.removeEffect(effect2);
            effectData = {
                'label': 'Crystal Blade - Bright Light',
                'icon': workflow.item.img,
                'origin': workflow.item.uuid,
                'duration': {
                    'seconds': 86400
                },
                'changes': [
                    {
                        'key': 'ATL.light.dim',
                        'mode': 4,
                        'value': '60',
                        'priority': 20
                    },
                    {
                        'key': 'ATL.light.bright',
                        'mode': 4,
                        'value': '30',
                        'priority': 20
                    }
                ]
            }
            await chris.createEffect(workflow.actor, effectData);
            return;
        case 'dim':
            if (effect1) await chris.removeEffect(effect1);
            effectData = {
                'label': 'Crystal Blade - Dim Light',
                'icon': workflow.item.img,
                'origin': workflow.item.uuid,
                'duration': {
                    'seconds': 86400
                },
                'changes': [
                    {
                        'key': 'ATL.light.dim',
                        'mode': 4,
                        'value': '30',
                        'priority': 20
                    }
                ]
            }
            await chris.createEffect(workflow.actor, effectData);
            return;
        case 'douse':
            if (effect1) await chris.removeEffect(effect1);
            if (effect2) await chris.removeEffect(effect2);
            return;
    }
}
let crystalBlade = {
    'heal': heal,
    'item': crystalBlade_item,
    'light': light
}
;// CONCATENATED MODULE: ./scripts/macros/items/dancingSword.js

async function dancingSword_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let sourceActor = game.actors.getName('CPR - Dancing Sword');
    if (!sourceActor) return;
    let effect = chris.findEffect(workflow.actor, 'Dancing Sword Passive');
    if (!effect) return;
    let originItem = await fromUuid(effect.origin);
    if (!originItem) return;
    async function effectMacro() {
        let originActor = origin.actor;
        await warpgate.dismiss(token.id);
        let castEffect = chrisPremades.helpers.findEffect(originActor, origin.name);
        if (castEffect) await chrisPremades.helpers.removeEffect(castEffect);
    }
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': 'Dismiss Summon'
                }
            }
        }
    };
    let name = chris.getConfiguration(workflow.item, 'name') ?? originItem.name;
    if (name === '') name = originItem.name;
    let updates = {
        'actor': {
            'name': name,
            'prototypeToken': {
                'name': name
            }
        },
        'token': {
            'name': name
        },
        'embedded': {
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    
    let avatarImg = chris.getConfiguration(originItem, 'avatar');
    if (avatarImg) updates.actor.img = avatarImg;
    let tokenImg = chris.getConfiguration(originItem, 'token');
    if (!tokenImg) {
        let weaponType = originItem.system.baseItem;
        if (chris.jb2aCheck() && weaponType) {
            try {
                tokenImg = await Sequencer.Database.getEntry('jb2a.spiritual_weapon.' + weaponType + '.01.spectral.02.green').file;
            } catch {}
            if (!tokenImg) await Sequencer.Database.getEntry('jb2a.spiritual_weapon.greatsword.01.spectral.02.green').file;
        }
    }
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    let options = {
        'controllingActor': workflow.token.actor
    };
    let tokenDocument = await sourceActor.getTokenDocument();
    let spawnedTokens = await warpgate.spawn(tokenDocument, updates, {}, options);
    if (!spawnedTokens) return;
    let spawnedToken = game.canvas.scene.tokens.get(spawnedTokens[0]);
    if (!spawnedToken) return;
    let targetEffect = chris.findEffect(spawnedToken.actor, workflow.item.name);
    if (!targetEffect) return;
    let casterEffectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'changes': [
            {
                'key': 'flags.chris-premades.feature.dancingSword.tokenUuid',
                'mode': 5,
                'value': spawnedToken.uuid,
                'priority': 20
            }
        ],
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': 'let effect = await fromUuid("' + targetEffect.uuid + '"); if (effect) await chrisPremades.helpers.removeEffect(effect); await warpgate.revert(token.document, "Dancing Sword");'
                }
            },
            'chris-premades': {
                'vae': {
                    'button': 'Dancing Sword - Attack'
                }
            }
        }
    };
    let attackFeatureData = await chris.getItemFromCompendium('chris-premades.CPR Item Features', 'Dancing Sword - Attack', false);
    if (!attackFeatureData) return;
    attackFeatureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Dancing Sword - Attack');
    attackFeatureData.system.ability = originItem.system.ability;
    if (originItem.system.properties.fin && workflow.actor.system.abilities.dex.mod > workflow.actor.system.abilities.str.mod) attackFeatureData.system.ability = 'dex';
    attackFeatureData.system.damage.parts = originItem.system.damage.parts;
    attackFeatureData.img = originItem.img;
    let updates2 = {
        'embedded': {
            'Item': {
                [attackFeatureData.name]: attackFeatureData
            },
            'ActiveEffect': {
                [casterEffectData.name]: casterEffectData
            }
        }
    };
    let options2 = {
        'permanent': false,
        'name': 'Dancing Sword',
        'description': 'Dancing Sword'
    };
    await warpgate.mutate(workflow.token.document, updates2, {}, options2);
}
async function attackEarly({speaker, actor, token, character, item, args, scope, workflow}) {
    let uses = workflow.item?.flags['chris-premades']?.feature?.dancingSword?.uses ?? 0;
    uses += 1;
    await workflow.item.setFlag('chris-premades', 'feature.dancingSword.uses', uses);
    await workflow.item.setFlag('chris-premades', 'feature.dancingSword.position', {'x': workflow.token.document.x, 'y': workflow.token.document.y});
    await workflow.actor.setFlag('chris-premades', 'mechanic.noFlanking', true);
    let weaponTokenUuid = workflow.actor.flags['chris-premades']?.feature?.dancingSword?.tokenUuid;
    if (!weaponTokenUuid) return;
    let weaponToken = await fromUuid(weaponTokenUuid);
    if (!weaponToken) return;
    let position = canvas.grid.getSnappedPosition(weaponToken.x, weaponToken.y);
    workflow.token.document.x = position.x;
    workflow.token.document.y = position.y;
    workflow.flankingAdvantage = false; //Does not currently work.
}
async function attackLate({speaker, actor, token, character, item, args, scope, workflow}) { 
    await workflow.actor.unsetFlag('chris-premades', 'mechanic.noFlanking');
    let position = workflow.item.flags['chris-premades']?.feature?.dancingSword?.position;
    if (!position) return;
    workflow.token.document.x = position.x;
    workflow.token.document.y = position.y;
    if (workflow.item?.flags['chris-premades']?.feature?.dancingSword?.uses === 4) {
        let effect = chris.findEffect(workflow.actor, 'Dancing Sword - Toss');
        if (!effect) return;
        await chris.removeEffect(effect);
    }
}
async function equip(actor, origin, level) {
    let itemData = await chris.getItemFromCompendium('chris-premades.CPR Item Features', 'Dancing Sword - Toss', false);
    if (!itemData) return;
    itemData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Dancing Sword - Toss');
    itemData.img = (origin).img;
    await chris.addTempItem(actor, itemData, origin.id, 'Dancing Sword - Toss', false, 0);
}
async function unequip(actor, origin) {
    await chris.removeTempItems(actor, origin.id);
}
async function deleted(actor, effect) {
    if (effect.disabled) return;
    let originArray = effect.origin.split('Item.');
    if (originArray.length != 2) return;
    let originID = originArray[1];
    await chris.removeTempItems(actor, originID);
}
let dancingSword = {
    'item': dancingSword_item,
    'attackEarly': attackEarly,
    'attackLate': attackLate,
    'equip': equip,
    'unequip': unequip,
    'deleted': deleted
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/barbarian/dangerSense.js

function dangerSense(saveId, options) {
    let blinded = chris.findEffect(this, 'Blinded');
    let deafened = chris.findEffect(this, 'Deafened');
    let incapacitated = chris.findEffect(this, 'Incapacitated');
    if (blinded || deafened || incapacitated) return;
    return saveId != 'dex' ? false : {'label': 'This save from an effect you can see.', 'type': 'advantage'};
}
;// CONCATENATED MODULE: ./scripts/macros/spells/danseMacabre.js


async function danseMacabre({speaker, actor, token, character, item, args, scope, workflow}) {
    let zombieActor = game.actors.getName('CPR - Zombie');
    let skeletonActor = game.actors.getName('CPR - Skeleton');
    if (!zombieActor || !skeletonActor) return;
    let nearbyTokens = await chris.findNearby(workflow.token, 60, 'all', true).filter(t => t.actor.system.attributes.hp.value === 0 && !chris.findEffect(t.actor, 'Unconscious'));
    if (!nearbyTokens.length) return;
    let options = [
        'Ignore',
        'Skeleton',
        'Zombie'
    ];
    let bonusHP = 0;
    let damageBonus;
    if (workflow.actor.flags["chris-premades"]?.feature?.undeadThralls) {
        let wizardLevels = workflow.actor.classes.wizard?.system?.levels;
        if (wizardLevels) bonusHP += wizardLevels;
        damageBonus = workflow.actor.system.attributes.prof;
    }
    let maxTargets = 5 + ((workflow.castData.castLevel - 5) * 2);
    let selection = await chris.selectTarget('Select your targets. (Max: ' + maxTargets + ')', constants_constants.okCancel, nearbyTokens, true, 'select', options);
    if (!selection.buttons) return;
    let totalSelected = selection.inputs.filter(i => i != 'Ignore').length;
    if (totalSelected > maxTargets) {
        ui.notifications.info('Too many targets selected!');
        return;
    }
    let zombieActorUpdates = zombieActor.toObject();
    delete zombieActorUpdates.token;
    delete zombieActorUpdates.items;
    delete zombieActorUpdates.effects;
    delete zombieActorUpdates.type;
    delete zombieActorUpdates.flags;
    delete zombieActorUpdates.folder;
    zombieActorUpdates.name = 'Zombie';
    zombieActorUpdates.system.attributes.hp.value += bonusHP;
    zombieActorUpdates.system.attributes.hp.max += bonusHP;
    zombieActorUpdates.system.attributes.hp.formula += ' + ' + bonusHP;
    delete zombieActorUpdates.sort;
    delete zombieActorUpdates._id;
    delete zombieActorUpdates._stats;
    delete zombieActorUpdates.ownership;
    setProperty(zombieActorUpdates, 'ownership.' + game.user.id, CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER);
    let zombieTokenUpdates = (await zombieActor.getTokenDocument()).toObject();
    zombieTokenUpdates.actorLink = false;
    delete zombieTokenUpdates.actorId;
    delete zombieTokenUpdates.x;
    delete zombieTokenUpdates.y;
    delete zombieTokenUpdates._id;
    zombieTokenUpdates.disposition = workflow.token.document.disposition;
    let zombieItems = zombieActor.getEmbeddedCollection('Item').reduce( (acc, element) => {acc[element.id] = element.toObject(); return acc;}, {});
    let skeletonActorUpdates = skeletonActor.toObject();
    delete skeletonActorUpdates.token;
    delete skeletonActorUpdates.items;
    delete skeletonActorUpdates.effects;
    delete skeletonActorUpdates.type;
    delete skeletonActorUpdates.flags;
    delete skeletonActorUpdates.folder;
    skeletonActorUpdates.name = 'Skeleton';
    skeletonActorUpdates.system.attributes.hp.value += bonusHP;
    skeletonActorUpdates.system.attributes.hp.max += bonusHP;
    skeletonActorUpdates.system.attributes.hp.formula += ' + ' + bonusHP;
    delete skeletonActorUpdates.sort;
    delete skeletonActorUpdates._id;
    delete skeletonActorUpdates._stats;
    delete skeletonActorUpdates.ownership;
    setProperty(skeletonActorUpdates, 'ownership.' + game.user.id, CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER);
    let skeletonTokenUpdates = (await skeletonActor.getTokenDocument()).toObject();
    skeletonTokenUpdates.actorLink = false;
    delete skeletonTokenUpdates.actorId;
    delete skeletonTokenUpdates.x;
    delete skeletonTokenUpdates.y;
    delete skeletonTokenUpdates._id;
    skeletonTokenUpdates.disposition = workflow.token.document.disposition;
    let skeletonItems = skeletonActor.getEmbeddedCollection('Item').reduce( (acc, element) => {acc[element.id] = element.toObject(); return acc;}, {});
    let mutationName = 'Danse Macabre';
    let mutateOptions =  {
        'name': mutationName,
        'permanent': false,
        'comparisonKeys': {
            'Item': 'id'
        }
    };
    async function effectMacro () {
        await warpgate.revert(token.document, 'Danse Macabre');
        if (actor.type === 'character') await chrisPremades.helpers.addCondition(actor, 'Dead', true);
    }
    let spellMod = '+ ' + chris.getSpellMod(workflow.item);
    if (damageBonus) spellMod += ' + ' + damageBonus;
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'changes': [
            {
                'key': 'system.bonuses.All-Damage',
                'mode': 2,
                'value': spellMod,
                'priority': 20
            },
            {
                'key': 'system.bonuses.All-Attacks',
                'mode': 2,
                'value': spellMod,
                'priority': 20
            }
        ],
        'duration': {
            'seconds': 3600
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            }
        },
        'transfer': true
    };
    let targetTokens = [];
    for (let i = 0; nearbyTokens.length > i; i++) {
        if (selection.inputs[i] === 'Ignore') continue;
        let turnToken = nearbyTokens[i];
        targetTokens.push(turnToken.document.uuid);
        if (turnToken.actor.type === 'character') await chris.removeCondition(turnToken.actor, 'Dead');
        let newItems;
        let updates;
        let itemUpdates;
        if (selection.inputs[i] === 'Zombie') {
            newItems = zombieItems;
            itemUpdates = turnToken.actor.items.reduce( (acc, val) => {acc[val.id] = warpgate.CONST.DELETE; return acc;}, newItems);
            updates = {
                'token': zombieTokenUpdates,
                'actor': zombieActorUpdates,
                'embedded': {
                    'Item': itemUpdates,
                    'ActiveEffect': {
                        [effectData.name]: effectData
                    }
                }
            };
        } else if (selection.inputs[i] === 'Skeleton') {
            newItems = skeletonItems;
            itemUpdates = turnToken.actor.items.reduce( (acc, val) => {acc[val.id] = warpgate.CONST.DELETE; return acc;}, newItems);
            updates = {
                'token': skeletonTokenUpdates,
                'actor': skeletonActorUpdates,
                'embedded': {
                    'Item': itemUpdates,
                    'ActiveEffect': {
                        [effectData.name]: effectData
                    }
                }
            };
        }
        await warpgate.mutate(turnToken.document, updates, {}, mutateOptions);
    }
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Danse Macabre - Command Undead', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Danse Macabre - Command Undead');
    async function effectMacro2 () {
        let targetTokens = effect.flags['chris-premades']?.spell?.danseMacabre;
        if (targetTokens) {
            for (let i of targetTokens) {
                let targetToken = await fromUuid(i);
                if (!targetToken) continue;
                let targetEffect = chrisPremades.helpers.findEffect(targetToken.actor, 'Danse Macabre');
                if (targetEffect) chrisPremades.helpers.removeEffect(targetEffect);
            }
        }
        await warpgate.revert(token.document, 'Danse Macabre - Command Undead');
    }
    let effectData2 = {
        'name': workflow.item.name + ' - Caster',
        'icon': workflow.item.img,
        'duration': {
            'seconds': 3600
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro2)
                }
            },
            'chris-premades': {
                'spell': {
                    'danseMacabre': targetTokens
                }
            }
        }
    };
    let updates2 = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData2.name]: effectData2
            }
        }
    };
    let options2 = {
        'permanent': false,
        'name': 'Danse Macabre - Command Undead',
        'description': featureData.name
    };
    await warpgate.mutate(workflow.token.document, updates2, {}, options2);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/warlock/fiend/darkOnesBlessing.js

async function darkOnesBlessing({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size === 0 || !workflow.damageList) return;
    let doHealing = false;
    for (let i of workflow.damageList) {
        if (i.oldHP != 0 && i.newHP === 0) {
            doHealing = true;
            break;
        }
    }
    if (!doHealing) return;
    let effect = chris.findEffect(workflow.actor, 'Dark One\'s Blessing');
    if (!effect) return;
    let originItem = await fromUuid(effect.origin);
    await originItem.use();
}
;// CONCATENATED MODULE: ./scripts/macros/spells/darkness.js


async function darknessItem({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.templateId) return;
    let template = canvas.scene.collections.templates.get(workflow.templateId);
    if (!template) return;
    await template.update({
        'flags': {
            'chris-premades': {
                'spell': {
                    'darkness': true
                }
            },
            'limits': {
                'sight': {
                    'basicSight': {
                        'enabled': true,
                        'range': 0
                    },
                    'ghostlyGaze': {
                        'enabled': true,
                        'range': 0
                    },
                    'lightPerception': {
                        'enabled': true,
                        'range': 0
                    }
                },
                'light': {
                    'enabled': true,
                    'range': 0
                }
            },
            'walledtemplates': {
                'wallRestriction': 'move',
                'wallsBlock': 'recurse'
            }
        }
    });
    let attachToken = await chris.dialog('Attach to self?', [['Yes', true], ['No', false]]) || false;
    if (attachToken) {
        let tokenObject = workflow.token;
        await template.update(
            {
                'x': tokenObject.center.x,
                'y': tokenObject.center.y
            }
        );
        await tokenAttacher.attachElementsToToken([template], tokenObject, false);
    };
    let xray = game.settings.get('chris-premades', 'Show Limits Animations');
    if(game.modules.get('walledtemplates')?.active) {
        new Sequence().effect().file('jb2a.darkness.black').scaleToObject().aboveLighting().opacity(0.5).xray(xray).mask(template).persist(true).attachTo(template).play();
    } else {
        new Sequence().effect().file('jb2a.darkness.black').scaleToObject().aboveLighting().opacity(0.5).xray(xray).persist(true).attachTo(template).play();
    }
}
async function darknessHook(workflow) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first().document;
    if (!targetToken) return;
    let sourceToken = workflow.token.document;
    let sourceTemplates = game.modules.get('templatemacro').api.findContainers(sourceToken);
    let sourceInDarkness = false;
    for (let i = 0; sourceTemplates.length > i; i++) {
        let testTemplate = canvas.scene.collections.templates.get(sourceTemplates[i]);
        if (!testTemplate) continue;
        let darkness = testTemplate.flags['chris-premades']?.spell?.darkness;
        if (darkness) {
            sourceInDarkness = true;
            break;
        }
    }
    let targetInDarkness = false;
    let targetTemplates = game.modules.get('templatemacro').api.findContainers(targetToken);
    for (let i = 0; targetTemplates.length > i; i++) {
        let testTemplate = canvas.scene.collections.templates.get(targetTemplates[i]);
        if (!testTemplate) continue;
        let darkness = testTemplate.flags['chris-premades']?.spell?.darkness;
        if (darkness) {
            targetInDarkness = true;
            break;
        }
    }
    if (!sourceInDarkness && !targetInDarkness) return;
    let distance = chris.getDistance(sourceToken, targetToken);
    let sourceCanSeeTarget = false;
    let targetCanSeeSource = false;
    let sourceActor = sourceToken.actor;
    let targetActor = targetToken.actor;
    let sourceDS = sourceActor.flags['chris-premades']?.feature?.devilsight;
    let targetDS = targetActor.flags['chris-premades']?.feature?.devilsight;
    let sourceSenses = sourceToken.actor.system.attributes.senses;
    let targetSenses = targetToken.actor.system.attributes.senses;
    if ((sourceDS && distance <= 120) || (sourceSenses.tremorsense >= distance) || (sourceSenses.blindsight >= distance) || (sourceSenses.truesight >= distance)) sourceCanSeeTarget = true;
    if ((targetDS && distance <= 120) || (targetSenses.tremorsense >= distance) || (targetSenses.blindsight >= distance) || (targetSenses.truesight >= distance)) targetCanSeeSource = true;
    if (sourceCanSeeTarget && targetCanSeeSource) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'darkness', 50);
    if (!queueSetup) return;
    if (sourceCanSeeTarget && !targetCanSeeSource) {
        workflow.advantage = true;
        workflow.attackAdvAttribution.add('Darkness: Target Can\'t See Source');
    }
    if (!sourceCanSeeTarget && targetCanSeeSource) {
        workflow.disadvantage = true;
        workflow.flankingAdvantage = false;
        workflow.attackAdvAttribution.add('Darkness: Source Can\'t See Target');
    }
    if (!sourceCanSeeTarget && !targetCanSeeSource) {
        workflow.advantage = true;
        workflow.disadvantage = true;
        workflow.attackAdvAttribution.add('Darkness: Target And Source Can\'t See Eachother');
    }
    queue_queue.remove(workflow.item.uuid);
}
let darkness = {
    'item': darknessItem,
    'hook': darknessHook
}
;// CONCATENATED MODULE: ./scripts/macros/spells/dawn.js


async function dawn_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let template = canvas.scene.collections.templates.get(workflow.templateId);
    if (!template) return;
    await template.setFlag('chris-premades', 'template', {
        'name': 'dawn',
        'castLevel': workflow.castData.castLevel,
        'saveDC': chris.getSpellDC(workflow.item),
        'macroName': 'dawn',
        'templateUuid': template.uuid,
        'turn': 'end',
        'ignoreMove': true
    });
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Dawn - Move', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Dawn - Move');
    async function effectMacro () {
        await warpgate.revert(token.document, 'Dawn');
    }
    let effectData = {
        'name': 'Dawn',
        'icon': workflow.item.img,
        'transfer': false,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 60
        },
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': effectData.name,
        'description': effectData.name
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
async function dawn_trigger(token, trigger) {
    let template = await fromUuid(trigger.templateUuid);
    if (!template) return;
    let originUuid = template.flags.dnd5e?.origin;
    if (!originUuid) return;
    let originItem = await fromUuid(originUuid);
    if (!originItem) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Dawn - End Turn', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Dawn - End Turn');
    featureData.system.save.dc = trigger.saveDC;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': originItem.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.uuid]);
    await MidiQOL.completeItemUse(feature, config, options);
}
let dawn = {
    'item': dawn_item,
    'trigger': dawn_trigger
}
;// CONCATENATED MODULE: ./scripts/macros/spells/deathWard.js


async function deathWard(token, {item, workflow, ditem}) {
    let effect = chris.findEffect(token.actor, 'Death Ward');
    if (!effect) return;
    let queueSetup = await queue_queue.setup(workflow.uuid, 'deathWard', 390);
    if (!queueSetup) return;
    if (ditem.newHP != 0) {
        queue_queue.remove(workflow.uuid);
        return;
    }
    ditem.newHP = 1;
    ditem.hpDamage = Math.abs(ditem.newHP - ditem.oldHP);
    await chris.removeEffect(effect);
    queue_queue.remove(workflow.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/deepGnome/stoneCamouflage.js
function stoneCamouflage(skillId, options) {
    return skillId != 'ste' ? false : {'label': 'Hiding in rocky terrain?', 'type': 'advantage'};
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/deepGnome/deepGnome.js

let deepGnome = {
    'stoneCamouflage': stoneCamouflage
}
;// CONCATENATED MODULE: ./scripts/macros/spells/destructiveWave.js


async function destructiveWave({speaker, actor, token, character, item, args, scope, workflow}) {
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'destructiveWave', 50);
    if (!queueSetup) return;
    let selection = await chris.dialog('What damage type?', [['Radiant', 'radiant'], ['Necrotic', 'necrotic']]);
    if (!selection) selection = 'radiant';
    let animation = 'jb2a.thunderwave.center.blue';
    if (chris.jb2aCheck() === 'patreon') {
        if (selection === 'necrotic') {
            animation = 'jb2a.thunderwave.center.dark_purple';
        } else {
            animation = 'jb2a.thunderwave.center.orange'
        }
    }
    new Sequence().effect().atLocation(workflow.token).file(animation).scale(2.2).playbackRate(0.5).play();
    let damageFormula = workflow.damageRoll._formula.replace('none', selection);
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/cleric/tempestDomain/destructiveWrath.js

async function destructiveWrath({speaker, actor, token, character, item, args, scope, workflow}) {
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'destructiveWrath', 351);
    if (!queueSetup) return;
    let oldDamageRoll = workflow.damageRoll;
    if (oldDamageRoll.terms.length === 0) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let newDamageRoll = '';
    for (let i = 0; oldDamageRoll.terms.length > i; i++) {
        let flavor = oldDamageRoll.terms[i].flavor;
        let isDeterministic = oldDamageRoll.terms[i].isDeterministic;
        if (!(flavor.toLowerCase() === 'lightning' || flavor.toLowerCase() === 'thunder') || isDeterministic === true) {
            newDamageRoll += oldDamageRoll.terms[i].formula;
        } else {
            newDamageRoll += '(' + oldDamageRoll.terms[i].number + '*' + oldDamageRoll.terms[i].faces + ')[' + flavor + ']';
        }
    }
    let damageRoll = await new Roll(newDamageRoll).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/detectThoughts.js

async function detectThoughtsProbeItem({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size === 1) return;
    let effect = chris.findEffect(workflow.actor, 'Detect Thoughts');
    if (!effect) return;
    await chris.removeEffect(effect);
    await chris.removeCondition(workflow.actor, 'Concentrating');
}
async function detectThoughtsItem({speaker, actor, token, character, item, args, scope, workflow}) {
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Detect Thoughts - Probe Deeper', false);
    if (!featureData) return;
    featureData.system.save.dc = chris.getSpellDC(workflow.item);
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Detect Thoughts - Probe Deeper');
    async function effectMacro () {
        await warpgate.revert(token.document, 'Detect Thoughts - Probe Deeper');
    }
    let effectData = {
        'label': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [workflow.item.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': featureData.name,
        'description': featureData.name
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
let detectThoughts = {
    'item': detectThoughtsItem,
    'probe': detectThoughtsProbeItem
}
;// CONCATENATED MODULE: ./scripts/macros/spells/disintegrate.js


async function disintegrate({speaker, actor, token, character, item, args, scope, workflow}) {
    //Animations by: eskiemoh
    if (!workflow.targets.size) return;
    let target = workflow.targets.first();
    let targetDeath = workflow.damageList[0].newHP === 0;
    if (targetDeath && target.actor.type === 'character') await chris.addCondition(target.actor, 'Dead', true);
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? 'default';
    if (animation === 'none' || chris.jb2aCheck() === 'free' || !chris.aseCheck()) return;
    let centerX =  target.x + canvas.grid.size / 2;
    let centerY =  target.y + canvas.grid.size / 2;
    new Sequence()
        .effect()
        .atLocation(workflow.token)
        .file('jb2a.magic_signs.circle.02.transmutation.loop.dark_green')
        .scaleToObject(1.25)
        .rotateIn(180, 600, {'ease': 'easeOutCubic'})
        .scaleIn(0, 600, {'ease': 'easeOutCubic'})
        .loopProperty('sprite', 'rotation', {'from': 0, 'to': -360, 'duration': 10000})
        .belowTokens()
        .fadeOut(2000)
        .zIndex(0)

        .effect()
        .atLocation(workflow.token)
        .file('jb2a.magic_signs.circle.02.transmutation.loop.dark_green')
        .scaleToObject(1.25)
        .rotateIn(180, 600, {'ease': 'easeOutCubic'})
        .scaleIn(0, 600, {'ease': 'easeOutCubic'})
        .loopProperty('sprite', 'rotation', {'from': 0, 'to': -360, 'duration': 10000})
        .belowTokens(true)
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 2})
        .filter('Blur', {'blurX': 5, 'blurY': 10 })
        .zIndex(1)
        .duration(1200)
        .fadeIn(200, {'ease': 'easeOutCirc', 'delay': 500})
        .fadeOut(300, {'ease': 'linear'})
        .zIndex(0.1)

        .effect()
        .file('jb2a.particles.outward.white.01.02')
        .scaleIn(0, 1000, {'ease': 'easeOutQuint'})
        .delay(500)
        .fadeOut(1000)
        .atLocation(workflow.token)
        .duration(1000)
        .size(1.75, {'gridUnits': true})
        .animateProperty('spriteContainer', 'position.y', {'from':0 , 'to': -0.5, 'gridUnits': true, 'duration': 1000})
        .zIndex(1)

        .effect()
        .file('jb2a.particles.outward.white.01.02')
        .scaleIn(0, 1000, {'ease': 'easeOutQuint'})
        .delay(500)
        .fadeOut(1000)
        .atLocation(workflow.token)
        .duration(1000)
        .size(1.75, {'gridUnits': true})
        .animateProperty('spriteContainer', 'position.y', {'from': 0 , 'to': -0.5, 'gridUnits': true, 'duration': 1000})
        .zIndex(1)
        .mirrorX()

        .wait(1000)

        .effect()
        .file('jb2a.extras.tmfx.border.circle.inpulse.01.fast')
        .atLocation(workflow.token)
        .tint('#d9df53')
        .scaleToObject(1.5)

        .wait(500)

        .effect()
        .file('jb2a.disintegrate.green')
        .atLocation(workflow.token)
        .stretchTo(target)
        .missed(workflow.failedSaves.size === 0)
        .zIndex(1)

        .wait(500)

        //Death Effect
        .animation()
        .on(target)
        .opacity(0)
        .playIf(targetDeath)

        .effect()
        .file('animated-spell-effects-cartoon.smoke.97')
        .atLocation(target, {'offset': {'y':-0.25}, 'gridUnits': true})
        .fadeIn(1000)
        .scaleIn(0, 1000, {'ease': 'easeOutCubic'})
        .delay(1000)
        .duration(10000)
        .fadeOut(500)
        .scaleToObject(0.5)
        .filter('ColorMatrix', {'brightness': 0})
        .zIndex(0.1)
        .belowTokens()
        .playIf(targetDeath)

        .effect()
        .file('jb2a.spirit_guardians.green.particles')
        .atLocation(target)
        .duration(7500)
        .fadeOut(3000)
        .scaleToObject(0.35)
        .filter('ColorMatrix', {'hue': -25})
        .belowTokens()
        .playIf(targetDeath)

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'fillColor': '#FF0000',
            'radius': 0.15,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': canvas.grid.size * 0.1, 'y': -canvas.grid.size * 0.4}, 
            
        })
        .duration(1500)
        .fadeOut(1000)
        .playIf(targetDeath)

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'radius': 0.2,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': canvas.grid.size * 0.1, 'y': -canvas.grid.size * 0.4},            
        })
        .duration(1800)
        .fadeOut(1000)
        .playIf(targetDeath)
                
        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'radius': 0.25,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': canvas.grid.size * 0.1, 'y': -canvas.grid.size * 0.4}, 
        })
        .duration(2000)
        .fadeOut(1000)
        .playIf(targetDeath)

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'radius': 0.3,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': canvas.grid.size * 0.1, 'y': -canvas.grid.size * 0.4}, 
        })
        .duration(2200)
        .fadeOut(1000)
        .playIf(targetDeath)

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'radius': 0.35,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': canvas.grid.size * 0.1, 'y': -canvas.grid.size * 0.4}, 
        })   
        .duration(2400)
        .fadeOut(1000)
        .playIf(targetDeath)

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'radius': 0.4,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': canvas.grid.size * 0.1, 'y': -canvas.grid.size * 0.4}, 
        })
        .duration(2600)
        .fadeOut(1000)
        .playIf(targetDeath)

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'radius': 0.45,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': canvas.grid.size * 0.1, 'y': -canvas.grid.size * 0.4}, 
        })    
        .duration(2800)
        .fadeOut(1000)
        .playIf(targetDeath)

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'fillColor': '#FF0000',
            'radius': 0.15,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': -canvas.grid.size * 0.4, 'y': canvas.grid.size * 0.3}, 
            
        })
        .duration(500)
        .fadeOut(1000)
        .playIf(targetDeath)       

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'radius': 0.2,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': -canvas.grid.size * 0.4, 'y': canvas.grid.size * 0.3},           
        })
        .duration(700)
        .fadeOut(1000)
        .playIf(targetDeath)               

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'radius': 0.25,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': -canvas.grid.size * 0.4, 'y': canvas.grid.size * 0.3}, 
        })
        .duration(900)
        .fadeOut(1000)
        .playIf(targetDeath)   

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'radius': 0.3,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': -canvas.grid.size * 0.4, 'y': canvas.grid.size * 0.3}, 
        })
        .duration(1100)
        .fadeOut(1000)
        .playIf(targetDeath)    

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'radius': 0.35,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': -canvas.grid.size * 0.4, 'y': canvas.grid.size * 0.3}, 
        })   
        .duration(1300)
        .fadeOut(1000)
        .playIf(targetDeath)    

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'radius': 0.4,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': -canvas.grid.size * 0.4, 'y': canvas.grid.size * 0.3}, 
        })
        .duration(1500)
        .fadeOut(1000)
        .playIf(targetDeath)  

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'radius': 0.45,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': -canvas.grid.size * 0.4, 'y': canvas.grid.size * 0.3}, 
        })   
        .duration(1700)
        .fadeOut(1000)
        .playIf(targetDeath)  

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'radius': 0.5,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': -canvas.grid.size * 0.4, 'y': canvas.grid.size * 0.3}, 
        }) 
        .duration(1900)
        .fadeOut(1000)
        .playIf(targetDeath)

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'radius': 0.55,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': -canvas.grid.size * 0.4, 'y' :canvas.grid.size * 0.3}, 
        })
        .duration(2100)
        .fadeOut(1000)
        .playIf(targetDeath) 

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'fillColor': '#FF0000',
            'radius': 0.15,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': canvas.grid.size*0.5, 'y': canvas.grid.size*0.4}, 
        })
        .duration(1500)
        .fadeOut(1000)
        .playIf(targetDeath)

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX) 
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'radius': 0.2,
            'radius': 0.25,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': canvas.grid.size * 0.5, 'y': canvas.grid.size * 0.4},  
        })
        .duration(1900)
        .fadeOut(1000)
        .playIf(targetDeath)

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'radius': 0.3,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': canvas.grid.size * 0.5, 'y': canvas.grid.size * 0.4}, 
        })
        .duration(2100)
        .fadeOut(1000)
        .playIf(targetDeath)

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'radius': 0.35,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': canvas.grid.size * 0.5, 'y': canvas.grid.size * 0.4}, 
        })   
        .duration(2300)
        .fadeOut(1000)
        .playIf(targetDeath)
        
        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'radius': 0.4,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': canvas.grid.size * 0.5, 'y': canvas.grid.size * 0.4}, 
        })
        .duration(2500)
        .fadeOut(1000)    

        .effect()
        .atLocation({'x': centerX, 'y': centerY})
        .from(target)
        .scaleToObject(target.document.texture.scaleX)
        .shape('circle', {
            'lineSize': 25,
            'lineColor': '#FF0000',
            'radius': 0.45,
            'gridUnits': true,
            'name': 'test',
            'isMask': true,
            'offset': {'x': canvas.grid.size * 0.5, 'y': canvas.grid.size * 0.4}, 
        })    
        .duration(2700)
        .fadeOut(1000)
        .playIf(targetDeath)

        .wait(1500)

        .thenDo(async function() {
            if( targetDeath == true){    
                let updates = {'token': {'hidden': true}};
                let options = {
                    'permanent': true,
                    'name': workflow.item.name,
                    'description': workflow.item.name
                };
                await warpgate.mutate(target.document, updates, {}, options);
            }
        })

        .play()
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/barbarian/zealot/divineFury.js


async function divineFury_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || workflow.item.type != 'weapon') return;
    let effect = chris.findEffect(workflow.actor, 'Rage');
    if (!effect) return;
    let divineEffect = chris.findEffect(workflow.actor, 'Divine Fury');
    if (!divineEffect) return;
    let originItem = await fromUuid(divineEffect.origin);
    if (!originItem) return;
    let classLevels = workflow.actor.classes.barbarian?.system?.levels;
    if (!classLevels) return;
    let barbDamage = Math.floor(classLevels / 2);
    let damageType = workflow.actor.flags['chris-premades']?.feature?.divineFury?.damageType;
    if (!damageType) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'divineFury', 250);
    if (!queueSetup) return;
    let doExtraDamage = chris.perTurnCheck(originItem, 'feature', 'divineFury', true, workflow.token.id);
    if (!doExtraDamage) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await chris.setTurnCheck(originItem, 'feature', 'divineFury');
    let bonusDamage = '1d6[' + damageType + '] + ' + barbDamage;
    if (workflow.isCritical) bonusDamage = chris.getCriticalFormula(bonusDamage);
    let damageFormula = workflow.damageRoll._formula + ' + ' + bonusDamage;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function divineFury_end(origin) {
    await chris.setTurnCheck(origin, 'feature', 'divineFury', true);
}
let divineFury = {
    'attack': divineFury_attack,
    'end': divineFury_end
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/paladin/divineSmite.js


async function divineSmite({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (workflow.item.name === 'Unarmed Strike' && !game.settings.get('chris-premades', 'Unarmed Strike Smite')) return;
    let validTypes = ['martialM', 'simpleM'];
    if (game.settings.get('chris-premades', 'Ranged Smite')) {
        validTypes.push('martialR');
        validTypes.push('simpleR');
    }
    if (!validTypes.includes(workflow.item.system.weaponType)) return;
    let feature = chris.getItem(workflow.actor, 'Divine Smite');
    if (!feature) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'divineSmite', 250);
    if (!queueSetup) return;
    let spells = workflow.actor.system.spells;
    let pactSlots = spells.pact.value;
    let pactLevel = spells.pact.level;
    let spell1 = spells.spell1.value;
    let spell2 = spells.spell2.value;
    let spell3 = spells.spell3.value;
    let spell4 = spells.spell4.value;
    let spell5 = spells.spell5.value;
    let spell6 = spells.spell6.value;
    let spell7 = spells.spell7.value;
    let spell8 = spells.spell8.value;
    let spell9 = spells.spell9.value;
    if (pactSlots + spell1 + spell2 + spell3 + spell4 + spell5 + spell6 + spell7 + spell8 + spell9 === 0) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let menuOptions = [];
    if (pactSlots > 0) menuOptions.push(['Pact (' + pactLevel + ')', 'p']);
    if (spell1 > 0) menuOptions.push(['1st Level', 1]);
    if (spell2 > 0) menuOptions.push(['2nd Level', 2]);
    if (spell3 > 0) menuOptions.push(['3rd Level', 3]);
    if (spell4 > 0) menuOptions.push(['4th Level', 4]);
    if (spell5 > 0) menuOptions.push(['5th Level', 5]);
    if (spell6 > 0) menuOptions.push(['6th Level', 6]);
    if (spell7 > 0) menuOptions.push(['7th Level', 7]);
    if (spell8 > 0) menuOptions.push(['8th Level', 8]);
    if (spell9 > 0) menuOptions.push(['9th Level', 9]);
    menuOptions.push(['No', false]);
    let selectedOption = await chris.dialog(feature.name, menuOptions, 'Use ' + feature.name + '?');
    if (!selectedOption) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let update = {};
    let damageDiceNum;
    switch (selectedOption) {
        case 'p':
            update = {'system.spells.pact.value': pactSlots - 1};
            damageDiceNum = pactLevel + 1;
            break;
        case 1:
            update = {'system.spells.spell1.value': spell1 - 1};
            damageDiceNum = 2;
            break;
        case 2:
            update = {'system.spells.spell2.value': spell2 - 1};
            damageDiceNum = 3;
            break;
        case 3:
            update = {'system.spells.spell3.value': spell3 - 1};
            damageDiceNum = 4;
            break;
        case 4:
            update = {'system.spells.spell4.value': spell4 - 1};
            damageDiceNum = 5;
            break;
        case 5:
            update = {'system.spells.spell5.value': spell5 - 1};
            damageDiceNum = 5;
            break;
        case 6:
            update = {'system.spells.spell6.value': spell6 - 1};
            damageDiceNum = 5;
            break;
        case 7:
            update = {'system.spells.spell7.value': spell7 - 1};
            damageDiceNum = 5;
            break;
        case 8:
            update = {'system.spells.spell8.value': spell8 - 1};
            damageDiceNum = 5;
            break;
        case 9:
            update = {'system.spells.spell9.value': spell9 - 1};
            damageDiceNum = 5;
            break;
    }
    await workflow.actor.update(update);
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    let type = chris.raceOrType(targetActor);
    if (type === 'undead' || type === 'fiend') damageDiceNum += 1;
    let damageDice = damageDiceNum + 'd8[radiant]';
    if (workflow.isCritical) damageDice = chris.getCriticalFormula(damageDice);
    let damageFormula = workflow.damageRoll._formula + ' + ' + damageDice;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    await feature.displayCard();
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/cleric/divineStrike.js



async function divineStrike_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || workflow.isFumble || workflow.item.type != 'weapon') return;
    let feature = chris.getItem(workflow.actor, 'Divine Strike')
    if (!feature) return;
    let doExtraDamage = chris.perTurnCheck(feature, 'feature', 'divineStrike', true, workflow.token.id);
    if (!doExtraDamage) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'divineStrike', 250);
    if (!queueSetup) return;
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Divine Strike: Apply extra damage?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    if (chris.inCombat()) await feature.setFlag('chris-premades', 'feature.divineStrike.turn', game.combat.round + '-' + game.combat.turn);
    let diceNumber = 1;
    let classLevels = workflow.actor.classes.cleric?.system?.levels;
    let subClassIdentifier = workflow.actor.classes.cleric?.subclass?.identifier;
    if (!classLevels || !subClassIdentifier) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let damageType = chris.getConfiguration(feature, 'damagetype');
    if (!damageType || damageType === 'default') {
        switch (subClassIdentifier) {
            case 'death-domain':
                damageType = 'necrotic';
                break;
            case 'forge-domain':
                damageType = 'fire';
                break;
            case 'light-domain':
                damageType = 'radiant';
                break;
            case 'nature-domain':
                damageType = await chris.dialog('What damage type?', [['Acid', 'acid'], ['Cold', 'cold'], ['Fire', 'fire'], ['Lightning', 'lightning'], ['Thunder', 'thunder']]);
                if (!damageType) {
                    queue_queue.remove(workflow.item.uuid);
                    return;
                }
                break;
            case 'order-domain':
                damageType = 'psychic';
                break;
            case 'tempest-domain':
                damageType = 'thunder';
                break;
            case 'trickery-domain':
                damageType = 'poison';
                break;
            case 'war-domain':
                damageType = workflow.defaultDamageType;
                break;
            default:
                damageType = 'radiant';
                break;
        }
    }
    if (classLevels >= 14) diceNumber += 1;
    let bonusDamageFormula = diceNumber + 'd8[' + damageType + ']';
    if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
    let damageFormula = workflow.damageRoll._formula + ' + ' + bonusDamageFormula;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function divineStrike_combatEnd(origin) {
    await origin.setFlag('chris-premades', 'feature.divineStrike.turn', '');
}
let divineStrike = {
    'item': divineStrike_item,
    'combatEnd': divineStrike_combatEnd
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/draconicSpirit/breathWeapon.js


async function breathWeapon_breathWeapon({speaker, actor, token, character, item, args, scope, workflow}) {
    let dragonType = workflow.actor.flags['chris-premades']?.draconicSpirit?.type;
    if (!dragonType) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'breathWeapon', 50);
    if (!queueSetup) return;
    let options;
    switch (dragonType) {
        case 'Chromatic':
        case 'Metallic':
            options = [['Acid', 'acid'], ['Cold', 'cold'], ['Fire', 'fire'], ['Lightning', 'lightning'], ['Poison', 'poison']];
            break;
        case 'Gem':
            options = [['Force', 'force'], ['Necrotic', 'necrotic'], ['Psychic', 'psychic'], ['Radiant', 'radiant'], ['Thunder', 'thunder']];
            break;
    }
    let selection = await chris.dialog('What damage type?', options);
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let damageFormula = workflow.damageRoll._formula + '[' + selection + ']';
    let diceRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(diceRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/draconicSpirit/draconicSpirit.js

let draconicSpirit = {
    'breathWeapon': breathWeapon_breathWeapon
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/monk/wayOfTheAscendantDragon/draconicStrike.js


async function draconicStrike({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.hitTargets.size) return;
    let unarmedStrike = chris.getItem(workflow.actor, 'Unarmed Strike (Monk)');
    if (!unarmedStrike) return;
    if (workflow.item.uuid != unarmedStrike.uuid) return;
    let feature = chris.getItem(workflow.actor, 'Draconic Strike');
    if (!feature) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'draconicStrike', 50);
    if (!queueSetup) return;
    let options = [
        ['🧪 Acid', 'acid'],
        ['❄️ Cold', 'cold'],
        ['🔥 Fire', 'fire'],
        ['⚡ Lightning', 'lightning'],
        ['☠️ Poison', 'poison'],
        ['Unchanged', false]
    ];
    let selection = await chris.dialog(feature.name, options, 'Change ' + workflow.item.name + '\'s damage type?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let damageRoll = workflow.damageRoll
    damageRoll.terms[0].options.flavor = selection;
    damageRoll.terms[2].options.flavor = selection;
    damageRoll._formula = damageRoll._formula.replace(workflow.defaultDamageType, selection);
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/items/dragonVessel.js

async function dragonVessel({speaker, actor, token, character, item, args, scope, workflow}) {
    let level = workflow.actor.flags['chris-premades']?.item?.dragonVessel?.level;
    if (level === undefined) return;
    let options = [
        ['Ale', false],
        ['Olive Oil', false],
        ['Potion of Healing (Normal)', 'Potion of Healing (Normal)'],
        ['Potion of Climbing', 'Potion of Climbing']
    ];
    if (level > 0) {
        options.push(['Mead', false]);
        options.push(['Potion of Fire Breath', 'Potion of Fire Breath']);
        options.push(['Potion of Healing (Greater)', 'Potion of Healing (Greater)']);
    }
    if (level > 1) {
        options.push(['Wine', false]);
        options.push(['Potion of Flying', 'Potion of Flying']);
        options.push(['Potion of Healing (Superior)', 'Potion of Healing (Superior)']);
    }
    if (level > 2) {
        options.push(['Whiskey', false]);
        options.push(['Potion of Healing (Supreme)', 'Potion of Healing (Supreme)']);
        options.push(['Potion of Dragon\'s Majesty', 'Potion of Dragon\'s Majesty']);
    }
    let selection = await chris.dialog('What item?', options);
    if (!selection) return;
    let itemData;
    if (selection === 'Potion of Fire Breath') {
        itemData = await chris.getItemFromCompendium('chris-premades.CPR Items', 'Potion of Fire Breath', false);
        if (!itemData) return;
        itemData.system.description.value = await chris.getCompendiumItemDescription('Potion of Fire Breath');
    }
    if (!itemData) itemData = await chris.getItemFromCompendium(game.settings.get('chris-premades', 'Item Compendium'), selection, false);
    if (!itemData) return;
    itemData.name = workflow.item.name + ': ' + itemData.name;
    itemData.flags['tidy5e-sheet'] = {
        'favorite': true
    }
    async function effectMacro () {
        await warpgate.revert(token.document, 'Dragon Vessel');
    }
    let effectData = {
        'label': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 604800
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'dae': {
                'specialDuration': [
                    'longRest'
                ],
                'stackable': 'multi',
                'macroRepeat': 'none'
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [itemData.name]: itemData
            },
            'ActiveEffect': {
                [itemData.name]: effectData
            }
        }
    };
    let optionsW = {
        'permanent': false,
        'name': 'Dragon Vessel',
        'description': itemData.name
    };
    await warpgate.mutate(workflow.token.document, updates, {}, optionsW);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/dragonsBreath.js

async function dragonsBreath({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    let damageType = await chris.dialog(workflow.item.name, [['🧪 Acid', 'acid'], ['❄️ Cold', 'cold'], ['🔥 Fire', 'fire'], ['⚡ Lightning', 'lightning'], ['☠️ Poison', 'poison']], 'What damage type?');
    if (!damageType) damageType = 'fire';
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Dragon Breath', false);
    if (!featureData) return;
    let diceNumber = workflow.castData.castLevel + 1;
    featureData.system.damage.parts = [
        [
            diceNumber + 'd6[' + damageType + ']',
            damageType
        ]
    ];
    featureData.system.save.dc = chris.getSpellDC(workflow.item);
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Dragon Breath');
    featureData.flags['chris-premades'] = {
        'spell': {
            'castData': workflow.castData
        }
    };
    featureData.flags['chris-premades'].spell.castData.school = workflow.item.system.school;
    async function effectMacro () {
        await warpgate.revert(token.document, 'Dragon Breath');
    }
    let effectData = {
        'name': featureData.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [featureData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Dragon Breath',
        'description': 'Dragon Breath'
    };
    await warpgate.mutate(targetToken.document, updates, {}, options);
}
;// CONCATENATED MODULE: ./scripts/macros/items/dragonsWrath.js

async function dragonsWrath_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let targetToken = workflow.targets.first();
    let damageType = workflow.item.system.damage.parts[1][1];
    if (workflow.d20AttackRoll === 20) {
        let animation = workflow.actor.flags['chris-premades']?.item?.dragonsWrathWeapon?.animation;
        if (!animation) return;
        let nearbyTargets = await chris.findNearby(targetToken, 5, 'ally');
        new Sequence().wait(1250).effect().file(animation).atLocation(targetToken).belowTokens(true).play();
        if (nearbyTargets.length != 0) await chris.applyDamage(nearbyTargets, 5, damageType);
    }
}
async function dragonsWrath_equip(actor, origin, level) {
    let charges = origin.flags['chris-premades']?.item?.dragonsWrath?.charges;
    if (charges === undefined) charges = 1;
    let itemData = await chris.getItemFromCompendium('chris-premades.CPR Item Features', 'Dragon\'s Wrath Breath', false);
    if (!itemData) return;
    let damageType = origin.system.damage.parts[1][1];
    let damageDice = '8d6';
    if (level === 1) {
        damageDice = '12d6';
        itemData.system.target.value = 60;
        itemData.system.save.dc = 18;
    }
    itemData.system.damage.parts = [
        [
            damageDice + '[' + damageType + ']',
            damageType
        ]
    ];
    itemData.system.uses.value = charges;
    itemData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Dragon\'s Wrath Breath');
    await chris.addTempItem(actor, itemData, origin.id, 'Dragon\'s Wrath Weapon', false, 0);
}
async function dragonsWrath_unequip(actor, origin) {
    let charges = 1;
    let tempItem = chris.getTempItem(actor, origin.id, 0);
    if (tempItem) charges = tempItem.system.uses.value;
    await origin.setFlag('chris-premades', 'item.dragonsWrath.charges', charges);
    await chris.removeTempItems(actor, origin.id);
}
async function dragonsWrath_deleted(actor, effect) {
    if (effect.disabled) return;
    let originArray = effect.origin.split('Item.');
    if (originArray.length != 2) return;
    let originID = originArray[1];
    await chris.removeTempItems(actor, originID);
}
let dragonsWrath = {
    'item': dragonsWrath_item,
    'equip': dragonsWrath_equip,
    'unequip': dragonsWrath_unequip,
    'deleted': dragonsWrath_deleted
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/ranger/gloomStalker/dreadAmbusher.js
async function dreadAmbusher(origin) {
    if (game.combat.round != 1) return;
    await origin.use();
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/paladin/oathbreaker/dreadLord.js



async function dreadLord_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.token) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Dread Lord Shadow Attack', false);
    if (!featureData) return;
    delete featureData._id;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Dread Lord Shadow Attack');
    let effectData = {
        'name': 'Dread Lord',
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'changes': [
            {
                'key': 'flags.chris-premades.aura.dreadLord.name',
                'mode': 5,
                'value': 'Dread Lord',
                'priority': 20
            },
            {
                'key': 'flags.chris-premades.aura.dreadLord.range',
                'mode': 5,
                'value': 30,
                'priority': 20
            },
            {
                'key': 'flags.chris-premades.aura.dreadLord.disposition',
                'mode': 5,
                'value': 'ally',
                'priority': 20
            },
            {
                'key': 'flags.chris-premades.aura.dreadLord.effectName',
                'mode': 5,
                'value': 'Dread Lord\'s Shadow',
                'priority': 20
            },
            {
                'key': 'flags.chris-premades.aura.dreadLord.macroName',
                'mode': 5,
                'value': 'dreadLord',
                'priority': 20
            },
            {
                'key': 'flags.chris-premades.aura.dreadLord.self',
                'mode': 5,
                'value': false,
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.grants.disadvantage.attack.all',
                'value': 1,
                'mode': 0,
                'priority': 20
            }
        ],
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': 'await chrisPremades.macros.dreadLord.end(token, origin);'
                },
                'onEachTurn': {
                    'script': 'await chrisPremades.macros.dreadLord.turnStart(token, origin);'
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Dread Lord',
        'description': 'Dread Lord'
    };
    let flagAuras = {
        'dreadLord': {
            'name': 'dreadLord',
            'range': 30,
            'disposition': 'ally',
            'effectName': 'Dread Lord\'s Shadow',
            'macroName': 'dreadLord',
            'self': false
        }
    };
    let animation = chris.getConfiguration(workflow.item, 'animation');
    if (chris.jb2aCheck() != 'patreon') animation = false;
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar');
    let tokenImg = chris.getConfiguration(workflow.item, 'token');
    if (avatarImg) setProperty(updates, 'actor.img', avatarImg);
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    if (!animation) {
        await warpgate.mutate(workflow.token.document, updates, {}, options);
        effectAuras.add(flagAuras, workflow.token.document.uuid, true);
    } else {
        //Animation by Eskimoh
        new Sequence()
            .effect()
            .file('jb2a.energy_strands.in.red.01')
            .attachTo(workflow.token)
            .scaleToObject(9, {'considerTokenScale': true})
            .filter('ColorMatrix', {'brightness': 0})
            .randomRotation()
            .belowTokens()
            .zIndex(0.1)

            .effect()
            .file('jb2a.token_border.circle.static.purple.004')
            .name('Dread Lord')
            .attachTo(workflow.token)
            .opacity(0.6)
            .scaleToObject(1.7, {'considerTokenScale': true})
            .fadeIn(500)
            .fadeOut(500)
            .duration(2500)
            .filter('ColorMatrix', {'saturate': 0.5, 'hue': -5})
            .tint('#e51e19')
            .belowTokens()
            .zIndex(2)

            .effect()
            .file(canvas.scene.background.src)
            .filter('ColorMatrix', {'brightness': 0.3})
            .atLocation({'x': canvas.dimensions.width / 2, 'y': canvas.dimensions.height / 2})
            .size({'width': canvas.scene.width / canvas.grid.size, 'height': canvas.scene.height / canvas.grid.size}, {'gridUnits': true})
            .spriteOffset({'x': 0}, {'gridUnits': true})
            .duration(7000)
            .fadeIn(500)
            .fadeOut(1000)
            .belowTokens()

            .effect()
            .file('jb2a.particles.outward.red.01.03')
            .attachTo(workflow.token, {'offset': {'y': 0.1}, 'gridUnits': true, 'followRotation': false})
            .size(0.5 * workflow.token.document.width, {'gridUnits': true})
            .duration(1000)
            .fadeOut(800)
            .scaleIn(0, 1000, {'ease': 'easeOutCubic'})
            .animateProperty('sprite', 'width', {'from': 0, 'to': 0.25, 'duration': 500, 'gridUnits': true, 'ease': 'easeOutBack'})
            .animateProperty('sprite', 'height', {'from': 0, 'to': 1.0, 'duration': 1000, 'gridUnits': true, 'ease': 'easeOutBack'})
            .animateProperty('sprite', 'position.y', {'from': 0, 'to': -0.6, 'duration': 1000, 'gridUnits': true})
            .filter('ColorMatrix', {'saturate': 1, 'hue': 20})
            .zIndex(0.3)

            .effect()
            .file('jb2a.flames.04.complete.purple')
            .attachTo(workflow.token, {'offset': {'y': -0.35}, 'gridUnits': true, 'followRotation': true})
            .scaleToObject(1.5 * workflow.token.document.texture.scaleX)
            .tint('#e51e19')
            .fadeOut(500)
            .scaleOut(0, 500, {'ease': 'easeOutCubic'})
            .duration(2500)
            .zIndex(1)
            .waitUntilFinished(-500)

            .effect()
            .file('jb2a.impact.ground_crack.dark_red.01')
            .atLocation(workflow.token)
            .belowTokens()
            .filter('ColorMatrix', {'hue': -15, 'saturate': 1})
            .size(7, {'gridUnits': true})
            .tint('#e51e19')
            .zIndex(0.1)

            .thenDo(async function(){
                await warpgate.mutate(workflow.token.document, updates, {}, options);
                effectAuras.add(flagAuras, workflow.token.document.uuid, true);
            })

            .canvasPan()
            .shake({'duration': 3000, 'strength': 2, 'rotation': false, 'fadeOut': 3000})

            .effect()
            .file('jb2a.token_border.circle.static.purple.004')
            .name('Dread Lord')
            .attachTo(workflow.token)
            .opacity(0.6)
            .scaleToObject(1.7, {'considerTokenScale': true})
            .fadeIn(250)
            .fadeOut(500)
            .duration(2500)
            .filter('ColorMatrix', {'saturate': 0.5, 'hue': -5})
            .tint('#e51e19')
            .persist()
            .zIndex(2)

            .effect()
            .name('Dread Lord')
            .file('jb2a.energy_strands.complete.dark_red.01')
            .attachTo(workflow.token)
            .scaleToObject(2, {'considerTokenScale': true})
            .opacity(1)
            .filter('ColorMatrix', {'brightness': 0})
            .scaleIn(0, 1000, {'ease': 'easeOutBack'})
            .belowTokens()
            .persist()
            .zIndex(3)

            .effect()
            .name('Dread Lord')
            .file('jb2a.energy_strands.overlay.dark_red.01')
            .attachTo(workflow.token)
            .scaleToObject(2, {'considerTokenScale': true})
            .filter('ColorMatrix', {'brightness': 0})
            .scaleIn(0, 1000, {'ease': 'easeOutBack'})
            .belowTokens()
            .persist()
            .zIndex(3)

            .effect()
            .name('Dread Lord')
            .file('jb2a.template_circle.aura.01.complete.small.bluepurple')
            .attachTo(workflow.token, {'offset': {'y': 0}, 'gridUnits': true, 'followRotation': true})
            .size(7.5, {'gridUnits': true})
            .opacity(0.7)
            .scaleIn(0, 250, {'ease': 'easeOutBack'})
            .scaleOut(0, 6500, {'ease': 'easeInSine'})
            .filter('ColorMatrix', {'saturate': 0.5, 'hue': -2})
            .tint('#e51e19')
            .randomRotation()
            .belowTokens()
            .persist()
            .zIndex(0.3)

            .effect()
            .name('Dread Lord')
            .file('jb2a.extras.tmfx.outflow.circle.02')
            .attachTo(workflow.token, {'offset': {'y': 0}, 'gridUnits': true, 'followRotation': true})
            .size(13, {'gridUnits': true})
            .opacity(0.65)
            .scaleIn(0, 250, {'ease': 'easeOutBack'})
            .scaleOut(0, 6500, {'ease': 'easeInSine'})
            .filter('ColorMatrix', {'brightness': 0})
            .belowTokens()
            .persist()
            .zIndex(0.2)

            .effect()
            .name('Dread Lord')
            .file('jb2a.extras.tmfx.outflow.circle.01')
            .attachTo(workflow.token, {'offset': {'y': 0}, 'gridUnits': true, 'followRotation': true})
            .size(13, {'gridUnits': true})
            .opacity(0.7)
            .scaleIn(0, 250, {'ease': 'easeOutBack'})
            .scaleOut(0, 6500, {'ease': 'easeInSine'})
            .filter('ColorMatrix', {'brightness': 0})
            .rotate(90)
            .loopProperty('sprite', 'rotation', {'from': 0, 'to': 360, 'duration': 20000})
            .belowTokens()
            .persist()
            .zIndex(0.3)

            .effect()
            .file('jb2a.impact.003.dark_red')
            .attachTo(workflow.token, {'offset': {'y': 0.1}, 'gridUnits': true, 'followRotation': true})
            .scaleToObject(1, {'considerTokenScale': true})
            .zIndex(2)

            .play()
    }
}
async function dreadLord_aura(token, selectedAura) {
    let originToken = await fromUuid(selectedAura.tokenUuid);
    if (!originToken) return;
    let originActor = originToken.actor;
    let auraEffect = chris.findEffect(originActor, 'Dread Lord');
    if (!auraEffect) return;
    let originItem = await fromUuid(auraEffect.origin);
    if (!originItem) return;
    let effectData = {
        'name': 'Dread Lord\'s Shadow',
        'icon': originItem.img,
        'origin': originItem.uuid,
        'duration': {
            'seconds': 604800
        },
        'changes': [
            {
                'key': 'flags.midi-qol.grants.disadvantage.attack.all',
                'value': 1,
                'mode': 0,
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'aura': true,
                'effect': {
                    'noAnimation': true
                }
            }
        }
    };
    let effect = chris.findEffect(token.actor, effectData.name);
    if (effect?.origin === effectData.origin) return;
    if (effect) chris.removeEffect(effect);
    await chris.createEffect(token.actor, effectData);
}
async function dreadLord_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.targets.size) return;
    let feature = chris.getItem(workflow.actor, 'Dread Lord');
    if (!feature) return;
    let animation = chris.getConfiguration(feature, 'animation');
    if (chris.jb2aCheck() != 'patreon' || !animation) return;
    let target = workflow.targets.first();
    //Animation by Eskimoh
    new Sequence()
        .effect()
        .file('jb2a.melee_generic.piercing.two_handed')
        .atLocation(target)
        .spriteOffset({'x': -5.6, 'y': 0.1}, {'gridUnits': true})
        .size(8, {'gridUnits': true})
        .rotateTowards(workflow.token)
        .playbackRate(0.8)
        .randomizeMirrorY()
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 0})
        .rotate(180)
        .zIndex(1)
        
        .effect()
        .from(target)
        .attachTo(target)
        .fadeIn(500)
        .fadeOut(500)
        .loopProperty('sprite', 'position.x', {'from': -0.05, 'to': 0.05, 'duration': 55, 'pingPong': true, 'gridUnits': true})
        .filter("ColorMatrix", {'saturate': -1, 'brightness': 0.5})
        .scaleToObject(1, {'considerTokenScale': true})
        .opacity(0.65)
        .zIndex(0.1)
        
        .play();
}
async function dreadLord_end(token, origin) {
    await warpgate.revert(token.document, 'Dread Lord');
    effectAuras.remove('dreadLord', token.document.uuid);
    if (chris.getConfiguration(origin, 'animation')) Sequencer.EffectManager.endEffects({'name': 'Dread Lord', 'object': token});
}
async function dreadLord_turnStart(token, origin) {
    let targetToken = game.canvas.tokens.get(game.combat.current.tokenId);
    if (!targetToken) return;
    if (targetToken.document.disposition === token.document.disposition) return;
    let distance = chris.getDistance(token, targetToken);
    if (distance > 30) return;
    let effect = targetToken.effects.find(i => i.name === 'Frightened' && i.origin === token.document.uuid);
    if (!effect) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Dread Lord - Turn Start', false);
    if (!featureData) return;
    delete featureData._id;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Dread Lord - Turn Start');
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': token.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.document.uuid]);
    let queueSetup = await queue.setup(origin.uuid, 'dreadLord', 50);
    if (!queueSetup) return;
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature, config, options);
    queue.remove(origin.uuid);
}
let dreadLord = {
    'item': dreadLord_item,
    'attack': dreadLord_attack,
    'end': dreadLord_end,
    'turnStart': dreadLord_turnStart,
    'aura': dreadLord_aura
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/paladin/oathbreaker/dreadfulAspect.js



async function dreadfulAspect_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'changes': [
            {
                'key': 'macro.CE',
                'mode': 0,
                'value': 'Frightened',
                'priority': 20
            }
        ],
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'flags': {
            'chris-premades': {
                'feature': {
                    'dreadfulAspect': {
                        'sourceTokenUuid': workflow.token.document.uuid
                    }
                }
            },
            'effectmacro': {
                'onTurnEnd': {
                    'script': 'await chrisPremades.macros.dreadfulAspect.turnEnd(effect, origin, token);'
                }
            }
        }
    };
    for (let i of Array.from(workflow.failedSaves)) {
        let effect = chris.findEffect(i.actor, workflow.item.name);
        if (effect) await chris.removeEffect(effect);
        await chris.createEffect(i.actor, effectData);
    }
    let animation = chris.getConfiguration(workflow.item, 'animation');
    if (chris.jb2aCheck() != 'patreon' || !animation) return;
    //Animation by Eskimoh
    await new Sequence()
        .effect()
        .file('jb2a.extras.tmfx.border.circle.inpulse.01.fast')
        .attachTo(workflow.token)
        .scaleToObject(2, {'considerTokenScale': true})
        .filter('ColorMatrix', {'brightness': 0})

        .effect()
        .file('jb2a.token_border.circle.static.purple.004')
        .attachTo(workflow.token)
        .name('Dreadful Aspect')
        .opacity(0.6)
        .scaleToObject(1.7,{'considerTokenScale': true})
        .fadeIn(500)
        .fadeOut(500)
        .duration(2500)
        .filter('ColorMatrix', {'saturate': 0.5, 'hue': -5})
        .tint('#e51e19')
        .belowTokens()
        .zIndex(2)

        .effect()
        .file(canvas.scene.background.src)
        .filter('ColorMatrix', {'brightness': 0.3})
        .atLocation({'x': canvas.dimensions.width / 2, 'y': canvas.dimensions.height / 2})
        .size({'width': canvas.scene.width / canvas.grid.size, 'height': canvas.scene.height / canvas.grid.size}, {'gridUnits': true})
        .spriteOffset({'x': -0}, {'gridUnits': true})
        .duration(3000)
        .fadeIn(500)
        .fadeOut(1000)
        .belowTokens()

        .effect()
        .file('jb2a.particles.outward.red.01.03')
        .attachTo(workflow.token, {'offset': {'y': 0.1}, 'gridUnits': true, 'followRotation': false})
        .size(0.5  * workflow.token.document.width, {'gridUnits': true})
        .duration(1000)
        .fadeOut(800)
        .scaleIn(0, 1000, {'ease': 'easeOutCubic'})
        .animateProperty('sprite', 'width', {'from': 0, 'to': 0.25, 'duration': 500, 'gridUnits': true, 'ease': 'easeOutBack'})
        .animateProperty('sprite', 'height', {'from': 0, 'to': 1.0, 'duration': 1000, 'gridUnits': true, 'ease': 'easeOutBack'})
        .animateProperty('sprite', 'position.y', {'from': 0, 'to': -0.6, 'duration': 1000, 'gridUnits': true})
        .filter('ColorMatrix', {'saturate': 1, 'hue': 20})
        .zIndex(0.3)

        .effect()
        .file('jb2a.flames.04.complete.purple')
        .attachTo(workflow.token, {'offset': {'y': -0.35}, 'gridUnits': true, 'followRotation': true})
        .scaleToObject(1.5 * workflow.token.document.texture.scaleX)
        .tint('#e51e19')
        .fadeOut(500)
        .scaleOut(0, 500, {'ease': 'easeOutCubic'})
        .duration(2500)
        .zIndex(1)

        .effect()
        .file('jb2a.cast_generic.ice.01.blue')
        .attachTo(workflow.token, {'offset': {'y': 0.15}, 'gridUnits': true, 'followRotation': true})
        .opacity(1.5)
        .playbackRate(1.5)
        .scaleToObject(1.5, {'considerTokenScale': true})
        .filter('ColorMatrix', {'brightness': 0})
        .waitUntilFinished(-200)

        .effect()
        .file('jb2a.template_circle.aura.01.complete.small.bluepurple')
        .attachTo(workflow.token, {'offset': {'y':0}, 'gridUnits': true, 'followRotation': true})
        .scaleToObject(4, {'considerTokenScale': true})
        .scaleIn(0, 250, {'ease': 'easeOutBack'})
        .scaleOut(0, 6500, {'ease': 'easeInSine'})
        .filter('ColorMatrix', {'saturate': 0.5, 'hue': -2})
        .tint('#e51e19')
        .randomRotation()
        .belowTokens()
        .zIndex(3)

        .canvasPan()
        .shake({'duration': 1500, 'strength': 2, 'rotation': false, 'fadeOut': 1500})

        .effect()
        .attachTo(workflow.token)
        .file('jb2a.extras.tmfx.outflow.circle.01')
        .scaleToObject(1.5 * workflow.token.document.texture.scaleX)
        .opacity(1)
        .belowTokens()
        .randomRotation()
        .filter('ColorMatrix', {'brightness': 0})
        .fadeIn(500)
        .fadeOut(500)

        .effect()
        .file('jb2a.impact.003.dark_red')
        .attachTo(workflow.token, {'offset': {'y': 0.1}, 'gridUnits': true, 'followRotation': true})
        .scaleToObject(1, {'considerTokenScale': true})
        .zIndex(2)

        .effect()
        .file('jb2a.impact.004.dark_red')
        .attachTo(workflow.token, {'offset': {'y': 0}, 'gridUnits': true, 'followRotation': true})
        .scaleToObject(7.5, {considerTokenScale: true})
        .randomRotation()
        .filter('ColorMatrix', {'brightness': 0})
        .opacity(0.75)
        .scaleIn(0, 1400, {'ease': 'easeOutCubic'})
        .fadeOut(1000)
        .belowTokens()
        .zIndex(2)

        .effect()
        .file('jb2a.extras.tmfx.outpulse.circle.02.fast')
        .attachTo(workflow.token, {'offset': {'y': 0}, 'gridUnits': true, 'followRotation': true})
        .size(13, {'gridUnits': true})
        .opacity(0.5)
        .filter('ColorMatrix', {'brightness': 0})
        .tint('#e51e19')
        .waitUntilFinished()
        .play();

        Array.from(workflow.targets).forEach(target => {   
            new Sequence()
                .effect()
                .file('jb2a.toll_the_dead.red.skull_smoke')
                .attachTo(target)
                .scaleToObject(1.65, {'considerTokenScale': true})
                .filter('ColorMatrix', {'saturate': 0.25, 'hue': -2})
                .zIndex(1)

                .effect()
                .from(target)
                .attachTo(target)
                .fadeIn(500)
                .fadeOut(2000)
                .loopProperty('sprite', 'position.x', {'from': -0.05, 'to': 0.05, 'duration': 55, 'pingPong': true, 'gridUnits': true})
                .filter('ColorMatrix', {'saturate': -1, 'brightness': 0.5})
                .scaleToObject(1, {'considerTokenScale': true})
                .duration(5000)
                .opacity(0.65)
                .zIndex(0.1)

                .effect()
                .file('jb2a.particles.outward.red.01.03')
                .attachTo(target, {'offset': {'y': 0.1}, 'gridUnits': true, 'followRotation': false})
                .size(1 * target.document.width, {'gridUnits': true})
                .duration(1000)
                .fadeOut(800)
                .scaleIn(0, 1000, {'ease': 'easeOutCubic'})
                .animateProperty('sprite', 'width', {'from': 0, 'to': 0.25, 'duration': 500, 'gridUnits': true, 'ease': 'easeOutBack'})
                .animateProperty('sprite', 'height', {'from': 0, 'to': 1.0, 'duration': 1000, 'gridUnits': true, 'ease': 'easeOutBack'})
                .animateProperty('sprite', 'position.y', {'from': 0, 'to': -0.6, 'duration': 1000, 'gridUnits': true})
                .filter('ColorMatrix', {'saturate': 1, 'hue': 20})
                .zIndex(0.3)

                .play()
        }
    )
}
async function dreadfulAspect_turnEnd(effect, origin, token) {
    let sourceTokenUuid = effect.flags['chris-premades']?.feature?.dreadfulAspect?.sourceTokenUuid;
    if (!sourceTokenUuid || !token) return;
    let sourceToken = await fromUuid(sourceTokenUuid);
    if (sourceToken) {
        if (chris.getDistance(sourceToken.object, token) < 30) return;
    }
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Dreadful Aspect - End of Turn');
    if (!featureData) return;
    delete featureData._id;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Dreadful Aspect - End of Turn');
    featureData.system.save.dc = chris.getSpellDC(origin);
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': sourceToken.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.document.uuid]);
    let queueSetup = await queue_queue.setup(origin.uuid, 'dreadfulAspect', 50);
    if (!queueSetup) return;
    await warpgate.wait(100);
    let workflow = await MidiQOL.completeItemUse(feature, config, options);
    queue_queue.remove(origin.uuid);
    if (workflow.failedSaves.size) return;
    await chris.removeEffect(effect);
}
let dreadfulAspect = {
    'item': dreadfulAspect_item,
    'turnEnd': dreadfulAspect_turnEnd
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/dreamEater/engulfingNightmare.js

async function engulfingNightmare(origin, token) {
    let turnToken = game.combat.scene.tokens.get(game.combat.current.tokenId);
    let turnActor = turnToken.actor;
    let originActor = origin.actor;
    if (originActor.id != turnActor.id) return;
    let damageRoll = await new Roll('3d6[psychic]').roll({async: true});
    damageRoll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: origin.name
    });
    await chris.applyDamage(token, damageRoll.total);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/dreamEater/dreamEater.js

let dreamEater = {
    'engulfingNightmare': engulfingNightmare
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/drow/handCrossbow.js

async function handCrossbow({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size != 1 || workflow.hitTargets.size != 1) return;
    let targetActor = workflow.targets.first().actor;
    if (workflow.saveResults[0].total + 5 > workflow.item.system.save.dc) return;
    let isImmune = chris.checkTrait(targetActor, 'ci', 'poisoned');
    if (isImmune) return;
    await chris.addCondition(targetActor, 'Unconscious', true, workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/drow/drow.js

let drow = {
    'handCrossbow': handCrossbow
}
;// CONCATENATED MODULE: ./scripts/macros/feats/dualWielder.js

async function dualWielder(item, updates, options, userId) {
    if (item.type != 'weapon' && item.type != 'equipment') return;
    let actor = item.actor;
    if (!actor) return;
    let effect = chris.findEffect(actor, 'Dual Wielder');
    if (!effect) return;
    let items = actor.items.filter(i => i.type==='weapon' && i.system.equipped);
    console.log(items);
    let shields = actor.items.filter(i => i.system.armor?.type === 'shield' && i.system.equipped);
    console.log(shields);
    if (shields.length) {
        if (!effect.disabled) await effect.update({'disabled': true});
        return;
    }
    if (items.length > 1 && effect.disabled) await effect.update({'disabled': false});
    if (items.length <= 1 && !effect.disabled) await effect.update({'disabled': true});
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/duergarMindMaster/mindMastery.js

async function mindMastery({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size != 1) return;
    let targetActor = workflow.targets.first().actor;
    let effect = chris.findEffect(targetActor, 'Reaction');
    if (effect) return;
    await chris.addCondition(targetActor, 'Reaction', false);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/duergarMindMaster/reduce.js


async function reduce_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.token) return;
    let piercing = translate.damageType('piercing');
    let psychic = translate.damageType('psychic');
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Actions', 'Hide', false);
    if (!featureData) return;
    featureData.system.activation.type = 'bonusaction';
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Hide');
    let updates = {
        'embedded': {
            'Item': {
                ['Mind-Poison Dagger']: {
                    'system': {
                        'damage': {
                            'parts': [
                                [
                                    '1[' + piercing + ']',
                                    piercing
                                ],
                                [
                                    '3d6[' + psychic + ']',
                                    psychic
                                ]
                            ]
                        }
                    }
                },
                [featureData.name]: featureData
            }
        }
    }
    let options = {
        'permanent': false,
        'name': 'Reduce',
        'description': workflow.item.name
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
async function reduce_end(token) {
    await warpgate.revert(token.document, 'Reduce');
}
let reduce = {
    'item': reduce_item,
    'end': reduce_end
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/duergarMindMaster/duergarMindMaster.js


let duergarMindMaster = {
    'reduce': reduce,
    'mindMastery': mindMastery
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/duergar/enlarge.js

async function enlarge({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || workflow.item.type != 'weapon') return;
    if (workflow.item.system.properties?.fin) {
        let str = workflow.actor.system.abilities.str.value;
        let dex = workflow.actor.system.abilities.dex.value;
        if (str < dex) return;
    }
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'enlarge', 50);
    if (!queueSetup) return;
    let diceNum = workflow.damageRoll.terms[0].number * 2;
    let damageFormula = diceNum + workflow.damageRoll._formula.substring(1);
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/duergar/duergar.js

let duergar = {
    'enlarge': enlarge
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/wizard/warMagic/durableMagic.js

async function durableMagic({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!(workflow.item.system.components?.concentration || workflow.item.flags.midiProperties?.concentration)) return;
    let effect = chris.findEffect(workflow.actor, 'Concentrating');
    if (!effect) return;
    if (effect.flags['chris-premades']?.feature?.durableMagic) return;
    let updates = {
        'changes': [
            {
                'key': 'system.attributes.ac.bonus',
                'mode': 2,
                'value': '+2',
                'priority': 20
            },
            {
                'key': 'system.bonuses.abilities.save',
                'mode': 2,
                'value': '+2',
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'feature': {
                    'durableMagic': true
                }
            }
        }
    };
    await chris.updateEffect(effect, updates);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/dybbuk/tentacle.js

async function tentacle({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || workflow.failedSaves.size != 1) return;
    let damageRoll = await new Roll('1d6').roll({async: true});
    damageRoll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: workflow.item.name
    });
    let damage = -damageRoll.total;
    let targetActor = workflow.targets.first().actor;
    let targetMaxHP = targetActor.system.attributes.hp.max;
    let effect = chris.findEffect(targetActor, 'Dybbuk - Tentacle');
    if (!effect) {
        let effectData = {
            'label': 'Dybbuk - Tentacle',
            'icon': workflow.item.img,
            'duration': {
                'seconds': 2628000
            },
            'changes': [
                {
                    'key': 'system.attributes.hp.tempmax',
                    'mode': 2,
                    'value': Math.max(damage, -targetMaxHP),
                    'priority': 20
                }
            ],
            'flags': {
                'dae': {
                    'transfer': false,
                    'specialDuration': [
                        'shortRest'
                    ],
                    'stackable': 'multi',
                    'macroRepeat': 'none'
                }
            }
        };
        await chris.createEffect(targetActor, effectData);
    } else {
        let oldDamage = parseInt(effect.changes[0].value);
        damage += oldDamage;
        let updates = {
            'changes': [
                {
                    'key': 'system.attributes.hp.tempmax',
                    'mode': 2,
                    'value': Math.max(damage, -targetMaxHP),
                    'priority': 20
                }
            ]
        };
        await chris.updateEffect(effect, updates);
    }
    if (Math.abs(damage) >= targetMaxHP) {
        let unconscious = chris.findEffect(targetActor, 'Unconscious');
        if (!unconscious) return;
        await chris.removeCondition(targetActor, 'Unconscious');
        await chris.addCondition(targetActor, 'Dead', true, null)
    }
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/dybbuk/dybbuk.js

let dybbuk = {
    'tentacle': tentacle
}
;// CONCATENATED MODULE: ./scripts/macros/raceFeatures/eladrin/eladrinSeason.js

async function eladrinSeason({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.token) return;
    let currentSeason = workflow.actor.flags['chris-premades']?.race?.eladrin?.season;
    let generatedMenu = [];
    if (currentSeason != 'Autumn') generatedMenu.push(['🍂 Autumn', 'Autumn']);
    if (currentSeason != 'Winter') generatedMenu.push(['❄️ Winter', 'Winter']);
    if (currentSeason != 'Spring') generatedMenu.push(['🌼 Spring', 'Spring']);
    if (currentSeason != 'Summer') generatedMenu.push(['☀️ Summer', 'Summer']);
    let selection = await chris.dialog('What season?', generatedMenu);
    if (!selection) return;
    async function effectMacro () {
        await warpgate.revert(token.document, 'Eladrin Season');
    }
    let effectData = {
        'name': 'Eladrin Season',
        'icon': workflow.item.img,
        'changes': [
            {
                'key': 'flags.chris-premades.race.eladrin.season',
                'mode': 5,
                'value': selection,
                'priority': 20
            }
        ],
        'duration': {
            'seconds': 604800
        },
        'origin': workflow.item.uuid,
        'flags': {
            'dae': {
                'selfTarget': true,
                'selfTargetAlways': false,
                'stackable': 'none',
                'durationExpression': '',
                'macroRepeat': 'none',
                'specialDuration': [
                    'longRest'
                ],
                'transfer': true
            },
            'effectmacro': {
                'onDelete': {
                    'script': chrisPremades.helpers.functionToString(effectMacro)
                }
            }
        }
    }
    let hideIcon = chris.getConfiguration(workflow.item, 'showicon') ?? false;
    if (hideIcon) effectData.icon = '';
    let updates = {
        'embedded': {
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar-' + selection);
    let tokenImg = chris.getConfiguration(workflow.item, 'token-' + selection);
    if (avatarImg) setProperty(updates, 'actor.img', avatarImg);
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    if (workflow.actor.system.details.level >= 3) {
        let featureData = await chris.getItemFromCompendium('chris-premades.CPR Race Feature Items', 'Fey Step (' + selection + ')', false);
        if (!featureData) return;
        featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Fey Step (' + selection + ')');
        featureData.system.save.dc = chris.getSpellDC(workflow.item);
        updates.embedded.Item = {
            [featureData.name]: featureData
        }
    }
    let options = {
        'permanent': false,
        'name': 'Eladrin Season',
        'description': 'Eladrin Season'
    };
    let effect = chris.findEffect(workflow.actor, 'Eladrin Season');
    if (effect)  await chris.removeEffect(effect);
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/elderBrain/breakConcentration.js

async function breakConcentration({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetActor = workflow.targets.first().actor;
    let conEffect = chris.findEffect(targetActor, 'Concentrating');
    if (!conEffect) return;
    let conOriginUuid = conEffect.flags['midi-qol']?.isConcentration;
    if (!conOriginUuid) return;
    let effect = targetActor.effects.find(eff => eff.flags['midi-qol']?.castData?.itemUuid === conOriginUuid);
    if (!effect) return;
    let castLevel = chris.getEffectCastLevel(effect);
    if (!castLevel) return;
    let damageFormula = castLevel + 'd4[psychic]';
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await chris.removeEffect(effect);
    await chris.removeEffect(conEffect);
    await workflow.setDamageRoll(damageRoll);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/elderBrain/psychicLink.js

async function saveItem({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1 || workflow.failedSaves.size === 1) return;
    let effect = chris.findEffect(workflow.actor, 'Psychic Link');
    let damageRoll = await new Roll('3d6[psychic]').roll({async: true});
    damageRoll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: 'Psychic Link'
    });
    await chris.applyDamage(workflow.token, damageRoll.total, 'psychic');
    if (effect) chris.removeEffect(effect);
}
async function psychicLink_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Monster Feature Items', 'Break Psychic Link', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Break Psychic Link');
    async function effectMacro () {
        await warpgate.revert(token.document, 'Break Psychic Link');
    }
    let effectData = {
        'name': 'Psychic Link',
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': featureData.name,
        'description': featureData.name
    };
    await warpgate.mutate(workflow.targets.first().document, updates, {}, options);
}
async function sever({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let effect = chris.findEffect(workflow.targets.first().actor, 'Psychic Link');
    if (effect) await chris.removeEffect(effect);
}
async function pulse({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    let nearbyTokens = chris.findNearby(targetToken, 30, 'ally');
    await chris.applyDamage(nearbyTokens, workflow.damageRoll.total, 'psychic');
}
let psychicLink = {
    'item': psychicLink_item,
    'saveItem': saveItem,
    'sever': sever,
    'pulse': pulse
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/elderBrain/elderBrain.js


let elderBrain = {
    'breakConcentration': breakConcentration,
    'psychicLink': psychicLink
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/elderOblex/eatMemories.js

async function eatMemories({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size != 1) return;
    let diceSize = '1d4';
    let targetActor = workflow.targets.first().actor;
    let effect = chris.findEffect(targetActor,'Eat Memories');
    if (effect) {
        diceSize = effect.changes[0].value;
        switch (diceSize) {
            case '1d4':
                diceSize = '1d6';
                break;
            case '1d6':
                diceSize = '1d8';
                break;
            case '1d8':
                diceSize = '1d10';
                break;
            case '1d10':
                diceSize = '1d12';
                break;
            case '1d12':
                diceSize = '1d20';
                break;
            case '1d20':
                let condition = chris.findEffect(targetActor, 'Unconscious');
                if (!condition) await chris.addCondition(targetActor, 'Unconscious', true, workflow.item.uuid);
                return;
        }
        let changes = effect.changes;
        changes[0].value = diceSize;
        changes[1].value = '-' + diceSize;
        changes[2].value = '-' + diceSize;
        await chris.updateEffect(effect, {changes});
    } else {
        let effectData = {
            'label': workflow.item.name,
            'icon': workflow.item.img,
            'origin': workflow.item.uuid,
            'duration': {
                'seconds': 604800
            },
            'changes': [
                {
                    'key': 'flags.chris-premades.feature.eatmemories',
                    'mode': 5,
                    'value': diceSize,
                    'priority': 20
                },
                {
                    'key': 'system.bonuses.All-Attacks',
                    'mode': 2,
                    'value': '-' + diceSize,
                    'priority': 20
                },
                {
                    'key': 'system.bonuses.abilities.check',
                    'mode': 2,
                    'value': '-' + diceSize,
                    'priority': 20
                }
            ],
            'flags': {
                'dae': {
                    'transfer': false,
                    'specialDuration': [
                        'longRest',
                        'shortRest'
                    ],
                    'stackable': 'multi',
                    'macroRepeat': 'none'
                }
            }
        };
        await chris.createEffect(targetActor, effectData);
        let skillEffect = chris.findEffect(workflow.actor, workflow.item.name + ' Skills');
        let changes;
        if (skillEffect) {
            changes = skillEffect.changes;
        } else {
            changes = [];
        }
        for (let [key, value] of Object.entries(targetActor.system.skills)) {
            if (value.proficient > workflow.actor.system.skills[key].proficient) {
                changes.push({
                    'key': 'system.skills.' + key + '.value',
                    'mode': 5,
                    'value': value.proficient,
                    'priority': 20
                });
            }
        }
        for (let i of Array.from(targetActor.system.traits.languages.value)) {
            if (!workflow.actor.system.traits.languages.value.has(i)) {
                changes.push({
                    'key': 'system.traits.languages.value',
                    'mode': 2,
                    'value': i,
                    'priority': 20
                });
            }
        }
        if (!skillEffect) {
            let skillEffectData = {
                'label': workflow.item.name + ' Skills',
                'icon': 'icons/magic/symbols/circled-gem-pink.webp',
                'origin': workflow.item.uuid,
                'duration': {
                    'seconds': 2628000
                },
                'changes': changes
            }
            await chris.createEffect(workflow.actor, skillEffectData);
        } else {
            let updates = {changes};
            await chris.updateEffect(skillEffect, updates);
        }
    }
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/elderOblex/elderOblex.js

let elderOblex = {
    'eatMemories': eatMemories
}
;// CONCATENATED MODULE: ./scripts/macros/spells/eldritchBlast.js


async function eldritchBlast_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let color = chris.getConfiguration(workflow.item, 'color') ?? 'purple';
    if (color === 'none') return;
    let colors = [
        'dark_green',
        'dark_red',
        'green',
        'lightblue',
        'lightgreen',
        'orange',
        'pink',
        'rainbow',
        'yellow',
        'purple'
    ]
    if (color === 'cycle') {
        let lastColor = workflow.item.flags['chris-premades']?.spell?.eldritchBlast?.lastColor ?? Math.floor(Math.random() * colors.length);
        color = colors[lastColor];
        lastColor += 1;
        if (lastColor >= colors.length) lastColor = 0;
        await workflow.item.setFlag('chris-premades', 'spell.eldritchBlast.lastColor', lastColor);
    } else if (color === 'random') {
        color = colors[Math.floor(Math.random() * colors.length)];
    }
    let animation = 'jb2a.eldritch_blast.' + color;
    new Sequence().effect().atLocation(workflow.token).stretchTo(workflow.targets.first()).file(animation).missed(workflow.hitTargets.size === 0).play();
}
async function eldritchBlast_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.damageRoll) return;
    let agonizingBlast = workflow.actor.flags['chris-premades']?.feature?.agonizingBlast ?? chris.getConfiguration(workflow.item, 'agonizingblast');
    if (!agonizingBlast) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'agonizingBlast', 50);
    if (!queueSetup) return;
    let bonusDamage = Math.max(workflow.actor.system.abilities.cha.mod, 0);
    let damageFormula = workflow.damageRoll._formula + ' + ' + bonusDamage;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
let eldritchBlast = {
    'item': eldritchBlast_item,
    'damage': eldritchBlast_damage
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/warlock/invocations/eldritchSmite.js



async function eldritchSmite({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (!constants_constants.weaponAttacks.includes(workflow.item.system.actionType)) return;
    let feature = chris.getItem(workflow.actor, 'Eldritch Smite');
    if (!feature) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'eldritchSmite', 250);
    if (!queueSetup) return;
    let pactSlots = workflow.actor.system.spells.pact.value;
    if (pactSlots === 0) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let pactLevel = workflow.actor.system.spells.pact.level;
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Use Eldritch Smite?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let updates = {
        'system.spells.pact.value': pactSlots - 1
    }
    await workflow.actor.update(updates);
    let bonusDamage = (1 + pactLevel) + 'd8[force]';
    if (workflow.isCritical) bonusDamage = chris.getCriticalFormula(bonusDamage);
    let damageFormula = workflow.damageRoll._formula + ' + ' + bonusDamage;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    await feature.displayCard();
    let targetActor = workflow.targets.first().actor;
    let targetSize = chris.getSize(targetActor, false);
    let effect = chris.findEffect(targetActor, 'Prone');
    if (targetSize > 4 || effect) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let selection2 = await chris.dialog(feature.name, constants_constants.yesNo, 'Knock target prone?');
    if (!selection2 || chris.checkTrait(targetActor, 'ci', 'prone')) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await chris.addCondition(targetActor, 'Prone', false, null);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/feats/elementalAdept.js


async function elementalAdept_early(workflow) {
    if (workflow.targets.size === 0) return;
    let spellFlag = workflow.item.flags['chris-premades']?.spell;
    if (!(workflow.item.type === 'spell' || spellFlag)) return;
    let values = [];
    if (workflow.actor.flags['chris-premades']?.feat?.elementalAdept?.acid) values.push('acid');
    if (workflow.actor.flags['chris-premades']?.feat?.elementalAdept?.cold) values.push('cold');
    if (workflow.actor.flags['chris-premades']?.feat?.elementalAdept?.fire) values.push('fire');
    if (workflow.actor.flags['chris-premades']?.feat?.elementalAdept?.lightning) values.push('lightning');
    if (workflow.actor.flags['chris-premades']?.feat?.elementalAdept?.thunder) values.push('thunder');
    if (values.length === 0) return;
    let changes = [];
    for (let i of values) {
        changes.push({
            'key': 'system.traits.dv.value',
            'mode': 0,
            'value': i,
            'priority': 20
        });
    }
    let effectData = {
        'label': 'Elemental Adept',
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'origin': workflow.actor.uuid,
        'duration': {
            'seconds': 1
        },
        'changes': changes,
        'transfer': true
    }
    workflow.targets.forEach(async function(token, key, set) {
        for (let i of values) {
            if (chris.checkTrait(token.actor, 'dr', i)) {
                await chris.createEffect(token.actor, effectData);
                break;
            }
        }
    });
}
async function elementalAdept_late(workflow) {
    if (workflow.targets.size === 0) return;
    workflow.targets.forEach(async function(token, key, set) {
        let effect = chris.findEffect(token.actor, 'Elemental Adept');
        if (effect) await chris.removeEffect(effect);
    });
}
async function elementalAdept_damage(workflow) {
    if (workflow.targets.size === 0) return;
    let spellFlag = workflow.item.flags['chris-premades']?.spell;
    if (!(workflow.item.type === 'spell' || spellFlag)) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'elementalAdept', 320);
    if (!queueSetup) return;
    let values = [];
    if (workflow.actor.flags['chris-premades']?.feat?.elementalAdept?.acid) values.push('acid');
    if (workflow.actor.flags['chris-premades']?.feat?.elementalAdept?.cold) values.push('cold');
    if (workflow.actor.flags['chris-premades']?.feat?.elementalAdept?.fire) values.push('fire');
    if (workflow.actor.flags['chris-premades']?.feat?.elementalAdept?.lightning) values.push('lightning');
    if (workflow.actor.flags['chris-premades']?.feat?.elementalAdept?.thunder) values.push('thunder');
    if (values.length === 0) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let oldDamageRoll = workflow.damageRoll;
    let newDamageRoll = '';
    for (let i = 0; oldDamageRoll.terms.length > i; i++) {
        let flavor = oldDamageRoll.terms[i].flavor;
        let isDeterministic = oldDamageRoll.terms[i].isDeterministic;
        if (!values.includes(flavor.toLowerCase()) || isDeterministic === true) {
            newDamageRoll += oldDamageRoll.terms[i].formula;
        } else {
            newDamageRoll += oldDamageRoll.terms[i].expression + 'min2[' + flavor + ']'
        }
    }
    let damageRoll = await new Roll(newDamageRoll).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
let elementalAdept = {
    'early': elementalAdept_early,
    'late': elementalAdept_late,
    'damage': elementalAdept_damage
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/barbarian/giant/elementalCleaver.js

async function mutate(workflow, selected) {
    let damageType = await chris.dialog(workflow.item.name, [['🧪 Acid', 'acid'], ['❄️ Cold', 'cold'], ['🔥 Fire', 'fire'], ['☁️ Thunder', 'thunder'], ['⚡ Lightning', 'lightning']], 'What damage type?');
    if (!damageType) return;
    let parts = duplicate(selected.system.damage.parts);
    for (let i = 0; i < parts.length; i++) {
        parts[i][0] = parts[i][0].replaceAll(parts[i][1], damageType);
        parts[i][1] = damageType;
    }
    let versatile = duplicate(selected.system.damage.versatile);
    let demiurgicColossus = chris.getItem(workflow.actor, 'Demiurgic Colossus');
    let bonusDice = demiurgicColossus ? 2 : 1;
    parts.push([bonusDice + 'd6[' + damageType + ']', damageType]);
    if (selected.system.damage.parts.length) versatile.replaceAll(selected.system.damage.parts[0][1], selected);
    if (versatile != '') versatile += ' + ' + bonusDice + 'd6[' + damageType + ']';
    async function effectMacro () {
        await warpgate.revert(token.document, 'Elemental Cleaver');
    }
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Elemental Cleaver: Change Damage Type', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Elemental Cleaver: Change Damage Type');
    let effectData = {
        'name': 'Elemental Cleaver',
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                },
                'feature': {
                    'elementalCleaver': {
                        'weapon': selected.id
                    }
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [selected.name]: {
                    'system': {
                        'damage': {
                            'parts': parts,
                            'versatile': versatile
                        },
                        'properties': {
                            'thr': true
                        },
                        'range': {
                            'long': 60,
                            'value': 20
                        }
                    }
                },
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [featureData.name]: effectData
            }
        }
    }
    let options = {
        'permanent': false,
        'name': 'Elemental Cleaver',
        'description': 'Elemental Cleaver'
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
async function elementalCleaver_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.actor || !workflow.token) return;
    let weapons = workflow.actor.items.filter(i => i.type === 'weapon' && i.system.equipped && i.flags['chris-premades']?.info?.name != 'Unarmed Strike');
    if (!weapons.length) return;
    let selected;
    if (weapons.length === 1) {
        selected = weapons[0];
    } else {
        [selected] = await chris.selectDocument(workflow.item.name, weapons, false);
    }
    if (!selected) return;
    await mutate(workflow, selected);
}
async function change({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Elemental Cleaver');
    if (!effect) return;
    let weaponId = effect.flags['chris-premades']?.feature?.elementalCleaver?.weapon;
    if (!weaponId) return;
    let selected = workflow.actor.items.get(weaponId);
    if (!selected) return;
    await chris.removeEffect(effect);
    await mutate(workflow, selected);
}
let elementalCleaver = {
    'item': elementalCleaver_item,
    'change': change,
    'mutate': mutate
}
;// CONCATENATED MODULE: ./scripts/macros/spells/elementalWeapon.js

async function elementalWeapon({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    let weapons = targetActor.items.filter(i => i.type === 'weapon' && !i.system.properties?.mgc && i.system.equipped);
    if (!weapons.length) {
        ui.notifications.warn('Target has no valid non-magical equipped weapons!');
        return;
    }
    let selection;
    if (weapons.length === 1) {
        selection = [weapons[0]];
    } else {
        selection = await chris.selectDocument(workflow.item.name, weapons);
        if (!selection) return;
    }
    let damageType = await chris.dialog(workflow.item.name, [['🧪 Acid', 'acid'], ['❄️ Cold', 'cold'], ['🔥 Fire', 'fire'], ['⚡ Lightning', 'lightning'], ['☁️ Thunder', 'thunder']], 'What damage type?');
    if (!damageType) return;
    let castLevel = workflow.castData.castLevel;
    let bonus = 1;
    if (castLevel >= 5 && castLevel < 7) {
        bonus = 2;
    } else if (castLevel > 7) {
        bonus = 3;
    }
    let damageParts = duplicate(selection[0].system.damage.parts);
    damageParts.push([bonus + 'd4[' + damageType + ']', damageType]);
    let versatile = duplicate(selection[0].system.damage.versatile);
    if (versatile != '') versatile += ' + ' + bonus + 'd4[' + damageType + ']';
    async function effectMacro () {
        await warpgate.revert(token.document, 'Elemental Weapon');
    }
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 3600
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': selection[0].name
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [selection[0].name]: {
                    'system': {
                        'damage': {
                            'parts': damageParts,
                            'versatile': versatile
                        },
                        'attackBonus': bonus
                    }
                }
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Elemental Weapon',
        'description': 'Elemental Weapon'
    };
    await warpgate.mutate(targetToken.document, updates, {}, options);
}

;// CONCATENATED MODULE: ./scripts/macros/items/elixirOfHealth.js

async function elixirOfHealth({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetActor = workflow.targets.first().actor;
    await chris.removeCondition(targetActor, 'Blinded');
    await chris.removeCondition(targetActor, 'Deafened');
    await chris.removeCondition(targetActor, 'Paralyzed');
    await chris.removeCondition(targetActor, 'Poisoned');
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/cleric/peaceDomain/emboldeningBond.js



async function effectMacro() {
    await chrisPremades.macros.emboldeningBond.remove(token);
}
let emboldeningBond_effectData = {
    'name': 'Emboldening Bond Bonus',
    'changes': [
        {
            'key': 'flags.midi-qol.optional.emboldeningBond.count',
            'mode': 0,
            'value': '1',
            'priority': 20
        },
        {
            'key': 'flags.midi-qol.optional.emboldeningBond.label',
            'mode': 0,
            'value': 'Emboldening Bond',
            'priority': 20
        },
        {
            'key': 'flags.midi-qol.optional.emboldeningBond.save.all',
            'mode': 0,
            'value': '+ 1d4',
            'priority': 20
        },
        {
            'key': 'flags.midi-qol.optional.emboldeningBond.attack.all',
            'mode': 0,
            'value': '+ 1d4',
            'priority': 20
        },
        {
            'key': 'flags.midi-qol.optional.emboldeningBond.check.all',
            'mode': 0,
            'value': '+ 1d4',
            'priority': 20
        },
        {
            'key': 'flags.midi-qol.optional.emboldeningBond.skill.all',
            'mode': 0,
            'value': '+ 1d4',
            'priority': 20
        },
        {
            'key': 'system.attributes.init.bonus',
            'mode': 2,
            'value': '+ 1d4',
            'priority': 20
        }
    ],
    'flags': {
        'effectmacro': {
            'onDelete': {
                'script': chris.functionToString(effectMacro)
            }
        }
    }
};
async function emboldeningBond_turn(token, origin, effect) {
    let effect2 = chris.findEffect(token.actor, 'Emboldening Bond Bonus');
    if (effect2) return;
    let distance = effect.flags['chris-premades']?.feature?.emboldeningBond?.expansiveBond ?? 30;
    let nearbyTargets = chris.findNearby(token, distance, 'all', true).concat(token).filter(t => t.actor.effects.find(e => e.origin === origin.uuid && e.name === 'Emboldening Bond'));
    if (nearbyTargets.length < 2) return;
    let effectData2 = duplicate(emboldeningBond_effectData);
    setProperty(effectData2, 'flags.chris-premades.feature.emboldeningBond.sourceTokenUuid', token.document.uuid);
    setProperty(effectData2, 'origin', origin.uuid);
    setProperty(effectData2, 'icon', origin.img);
    setProperty(effectData2, 'duration.seconds', effect.duration.seconds);
    if (token.actor.flags['chris-premades']?.feature?.expansiveBond) setProperty(effectData2, 'flags.chris-premades.feature.emboldeningBond.expansiveBond', 60);
    await chris.createEffect(token.actor, effectData2);
}
async function checkBonus(effect) {
    if (!effect.origin) return;
    let tokens = canvas.scene.tokens.filter(t => t.actor.effects.find(e => e.name == 'Emboldening Bond' && e.origin === effect.origin));
    for (let token of tokens) {
        let effect3 = chris.findEffect(token.actor, 'Emboldening Bond');
        let distance = effect3.flags['chris-premades']?.feature?.emboldeningBond?.expansiveBond ?? 30;
        let nearbyTargets = chris.findNearby(token.object, distance, 'all', true).concat(token.object).filter(t => t.actor.effects.find(e => e.name === 'Emboldening Bond'));
        let effect2 = chris.findEffect(token.actor, 'Emboldening Bond Bonus');
        if (nearbyTargets.length < 2) {
            if (effect2) {
                await chris.updateEffect(effect2, {'disabled': true});
                await chris.removeEffect(effect2);
            }
        } else {
            if (effect2) continue;
            if (chris.inCombat()) {
                let currentTurn = game.combat.round + '-' + game.combat.turn;
                let previousTurn = effect3.flags['chris-premades']?.feature?.emboldeningBond.turn;
                if (currentTurn === previousTurn) continue;
            }
            let effectData2 = duplicate(emboldeningBond_effectData);
            setProperty(effectData2, 'flags.chris-premades.feature.emboldeningBond.sourceTokenUuid', effect3.flags['chris-premades']?.feature?.emboldeningBond?.sourceTokenUuid);
            setProperty(effectData2, 'origin', effect3.origin);
            setProperty(effectData2, 'icon', effect3.icon);
            setProperty(effectData2, 'duration.seconds', effect3.duration.seconds);
            if (effect3.flags['chris-premades']?.feature?.emboldeningBond?.expansiveBond) setProperty(effectData2, 'flags.chris-premades.feature.emboldeningBond.expansiveBond', 60);
            await chris.createEffect(token.actor, effectData2);
        }
    }
}
async function emboldeningBond_move(token, changes) {
    if (!chris.isLastGM()) return;
    if (token.parent.id != canvas.scene.id) return;
    if (!changes.x && !changes.y && !changes.elevation) return;
    let effect = chris.findEffect(token.actor, 'Emboldening Bond');
    if (!effect) return;
    await token.object?._animation;
    checkBonus(effect);
}
async function emboldeningBond_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size === 0) return;
    let effectData2 = duplicate(emboldeningBond_effectData);
    setProperty(effectData2, 'flags.chris-premades.feature.emboldeningBond.sourceTokenUuid', token.document.uuid);
    setProperty(effectData2, 'origin', workflow.item.uuid);
    setProperty(effectData2, 'icon', workflow.item.img);
    setProperty(effectData2, 'duration.seconds', 600)
    async function effectMacro() {
        await chrisPremades.macros.emboldeningBond.turn(token, origin, effect);
    }
    async function effectMacro2() {
        await chrisPremades.macros.emboldeningBond.removeBonus(token);
    }
    let effectData3 = {
        'name': 'Emboldening Bond',
        'icon': workflow.item.img,
        'duration': {
            'seconds': 600,
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onEachTurn': {
                    'script': chris.functionToString(effectMacro)
                },
                'onDelete': {
                    'script': chris.functionToString(effectMacro2)
                }
            },
            'chris-premades': {
                'feature': {
                    'emboldeningBond': {
                        'sourceTokenUuid': workflow.token.document.uuid
                    }
                }
            }
        }
    };
    if (workflow.actor.flags['chris-premades']?.feature?.expansiveBond) {
        setProperty(effectData2, 'flags.chris-premades.feature.emboldeningBond.expansiveBond', 60);
        setProperty(effectData3, 'flags.chris-premades.feature.emboldeningBond.expansiveBond', 60);
    }
    if (workflow.actor.flags['chris-premades']?.feature?.emboldeningBond?.protectiveBond) {
        setProperty(effectData3, 'flags.chris-premades.feature.emboldeningBond.protectiveBond', true);
    }
    for (let token of Array.from(workflow.targets)) {
        await chris.createEffect(token.actor, effectData3);
        await chris.createEffect(token.actor, effectData2);
    }
}
async function emboldeningBond_remove(token) {
    let effect = chris.findEffect(token.actor, 'Emboldening Bond');
    if (!effect) return;
    await effect.setFlag('chris-premades', 'feature.emboldeningBond.turn', game.combat.round + '-' + game.combat.turn);
}
async function emboldeningBond_damage(targetToken, {workflow, ditem}) {
    if (!workflow) return;
    if (workflow.defaultDamageType === 'healing' || workflow.defaultDamageType === 'temphp') return;
    if (workflow.item?.flags?.['chris-premades']?.feature?.protectiveBond) return;
    let effect = chris.findEffect(targetToken.actor, 'Emboldening Bond');
    if (!effect) return;
    if (!effect.flags['chris-premades']?.feature?.emboldeningBond?.protectiveBond) return;
    if (chris.findEffect(targetToken.actor, 'Reaction')) return;
    let distance = effect.flags['chris-premades']?.feature?.emboldeningBond?.expansiveBond ?? 30;
    let nearbyTargets = chris.findNearby(targetToken, distance, 'all', true).filter(t => t.actor.effects.find(e => e.origin === effect.origin && e.name === 'Emboldening Bond') && !chris.findEffect(t.actor, 'Reaction'));
    if (nearbyTargets.length === 0) return;
    let queueSetup = await queue_queue.setup(workflow.uuid, 'protectiveBond', 400);
    if (!queueSetup) return;
    for (let token of nearbyTargets) {
        let owner = chris.firstOwner(token.document);
        if (!owner) continue;
        let title = 'Protective Bond: Protect Target?';
        if (owner.isGM) title = '[' + token.actor.name + '] ' + title;
        let firstOwner = chris.firstOwner(token.document).id;
        await chris.thirdPartyReactionMessage(firstOwner);
        let selection = await chris.remoteDialog('Protective Bond', constants_constants.yesNo, firstOwner, title);
        if (!selection) continue;
        let featureDamage = 0;
        let damages = {};
        for (let term of workflow.damageRoll.terms) {
            if (isNaN(term.total)) continue;
            let flavor = term.flavor.toLowerCase();
            if (!damages[flavor]) damages[flavor] = 0;
            damages[flavor] += term.total;
        }
        let forceDR = !!effect.flags['chris-premades']?.feature?.emboldeningBond?.expansiveBond;
        for (let [key, value] of Object.entries(damages)) {
            if (chris.checkTrait(token.actor, 'di', key)) continue;
            let dr = chris.checkTrait(token.actor, 'dr', key);
            if (forceDR) dr = true;
            let dv = chris.checkTrait(token.actor, 'dv', key);
            if (dr && !dv) featureDamage += Math.floor(value / 2);
            if (!dr && dv) featureDamage += value * 2;
            if (!dr && !dv) featureDamage += value;
        }
        let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Protective Bond - Damage', false);
        if (!featureData) {
            queue_queue.remove(workflow.uuid);
            return;
        }
        delete featureData._id;
        if (effect.flags['chris-premades']?.feature?.emboldeningBond?.expansiveBond) setProperty(featureData, 'flags.autoanimations.data.options.range', 60);
        featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Protective Bond - Damage');
        featureData.system.damage.parts = [
            [
                featureDamage,
                'none'
            ]
        ];
        setProperty(featureData, 'flags.chris-premades.feature.protectiveBond', true);
        async function effectMacro() {
            await chrisPremades.macros.emboldeningBond.teleport(token);
        }
        let effectData = {
            'name': featureData.name,
            'icon': featureData.img,
            'duration': {
                'seconds': 1
            },
            'origin': workflow.item.uuid,
            'flags': {
                'effectmacro': {
                    'onCreate': {
                        'script': chris.functionToString(effectMacro)
                    }
                }
            }
        };
        let updates = {
            'embedded': {
                'Item': {
                    [featureData.name]: featureData
                },
                'ActiveEffect': {
                    [effectData.name]: effectData
                }
            }
        };
        let options = {
            'permanent': false,
            'name': featureData.name,
            'description': featureData.name
        };
        await warpgate.mutate(token.document, updates, {}, options);
        ditem.appliedDamage = 0;
        ditem.hpDamage = 0;
        ditem.newHP = ditem.oldHP;
        ditem.newTempHP = ditem.oldTempHP;
        ditem.newVitality = ditem.oldVitality;
        ditem.tempDamage = 0;
        ditem.totalDamage = 0;
        break;
    }
    await chris.clearThirdPartyReactionMessage();
    queue_queue.remove(workflow.uuid);
}
async function teleport(token) {
    let feature = token.actor.items.find(i => i.flags['chris-premades']?.feature?.protectiveBond);
    if (feature) await feature.use();
    await warpgate.revert(token.document, 'Protective Bond - Damage');
}
async function removeBonus(token) {
    let effect = chris.findEffect(token.actor, 'Emboldening Bond Bonus');
    if (!effect) return;
    await chris.removeEffect(effect);
}
let emboldeningBond = {
    'turn': emboldeningBond_turn,
    'move': emboldeningBond_move,
    'item': emboldeningBond_item,
    'remove': emboldeningBond_remove,
    'damage': emboldeningBond_damage,
    'teleport': teleport,
    'removeBonus': removeBonus
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/druid/circleOfWildfire/enhancedBond.js

function enhancedBond(actor) {
    let effect = chris.findEffect(actor, 'Summon Wildfire Spirit');
    return !!effect;
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/artificer/infusions/enhancedWeapon.js


async function enhancedWeapon_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let infusionId = workflow.item.flags['chris-premades']?.feature?.infusion?.enhancedWeapon?.id;
    if (!infusionId) {
        let validWeapons = workflow.actor.items.filter(i => i.type === 'weapon' && !i.system.properties?.mgc);
        if (chris.getItem(actor, 'Armor Modifications')) {
            let gauntlets = chris.getItem(workflow.actor, 'Guardian Armor: Thunder Gauntlets');
            if (gauntlets) validWeapons.push(gauntlets);
            let launcher = chris.getItem(workflow.actor, 'Infiltrator Armor: Lightning Launcher');
            if (launcher) validWeapons.push(launcher);
        }
        if (validWeapons.length === 0) {
            ui.notifications.info('No valid weapon to infuse!');
            return;
        }
        let [selection] = await chris.selectDocument('Infuse what weapon?', validWeapons, false);
        if (!selection) return;
        await workflow.item.setFlag('chris-premades', 'feature.infusion.enhancedWeapon.id', selection.id);
    } else {
        let selection = await chris.dialog(workflow.item.name, [['Yes', true], ['No', false]], 'Remove enhanced weapon infusion?');
        if (!selection) return;
        await workflow.item.setFlag('chris-premades', 'feature.infusion.enhancedWeapon.id', null);
    }
}
async function enhancedWeapon_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    let originItem = chris.getItem(workflow.actor, 'Enhanced Weapon, +2') ?? chris.getItem(workflow.actor, 'Enhanced Weapon, +1');
    if (!originItem) return;
    if (workflow.item.id != originItem.flags['chris-premades']?.feature?.infusion?.enhancedWeapon?.id) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'enhancedWeapon', 150);
    if (!queueSetup) return;
    let parts = duplicate(workflow.item.system.damage.parts);
    let level = chris.getConfiguration(originItem, 'level') ?? 1;
    parts[0][0] = parts[0][0] + ' + ' + level;
    let properties = duplicate(workflow.item.system.properties);
    let attackBonus = duplicate(workflow.item.system.attackBonus);
    attackBonus = level;
    properties.mgc = true;
    workflow.item = workflow.item.clone({'system.damage.parts': parts, 'system.properties': properties, 'system.attackBonus': attackBonus}, {'keepId': true});
    workflow.item.prepareData();
    workflow.item.prepareFinalAttributes();
    queue_queue.remove(workflow.item.uuid);
}
let enhancedWeapon = {
    'item': enhancedWeapon_item,
    'attack': enhancedWeapon_attack
}
;// CONCATENATED MODULE: ./scripts/macros/spells/enlargeReduce.js

async function enlargeAnimation(token, updates, name, callbacks) {
    //Animations by: eskiemoh
    let scale = 1;
    let size = chris.getSize(token.actor, true);
    switch (size) {
        case 'small':
            scale = 0.8;
            break;
        case 'tiny':
            scale = 0.5;
            break;
    }
    await new Sequence()
        .effect()
        .file('jb2a.static_electricity.03.orange')
        .atLocation(token)
        .duration(3000)
        .scaleToObject(1)
        .fadeIn(250)
        .fadeOut(250)
        .zIndex(2)
        
        .effect()
        .from(token)
        .atLocation(token)
        .scaleToObject(2)
        .duration(500)
        .scaleIn(0.25,500)
        .fadeIn(250)
        .fadeOut(250)
        .repeats(3, 500, 500)
        .opacity(0.2)
        .zIndex(1)
        
        .animation()
        .on(token)
        .opacity(0)
        
        .effect()
        .from(token)
        .atLocation(token)
        .loopProperty('sprite', 'position.x', {'from': -40, 'to': 40, 'duration': 75, 'pingPong': true, 'delay': 200})
        .scaleToObject(scale)
        .duration(2000)
        .waitUntilFinished(-200)
        .zIndex(0)
        
        .thenDo(async () => {
            let options = {
                'permanent': false,
                'name': name,
                'description': name,
                'updateOpts': {'token': {'animate': false}}
            };
            await warpgate.mutate(token.document, updates, callbacks, options);
        })
        
        .wait(200)
        
        .effect()
        .from(token)
        .atLocation(token)
        .scaleToObject(1)
        .duration(3000)
        .scaleIn(0.25,700, {'ease': 'easeOutBounce'})
        
        .effect()
        .file('jb2a.extras.tmfx.outpulse.circle.01.fast')
        .atLocation(token)
        .belowTokens()
        .opacity(0.75)
        .scaleToObject(2)
        .zIndex(1)
        
        .effect()
        .file('jb2a.impact.ground_crack.orange.02')
        .atLocation(token)
        .belowTokens()
        .scaleToObject(2)
        .zIndex(0)
        
        .effect()
        .file('jb2a.particles.outward.orange.01.04')
        .scaleIn(0.25, 500, {'ease': 'easeOutQuint'})
        .fadeIn(500)
        .fadeOut(1000)
        .atLocation(token)
        .randomRotation()
        .duration(3000)
        .scaleToObject(1.5)
        .zIndex(4)
        
        .effect()
        .file('jb2a.static_electricity.03.orange')
        .atLocation(token)
        .duration(5000)
        .scaleToObject(1)
        .fadeIn(250)
        .fadeOut(250)
        .waitUntilFinished(-3000)
        
        .animation()
        .on(token)
        .opacity(1)
        
        .play();
}
async function reduceAnimation(token, updates, name) {
    //Animations by: eskiemoh
    let scale = 1;
    let size = chris.getSize(token.actor, true);
    switch (size) {
        case 'medium':
            scale = 0.8;
            break;
        case 'small':
            scale = 0.5;
            break;
        case 'tiny':
            scale = 0.25;
            break;
    }
    await new Sequence()
        .effect()
        .file('jb2a.static_electricity.03.orange')
        .atLocation(token)
        .duration(3000)
        .scaleToObject(1)
        .fadeIn(250)
        .fadeOut(250)
        .zIndex(2)

        .effect()
        .from(token)
        .atLocation(token)
        .scaleToObject(2)
        .duration(500)
        .scaleIn(0.25,500)
        .fadeIn(250)
        .fadeOut(250)
        .repeats(3, 500, 500)
        .opacity(0.2)
        .zIndex(1)

        .animation()
        .on(token)
        .opacity(0)

        .effect()
        .from(token)
        .atLocation(token)
        .loopProperty('sprite', 'rotation', {'from': -10, 'to': 10, 'duration': 75, 'pingPong': true, 'delay': 200})
        .duration(2000)
        .waitUntilFinished(-200)
        .zIndex(0)

        .thenDo(async () => {
            let options = {
                'permanent': false,
                'name': name,
                'description': name,
                'updateOpts': {'token': {'animate': false}}
            };
            await warpgate.mutate(token.document, updates, {}, options);
        })

        .wait(200)

        .effect()
        .from(token)
        .atLocation(token)
        .scaleToObject(scale)
        .duration(3000)
        .scaleIn(0.25, 700, {'ease': 'easeOutBounce'})

        .effect()
        .file('jb2a.extras.tmfx.outpulse.circle.01.fast')
        .atLocation(token)
        .opacity(0.75)
        .scaleToObject(2)
        .zIndex(1)

        .effect()
        .file('jb2a.energy_strands.in.yellow.01.2')
        .atLocation(token)
        .belowTokens()
        .scaleToObject(2)
        .zIndex(0)

        .effect()
        .file('jb2a.particles.outward.orange.01.04')
        .scaleIn(0.25, 500, {'ease': 'easeOutQuint'})
        .fadeIn(500)
        .fadeOut(1000)
        .atLocation(token)
        .randomRotation()
        .duration(3000)
        .scaleToObject(1.5)
        .zIndex(4)

        .effect()
        .file('jb2a.static_electricity.03.orange')
        .atLocation(token)
        .duration(5000)
        .scaleToObject(1)
        .fadeIn(250)
        .fadeOut(250)
        .waitUntilFinished(-3000)

        .animation()
        .on(token)
        .opacity(1)

        .play()
}
async function enlargeReduce_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size != 1) return;
    let animate = chris.getConfiguration(workflow.item, 'animation') ?? chris.jb2aCheck() === 'patreon';
    let selection = await chris.dialog(workflow.item.name, [['Enlarge', 'enlarge'], ['Reduce', 'reduce']], 'Enlarge or Reduce?');
    if (!selection) return;
    let targetToken = workflow.targets.first();
    if (selection === 'enlarge') {
        async function effectMacro() {
            await chrisPremades.macros.enlargeReduce.end(token);
        }
        let effectData = {
            'name': workflow.item.name,
            'icon': workflow.item.img,
            'origin': workflow.item.uuid,
            'duration': {
                'seconds': 60
            },
            'changes': [
                {
                    'key': 'system.bonuses.mwak.damage',
                    'mode': 2,
                    'value': '+1d4',
                    'priority': 20
                },
                {
                    'key': 'system.bonuses.rwak.damage',
                    'mode': 2,
                    'value': '+1d4',
                    'priority': 20
                },
                {
                    'key': 'flags.midi-qol.advantage.ability.check.str',
                    'mode': 0,
                    'value': '1',
                    'priority': 20
                },
                {
                    'key': 'flags.midi-qol.advantage.ability.save.str',
                    'mode': 0,
                    'value': '1',
                    'priority': 20
                }
            ],
            'flags': {
                'effectmacro': {
                    'onDelete': {
                        'script': chris.functionToString(effectMacro)
                    }
                },
                'chris-premades': {
                    'spell': {
                        'enlargeReduce': selection
                    }
                }
            }
        };
        let token = {};
        let actor = {};
        let doGrow = true;
        let targetSize = targetToken.actor.system.traits.size;
        if (targetSize != 'tiny' || targetSize != 'sm') {
            let room = chris.checkForRoom(targetToken, 1);
            let direction = chris.findDirection(room);
            switch(direction) {
                case 'none':
                    doGrow = false;
                    break;
                case 'ne':
                    setProperty(token, 'y', targetToken.y - canvas.grid.size);
                    break;
                case 'sw':
                    setProperty(token, 'x', targetToken.x - canvas.grid.size);
                    break;
                case 'nw':
                    setProperty(token, 'x', targetToken.x - canvas.grid.size);
                    setProperty(token, 'y', targetToken.y - canvas.grid.size);
                    break;
            }
        }
        if (doGrow) {
            switch (targetSize) {
                case 'tiny':
                    setProperty(token, 'texture.scaleX', '0.8');
                    setProperty(token, 'texture.scaleY', '0.8');
                    setProperty(actor, 'system.traits.size', 'sm');
                    break;
                case 'sm':
                    setProperty(token, 'texture.scaleX', '1');
                    setProperty(token, 'texture.scaleY', '1');
                    setProperty(actor, 'system.traits.size', 'med');
                    break;
                case 'med':
                    setProperty(token, 'height', targetToken.document.height + 1);
                    setProperty(token, 'width', targetToken.document.width + 1);
                    setProperty(actor, 'system.traits.size', 'lg');
                    break;
                case 'lg':
                    setProperty(token, 'height', targetToken.document.height + 1);
                    setProperty(token, 'width', targetToken.document.width + 1);
                    setProperty(actor, 'system.traits.size', 'huge');
                    break;
                case 'huge':
                    setProperty(token, 'height', targetToken.document.height + 1);
                    setProperty(token, 'width', targetToken.document.width + 1);
                    setProperty(actor, 'system.traits.size', 'grg');
                    break;
                case 'grg':
                    setProperty(token, 'height', targetToken.document.height + 1);
                    setProperty(token, 'width', targetToken.document.width + 1);
                    break;
            }
        }
        let updates = {
            'token': token,
            'actor': actor,
            'embedded': {
                'ActiveEffect': {
                    [effectData.name]: effectData
                }
            }
        };
        let callbacks = {
            'delta': (delta, tokenDoc) => {
                if ('x' in delta.token) delete delta.token.x;
                if ('y' in delta.token) delete delta.token.y;
            }
        };
        if (animate) {
            await enlargeAnimation(targetToken, updates, 'Enlarge/Reduce', callbacks);
        } else {
            let options = {
                'permanent': false,
                'name': 'Enlarge/Reduce',
                'description': 'Enlarge/Reduce'
            };
            await warpgate.mutate(targetToken.document, updates, callbacks, options);
        }
    } else {
        async function effectMacro() {
            await chrisPremades.macros.enlargeReduce.end(token);
        }
        let effectData = {
            'name': workflow.item.name,
            'icon': workflow.item.img,
            'origin': workflow.item.uuid,
            'duration': {
                'seconds': 60
            },
            'changes': [
                {
                    'key': 'system.bonuses.mwak.damage',
                    'mode': 2,
                    'value': '-1d4',
                    'priority': 20
                },
                {
                    'key': 'system.bonuses.rwak.damage',
                    'mode': 2,
                    'value': '-1d4',
                    'priority': 20
                },
                {
                    'key': 'flags.midi-qol.disadvantage.ability.check.str',
                    'mode': 0,
                    'value': '1',
                    'priority': 20
                },
                {
                    'key': 'flags.midi-qol.disadvantage.ability.save.str',
                    'mode': 0,
                    'value': '1',
                    'priority': 20
                }
            ],
            'flags': {
                'effectmacro': {
                    'onDelete': {
                        'script': chris.functionToString(effectMacro)
                    }
                },
                'chris-premades': {
                    'spell': {
                        'enlargeReduce': selection
                    }
                }
            }
        };
        let token = {};
        let actor = {};
        let targetSize = targetToken.actor.system.traits.size;
        switch (targetSize) {
            case 'tiny':
                setProperty(token, 'texture.scaleX', '0.25');
                setProperty(token, 'texture.scaleY', '0.25');
            case 'sm':
                setProperty(token, 'texture.scaleX', '0.5');
                setProperty(token, 'texture.scaleY', '0.5');
                setProperty(actor, 'system.traits.size', 'tiny');
                break;
            case 'med':
                setProperty(token, 'texture.scaleX', '0.8');
                setProperty(token, 'texture.scaleY', '0.8');
                setProperty(actor, 'system.traits.size', 'sm');
                break;
            case 'lg':
                setProperty(token, 'height', targetToken.document.height - 1);
                setProperty(token, 'width', targetToken.document.width - 1);
                setProperty(actor, 'system.traits.size', 'med');
                break;
            case 'huge':
                setProperty(token, 'height', targetToken.document.height - 1);
                setProperty(token, 'width', targetToken.document.width - 1);
                setProperty(actor, 'system.traits.size', 'lg');
                break;
            case 'grg':
                setProperty(token, 'height', targetToken.document.height - 1);
                setProperty(token, 'width', targetToken.document.width - 1);
                setProperty(actor, 'system.traits.size', 'huge');
                break;
        }
        let updates = {
            'token': token,
            'actor': actor,
            'embedded': {
                'ActiveEffect': {
                    [effectData.name]: effectData
                }
            }
        };
        if (animate) {
            await reduceAnimation(targetToken, updates, 'Enlarge/Reduce');
        } else {
            let options = {
                'permanent': false,
                'name': 'Enlarge/Reduce',
                'description': 'Enlarge/Reduce'
            };
            await warpgate.mutate(targetToken.document, updates, {}, options);
        }
    }
}
async function enlargeReduce_end(token, origin) {
    await warpgate.revert(token.document, 'Enlarge/Reduce', {'updateOpts': {'token': {'animate': true}}});
}
let enlargeReduce = {
    'enlargeAnimation': enlargeAnimation,
    'reduceAnimation': reduceAnimation,
    'item': enlargeReduce_item,
    'end': enlargeReduce_end
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/artificer/alchemist/experimentalElixir.js

async function experimentalElixir({speaker, actor, token, character, item, args, scope, workflow}) {
    let roll = await new Roll('1d6').roll({async: true});
    roll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: 'Experimental Elixir'
    });
    let itemName;
    switch (roll.total) {
        case 1:
            itemName = 'Experimental Elixir - Healing';
            break;
        case 2:
            itemName = 'Experimental Elixir - Swiftness';
            break;
        case 3:
            itemName = 'Experimental Elixir - Resilience';
            break;
        case 4:
            itemName = 'Experimental Elixir - Boldness';
            break;
        case 5:
            itemName = 'Experimental Elixir - Flight';
            break;
        case 6:
            itemName = 'Experimental Elixir - Transformation';
            break;
    }
    let feature = workflow.actor.items.getName(itemName);
    if (feature) {
        feature.update({
            'system.quantity': item.system.quantity + 1
        });
    } else {
        let itemData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', itemName, false);
        if (!itemData) return;
        itemData.system.description.value = chris.getItemDescription('CPR - Descriptions', itemName);
        if (itemName === 'Experimental Elixir - Healing') {
            itemData.system.damage.parts = [
                [
                    '2d4[healing] + ' + workflow.actor.system.abilities.int.mod,
                    'healing'
                ]
            ];
        }
        if (workflow.actor.classes.artificer?.system?.levels >= 9) {
            if (!itemData.system.damage.parts) itemData.system.damage.parts = [];
            itemData.system.damage.parts.push([
                '2d6[temphp] + ' + workflow.actor.system.abilities.int.mod,
                'temphp'
            ]);
        }
        let effectData = {
            'name': itemData.name + ' Item',
            'icon': '', //Blank to avoid showing up as a status icon.
            'duration': {
                'seconds': 604800
            },
            'origin': workflow.item.uuid,
            'flags': {
                'effectmacro': {
                    'onDelete': {
                        'script': "warpgate.revert(token.document, '" + itemData.name + " Item');"
                    }
                },
                'dae': {
                    'transfer': false,
                    'specialDuration': [
                        'longRest'
                    ],
                    'stackable': 'multi',
                    'macroRepeat': 'none'
                }
            }
        };
        let updates = {
            'embedded': {
                'Item': {
                    [itemData.name]: itemData
                },
                'ActiveEffect': {
                    [effectData.name]: effectData
                }
            }
        };
        let options = {
            'permanent': false,
            'name': effectData.name,
            'description': effectData.name
        };
        await warpgate.mutate(workflow.token.document, updates, {}, options);
    }
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/wizard/schoolOfDivination/expertDivination.js

async function expertDivination({speaker, actor, token, character, item, args, scope, workflow}) {
    let type = workflow.item.type;
    if (type != 'spell') return;
    let school = workflow.item.system.school;
    if (school != 'div') return;
    let level = workflow.item.system.level;
    if (level < 2) return;
    let missingFirst = workflow.actor.system.spells.spell1.max - workflow.actor.system.spells.spell1.value;
    let missingSecond = workflow.actor.system.spells.spell2.max - workflow.actor.system.spells.spell2.value;
    let missingThird = workflow.actor.system.spells.spell3.max - workflow.actor.system.spells.spell3.value;
    let missingFourth = workflow.actor.system.spells.spell4.max - workflow.actor.system.spells.spell4.value;
    let missingFifth = workflow.actor.system.spells.spell5.max - workflow.actor.system.spells.spell5.value;
    let menu = [];
    if (level > 1 && missingFirst > 0) menu.push(['1st Level', 1]);
    if (level > 2 && missingSecond > 0) menu.push(['2nd Level', 2]);
    if (level > 3 && missingThird > 0) menu.push(['3rd Level', 3]);
    if (level > 4 && missingFourth > 0) menu.push(['4th Level', 4]);
    if (level > 5 && missingFifth > 0) menu.push(['5th Level', 5]);
    if (menu.length === 0) return;
    let slot = await chris.dialog('What level spell slot do you want to regain?', menu);
    if (!slot) return;
    let updateString;
    let updateValue;
    let messageString;
    switch (slot) {
        case 1:
            updateString = 'system.spells.spell1.value';
            updateValue = workflow.actor.system.spells.spell1.value + 1;
            messageString = 'Regained a 1st level spell slot!'
            break;
        case 2:
            updateString = 'system.spells.spell2.value';
            updateValue = workflow.actor.system.spells.spell2.value + 1;
            messageString = 'Regained a 2nd level spell slot!'
            break;
        case 3:
            updateString = 'system.spells.spell3.value';
            updateValue = workflow.actor.system.spells.spell3.value + 1;
            messageString = 'Regained a 3rd level spell slot!'
            break;
        case 4:
            updateString = 'system.spells.spell4.value';
            updateValue = workflow.actor.system.spells.spell4.value + 1;
            messageString = 'Regained a 4th level spell slot!'
            break;
        case 5:
            updateString = 'system.spells.spell5.value';
            updateValue = workflow.actor.system.spells.spell5.value + 1;
            messageString = 'Regained a 5th level spell slot!'
            break;
    }
    workflow.actor.update({[updateString]: updateValue});
    let effect = chris.findEffect(workflow.actor, 'Expert Divination');
    if (!effect) return;
    let originItem = await fromUuid(effect.origin);
    let tempItem = duplicate(originItem.toObject());
    tempItem.system.description.value = tempItem.system.description.value + '\n<hr><p>' + messageString + '</p>'
    let feature = new CONFIG.Item.documentClass(tempItem, {'parent': workflow.actor});
    await feature.use();
}
;// CONCATENATED MODULE: ./scripts/macros/mechanics/explodingHeals.js


async function explodingHeals(workflow) {
    if (!workflow.damageRoll) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'explodingHeals', 350);
    if (!queueSetup) return;
    let damageTypes = chris.getRollDamageTypes(workflow.damageRoll);
    if (!damageTypes.has('healing')) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let newFormula = '';
    for (let i of workflow.damageRoll.terms) {
        if (i.isDeterministic) {
            newFormula += i.expression;
        } else {
            if (i.flavor === 'healing' && !i.expression.toLowerCase().includes('x')) {
                newFormula += i.expression + 'x[' + i.flavor + ']';
            } else {
                newFormula += i.formula;
            }
        }
    }
    let damageRoll = await new Roll(newFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/items/eyesOfMinuteSeeing.js
function eyesOfMinuteSeeing(skillId, options) {
    return skillId != 'inv' ? false : {'label': 'This check relies on searching or studying and object.', 'type': 'advantage'};
}
;// CONCATENATED MODULE: ./scripts/macros/items/eyesOfTheEagle.js
function eyesOfTheEagle(skillId, options) {
    return skillId != 'prc' ? false : {'label': 'This check relies on sight.', 'type': 'advantage'};
}
;// CONCATENATED MODULE: ./scripts/macros/spells/faerieFire.js

async function faerieFire_item({speaker, actor, token, character, item, args, scope, workflow}) {
    //Animations by: eskiemoh
    if (!workflow.templateUuid) return;
    let color = chris.getConfiguration(workflow.item, 'animation') ?? 'green';
    if (color === 'none' || chris.jb2aCheck() === 'free' || !chris.aseCheck()) return;
    let tintColor;
    let hue;
    switch (color) {
        case 'blue':
            tintColor = '0x91c5d2';
            hue = '160';
            break;
        case 'green':
            tintColor = '0xd3eb6a';
            hue = '45';
            break;
        case 'purple':
            tintColor = '0xdcace3';
            hue = '250';
    }
    let templateDoc = await fromUuid(workflow.templateUuid);
    if (!templateDoc) return;
    let template = templateDoc.object;
    let position = template.ray.project(0.5);
    new Sequence()
        .effect()
        .file('animated-spell-effects-cartoon.flash.25')
        .atLocation(position)
        .scale(0.05)
        .playbackRate(1)
        .duration(1500)
        .opacity(0.75)
        .scaleIn(0, 1000, {'ease': 'easeOutCubic'})
        .filter('ColorMatrix', {'brightness': 0, 'hue': hue})
        .filter('Blur', {'blurX': 5, 'blurY': 10 })
        .animateProperty('sprite', 'width', {'from': 0, 'to': -0.25, 'duration': 2500, 'gridUnits': true, 'ease': 'easeInOutBack'})
        .animateProperty('sprite', 'height', {'from': 0, 'to': -0.25, 'duration': 2500, 'gridUnits': true, 'ease': 'easeInOutBack'})
        .belowTokens()

        .effect()
        .file('jb2a.particles.outward.white.01.03')
        .atLocation(position)
        .scale(0.025)
        .playbackRate(1)
        .duration(1500)
        .fadeIn(1500)
        .scaleIn(0, 1500, {'ease': 'easeOutCubic'})
        .filter('ColorMatrix', {'hue': hue})
        .animateProperty('sprite', 'width', {'from': 0, 'to': 0.5, 'duration': 2500, 'gridUnits' :true, 'ease': 'easeOutBack'})
        .animateProperty('sprite', 'height', {'from': 0, 'to': 1, 'duration': 2500, 'gridUnits': true, 'ease': 'easeOutBack'})
        .animateProperty('sprite', 'position.y', {'from': 0, 'to': -0.45, 'duration': 2500, 'gridUnits': true})

        .effect()
        .file('jb2a.sacred_flame.target.' + color)
        .atLocation(position)
        .scale(0.05)
        .playbackRate(1)
        .duration(1500)
        .scaleIn(0, 1500, {'ease': 'easeOutCubic'})
        .animateProperty('sprite', 'width', {'from': 0, 'to': 0.5, 'duration': 2500, 'gridUnits': true, 'ease': 'easeOutBack'})
        .animateProperty('sprite', 'height', {'from': 0, 'to': 0.5, 'duration': 2500, 'gridUnits': true, 'ease': 'easeOutBack'})
        .animateProperty('sprite', 'position.y', {'from': 0, 'to': -0.25, 'duration': 2500, 'gridUnits': true, 'ease': 'easeOutBack'})
        .waitUntilFinished(-200)

        .effect()
        .file('jb2a.impact.010.' + color)
        .atLocation(position, {'offset': {'y':-0.25}, 'gridUnits': true})
        .scale(0.45)
        .randomRotation()
        .zIndex(1)

        .effect()
        .file('jb2a.particles.outward.white.01.03')
        .scaleIn(0, 500, {'ease': 'easeOutQuint'})
        .fadeOut(1000)
        .atLocation(position, {'offset': {'y':-0.25}, 'gridUnits': true})
        .randomRotation()
        .duration(2500)
        .size(3, {'gridUnits': true})
        .filter('Glow', {'color': tintColor, 'distance': 10})
        .zIndex(2)

        .effect()
        .file('jb2a.fireflies.{{Pfew}}.02.' + color)
        .atLocation(position, {'randomOffset': 0.25})
        .scaleToObject(1.8)
        .randomRotation()
        .duration(750)
        .fadeOut(500)
        .setMustache({
            'Pfew': ()=> {
                let Pfews = ['few','many'];
                return Pfews[Math.floor(Math.random()*Pfews.length)];
            }
        })
        .repeats(10, 75, 75)
        .zIndex(1)

        .effect()
        .file('animated-spell-effects-cartoon.energy.pulse.yellow')
        .atLocation(position, {'offset': {'y':-0.25}, 'gridUnits': true})
        .size(5, {'gridUnits': true})
        .filter('ColorMatrix', {'saturate': -1, 'brightness':2, 'hue': hue})
        .fadeOut(250)
        .filter('Blur', {'blurX': 10, 'blurY': 10})
        .zIndex(0.5)

        .effect()
        .delay(50)
        .file('animated-spell-effects-cartoon.energy.pulse.yellow')
        .atLocation(position, {'offset': {'y':-0.25}, 'gridUnits': true})
        .size(5, {'gridUnits': true})
        .filter('ColorMatrix', {'hue': hue})
        .zIndex(0.5)

        .play();
    if (!workflow.failedSaves.size) return;
    await (warpgate.wait(1000));
    for (let i of workflow.failedSaves) {
        new Sequence()
            .effect()
            .file('jb2a.fireflies.many.01.' + color)
            .attachTo(i)
            .scaleToObject(1.4)
            .persist()
            .randomRotation()
            .fadeIn(500, {'delay':500})
            .fadeOut(1500, {'ease': 'easeInSine'})
            .name('Faerie Fire')
            .private()

            .effect()
            .from(i)
            .belowTokens()
            .attachTo(i)
            .scaleToObject(i.document.texture.scaleX)
            .spriteRotation(i.document.texture.rotation*-1)
            .filter('Glow', {'color': tintColor, 'distance': 20})
            .persist()
            .fadeIn(1500, {'delay' :500})
            .fadeOut(1500, {'ease': 'easeInSine'})
            .zIndex(0.1)
            .name('Faerie Fire')
            .play();
    }
}
async function animationEnd(token, origin) {
    let color = chris.getConfiguration(origin, 'animation') ?? 'green';
    if (color === 'none' || chris.jb2aCheck() === 'free' || !chris.aseCheck()) return;
    Sequencer.EffectManager.endEffects({'name': 'Faerie Fire', object: token});
}
let faerieFire = {
    'item': faerieFire_item,
    'animationEnd': animationEnd
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/bloodHunter/bloodCurses/fallenPuppet.js

async function fallenPuppet({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let amplify = await chris.dialog('Amplify Blood Curse?', [['Yes', true], ['No', false]]);
    if (!amplify) return;
    let damageDice = workflow.actor.system.scale['blood-hunter']['crimson-rite'];
    if (!damageDice) {
        ui.notifications.warn('Source actor does not appear to have a Crimson Rite scale!');
        return;
    }
    let roll = await new Roll(damageDice + '[none]').roll({async: true});
    roll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: workflow.item.name
    });
    await chris.applyDamage(workflow.token, roll.total, 'none');
    let effect = chris.findEffect(workflow.targets.first().actor, 'Blood Curse of the Fallen Puppet');
    if (!effect) return;
    let modifier = chris.getSpellMod(workflow.item);
    let updates = {
        'changes': [
            {
                'key': 'system.bonuses.All-Attacks',
                'mode': 2,
                'priority': 20,
                'value': '+' + modifier
            }
        ]
    };
    await chris.updateEffect(effect, updates);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/farStep.js


async function farStep_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.token || !workflow.actor) return;
    let queueSetup = queue_queue.setup(workflow.item.uuid, 'farStep', 50);
    if (!queueSetup) return;
    await workflow.actor.sheet.minimize();
    await farStep_teleport(workflow.item, workflow.token, true);
    await workflow.actor.sheet.maximize();
    queue_queue.remove(workflow.item.uuid);
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Far Step - Teleport', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Far Step - Teleport');
    async function effectMacro() {
        await chrisPremades.macros.farStep.end(token, origin);
    }
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 60
        },
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Far Step',
        'description': 'Far Step'
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
async function farStep_teleport(item, token, passive) {
    let interval = token.document.width % 2 === 0 ? 1 : -1;
    let position = await chris.aimCrosshair(token, 60, token.document.texture.src, interval, token.document.width);
    if (position.cancelled) return;
    let animation = chris.getConfiguration(item, 'animation') ?? 'default';
    if (chris.jb2aCheck() != 'patreon') animation === 'simple';
    if (animation === 'simple') {
        await new Sequence()
            .effect()
            .file('jb2a.misty_step.01.blue')
            .atLocation(token)
            .randomRotation()
            .scaleToObject(2)
            .wait(750)
            .animation()
            .on(token)
            .opacity(0.0)
            .waitUntilFinished()
            .play();
        let newCenter = canvas.grid.getSnappedPosition(position.x - token.w / 2, position.y - token.h / 2, 1);
        let targetUpdate = {
            'token': {
                'x': newCenter.x,
                'y': newCenter.y
            }
        };
        let options = {
            'permanent': true,
            'name': 'Far Step Teleport',
            'description': 'Far Step Teleport',
            'updateOpts': {'token': {'animate': false}}
        };
        await warpgate.mutate(token.document, targetUpdate, {}, options);
        await new Sequence()
            .effect()
            .file('jb2a.misty_step.02.blue')
            .atLocation(token)
            .randomRotation()
            .scaleToObject(2)
            .wait(1500)
            .animation()
            .on(token)
            .opacity(1.0)
            .play();
    } else {
        let selected = token.document;
        //Animations by: eskiemoh
        new Sequence()
            .effect()
            .file('jb2a.explosion.07.bluewhite')
            .atLocation(position)
            .scaleIn(0, 500, {'ease': 'easeOutCubic'})
            .fadeOut(1000)
            .scale({'x': selected.width / 4, 'y': selected.height / 4})
            
            .animation()
            .on(selected)
            .opacity(0)
            
            .effect()
            .file('jb2a.energy_strands.range.standard.blue.04')
            .atLocation(selected)
            .stretchTo(position)
            .waitUntilFinished(-2000)
            .playbackRate(1.25)
            
            .effect()
            .file('jb2a.explosion.07.bluewhite')
            .atLocation(position)
            .scale({'x': selected.width / 4, 'y': selected.height / 4})
            .scaleIn(0, 500, {'ease': 'easeOutCubic'})
            .fadeOut(1000)
            
            .animation()
            .on(selected)
            .teleportTo(position)
            .snapToGrid()
            .offset({'x': -1, 'y': -1 })
            .waitUntilFinished()
            
            .animation()
            .on(selected)
            .opacity(1)
            .waitUntilFinished()
            
            .play();

        if (passive) new Sequence()            
            .effect()
            .file('jb2a.token_border.circle.spinning.blue.001')
            .name('Far Step')
            .scaleIn(0, 1000, {'ease': 'easeOutElastic'})
            .persist()
            .scaleOut(0, 500, {'ease': 'easeOutElastic'})
            .atLocation(selected)
            .attachTo(selected, {'bindAlpha': false})
            .scaleToObject(2)
            .play();
    }
    await warpgate.wait(1000);
}
async function farStep_end(token, origin) {
    await warpgate.revert(token.document, 'Far Step');
    let animation = chris.getConfiguration(origin, 'animation') ?? 'default';
    if (chris.jb2aCheck() != 'patreon') animation === 'simple';
    if (animation === 'simple') return;
    await Sequencer.EffectManager.endEffects({'name': 'Far Step'});
}
async function bonus({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.token || !workflow.actor) return;
    let queueSetup = queue_queue.setup(workflow.item.uuid, 'farStepBonus', 50);
    if (!queueSetup) return;
    let feature = chris.getItem(workflow.actor, 'Far Step');
    if (!feature) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await workflow.actor.sheet.minimize();
    await farStep_teleport(workflow.item, workflow.token, false);
    await workflow.actor.sheet.maximize();
    queue_queue.remove(workflow.item.uuid);
}
let farStep = {
    'item': farStep_item,
    'end': farStep_end,
    'teleport': farStep_teleport,
    'bonus': bonus
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/ranger/favoredFoe.js



async function extraDamage(workflow) {
    let damageFormula = workflow.damageRoll._formula;
    let scale = workflow.actor.system.scale?.ranger?.['favored-foe']?.formula;
    if (!scale) return;
    let bonusDamageFormula = scale + '[' + workflow.defaultDamageType + ']';
    if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
    let damageRoll = await new Roll(damageFormula + ' + ' + bonusDamageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
}
async function favoredFoe({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (!constants_constants.attacks.includes(workflow.item.system.actionType)) return;
    let originItem = chris.getItem(workflow.actor, 'Favored Foe');
    if (!originItem) return;
    let turnCheck = chris.perTurnCheck(originItem, 'feature', 'favoredFoe', true, workflow.token.id);
    if (!turnCheck) return;
    let targetToken = workflow.targets.first();
    let effect = targetToken.actor.effects.find(e => e.name === 'Favored Foe' && e.origin === originItem.uuid);
    let queueSetup = await queue_queue.setup(workflow.item.uuidk, 'favoredFoe', 250);
    if (!queueSetup) return;
    if (effect) {
        await extraDamage(workflow);
        if (chris.inCombat()) await chris.setTurnCheck(originItem, 'feature', 'favoredFoe');
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let uses = originItem.system.uses.value;
    if (!uses) return;
    let selection = await chris.dialog(originItem.name, constants_constants.yesNo, 'Use Favored Foe?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(originItem, config, options);
    await originItem.update({'system.uses.value': uses - 1});
    await extraDamage(workflow);
    if (chris.inCombat()) await chris.setTurnCheck(originItem, 'feature', 'favoredFoe');
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/warlock/archfey/feyPresence.js

async function feyPresence({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size === 0) return;
    let selection = await chris.dialog('What condition?', [['Charmed', 'Charmed'], ['Frightened', 'Frightened']]);
    if (!selection) selection = 'Charmed';
    let effectData = {
        'label': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 12
        },
        'changes': [
            {
                'key': 'macro.CE',
                'mode': 0,
                'value': selection,
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    'turnEndSource'
                ],
                'stackable': 'multi',
                'macroRepeat': 'none'
            }
        }
    }
    for (let token of workflow.failedSaves) {
        await chris.createEffect(token.actor, effectData);
    }
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/feySpirit/fuming.js
async function fuming({speaker, actor, token, character, item, args, scope, workflow}) {
    let feature = workflow.actor.items.getName('Fuming');
    if (!feature) return;
    await feature.use();
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/feySpirit/tricksy.js

async function tricksy({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.templateId) return;
    let template = canvas.scene.collections.templates.get(workflow.templateId);
    if (!template) return;
    await template.update({
        'flags': {
            'chris-premades': {
                'spell': {
                    'darkness': true
                }
            },
            'limits': {
                'sight': {
                    'basicSight': {
                        'enabled': true,
                        'range': 0
                    },
                    'ghostlyGaze': {
                        'enabled': true,
                        'range': 0
                    },
                    'lightPerception': {
                        'enabled': true,
                        'range': 0
                    }
                },
                'light': {
                    'enabled': true,
                    'range': 0
                }
            },
            'walledtemplates': {
                'wallRestriction': 'move',
                'wallsBlock': 'recurse'
            }
        }
    });

    let xray = game.settings.get('chris-premades', 'Show Limits Animations');
    new Sequence().effect().file('jb2a.darkness.black').scaleToObject(1.25).aboveLighting().opacity(0.5).xray(xray).persist(true).attachTo(template).play();
    let effect = chris.findEffect(workflow.actor, workflow.item.name + ' Template');
    if (!effect) return;
    if (!chris.inCombat()) return;
    await effect.update({
        'name': effect.name + ' (' + game.combat.round + '-' + game.combat.turn + ')',
        'origin': workflow.actor.uuid,
        'flags': {
            'dae': {
                'specialDuration': [
                    'turnEndSource'
                ]
            }
        }
    });
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/feySpirit/feySpirit.js


let feySpirit = {
    'tricksy': tricksy,
    'fuming': fuming
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/fiendishSpirit/claws.js

async function claws({speaker, actor, token, character, item, args, scope, workflow}) {
    let selection = await chris.dialog('Use teleportation?', [['Yes', true], ['No', false]]);
    if (!selection) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Claws (Yugoloth Only) - Teleport', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Claws (Yugoloth Only) - Teleport');
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    await feature.use();
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/fiendishSpirit/deathThroes.js
async function deathThroes(origin) {
    await origin.use();
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/fiendishSpirit/fiendishSpirit.js


let fiendishSpirit = {
    'deathThroes': deathThroes,
    'claws': claws
}
;// CONCATENATED MODULE: ./scripts/macros/spells/findFamiliar.js


async function findFamiliar_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let folder = chris.getConfiguration(workflow.item, 'folder') ?? 'Familiars';
    if (folder === '') folder = 'Familiars';
    let actors = game.actors.filter(i => i.folder?.name === folder);
    if (actors.length < 1) {
        ui.notifications.warn('No actors found in familiars folder! (Default named "Familiars")');
        return;
    }
    let sourceActor = await chris.selectDocument('Choose Familiar', actors);
    if (!sourceActor) return;
    let creatureType = await chris.dialog('What creature type?', [['Celestial', 'celestial'], ['Fey', 'fey'], ['Fiend', 'fiend']]);
    if (!creatureType) return;
    let name = await chris.getConfiguration(workflow.item, 'name');
    if (!name || name === '') name = sourceActor[0].name + ' Familiar';
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'details': {
                    'type': {
                        'value': creatureType
                    }
                }
            },
            'prototypeToken': {
                'name': name
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition
        }
    };
    let attackData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Find Familiar - Attack', false);
    if (!attackData) return;
    attackData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Find Familiar - Attack');
    let updates2 = {
        'embedded': {
            'Item': {
                [attackData.name]: attackData
            }
        }
    }
    let updates3 = {
        'flags': {
            'chris-premades': {
                'spell': {
                    'findFamiliar': true
                },
                'vae': {
                    'button': attackData.name
                }
            }
        }
    }
    if (chris.getItem(workflow.actor, 'Eldritch Invocations: Investment of the Chain Master')) { 
        let movement = await chris.dialog('Which Movement Type?', [['Flying', 'fly'], ['Swimming', 'swim']]);
        let weaponItems = sourceActor[0].items.filter(i => i.type === 'weapon');
        let saveItems = sourceActor[0].items.filter(i => i.system.save.dc != null);
        for (let i of weaponItems) {
            setProperty(updates, 'embedded.Item.' + i.name + '.system.properties.mgc', true);
        }
        let saveDC = chris.getSpellDC(workflow.item);
        for (let i of saveItems) {
            setProperty(updates, 'embedded.Item.' + i.name + '.system.save.dc', saveDC);
        }
        setProperty(updates, 'actor.system.attributes.movement.' + movement, 40);
        let commandData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Investment of the Chain Master - Command', false);
        if (!commandData) return;
        commandData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Investment of the Chain Master - Command');
        let resistanceData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Investment of the Chain Master - Familiar Resistance', false);
        if (!resistanceData) return;
        resistanceData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Investment of the Chain Master - Familiar Resistance');
        setProperty(updates, 'embedded.Item.Investment of the Chain Master - Familiar Resistance', resistanceData);
        setProperty(updates2, 'embedded.Item.Investment of the Chain Master - Command', commandData);
        setProperty(updates3, 'flags.effectmacro.onTurnStart.script', 'chrisPremades.macros.investmentOfTheChainMaster.turnStart(effect)');
    }
    let options = {
        'permanent': false,
        'name': 'Find Familiar',
        'description': 'Find Familiar'
    };
    await warpgate.mutate(workflow.token.document, updates2, {}, options);
    let defaultAnimations = {
        'celestial': 'celestial',
        'fey': 'nature',
        'fiend': 'fire'
    };
    let animation = chris.getConfiguration(workflow.item, 'animation-' + creatureType) ?? defaultAnimations[creatureType];
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await summons.spawn(sourceActor, updates, 86400, workflow.item, undefined, undefined, 10, workflow.token, animation);
    let effect = chris.findEffect(workflow.actor, workflow.item.name);
    setProperty(updates3, 'flags.effectmacro.onDelete.script', effect.flags.effectmacro?.onDelete?.script + '; await warpgate.revert(token.document, "Find Familiar");');
    await chris.updateEffect(effect, updates3);
}
async function attackApply({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = workflow.actor.effects.find((e) => e?.flags['chris-premades']?.spell?.findFamiliar === true);
    if (!effect) return;
    let familiarId = effect.flags['chris-premades']?.summons?.ids[effect.name][0];
    if (!familiarId) return;
    let familiarToken = canvas.scene.tokens.get(familiarId);
    if (!familiarToken) return;
    if (chris.getDistance(workflow.token, familiarToken) > 100) {
        ui.notifications.info('Familiar Too Far Away!');
        return;
    }
    let effectData = {
        'name': 'Find Familiar Attack',
        'icon': workflow.item.img,
        'origin': effect.origin.uuid,
        'duration': {
            'seconds': 1
        },
        'changes': [
            {
                'key': 'flags.midi-qol.rangeOverride.attack.all',
                'mode': 0,
                'value': 1,
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'priority': 20,
                'value': 'function.chrisPremades.macros.findFamiliar.attackEarly,preambleComplete'
            }
        ],
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    '1Attack'
                ]
            }
        }
    }
    await chris.createEffect(workflow.actor, effectData);
    await chris.createEffect(familiarToken.actor, effectData);
}
async function findFamiliar_attackEarly({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.item.type != 'spell' || workflow.item.system.range.units != 'touch') {
        ui.notifications.info('Invalid Spell Type!');
        return false;
    }
    let effect = workflow.actor.effects.find((e) => e.value?.flags['chris-premades']?.spell?.findFamiliar === true);
    if (!effect) return;
    let familiarId = effect.flags['chris-premades']?.summons?.ids[effect.name][0];
    if (!familiarId) return;
    let familiarToken = canvas.scene.tokens.get(familiarId);
    if (!familiarToken) return;
    await chris.addCondition(familiarToken.actor, 'Reaction');
}
let findFamiliar = {
    'item': findFamiliar_item,
    'attackApply': attackApply,
    'attackEarly': findFamiliar_attackEarly
}
;// CONCATENATED MODULE: ./scripts/macros/spells/findGreaterSteed.js


async function findGreaterSteed_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let folder = chris.getConfiguration(workflow.item, 'folder') ?? 'Greater Steeds';
    if (folder === '') folder = 'Greater Steeds';
    let actors = game.actors.filter(i => i.folder?.name === folder);
    if (actors.length < 1) {
        ui.notifications.warn('No actors found in steeds folder! (Default named "Greater Steeds")');
        return;
    }
    let sourceActor = await chris.selectDocument('Choose Greater Steed', actors);
    if (!sourceActor) return;
    let creatureType = await chris.dialog('What creature type?', [['Celestial', 'celestial'], ['Fey', 'fey'], ['Fiend', 'fiend']]);
    if (!creatureType) return;
    let languageOptions = (Array.from(workflow.actor.system.traits.languages.value).map(i => [i.charAt(0).toUpperCase() + i.slice(1), i]));
    if (!languageOptions) return;
    let languageSelected = new Set(await chris.dialog('What language?', languageOptions));
    if (!languageSelected) return;
    let sourceActorIntelligence = sourceActor[0].system.abilities.int.value;
    if (sourceActorIntelligence < 6) sourceActorIntelligence = 6;
    let name = await chris.getConfiguration(workflow.item, 'name') ?? sourceActor[0].name + ' Greater Steed';
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'abilities': {
                    'int': {
                        'value': sourceActorIntelligence
                    }
                },
                'details': {
                    'type': {
                        'value': creatureType
                    }
                },
                'traits': {
                    'languages': languageSelected
                }
            },
            'prototypeToken': {
                'name': name
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition
        }
    };
    let updates2 = {
        'changes': [
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'priority': 20,
                'value': 'function.chrisPremades.macros.findGreaterSteed.onUse,preambleComplete'
            }
        ],
        'flags': {
            'chris-premades': {
                'spell': {
                    'findGreaterSteed': true
                }
            }
        }
    };
    let defaultAnimations = {
        'celestial': 'celestial',
        'fey': 'nature',
        'fiend': 'fire'
    };
    let animation = chris.getConfiguration(workflow.item, 'animation-' + creatureType) ?? defaultAnimations[creatureType];
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await summons.spawn(sourceActor, updates, 86400, workflow.item, undefined, undefined, 30, workflow.token, animation);
    let effect = chris.findEffect(workflow.actor, workflow.item.name);
    await chris.updateEffect(effect, updates2);
}
async function findGreaterSteed_onUse({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.item.type != 'spell') return;
    if (workflow.targets.size != 1) return;
    if (workflow.targets.first().id != workflow.token.id) return;
    let effect = Array.from(workflow.actor.effects).find((e) => e.flags['chris-premades']?.spell?.findGreaterSteed === true);
    if (!effect) return;
    let steedId = effect.flags['chris-premades']?.summons?.ids[effect.name][0];
    if (!steedId) return;
    let steedToken = canvas.scene.tokens.get(steedId).object;
    if (!steedToken) return;
    if (chris.getDistance(workflow.token, steedToken) > 5) return;
    if (await chris.dialog('Find Greater Steed', [['Yes', false], ['No', true]], 'Target Steed as well? (If mounted)')) return;
    let newTargets = [workflow.token.id, steedId];
    chris.updateTargets(newTargets);
}
let findGreaterSteed = {
    'item': findGreaterSteed_item,
    'onUse': findGreaterSteed_onUse
}
;// CONCATENATED MODULE: ./scripts/macros/spells/findSteed.js


async function findSteed_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let folder = chris.getConfiguration(workflow.item, 'folder') ?? 'Steeds';
    if (folder === '') folder = 'Steeds';
    let actors = game.actors.filter(i => i.folder?.name === folder);
    if (actors.length < 1) {
        ui.notifications.warn('No actors found in steeds folder! (Default named "Steeds")');
        return;
    }
    let sourceActor = await chris.selectDocument('Choose Steed', actors);
    if (!sourceActor) return;
    let creatureType = await chris.dialog('What creature type?', [['Celestial', 'celestial'], ['Fey', 'fey'], ['Fiend', 'fiend']]);
    if (!creatureType) return;
    let languageOptions = (Array.from(workflow.actor.system.traits.languages.value).map(i => [i.charAt(0).toUpperCase() + i.slice(1), i]));
    if (!languageOptions) return;
    let languageSelected = new Set(await chris.dialog('What language?', languageOptions));
    if (!languageSelected) return;
    let sourceActorIntelligence = sourceActor[0].system.abilities.int.value;
    if (sourceActorIntelligence < 6) sourceActorIntelligence = 6;
    let name = await chris.getConfiguration(workflow.item, 'name') ?? sourceActor[0].name + ' Steed';
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'abilities': {
                    'int': {
                        'value': sourceActorIntelligence
                    }
                },
                'details': {
                    'type': {
                        'value': creatureType
                    }
                },
                'traits': {
                    'languages': languageSelected
                }
            },
            'prototypeToken': {
                'name': name
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition
        }
    };
    let updates2 = {
        'changes': [
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'priority': 20,
                'value': 'function.chrisPremades.macros.findSteed.onUse,preambleComplete'
            }
        ],
        'flags': {
            'chris-premades': {
                'spell': {
                    'findSteed': true
                }
            }
        }
    };
    let defaultAnimations = {
        'celestial': 'celestial',
        'fey': 'nature',
        'fiend': 'fire'
    };
    let animation = chris.getConfiguration(workflow.item, 'animation-' + creatureType) ?? defaultAnimations[creatureType];
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await summons.spawn(sourceActor, updates, 86400, workflow.item, undefined, undefined, 30, workflow.token, animation);
    let effect = chris.findEffect(workflow.actor, workflow.item.name);
    await chris.updateEffect(effect, updates2);
}
async function findSteed_onUse({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.item.type != 'spell') return;
    if (workflow.targets.size != 1) return;
    if (workflow.targets.first().id != workflow.token.id) return;
    let effect = Array.from(workflow.actor.effects).find((e) => e.flags['chris-premades']?.spell?.findSteed === true);
    if (!effect) return;
    let steedId = effect.flags['chris-premades']?.summons?.ids[effect.name][0];
    if (!steedId) return;
    let steedToken = canvas.scene.tokens.get(steedId).object;
    if (!steedToken) return;
    if (chris.getDistance(workflow.token, steedToken) > 5) return;
    if (await chris.dialog('Find Steed', [['Yes', false], ['No', true]], 'Target Steed as well? (If mounted)')) return;
    let newTargets = [workflow.token.id, steedId];
    chris.updateTargets(newTargets);
}
let findSteed = {
    'item': findSteed_item,
    'onUse': findSteed_onUse
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/fireElemental/fireForm.js


async function fireForm(workflow, targetToken) {
    if (workflow.hitTargets.size === 0) return;
    if (!(workflow.item.system.actionType === 'mwak' || workflow.item.system.actionType === 'msak')) return;
    let distance = chris.getDistance(workflow.token, targetToken);
    if (distance > 5) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Monster Feature Items', 'Fire Form', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Fire Form');
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': targetToken.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.token.document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature, config, options);
}
async function douseFire({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Fire Form');
    if (!effect) return;
    await chris.removeEffect(effect);
}
async function fireForm_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    let effect = chris.findEffect(targetActor, 'Douse Fire');
    if (effect) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Monster Feature Items', 'Douse Fire', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Douse Fire');
    async function effectMacro () {
        await warpgate.revert(token.document, 'Douse Fire');
    }
    let effectData = {
        'name': 'Douse Fire',
        'icon': featureData.img,
        'duration': {
            'seconds': 604800
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': featureData.name,
        'description': featureData.name
    };
    await warpgate.mutate(targetToken.document, updates, {}, options);
}
async function effectEnd(actor) {
    let effect = chris.findEffect(actor, 'Douse Fire');
    if (!effect) return;
    await chris.removeEffect(effect);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/fireElemental/touch.js

async function touch({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    let effect = chris.findEffect(targetActor, 'Douse Fire');
    if (effect) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Monster Feature Items', 'Douse Fire', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Douse Fire');
    async function effectMacro () {
        await warpgate.revert(token.document, 'Douse Fire');
    }
    let effectData = {
        'name': 'Douse Fire',
        'icon': featureData.img,
        'duration': {
            'seconds': 604800
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
        }
    };
    let effects = {[effectData.name]: effectData};
    let effect2 = chris.findEffect(targetActor, 'Fire Form');
    if (!effect2) {
        let effect2Data = {
            'name': 'Fire Form',
            'icon': 'icons/magic/fire/projectile-embers-orange.webp',
            'changes': [
                {
                    'key': 'flags.midi-qol.OverTime',
                    'mode': 0,
                    'value': 'turn=start,\ndamageRoll=1d10,\ndamageType=fire,\nlabel=Fire Form (Start of Turn)',
                    'priority': 20
                },
                {
                    'key': 'macro.tokenMagic',
                    'mode': 0,
                    'value': 'fire',
                    'priority': 20
                }
            ],
            'duration': {
                'seconds': 604800
            },
            'origin': workflow.item.uuid,
            'flags': {
                'effectmacro': {
                    'onDelete': {
                        'script': 'await chrisPremades.macros.monster.fireElemental.effectEnd(actor);'
                    }
                }
            }
        }
        effects[effect2Data.name] = effect2Data;
    }
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': effects
        }
    };
    let options = {
        'permanent': false,
        'name': featureData.name,
        'description': featureData.name
    };
    await warpgate.mutate(targetToken.document, updates, {}, options);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/fireElemental/fireElemental.js


let fireElemental = {
    'fireForm': fireForm,
    'douseFire': douseFire,
    'fireFormItem': fireForm_item,
    'effectEnd': effectEnd,
    'touch': touch
}
;// CONCATENATED MODULE: ./scripts/macros/spells/fireShield.js



async function fireShield_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.token) return;
    let queueSetup = queue_queue.setup(workflow.item.uuid, 'fireShield', 50);
    if (!queueSetup) return;
    let selection = await chris.dialog(workflow.item.name, [['Warm Shield', 'fire'], ['Cold Shield', 'cold']], 'What kind of shield?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Fire Shield - Dismiss', false);
    if (!featureData) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Fire Shield - Dismiss');
    async function effectMacro() {
        await chrisPremades.macros.fireShield.end(token, origin);
    }
    let resistance = {
        'fire': 'cold',
        'cold': 'fire'
    };
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 600
        },
        'changes': [
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'value': resistance[selection],
                'priority': 20
            },
            {
                'key': 'flags.chris-premades.feature.onHit.fireShield',
                'mode': 5,
                'value': true,
                'priority': 20
            },
            {
                'key': 'ATL.light.dim',
                'mode': 4,
                'value': '20',
                'priority': 20
            },
            {
                'key': 'ATL.light.bright',
                'mode': 4,
                'value': '10',
                'priority': 20
            }
        ],
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'spell': {
                    'fireShield': selection
                },
                'vae': {
                    'button': featureData.name
                }
            },
            'autoanimations': {
                'isEnabled': false,
                'version': 5
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Fire Shield',
        'description': 'Fire Shield'
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
    queue_queue.remove(workflow.item.uuid);
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? chris.jb2aCheck() === 'patreon';
    if (!animation) return;
    await animation(workflow.token, selection, 'Fire Shield');
}
async function animation(token, selection, name) {
    let colors = {
        'fire': 'orange',
        'cold': 'blue'
    };
    let altColors = {
        'fire': 'yellow',
        'cold': 'blue'
    };
    //Animations by: eskiemoh
    new Sequence()
        .effect()
        .file('jb2a.impact.ground_crack.' + colors[selection] + '.01')
        .atLocation(token)
        .belowTokens()
        .scaleToObject(3)

        .effect()
        .file('jb2a.particles.outward.' + colors[selection] + '.01.03')
        .atLocation(token)
        .delay(200)
        .scaleIn(0.5, 250)
        .fadeOut(3000)
        .duration(15000)
        .scaleToObject(2.75)
        .playbackRate(1)
        .zIndex(2)

        .effect()
        .file('jb2a.energy_strands.in.' + altColors[selection] + '.01.2')
        .atLocation(token)
        .delay(200)
        .scaleIn(0.5, 250)
        .duration(2000)
        .belowTokens()
        .scaleToObject(2.75)
        .playbackRate(1)
        .zIndex(1)

        .effect()
        .file('jb2a.token_border.circle.spinning.' + colors[selection] + '.004')
        .atLocation(token)
        .scaleToObject(2.2)
        .playbackRate(1)
        .attachTo(token)
        .persist()
        .name(name)

        .effect()
        .file('jb2a.shield_themed.below.fire.03.' + colors[selection])
        .atLocation(token)
        .delay(1000)
        .persist()
        .fadeIn(500)
        .attachTo(token)
        .fadeOut(200)
        .belowTokens()
        .scaleToObject(1.7)
        .playbackRate(1)
        .name(name)

        .effect()
        .file('jb2a.shield_themed.above.fire.03.' + colors[selection])
        .atLocation(token)
        .persist()
        .fadeIn(3500)
        .attachTo(token)
        .fadeOut(200)
        .scaleToObject(1.7)
        .zIndex(0)
        .playbackRate(1)
        .name(name)

        .play();
}
async function fireShield_end(token, origin) {
    await warpgate.revert(token.document, 'Fire Shield');
    let animation = chris.getConfiguration(origin, 'animation') ?? chris.jb2aCheck() === 'patreon';
    if (!animation) return;
    await Sequencer.EffectManager.endEffects({'name': 'Fire Shield', 'object': token});
}
async function stop({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = workflow.actor.effects.find(i => i.flags['chris-premades']?.spell?.fireShield);
    if (!effect) return;
    await chris.removeEffect(effect);
}
async function fireShield_onHit(workflow, targetToken) {
    if (!workflow.hitTargets.size) return;
    let distance = chris.getDistance(workflow.token, targetToken);
    if (distance > 5) return;
    if (!constants_constants.meleeAttacks.includes(workflow.item.system.actionType)) return;
    let effect = targetToken.actor.effects.find(i => i.flags['chris-premades']?.spell?.fireShield);
    if (!effect) return;
    let type = effect.flags['chris-premades'].spell.fireShield;
    let featureNames = {
        'cold': 'Chill Shield',
        'fire': 'Warm Shield'
    };
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', featureNames[type], false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', featureNames[type]);
    delete featureData._id;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': targetToken.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.token.document.uuid]);
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'fireShield', 50);
    if (!queueSetup) return;
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature, config, options);
    queue_queue.remove(workflow.item.uuid);
}
let fireShield = {
    'item': fireShield_item,
    'end': fireShield_end,
    'stop': stop,
    'onHit': fireShield_onHit,
    'animation': animation
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/fireSnake/heatedBody.js


async function heatedBody(workflow, targetToken) {
    if (workflow.hitTargets.size === 0) return;
    if (!(workflow.item.system.actionType === 'mwak' || workflow.item.system.actionType === 'msak')) return;
    let distance = chris.getDistance(workflow.token, targetToken);
    if (distance > 5) return;
    let targetActor = targetToken.actor;
    let effect = chris.findEffect(targetActor, 'Heated Body');
    if (!effect) return;
    let feature = await fromUuid(effect.origin);
    if (!feature) return;
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.token.document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature, config, options);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/fireSnake/fireSnake.js

let fireSnake = {
    'heatedBody': heatedBody
}
;// CONCATENATED MODULE: ./scripts/macros/spells/fireStorm.js


async function fireStorm({speaker, actor, token, character, item, args, scope, workflow}) {
    let playAnimation = chris.getConfiguration(workflow.item, 'animation') ?? true;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'fireStorm', 50);
    if (!queueSetup) return;
    let templateData = {
        't': 'rect',
        'user': game.user,
        'distance': 14.14,
        'direction': 45,
        'x': 3080,
        'y': 1680,
        'fillColor': game.user.color,
        'flags': {
            'dnd5e': {
                'origin': workflow.item.uuid
            }
        },
        'width': 10,
        'angle': 0
    };
    let templateDoc = new CONFIG.MeasuredTemplate.documentClass(templateData, {'parent': canvas.scene});
    let templates = [];
    await workflow.actor.sheet.minimize();
    ui.notifications.info('Place up to 10 templates. Right click to finish.');
    for (let i = 0; i < 10; i++) {
        let template = new game.dnd5e.canvas.AbilityTemplate(templateDoc);
        try{
            let [finalTemplate] = await template.drawPreview();
            templates.push(finalTemplate);
        } catch {}
        if (templates.length != i + 1) break;
    }
    await workflow.actor.sheet.maximize();
    if (!templates.length) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let targets = new Set();
    for (let i of templates) {
        let position = i.object.ray.project(0.5);
        if (playAnimation) {
            new Sequence()
                .effect()
                .file('jb2a.explosion.01.orange')
                .atLocation(position)
                .scale(2)
                .play();
        }
        let tokens = chris.templateTokens(i);
        if (!tokens.length) continue;
        for (let j of tokens) targets.add(j);
    }
    chris.updateTargets(Array.from(targets));
    async function effectMacro() {
        let templates = effect.flags['chris-premades']?.spell?.fireStorm?.templates;
        if (!templates) return;
        for (let i of templates) {
            let template = await fromUuid(i);
            if (!template) continue;
            await template.delete();
        }
    }
    let effectData = {
        'label': workflow.item.name + ' Templates',
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 1,
        },
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'spell': {
                    'fireStorm': {
                        'templates': templates.map(i => i.uuid)
                    }
                }
            }
        }
    };
    await chris.createEffect(workflow.actor, effectData);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/feats/strikeOfTheGiants/fireStrike.js




async function fireStrike_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (workflow.item.system.actionType != 'mwak') return;
    let originFeature = chris.getItem(workflow.actor, 'Strike of the Giants: Fire Strike');
    if (!originFeature) return;
    if (!originFeature.system.uses.value) return;
    let turnCheck = chris.perTurnCheck(originFeature, 'feat', 'fireStrike', false, workflow.token.id);
    if (!turnCheck) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'fireStrike', 150);
    if (!queueSetup) return;
    let selection = await chris.dialog(originFeature.name, [['Yes', true], ['No', false]], 'Use ' + originFeature.name + '?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await originFeature.update({'system.uses.value': originFeature.system.uses.value - 1});
    if (chris.inCombat()) await originFeature.setFlag('chris-premades', 'feat.fireStrike.turn', game.combat.round + '-' + game.combat.turn);
    let damageFormula = workflow.damageRoll._formula;
    let bonusDamage = '1d10[' + translate.damageType('fire') + ']';
    if (workflow.isCritical) bonusDamage = chris.getCriticalFormula(bonusDamage);
    let damageRoll = await new Roll(damageFormula + ' + ' + bonusDamage).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    await originFeature.displayCard();
    queue_queue.remove(workflow.item.uuid);
}
async function fireStrike_end(origin) {
    await origin.setFlag('chris-premades', 'feat.fireStrike.turn', '');
}
let fireStrike = {
    'damage': fireStrike_damage,
    'end': fireStrike_end
}
;// CONCATENATED MODULE: ./scripts/macros/mechanics/firearm.js


function firearm_setup(enabled) {
    if (enabled) {
        CONFIG.DND5E.weaponIds['firearmCR'] = 'chris-premades.CPR Item Features.rOfrToXtvyjWSD8B';
        CONFIG.DND5E.featureTypes.class.subtypes.trickShot = 'Trick Shot';
        Hooks.on('midi-qol.preItemRoll', firearm_status);
        Hooks.on('midi-qol.preCheckHits', misfire);
        Hooks.on('midi-qol.RollComplete', grit);
        Hooks.on('midi-qol.RollComplete', firearm_critical);
    } else {
        delete CONFIG.DND5E.weaponIds['firearmCR'];
        delete CONFIG.DND5E.featureTypes.class.subtypes.trickShot;
        Hooks.off('midi-qol.preItemRoll', firearm_status);
        Hooks.off('midi-qol.preCheckHits', misfire);
        Hooks.off('midi-qol.RollComplete', grit);
        Hooks.off('midi-qol.RollComplete', firearm_critical);
    }
}
async function reload({speaker, actor, token, character, item, args, scope, workflow}) {
    let ammunition = workflow.actor.items.filter(i => i.system.consumableType === 'ammo' && i.system.quantity);
    if (!ammunition.length) {
        ui.notifications.info('You have no ammunition!');
        return;
    }
    let weapons = workflow.actor.items.filter(i => i.system.baseItem === 'firearmCR' && i.system.uses.value != i.system.uses.max);
    if (!weapons.length) {
        ui.notifications.info('You have no firearms to reload!');
        return;
    }
    let weapon;
    if (weapons.length === 1) {
        weapon = weapons[0];
    } else {
        [weapon] = await chris.selectDocument(workflow.item.name, weapons);
    }
    if (!weapon) return;
    let ammo;
    if (ammunition.length === 1) {
        ammo = ammunition[0];
    } else {
        [ammo] = await chris.selectDocument(workflow.item.name, ammunition);
    }
    if (!ammo) return;
    let usesLeft = ammo.system.quantity;
    let clip = weapon.system.uses.value;
    let clipSize = weapon.system.uses.max;
    let ammoRestored = Math.min(usesLeft, clipSize - clip);
    await weapon.update({'system.uses.value': clip + ammoRestored});
    await ammo.update({'system.quantity': usesLeft - ammoRestored});
}
async function firearm_status(workflow) {
    if (!workflow.item) return;
    let status = chris.getConfiguration(workflow.item, 'status');
    if (!status) return;
    ui.notifications.info('This firearm must be repaired first!');
    return false;
}
async function misfire(workflow) {
    if (!workflow.item) return;
    let baseItem = workflow.item.system.baseItem;
    if (baseItem != 'firearmCR') return;
    let proficient = workflow.item.system.proficient || workflow.item.actor.system.traits.weaponProf.value.has(baseItem);
    let misfireScore = chris.getConfiguration(workflow.item, 'misfire') ?? 1;
    if (!proficient) misfireScore += 1;
    if (workflow.attackRoll.terms[0].total > misfireScore) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'misfire', 50);
    if (!queueSetup) return;
    await ChatMessage.create({
        'speaker': {'alias': name},
        'content': workflow.item.name + ' has misfired!'
    });
    if (workflow.item.id) {
        let updates = {
            'flags.chris-premades.configuration.status': 1,
            'name': workflow.item.name += ' (Damaged)'
        }
        await workflow.item.update(updates);
    }
    queue_queue.remove(workflow.item.uuid);
    let effectData = {
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 1
        },
        'name': 'Misfire',
        'changes': [
            {
                'key': 'flags.midi-qol.fail.all',
                'mode': 0,
                'value': '1',
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    '1Attack'
                ]
            }
        }
    };
    await chris.createEffect(workflow.actor, effectData);
}
async function repair({speaker, actor, token, character, item, args, scope, workflow}) {
    let repairFirearms = workflow.actor.items.filter(i => chris.getConfiguration(i, 'status') === 1);
    if (!repairFirearms.length) {
        ui.notifications.info('You have no firearms to repair!');
        return;
    }
    let weapon;
    if (repairFirearms.length === 1) weapon = repairFirearms[0];
    if (!weapon) weapon = await chris.selectDocument(workflow.item.name, repairFirearms);
    if (!weapon) return;
    let tinker = workflow.actor.items.find(i => i.system.baseItem === 'tinker');
    if (!tinker) {
        ui.notifications.info('You have no Tinker\'s Tools to make the repair with!');
        return;
    }
    let roll = await workflow.actor.rollToolCheck('tinker');
    let misfireDC = 8 + (chris.getConfiguration(weapon, 'misfire') ?? 1);
    let updates;
    if (roll.total >= misfireDC) {
        updates = {
            'flags.chris-premades.configuration.status': 0,
            'name': weapon.name.replace(' (Damaged)', '')
        }
    } else {
        updates = {
            'flags.chris-premades.configuration.status': 2,
            'name': weapon.name.replace(' (Damaged)', ' (Broken)')
        }
    }
    await weapon.update(updates);
}
async function grit(workflow) {
    if (!workflow.item) return;
    if (workflow.hitTargets.size != 1) return;
    let baseItem = workflow.item.system.baseItem;
    if (baseItem != 'firearmCR') return;
    let regain = 0;
    if (workflow.d20AttackRoll === 20 || (chris.getItem(workflow.actor, 'Vicious Intent') && workflow.d20AttackRoll === 19)) {
        regain++;
    }
    if (workflow.damageItem) {
        let oldHP = workflow.damageItem.oldHP;
        let newHP = workflow.damageItem.newHP;
        if (oldHP != 0 && newHP === 0) regain++;
    }
    if (!regain) return;
    let feature = chris.getItem(workflow.actor, 'Adept Marksman');
    if (!feature) return;
    let max = feature.system.uses.max;
    let value = feature.system.uses.value ?? 0;
    if (value === max) return;
    let clamped = Math.clamped(value + regain, 0, max);
    await feature.update({'system.uses.value': clamped});
    ui.notifications.info('Grit regained! (+' + regain + ')');
}
async function firearm_critical(workflow) {
    if (!workflow.item) return;
    let baseItem = workflow.item.system.baseItem;
    if (baseItem != 'firearmCR') return;
    if (!workflow.isCritical || !workflow.damageRoll || workflow.targets.size != 1) return;
    let feature = chris.getItem(workflow.actor, 'Hemorrhaging Critical');
    if (!feature) return;
    let damage = Math.floor(workflow.damageItem.appliedDamage / 2);
    let effectData = {
        'label': feature.name,
        'icon': feature.img,
        'origin': feature.uuid,
        'duration': {
            'seconds': 12
        },
        'changes': [
            {
                'key': 'flags.midi-qol.OverTime',
                'mode': 0,
                'value': 'turn=end,damageRoll=' + damage + ',damageType=' + workflow.defaultDamageType + ',label=Hemorrhaging Critical',
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    'turnEnd'
                ]
            }
        }
    }
    await feature.displayCard();
    await chris.createEffect(workflow.targets.first().actor, effectData);
}
let firearm = {
    'setup': firearm_setup,
    'reload': reload,
    'status': firearm_status,
    'misfire': misfire,
    'repair': repair,
    'grit': grit,
    'critical': firearm_critical
}
;// CONCATENATED MODULE: ./scripts/macros/spells/flameBlade.js


async function flameBlade({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.token) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Flame Blade Scimitar', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Flame Blade Scimitar');
    let featureData2 = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Evoke Flame Blade', false);
    if (!featureData2) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Evoke Flame Blade');
    let damageDice = 3;
    switch (workflow.castData.castLevel) {
        case 4:
        case 5:
            damageDice = 4
            break;
        case 6:
        case 7:
            damageDice = 5
            break;
        case 8:
        case 9:
            damageDice = 6;
            break;
    }
    featureData.system.damage.parts[0][0] = damageDice + 'd6[' + translate.damageType('fire') + ']';
    async function effectMacro () {
        await warpgate.revert(token.document, 'Flame Blade');
    }
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 600
        },
        'origin': workflow.item.uuid,
        'changes': [
            {
                'key': 'ATL.light.dim',
                'mode': 4,
                'value': '20',
                'priority': 20
            },
            {
                'key': 'ATL.light.bright',
                'mode': 4,
                'value': '10',
                'priority': 20
            }
        ],
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData,
                [featureData2.name]: featureData2
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Flame Blade',
        'description': 'Flamde Blade'
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/fly.js

async function animationStart(token, origin) {
    //Animations by: eskiemoh
    let animation = chris.getConfiguration(origin, 'animation') ?? 'default';
    if (animation === 'none' || !chris.aseCheck()) return;
    new Sequence()
	.effect()
	.file('animated-spell-effects-cartoon.air.puff.03')
	.atLocation(token)
	.scaleToObject(1.75)
	.belowTokens()

	.animation()
	.on(token)
	.opacity(0)

	.effect()
	.from(token)
	.name('Fly')
	.atLocation(token)   
	.opacity(1)
	.duration(800)
	.anchor({'x': 0.5, 'y': 0.7})
	.animateProperty('sprite', 'position.y', {'from': 30, 'to': 0, 'duration': 500})
	.loopProperty('sprite', 'position.y', {'from':0 , 'to':-30, 'duration': 2500, 'pingPong': true, 'delay':500})
	.attachTo(token, {'bindAlpha': false})
	.zIndex(2)
	.persist()

	.effect()
	.from(token)
	.name('Fly')
	.atLocation(token)
	.scaleToObject(0.9)
	.duration(1000)
	.opacity(0.5)
	.belowTokens()
	.filter('ColorMatrix', {'brightness': -1 })
	.filter('Blur', {'blurX': 5, 'blurY': 10 })
	.attachTo(token, {'bindAlpha': false})
	.zIndex(1)
	.persist()

	.play();
}
async function fly_animationEnd(token, origin) {
    let animation = chris.getConfiguration(origin, 'animation') ?? 'default';
    if (animation === 'none' || !chris.aseCheck) return;
    await Sequencer.EffectManager.endEffects({'name': 'Fly', 'object': token });
    new Sequence()
        .animation()
        .on(token)
        .opacity(1)

        .play();
}
let fly = {
    'animationStart': animationStart,
    'animationEnd': fly_animationEnd
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/monk/focusedAim.js


async function focusedAim({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1 || workflow.isFumble) return;
    let feature = chris.getItem(workflow.actor, 'Ki Points');
    if (!feature) return;
    let featureUses = feature.system.uses.value;
    if (!featureUses) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'focusedAim', 151);
    if (!queueSetup) return;
    let attackTotal = workflow.attackTotal;
    let target = workflow.targets.first();
    let targetAC = target.actor.system.attributes.ac.value;
    if (targetAC <= attackTotal) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let featureMenu = [['Yes (1 Ki / +2 to hit)', 2]];
    if (featureUses >= 2) featureMenu.push(['Yes (2 Ki / +4 to hit)', 4]);
    if (featureUses >= 3) featureMenu.push(['Yes (3 Ki / +6 to hit)', 6]);
    featureMenu.push(['No', false]);
    let useFeature = await chris.dialog(feature.name, featureMenu, 'Attack roll (' + attackTotal + ') missed.  Use Focused Aim?');
    if (!useFeature) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let updatedRoll = await chris.addToRoll(workflow.attackRoll, useFeature);
    workflow.setAttackRoll(updatedRoll);
    feature.update({'system.uses.value': featureUses - (useFeature / 2)});
    let originItem = chris.getItem(workflow.actor, 'Focused Aim');
    if (originItem) await originItem.use();
    queue_queue.remove(workflow.item.uuid);
}

;// CONCATENATED MODULE: ./scripts/macros/spells/fogCloud.js


async function fogCloud_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let templateData = {
        't': 'circle',
        'user': game.user,
        'distance': workflow.castData.castLevel * 20,
        'direction': 0,
        'fillColor': game.user.color,
        'flags': {
            'dnd5e': {
                'origin': workflow.item.uuid
            },
            'midi-qol': {
                'originUuid': workflow.item.uuid
            },
            'chris-premades': {
                'spell': {
                    'fogCloud': true
                }
            },
            'limits': {
                'sight': {
                    'basicSight': {
                        'enabled': true,
                        'range': 0
                    },
                    'devilsSight': {
                        'enabled': true,
                        'range': 0
                    },
                    'lightPerception': {
                        'enabled': true,
                        'range': 0
                    },
                    'seeAll': {
                        'enabled': true,
                        'range': 0
                    }
                }
            },
            'walledtemplates': {
                'wallRestriction': 'move',
                'wallsBlock': 'recurse',
            }
        },
        'angle': 0
    };
    await workflow.actor.sheet.minimize();
    let template = await chris.placeTemplate(templateData);
    await workflow.actor.sheet.maximize();
    if (!template) return;
    let xray = game.settings.get('chris-premades', 'Show Limits Animations');
    let path = 'jb2a.fog_cloud.01.white';
    if (game.modules.get('jb2a_patreon')?.active) {
        if (isNewerVersion('0.6.1', game.modules.get('jb2a_patreon').version)) path = 'jb2a.fog_cloud.1.white';
    }
    if (game.modules.get('walledtemplates')) {
        new Sequence().effect().file(path).scaleToObject().aboveLighting().opacity(0.5).mask(template).xray(xray).persist(true).attachTo(template).play();
    } else {
        new Sequence().effect().file(path).scaleToObject().aboveLighting().opacity(0.5).xray(xray).persist(true).attachTo(template).play();
    }
    let effectData = {
        'label': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'changes': [
            {
                'key': 'flags.dae.deleteUuid',
                'mode': 5,
                'priority': 20,
                'value': template.uuid
            }
        ],
        'duration': {
            'seconds': chris.itemDuration(workflow.item).seconds
        }
    };
    await chris.createEffect(workflow.actor, effectData);
}
async function hook(workflow) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first().document;
    if (!targetToken) return;
    let sourceToken = workflow.token.document;
    let sourceTemplates = game.modules.get('templatemacro').api.findContainers(sourceToken);
    let sourceInFogCloud = false;
    for (let i = 0; sourceTemplates.length > i; i++) {
        let testTemplate = canvas.scene.collections.templates.get(sourceTemplates[i]);
        if (!testTemplate) continue;
        let fogCloud = testTemplate.flags['chris-premades']?.spell?.fogCloud;
        if (fogCloud) {
            sourceInFogCloud = true;
            break;
        }
    }
    let targetInFogCloud = false;
    let targetTemplates = game.modules.get('templatemacro').api.findContainers(targetToken);
    for (let i = 0; targetTemplates.length > i; i++) {
        let testTemplate = canvas.scene.collections.templates.get(targetTemplates[i]);
        if (!testTemplate) continue;
        let darkness = testTemplate.flags['chris-premades']?.spell?.fogCloud;
        if (darkness) {
            targetInFogCloud = true;
            break;
        }
    }
    if (!sourceInFogCloud && !targetInFogCloud) return;
    let distance = chris.getDistance(sourceToken, targetToken);
    let sourceCanSeeTarget = false;
    let targetCanSeeSource = false;
    let sourceSenses = sourceToken.actor.system.attributes.senses;
    let targetSenses = targetToken.actor.system.attributes.senses;
    if ((sourceSenses.tremorsense >= distance) || (sourceSenses.blindsight >= distance)) sourceCanSeeTarget = true;
    if ((targetSenses.tremorsense >= distance) || (targetSenses.blindsight >= distance)) targetCanSeeSource = true;
    if (sourceCanSeeTarget && targetCanSeeSource) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'fogCloud', 50);
    if (!queueSetup) return;
    if (sourceCanSeeTarget && !targetCanSeeSource) {
        workflow.advantage = true;
        workflow.attackAdvAttribution.add('Fog Cloud: Target Can\'t See Source');
    }
    if (!sourceCanSeeTarget && targetCanSeeSource) {
        workflow.disadvantage = true;
        workflow.flankingAdvantage = false;
        workflow.attackAdvAttribution.add('Fog Cloud: Source Can\'t See Target');
    }
    if (!sourceCanSeeTarget && !targetCanSeeSource) {
        workflow.advantage = true;
        workflow.disadvantage = true;
        workflow.attackAdvAttribution.add('Fog Cloud: Target And Source Can\'t See Eachother');
    }
    queue_queue.remove(workflow.item.uuid);
}
let fogCloud = {
    'item': fogCloud_item,
    'hook': hook
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/warlock/undead/formOfDread.js



async function formOfDread_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (!constants_constants.attacks.includes(workflow.item.system.actionType)) return;
    let feature = chris.getItem(workflow.actor, 'Form of Dread: Fear');
    let feature2 = chris.getItem(workflow.actor, 'Form of Dread');
    if (!feature || !feature2) return;
    let useFeature = chris.perTurnCheck(feature2, 'feature', 'formOfDread', true, workflow.token.id);
    if (!useFeature) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'formOfDread', 450);
    if (!queueSetup) return;
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Attempt to fear target?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    if (chris.inCombat()) await feature2.setFlag('chris-premades', 'feature.formOfDread.turn', game.combat.round + '-' + game.combat.turn);
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature, config, options);
    queue_queue.remove(workflow.item.uuid);
}
async function formOfDread_end(origin) {
    await origin.setFlag('chris-premades', 'feature.formOfDread.turn', '');
}
let formOfDread = {
    'attack': formOfDread_attack,
    'end': formOfDread_end
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/barbarian/beast/formOfTheBeast.js

async function formOfTheBeast({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (workflow.appliedDamage === 0) return;
    if (!chris.perTurnCheck(workflow.item, 'feature', 'formOfTheBeast', true, workflow.token.id)) return;
    let maxHP = workflow.actor.system.attributes.hp.max;
    let currentHP = workflow.actor.system.attributes.hp.value;
    if (Math.ceil(maxHP / 2) <= currentHP) return;
    await chris.applyDamage([workflow.token], workflow.actor.system.attributes.prof, 'healing');
    await chris.setTurnCheck(workflow.item, 'feature', 'formOfTheBeast');
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/fragmentOfKrokulmar/psionicRevitalization.js

async function psionicRevitalization({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let damageRoll = await new Roll('1d6[psychic]').roll({async: true});
    let nearbyTargets = await chris.findNearby(workflow.targets.first(), 10, 'all');
    if (nearbyTargets.length === 0) return;
    await chris.applyWorkflowDamage(workflow.token, damageRoll, 'psychic', nearbyTargets, workflow.item.name, workflow.itemCardId);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/fragmentOfKrokulmar/fragmentOfKrokulmar.js

let fragmentOfKrokulmar = {
    'psionicRevitalization': psionicRevitalization
}
;// CONCATENATED MODULE: ./scripts/macros/spells/frostFingers.js
async function frostFingers({speaker, actor, token, character, item, args, scope, workflow}) {
    let template = await fromUuid(workflow.templateUuid);
    await new Sequence()
        .effect()
            .file('jb2a.cone_of_cold.blue')
            .attachTo(template, {offset: {x: 1.5}, local: true, gridUnits: true})
            .scaleToObject(1)
            .scale({x: 1.25, y: 1.5})
            .playbackRate(.7)
            .belowTokens()
            .waitUntilFinished(-5000)
        .play();
    for (let i of workflow.targets) {
        new Sequence()
            .effect()
                .file('jb2a.markers.snowflake.blue.01')
                .atLocation(i)
                .scaleToObject(1.5)
                .delay(150)
                .fadeIn(500)
                .fadeOut(500)
                .playbackRate(2)
            .play();
    }
    Hooks.once('midi-qol.postCheckSaves', async function() {
        await warpgate.wait(2000);
        for (let i of workflow.failedSaves) {
            new Sequence()
                .effect()
                    .file('jb2a.impact_themed.ice_shard.blue')
                    .atLocation(i)
                    .scaleToObject(1.5)
                    .delay(200)
                    .playbackRate(0.75)
                .play();
        }
        for (let i of workflow.saves) {
            new Sequence()
                .effect()
                    .file('jb2a.energy_field.02.above.blue')
                    .duration(3000)
                    .startTime(1200)
                    .atLocation(i)
                    .scaleToObject(1)
                    .playbackRate(2)
                .play();
        }
    })
}
;// CONCATENATED MODULE: ./scripts/macros/feats/strikeOfTheGiants/frostStrike.js




async function frostStrike_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (workflow.item.system.actionType != 'mwak') return;
    let originFeature = chris.getItem(workflow.actor, 'Strike of the Giants: Frost Strike');
    if (!originFeature) return;
    if (!originFeature.system.uses.value) return;
    let turnCheck = chris.perTurnCheck(originFeature, 'feat', 'frostStrike', false, workflow.token.id);
    if (!turnCheck) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'frostStrike', 150);
    if (!queueSetup) return;
    let selection = await chris.dialog(originFeature.name, [['Yes', true], ['No', false]], 'Use ' + originFeature.name + '?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await originFeature.update({'system.uses.value': originFeature.system.uses.value - 1});
    if (chris.inCombat()) await originFeature.setFlag('chris-premades', 'feat.frostStrike.turn', game.combat.round + '-' + game.combat.turn);
    let damageFormula = workflow.damageRoll._formula;
    let bonusDamage = '1d6[' + translate.damageType('cold') + ']';
    if (workflow.isCritical) bonusDamage = chris.getCriticalFormula(bonusDamage);
    let damageRoll = await new Roll(damageFormula + ' + ' + bonusDamage).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    let saveDC = Math.max(workflow.actor.system.abilities.con.dc, workflow.actor.system.abilities.str.dc);
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Feat Features', 'Strike of the Giants: Frost Strike', false);
    if (!featureData) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Strike of the Giants: Frost Strike');
    featureData.system.save.dc = saveDC;
    delete featureData._id;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    feature.prepareData();
    feature.prepareFinalAttributes();
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.hitTargets.first().document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature, config, options);
    queue_queue.remove(workflow.item.uuid);
}
async function frostStrike_end(origin) {
    await origin.setFlag('chris-premades', 'feat.frostStrike.turn', '');
}
let frostStrike = {
    'damage': frostStrike_damage,
    'end': frostStrike_end
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/gallowsSpeaker/sufferingEchoes.js

async function sufferingEchoes({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size === 0) {
        new Sequence().effect().atLocation(workflow.token).stretchTo(workflow.targets.first()).file('jb2a.eldritch_blast.purple.30ft').play();
        return;
    }
    let nearbyTargets = chris.findNearby(workflow.targets.first(), 30, 'ally');
    if (nearbyTargets.length === 0) return;
    let buttons = [
        {
            'label': 'OK',
            'value': true
        }, {
            'label': 'Cancel',
            'value': false
        }
    ];
    if (nearbyTargets.length > 3) {
        let selection = await chris.selectTarget('What additional targets? Max: 3', buttons, nearbyTargets, true, 'multiple');
        if (!selection.buttons) return;
        nearbyTargets = [];
        for (let i of selection.inputs) {
            if (i) nearbyTargets.push(await fromUuid(i));
        }
        if (nearbyTargets.length > 3) {
            ui.notifications.info('Too many targets selected!');
            return;
        }
    }
    let damageRoll = await new Roll('3d8[psychic]').roll({async: true});
    damageRoll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: workflow.item.name
    });
    await chris.applyDamage(nearbyTargets, damageRoll.total, 'psychic');
    new Sequence().effect().atLocation(workflow.token).stretchTo(workflow.targets.first()).file('jb2a.eldritch_blast.purple').play();
    await warpgate.wait(1000);
    for (let i of nearbyTargets) {
        new Sequence().effect().atLocation(workflow.targets.first()).stretchTo(i).file('jb2a.eldritch_blast.purple').play();
    }
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/gallowsSpeaker/gallowsSpeaker.js

let gallowsSpeaker = {
    'sufferingEchoes': sufferingEchoes
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/ranger/swarmKeeper/gatheredSwarm.js

let states = {};
async function loop(token) {
    while (states[token.id].state != 'stopped') {
        let effect = 'jb2a.' + states[token.id].animation + '.loop.01.' + states[token.id].color;
        switch (states[token.id].state) {
            case 'ready':
                await new Sequence()
                    .effect()
                        .atLocation(token)
                        .file(effect)
                        .attachTo(token)
                        .scaleToObject(2)
                        .name('swarm-' + token.id)
                        .fadeIn(100)
                        .fadeOut(100)
                        .waitUntilFinished(-100)
                    .play();
                break;
            case 'attack':
                await new Sequence()
                    .effect()
                        .atLocation(token)
                        .file(effect)
                        .scaleToObject(2)
                        .scaleOut(1.5, 500, {'delay': -500})
                        .fadeIn(100)
                        .fadeOut(100)
                        .moveTowards(states[token.id].target, {'ease': 'easeInOutSine'})
                        .waitUntilFinished(-100)
                    .effect()
                        .atLocation(states[token.id].target)
                        .file('jb2a.' + states[token.id].animation + '.inward.01.' + states[token.id].color)
                        .scaleToObject(2)
                    .effect()
                        .atLocation(states[token.id].target)
                        .file(effect)
                        .scaleToObject(4)
                        .fadeIn(100)
                        .fadeOut(100)
                        .duration(3000)
                        .waitUntilFinished(-100)
                    .effect()
                        .atLocation(states[token.id].target)
                        .file(effect)
                        .scaleToObject(4)
                        .scaleOut(0.375, 500, {'delay': -2000})
                        .fadeIn(100)
                        .fadeOut(100)
                        .moveTowards(token, {'ease': 'easeInOutSine'})
                        .waitUntilFinished(-100)
                    .play();
                states[token.id].state = 'ready';
                break;
        }
    }
}
function gatheredSwarm_start(token, animation, color) {
    setProperty(states, token.id, {'animation': animation, 'color': color, 'state': 'ready', 'target': null});
    loop(token);
}
function gatheredSwarm_stop(token) {
    setProperty(states, token.id, {'animation': states[token.id]?.animation, 'color': states[token.id]?.color, 'state': 'stopped', 'target': null});
}
function gatheredSwarm_attack(token, target) {
    setProperty(states, token.id, {'animation': states[token.id]?.animation, 'color': states[token.id]?.color, 'state': 'attack', 'target': target});
}
let stateMachine = {
    'start': gatheredSwarm_start,
    'stop': gatheredSwarm_stop,
    'attack': gatheredSwarm_attack,
    'loop': loop
}
let gatheredSwarm = {
    'animation': {
        'stateMachine': stateMachine
    }
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/generic/autoGrapple.js

async function autoGrapple({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    await chris.addCondition(workflow.targets.first().actor, 'Grappled', false, workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/generic/regeneration.js
async function regeneration(actor, origin) {
    if (actor.system.attributes.hp.value != 0) await origin.use();
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/generic/swarm.js

async function swarmDamage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let hp = workflow.actor.system.attributes.hp.value;
    let maxhp = workflow.actor.system.attributes.hp.max;
    if (hp > Math.floor(maxhp / 2)) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'swarmDamage', 50);
    if (!queueSetup) return;
    let damageFormula = workflow.damageRoll._formula;
    let diceNum = Number(damageFormula.substring(0,1)) / 2;
    let restOfFormula = damageFormula.substring(1);
    let newFormula = diceNum + restOfFormula;
    let damageRoll = await new Roll(newFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/generic/prone.js

async function prone({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1 || workflow.failedSaves.size != 1) return;
    let targetActor = workflow.targets.first().actor;
    let effect = chris.findEffect(targetActor, 'Prone');
    if (effect) return;
    await chris.addCondition(targetActor, 'Prone', false, workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/generic/parry.js

async function parry({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.actor) return;
    let bonus = chris.getConfiguration(workflow.item, 'acbonus') ?? false;
    console.log(bonus);
    if (!bonus) return;
    let effectData = {
        'label': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 1,
        },
        'changes': [
            {
                'key': 'system.attributes.ac.bonus',
                'mode': 2,
                'value': '+ ' + bonus,
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    '1Reaction'
                ]
            }
        }
    };
    await chris.createEffect(workflow.actor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/generic/generic.js












let generic = {
    'autoGrapple': autoGrapple,
    'swarmDamage': swarmDamage,
    'regeneration': regeneration,
    'stealthCheck': stealthCheck,
    'search': search,
    'grapple': grapple,
    'shove': shove,
    'prone': prone,
    'fall': fall,
    'underwater': underwater,
    'nonLethal': nonLethal,
    'parry': parry
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/ghast/ghast.js

let ghast = {
    'stench': stench
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/gibberingMouther/gibbering.js


async function allTurns(token, origin, range) {
    let targetToken = game.combat.scene.tokens.get(game.combat.current.tokenId);
    if (!targetToken || targetToken?.id === token.id) return;
    let distance = chris.getDistance(token, targetToken);
    if (distance > range) return;
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.uuid]);
    await MidiQOL.completeItemUse(origin, config, options);
}
async function effectCreation(origin) {
    let roll = await new Roll('1d8').roll({async: true});
    roll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: origin.name
    });
}
let gibbering = {
    'allTurns': allTurns,
    'effectCreation': effectCreation
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/gibberingMouther/gibberingMouther.js

let gibberingMouther = {
    'gibbering': gibbering
}
;// CONCATENATED MODULE: ./scripts/macros/feats/giftOfTheChromaticDragon.js

async function chromaticInfusion({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    let targetWeapons = targetToken.actor.items.filter(i => i.type === 'weapon' && i.system.equipped);
    if (targetWeapons.length === 0) return;
    let selection;
    if (targetWeapons.length === 1) selection = targetWeapons[0];
    if (!selection) selection = await chris.selectDocument('Which weapon gets infused?', targetWeapons);
    if (!selection) return;
    let damageType = await chris.dialog(workflow.item.name, [['🧪 Acid', 'acid'], ['❄️ Cold', 'cold'], ['🔥 Fire', 'fire'], ['⚡ Lightning', 'lightning'], ['☠️ Poision', 'poison']], 'Which damage type?');
    if (!damageType) return;
    async function effectMacro() {
        await warpgate.revert(token.document, 'Chromatic Infusion');
    }
    let effectData = {
        'name': 'Chromatic Infusion',
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            }
        }
    };
    let damageParts = selection[0].system.damage.parts;
    damageParts.push(['1d4[' + damageType + ']', damageType]);
    let updates = {
        'embedded': {
            'Item': {
                [selection[0].name]: {
                    'system': {
                        'damage.parts': damageParts,
                    }
                }
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Chromatic Infusion',
        'description': 'Chromatic Infusion'
    };
    await warpgate.mutate(targetToken.document, updates, {}, options);
}
async function reactiveResistance({speaker, actor, token, character, item, args, scope, workflow}) {
    let selection = await chris.dialog(workflow.item.name, [['🧪 Acid', 'acid'], ['❄️ Cold', 'cold'], ['🔥 Fire', 'fire'], ['⚡ Lightning', 'lightning'], ['☠️ Poision', 'poison']], 'What damage type?');
    if (!selection) return;
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 1
        },
        'changes': [
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'value': selection,
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    '1Reaction'
                ],
                'macroRepeat': 'none'
            }
        }
    }
    await chris.createEffect(workflow.actor, effectData);
}
let giftOfTheChromaticDragon = {
    'chromaticInfusion': chromaticInfusion,
    'reactiveResistance': reactiveResistance
}
;// CONCATENATED MODULE: ./scripts/macros/generic/grapple.js
function initiate(skillId, options) {
    return skillId != 'ath' ? false : {'label': 'Attempting to initiate a grapple.', 'type': 'advantage'};
}
function grapple_escape(skillId, options) {
    return !['ath', 'acr'].includes(skillId) ? false : {'label': 'Attempting to escape a grapple.', 'type': 'advantage'};
    
}
let grapple_grapple = {
    'escape': grapple_escape,
    'initiate': initiate
}
;// CONCATENATED MODULE: ./scripts/macros/feats/graspOfAvarice.js



let position = null;
async function graspOfAvarice_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || !workflow.token || !workflow.damageRoll) return;
    if (constants_constants.nonDamageTypes.includes(workflow.defaultDamageType)) return;
    let targetToken = workflow.targets.first();
    if (chris.getDistance(workflow.token, targetToken) > 60) return;
    let feature = chris.getItem(workflow.actor, 'Baleful Scion: Grasp of Avarice');
    if (!feature) return;
    if (feature.uuid === workflow.item.uuid) return;
    if (!feature.system.uses.value) return;
    if (!chris.perTurnCheck(feature, 'feat', 'graspOfAvarice')) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'graspOfAvarice', 250);
    if (!queueSetup) return;
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Use ' + feature.name + '?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await chris.setTurnCheck(feature, 'feat', 'graspOfAvarice');
    await feature.update({'system.uses.value': feature.system.uses.value - 1});
    let featureData = feature.toObject();
    delete featureData._id;
    featureData.system.damage.parts = [];
    let sFeature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    await warpgate.wait(100);
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.document.uuid]);
    await MidiQOL.completeItemUse(sFeature, config, options);
    let oldFormula = workflow.damageRoll._formula;
    let bonusDamageFormula = feature.system.damage.parts[0][0].replace('@prof', workflow.actor.system.attributes.prof);
    if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
    let damageFormula = oldFormula + ' + ' + bonusDamageFormula;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    position = damageRoll.terms.length - 3;
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function damageMany({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size < 2 || !workflow.token || !workflow.damageRoll) return;
    if (constants_constants.nonDamageTypes.includes(workflow.defaultDamageType)) return;
    let feature = chris.getItem(workflow.actor, 'Baleful Scion: Grasp of Avarice');
    if (!feature) return;
    if (!feature.system.uses.value) return;
    if (!chris.perTurnCheck(feature, 'feat', 'graspOfAvarice')) return;
    let targetTokens = Array.from(workflow.targets).filter(t => chris.getDistance(workflow.token, t) <= 60);
    if (!targetTokens.length) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'graspOfAvarice', 250);
    if (!queueSetup) return;
    let selection = await chris.selectTarget('Use ' + feature.name + '?', constants_constants.yesNoButton, targetTokens, true, 'one');
    if (!selection.buttons) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let targetTokenUuid = selection.inputs.find(uuid => uuid);
    if (!targetTokenUuid) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await feature.update({'system.uses.value': feature.system.uses.value - 1});
    await chris.setTurnCheck(feature, 'feat', 'graspOfAvarice');
    let targetToken = await fromUuid(targetTokenUuid);
    let featureData = feature.toObject();
    delete featureData._id;
    featureData.system.damage.parts[0][1] = 'midi-none';
    featureData.system.damage.parts[0][0] = featureData.system.damage.parts[0][0].replace('[necrotic]', '');
    let sFeature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    await warpgate.wait(100);
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.uuid]);
    let sWorkflow = await MidiQOL.completeItemUse(sFeature, config, options);
    chris.addDamageDetailDamage(targetToken, sWorkflow.damageTotal, 'necrotic', workflow);
    queue_queue.remove(workflow.item.uuid);
}
async function graspOfAvarice_end(origin) {
    await chris.setTurnCheck(origin, 'feat', 'graspOfAvarice', true);
}
async function graspOfAvarice_heal({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!position || !workflow.damageRoll || !workflow.targets.size) return;
    let targetToken = workflow.targets.first();
    if (chris.checkTrait(targetToken.actor, 'di', 'necrotic')) {
        position = null;
        return;
    }
    let healing = workflow.damageRoll.terms[position].total + workflow.actor.system.attributes.prof;
    if (chris.checkTrait(targetToken.actor, 'dr', 'necrotic')) healing = Math.floor(healing / 2);
    await chris.applyDamage([workflow.token], healing, 'healing');
    position = null;
}
let graspOfAvarice = {
    'damage': graspOfAvarice_damage,
    'damageMany': damageMany,
    'end': graspOfAvarice_end,
    'heal': graspOfAvarice_heal
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/warlock/invocations/graspOfHadar.js


async function graspOfHadar_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let spellName = workflow.actor.flags['chris-premades']?.feature?.graspOfHadar?.name;
    if (!spellName) spellName = 'Eldritch Blast';
    if (workflow.item.name != spellName || workflow.hitTargets.size != 1) return;
    let targetToken = workflow.targets.first();
    let distance = chris.getDistance(workflow.token, targetToken);
    if (distance <= 5) return;
    let effect = chris.findEffect(workflow.actor, 'Eldritch Invocations: Grasp of Hadar');
    if (!effect) return;
    let originItem = await fromUuid(effect.origin);
    if (!originItem) return;
    if (!chris.perTurnCheck(originItem, 'feature', 'graspOfHadar', true, workflow.token.id)) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'graspOfHadar', 451);
    if (!queueSetup) return;
    let selection = await chris.dialog('Use Grasp of Hadar?', [['Yes', -10], ['No', false]]);
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    if (chris.inCombat()) await originItem.setFlag('chris-premades', 'feature.graspOfHadar.turn', game.combat.round + '-' + game.combat.turn);
    if (distance <= 10) selection = -5;
    let knockBackFactor;
    let ray;
    let newCenter;
    let hitsWall = true;
    while (hitsWall) {
        knockBackFactor = selection / canvas.dimensions.distance;
        ray = new Ray(workflow.token.center, targetToken.center);
        newCenter = ray.project(1 + ((canvas.dimensions.size * knockBackFactor) / ray.distance));
        hitsWall = targetToken.checkCollision(newCenter, {origin: ray.A, type: "move", mode: "any"});
        if (hitsWall) {
            selection -= 5;
            if (selection === 0) {
                ui.notifications.info('Target is unable to be moved!');
                queue_queue.remove(workflow.item.uuid);
                return;
            }
        }
    }
    newCenter = canvas.grid.getSnappedPosition(newCenter.x - targetToken.w / 2, newCenter.y - targetToken.h / 2, 1);
    let targetUpdate = {
        'token': {
            'x': newCenter.x,
            'y': newCenter.y
        }
    };
    let options = {
        'permanent': true,
        'name': workflow.item.name,
        'description': workflow.item.name
    };
    await warpgate.mutate(targetToken.document, targetUpdate, {}, options);
    await originItem.use();
    queue_queue.remove(workflow.item.uuid);
}
async function graspOfHadar_combatEnd(origin) {
    await origin.setFlag('chris-premades', 'feature.graspOfHadar.turn', '');
}
let graspOfHadar = {
    'item': graspOfHadar_item,
    'combatEnd': graspOfHadar_combatEnd
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/warlock/undead/graveTouched.js



async function graveTouched_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (!constants_constants.attacks.includes(workflow.item.system.actionType)) return;
    let feature = chris.getItem(workflow.actor, 'Grave Touched');
    if (!feature) return;
    let useFeature = chris.perTurnCheck(feature, 'feature', 'graveTouched,', true, workflow.token.id);
    if (!useFeature) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'graveTouched', 350);
    if (!queueSetup) return;
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Use ' + feature.name + '?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await feature.use();
    if (chris.inCombat()) await feature.setFlag('chris-premades', 'feature.formOfDread.turn', game.combat.round + '-' + game.combat.turn);
    let oldDamageRoll = workflow.damageRoll;
    let newDamageRoll = '';
    for (let i = 0; oldDamageRoll.terms.length > i; i++) {
        let isDeterministic = oldDamageRoll.terms[i].isDeterministic;
        if (isDeterministic === true) {
            newDamageRoll += oldDamageRoll.terms[i].expression;
        } else {
            newDamageRoll += oldDamageRoll.terms[i].number + 'd' + oldDamageRoll.terms[i].faces + '[necrotic]';
        }
    }
    let damageFormula = newDamageRoll;
    let effect = chris.findEffect(workflow.actor, 'Form of Dread');
    if (effect) {
        let extraDice = '+ 1d' + workflow.damageRoll.dice[0].faces + '[necrotic]';
        if (workflow.isCritical) extraDice = chris.getCriticalFormula(extraDice);
        damageFormula = newDamageRoll + extraDice;
    }
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function graveTouched_end(origin) {
    await origin.setFlag('chris-premades', 'feature.graveTouched.turn', '');
}
let graveTouched = {
    'attack': graveTouched_attack,
    'end': graveTouched_end
}

;// CONCATENATED MODULE: ./scripts/macros/spells/grease.js


async function grease_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let template = canvas.scene.collections.templates.get(workflow.templateId);
    if (!template) return;
    await template.setFlag('chris-premades', 'template', {
        'name': 'grease',
        'castLevel': workflow.castData.castLevel,
        'saveDC': chris.getSpellDC(workflow.item),
        'macroName': 'grease',
        'templateUuid': template.uuid,
        'turn': 'end',
        'ignoreMove': true
    });
    if (workflow.failedSaves.size === 0) return;
    let turn = game.combat.round + '-' + game.combat.turn;
    let updates = {};
    for (let i of Array.from(workflow.targets)) {
        setProperty(updates, 'flags.chris-premades', 'spell.grease.' + i.id + '.turn', turn);
    }
    await template.update(updates);
}
async function grease_trigger(token, trigger) {
    if (chris.checkTrait(token.actor, 'ci', 'prone')) return;
    let template = await fromUuid(trigger.templateUuid);
    if (!template) return;
    if (chris.inCombat()) {
        let turn = game.combat.round + '-' + game.combat.turn;
        let lastTurn = template.flags['chris-premades']?.spell?.grease?.[token.id]?.turn;
        if (turn === lastTurn) return;
        await template.setFlag('chris-premades', 'spell.grease.' + token.id + '.turn', turn);
    }
    let originUuid = template.flags.dnd5e?.origin;
    if (!originUuid) return;
    let originItem = await fromUuid(originUuid);
    if (!originItem) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Grease - Fall', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Grease - Fall');
    featureData.system.save.dc = trigger.saveDC;
    delete featureData._id;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': originItem.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.uuid]);
    await MidiQOL.completeItemUse(feature, config, options);
}
async function enter(template, token) {
    let trigger = template.flags['chris-premades']?.template;
    if (!trigger) return;
    await grease.trigger(token.document, trigger);
}
let grease = {
    'item': grease_item,
    'trigger': grease_trigger,
    'enter': enter
}
;// CONCATENATED MODULE: ./scripts/macros/spells/greenFlameBlade.js



async function greenFlameBlade({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let weapons = workflow.actor.items.filter(i => i.type === 'weapon' && i.system.equipped && i.system.actionType === 'mwak');
    if (!weapons.length) {
        ui.notifications.info('No equipped weapons found!');
        return;
    }
    let selection;
    if (weapons.length === 1) selection = weapons[0];
    if (!selection) [selection] = await chris.selectDocument('Attack with what weapon?', weapons);
    if (!selection) return;
    let level = chris.levelOrCR(workflow.actor);
    let diceNumber = Math.floor((level + 1) / 6);
    let weapon;
    if (level > 4) {
        let weaponData = duplicate(selection.toObject());
        delete weaponData._id;
        weaponData.system.damage.parts.push([diceNumber + 'd8[' + translate.damageType('fire') + ']', 'fire']);
        weaponData.system.properties.mgc = true;
        weapon = new CONFIG.Item.documentClass(weaponData, {'parent': workflow.actor});
        weapon.prepareData();
        weapon.prepareFinalAttributes();
    } else {
        weapon = selection;
    }
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
    await warpgate.wait(100);
    let attackWorkflow = await MidiQOL.completeItemUse(weapon, config, options);
    if (!attackWorkflow) return;
    if (!attackWorkflow.hitTargets.size) return;
    let targets = chris.findNearby(workflow.targets.first(), 5, 'ally', true, false);
    if (!targets.length) return;
    let target;
    if (targets.length === 1) target = targets[0];
    if (!target) {
        let selection = await chris.selectTarget(workflow.item.name, constants_constants.okCancel, targets, true, 'one', false, false, 'Where does the fire leap?');
        if (!selection.buttons) return;
        let targetUUid = selection.inputs.find(i => i);
        if (!targetUUid) return;
        target = await fromUuid(targetUUid);
    }
    if (!target) return;
    let modifier = chris.getSpellMod(workflow.item);
    let damageFormula = level > 4 ? diceNumber + 'd8[' + translate.damageType('fire') + '] + ' + modifier : modifier + '[' + translate.damageType('fire') + ']';
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await chris.applyWorkflowDamage(workflow.token, damageRoll, 'fire', [target], workflow.item.name, attackWorkflow.itemCardId);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/grell/tentacles.js

async function postHit({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let target = workflow.hitTargets.first();
    let effectData = {
        'label': 'Grell Tentacles Grapple',
        'icon': workflow.item.img,
        'duration': {
            'seconds': 86400
        },
        'origin': workflow.item.uuid,
        'changes': [
            {
                'key': 'macro.CE',
                'mode': 0,
                'value': 'Grappled',
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'stackable': [
                    'noneName'
                ]
            }
        }
    };
    if (chris.getSize(target.actor) <= chris.sizeStringValue('medium')) {
        let restrainedData = {
            'key': 'macro.CE',
            'mode': 0,
            'value': 'Restrained',
            'priority': 20
        };
        effectData.changes.push(restrainedData);
    }
    await chris.createEffect(target.actor, effectData);
}
async function preHit({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let target = workflow.targets.first();
    let effect = chris.findEffect(target.actor, 'Grell Tentacles Grapple');
    if (!effect) return;
    let effectData = {
        'label': 'Grell Tentacles Advantage',
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'duration': {
            'seconds': 6
        },
        'changes': [
            {
                'key': 'flags.midi-qol.advantage.attack.mwak',
                'mode': 0,
                'value': '1',
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    '1Attack'
                ]
            }
        }
    }
    await chris.createEffect(workflow.actor, effectData);
}
let tentacles = {
    postHit: postHit,
    preHit: preHit
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/grell/grell.js

let grell = {
    'tentacles': tentacles
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/wizard/schoolOfNecromancy/grimHarvest.js



async function grimHarvest({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.length === 0 || !workflow.damageList) return;
    let doHealing = false;
    for (let i of workflow.damageList) {
        if (i.oldHP != 0 && i.newHP === 0) {
            let targetToken = await fromUuid(i.tokenUuid);
            if (!targetToken) continue;
            let targetRace = chris.raceOrType(targetToken.actor);
            if (targetRace === 'undead' || targetRace === 'construct') continue;
            doHealing = true;
            break;
        }
    }
    if (!doHealing) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'grimHarvest', 450);
    if (!queueSetup) return;
    let spellLevel;
    let spellSchool;
    if (workflow.item.type === 'spell') {
        spellLevel = workflow.castData.castLevel;
        spellSchool = workflow.item.system.school;
    } else if (workflow.item.type === 'feat') {
        spellLevel = workflow.item.flags['chris-premades']?.spell?.castData?.castLevel;
        spellSchool = workflow.item.flags['chris-premades']?.spell?.castData?.school;
    }
    if (!spellSchool || !spellLevel) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let effect = chris.findEffect(workflow.actor, 'Grim Harvest');
    if (!effect) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let originItem = await fromUuid(effect.origin);
    if (!originItem) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let featureData = duplicate(originItem.toObject());
    let healingFormula = spellLevel * 2;
    if (spellSchool === 'nec') healingFormula = spellLevel * 3;
    featureData.system.damage.parts = [
        [
            healingFormula + '[healing]',
            'healing'
        ]
    ];
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.token.document.uuid]);
    await MidiQOL.completeItemUse(feature, config, options);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/items/grovelthrash.js


async function grovelthrash_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let level = workflow.actor.flags['chris-premades']?.item?.grovelthrash?.level;
    if (!level) return;
    if (workflow.hitTargets.size != 1) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'grovelthrash', 50);
    if (!queueSetup) return;
    let selected = await chris.dialog('Activate Grovelthrash?', [['Yes', true], ['No', false]]);
    let damageDiceNum = 0;
    if (selected) {
        damageDiceNum = 2;
    }
    if (level > 0) if (Math.floor(workflow.actor.system.attributes.hp.max / 2) > workflow.actor.system.attributes.hp.value) damageDiceNum += 2;
    if (damageDiceNum === 0) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let damageDice = damageDiceNum + 'd6[bludgeoning]';
    if (workflow.isCritical) damageDice = chris.getCriticalFormula(damageDice);
    let damageFormula = workflow.damageRoll._formula + ' + ' + damageDice;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    if (selected) {
        let selfDamageFormula = '1d6[psychic]';
        let selfDamageRoll = await new Roll(selfDamageFormula).roll({async: true});
        selfDamageRoll.toMessage({
            rollMode: 'roll',
            speaker: {alias: name},
            flavor: workflow.item.name
        });
        await chris.applyDamage([workflow.token], selfDamageRoll.total, 'psychic');
    }
    queue_queue.remove(workflow.item.uuid);
}
async function grovelthrash_equip(actor, origin, level) {
    let charges = origin.flags['chris-premades']?.item?.grovelthrash?.charges?.reaction;
    if (charges === undefined) charges = 1;
    let itemData = await chris.getItemFromCompendium('chris-premades.CPR Item Features', 'Grovelthrash Reaction', false);
    if (!itemData) return;
    itemData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Grovelthrash Reaction');
    itemData.system.uses.value = charges;
    await chris.addTempItem(actor, itemData, origin.id, 'Grovelthrash', false, 0);
    if (level > 0) {
        let earthquakeData = await chris.getItemFromCompendium(game.settings.get('chris-premades', 'Spell Compendium'), 'Earthquake', false);
        if (!earthquakeData) return;
        let eCharges = origin.flags['chris-premades']?.item?.grovelthrash?.charges?.earthquake;
        if (eCharges === undefined) eCharges = 1;
        earthquakeData.system.uses.per = 'day';
        earthquakeData.system.uses.max = 1;
        earthquakeData.system.uses.value = eCharges;
        earthquakeData.system.preparation.mode = 'atwill';
        earthquakeData.system.preparation.prepared = true;
        await chris.addTempItem(actor, earthquakeData, origin.id, 'Grovelthrash', false, 1);
        let meldIntoStoneData = await chris.getItemFromCompendium(game.settings.get('chris-premades', 'Spell Compendium'), 'Meld into Stone', false);
        if (!meldIntoStoneData) return;
        let mCharges = origin.flags['chris-premades']?.item?.grovelthrash?.charges?.meldIntoStone;
        if (mCharges === undefined) mCharges = 1;
        meldIntoStoneData.system.uses.per = 'day';
        meldIntoStoneData.system.uses.max = 1;
        meldIntoStoneData.system.uses.value = mCharges;
        meldIntoStoneData.system.preparation.mode = 'atwill';
        meldIntoStoneData.system.preparation.prepared = true;
        await chris.addTempItem(actor, meldIntoStoneData, origin.id, 'Grovelthrash', false, 2);
        let stoneShapeData = await chris.getItemFromCompendium(game.settings.get('chris-premades', 'Spell Compendium'), 'Stone Shape', false);
        if (!stoneShapeData) return;
        let sCharges = origin.flags['chris-premades']?.item?.grovelthrash?.charges?.stoneShape;
        if (sCharges === undefined) sCharges = 1;
        stoneShapeData.system.uses.per = 'day';
        stoneShapeData.system.uses.max = 1;
        stoneShapeData.system.uses.value = sCharges;
        stoneShapeData.system.preparation.mode = 'atwill';
        stoneShapeData.system.preparation.prepared = true;
        await chris.addTempItem(actor, stoneShapeData, origin.id, 'Grovelthrash', false, 3);
    }
}
async function grovelthrash_unequip(actor, origin, level) {
    let rcharges = 1;
    let tempItem = chris.getTempItem(actor, origin.id, 0);
    if (tempItem) rcharges = tempItem.system.uses.value;
    if (level === 0) await origin.setFlag('chris-premades', 'item.grovelthrash.charges.reaction', rcharges);
    if (level > 0) {
        let eCharges = 1;
        let earthquakeItem = chris.getTempItem(actor, origin.id, 1);
        if (earthquakeItem) eCharges = earthquakeItem.system.uses.value;
        let mCharges = 1;
        let meldIntoStoneItem = chris.getTempItem(actor, origin.id, 2);
        if (meldIntoStoneItem) mCharges = meldIntoStoneItem.system.uses.value;
        let sCharges = 1;
        let stoneShapeItem = chris.getTempItem(actor, origin.id, 3);
        if (stoneShapeItem) sCharges = stoneShapeItem.system.uses.value;
        let charges = {
            'reaction': rcharges,
            'earthquake': eCharges,
            'meldIntoStone': mCharges,
            'stoneShape': sCharges
        };
        await origin.setFlag('chris-premades', 'item.grovelthrash.charges', charges);
    }
    await chris.removeTempItems(actor, origin.id);
}
async function grovelthrash_deleted(actor, effect) {
    if (effect.disabled) return;
    let originArray = effect.origin.split('Item.');
    if (originArray.length != 2) return;
    let originID = originArray[1];
    await chris.removeTempItems(actor, originID);
}
let grovelthrash = {
    'item': grovelthrash_item,
    'equip': grovelthrash_equip,
    'unequip': grovelthrash_unequip,
    'deleted': grovelthrash_deleted
}
;// CONCATENATED MODULE: ./scripts/macros/raceFeatures/grung/grungPoison.js




async function grungPoison({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.item || !workflow.damageRoll || workflow.item?.type != 'weapon' || workflow.hitTargets.size != 1) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'grungPoison', 300);
    if (!queueSetup) return;
    let damageTypes = chris.getRollDamageTypes(workflow.damageRoll);
    if (!damageTypes.has('piercing')) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let feature = chris.getItem(workflow.actor, 'Grung Poison');
    if (!feature) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let prompt = chris.getConfiguration(feature, 'prompt') ?? false;
    let selection = prompt ? await chris.dialog(feature.name, constants_constants.yesNo, 'Use ' + feature.name + '?') : true;
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
    await warpgate.wait(100);
    let featureWorkflow = await MidiQOL.completeItemUse(feature, config, options);
    if (featureWorkflow.failedSaves.size != 1) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let damageFormula = workflow.damageRoll._formula + ' + 2d4[' + translate.damageType('poison') + ']';
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/utility/movement.js



let triggers = {};
async function loadTriggers() {
    triggers = game.settings.get('chris-premades', 'Movement Triggers');
    if (game.user.isGM) {
        for (let name of Object.values(triggers)) {
            for (let spell of name) {
                let effect = await fromUuid(spell.effectUuid)
                if (!effect) {
                    console.log('Chris Premades | Removing stale movement trigger for ' + spell.macro);
                    await removeTrigger(spell.macro, spell.sourceTokenID);
                }
            }
        }
    }
}
async function updateMoveTriggers(updatedTriggers) {
    triggers = updatedTriggers;
}
async function updateGMTriggers(updatedTriggers) {
    await game.settings.set('chris-premades', 'Movement Triggers', updatedTriggers);
}
async function tokenMovedEarly(token, updates, options, userId) {
    if (token.parent.id != canvas.scene.id) return;
    if (!updates.x && !updates.y && !updates.elevation) return;
    setProperty(options, 'chris-premades.coords.previous.x', token.x);
    setProperty(options, 'chris-premades.coords.previous.y', token.y);
    setProperty(options, 'chris-premades.coords.previous.elevation', token.elevation);
}
async function tokenMoved(token, changes, options, userId) {
    if (token.parent.id != canvas.scene.id) return;
    if (!chris.isLastGM()) return;
    if (!changes.x && !changes.y && !changes.elevation) return;
    await token.object._animation;
    for (let name of Object.values(triggers)) {
        let validSources = [];
        for (let spell of name) {
            let sourceToken = canvas.tokens.get(spell.sourceTokenID);
            if (!sourceToken) continue;
            if (spell.ignoreSelf && sourceToken.id == token.id) continue;
            if (spell.nonAllies && (token.disposition === sourceToken.document.disposition || token.disposition === 0)) continue;
            let distance = chris.getDistance(token.object, sourceToken);
            if (distance > spell.range) continue;
            if (spell.offTurnMoveSpecial && chris.inCombat()) {
                if (game.combat.current.tokenId != token.id) {
                    let oldDistance = chris.getCoordDistance(sourceToken, {
                        'width': token.width,
                        'height': token.height,
                        'x': options['chris-premades'].coords.previous.x,
                        'y': options['chris-premades'].coords.previous.y,
                        'elevation': options['chris-premades'].coords.previous.elevation
                    });
                    if (oldDistance <= distance) continue;
                }
            }
            validSources.push(spell);
        }
        let maxLevel = Math.max(...validSources.map(spell => spell.castLevel));
        let selectedSpell = validSources.find(spell => spell.castLevel === maxLevel);
        if (selectedSpell) macros.onMove(selectedSpell.macro, token, selectedSpell.castLevel, selectedSpell.spellDC, selectedSpell.damage, selectedSpell.damageType, selectedSpell.sourceTokenID, 'move');
    }
}
function combatUpdate(combat, changes, context) {
    if (!chris.isLastGM()) return;
    let currentTurn = combat.current.turn;
    let previousTurn = context.effectmacro?.previousTR?.T;
    let currentRound = combat.current.round;
    let previousRound = context.effectmacro?.previousTR?.R;
    if (!changes.turn && !changes.round) return;
    if (!combat.started || !combat.isActive) return;
    if (currentRound < previousRound || (currentTurn < previousTurn && currentTurn === previousRound)) return;
    let token = game.combat.scene.tokens.get(combat.current.tokenId);
    let lastToken = game.combat.scene.tokens.get(combat.previous.tokenId);
    if (token) {
        for (let name of Object.values(triggers)) {
            let validSources = [];
            for (let spell of name) {
                if (spell.turn != 'start') continue;
                let sourceToken = game.combat.scene.tokens.get(spell.sourceTokenID);
                if (!sourceToken) continue;
                if (spell.ignoreSelf && sourceToken.id == token.id) continue;
                if (spell.nonAllies && (token.disposition === sourceToken.disposition || token.disposition === 0)) continue;
                let distance = chris.getDistance(token, sourceToken);
                if (distance > spell.range) continue;
                validSources.push(spell);
            }
            let maxLevel = Math.max(...validSources.map(spell => spell.castLevel));
            let selectedSpell = validSources.find(spell => spell.castLevel === maxLevel);
            if (selectedSpell) macros.onMove(selectedSpell.macro, token, selectedSpell.castLevel, selectedSpell.spellDC, selectedSpell.damage, selectedSpell.damageType, selectedSpell.sourceTokenID, 'start');
        }
    }
    if (lastToken) {
        for (let name of Object.values(triggers)) {
            let validSources = [];
            for (let spell of name) {
                if (spell.turn != 'end') continue;
                let sourceToken = game.combat.scene.tokens.get(spell.sourceTokenID);
                if (!sourceToken) continue;
                if (spell.ignoreSelf && sourceToken.id == lastToken.id) continue;
                if (spell.nonAllies && (lastToken.disposition === sourceToken.disposition || lastToken.disposition === 0)) continue;
                let distance = chris.getDistance(lastToken, sourceToken);
                if (distance > spell.range) continue;
                validSources.push(spell);
            }
            let maxLevel = Math.max(...validSources.map(spell => spell.castLevel));
            let selectedSpell = validSources.find(spell => spell.castLevel === maxLevel);
            if (selectedSpell) macros.onMove(selectedSpell.macro, lastToken, selectedSpell.castLevel, selectedSpell.spellDC, selectedSpell.damage, selectedSpell.damageType, selectedSpell.sourceTokenID, 'end');
        }
    }
}
async function addTrigger(name, castLevel, spellDC, damage, damageType, sourceTokenID, range, ignoreSelf, nonAllies, turn, effectUuid, offTurnMoveSpecial) {
    let spell = {
        'castLevel': castLevel,
        'spellDC': spellDC,
        'damage': damage,
        'damageType': damageType,
        'sourceTokenID': sourceTokenID,
        'range': range,
        'ignoreSelf': ignoreSelf,
        'nonAllies': nonAllies,
        'turn': turn,
        'macro': name,
        'effectUuid': effectUuid,
        'offTurnMoveSpecial': offTurnMoveSpecial
    }
    if (!triggers[name]) triggers[name] = [];
    triggers[name].push(spell);
    await socket.executeForEveryone('updateMoveTriggers', triggers);
    await socket.executeAsGM('updateGMTriggers', triggers);
}
async function removeTrigger(name, sourceTokenID) {
    if (!triggers[name]) return;
    triggers[name] = triggers[name].filter(spell => spell.sourceTokenID != sourceTokenID);
    if (triggers[name].length === 0) delete(triggers[name]);
    await socket.executeForEveryone('updateMoveTriggers', triggers);
    await socket.executeAsGM('updateGMTriggers', triggers);
}
function movement_status() {
    return triggers;
}
async function movement_purge() {
    await socket.executeForEveryone('updateMoveTriggers', {});
    await socket.executeAsGM('updateGMTriggers', {});
}
let tokenMove = {
    'add': addTrigger,
    'remove': removeTrigger,
    'status': movement_status,
    'purge': movement_purge
}
;// CONCATENATED MODULE: ./scripts/macros/spells/guardianOfFaith.js




async function guardianOfFaith_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let sourceActor = game.actors.getName('CPR - Guardian of Faith');
    if (!sourceActor) return;
    async function effectMacro() {
        await chrisPremades.macros.guardianOfFaith.remove(token, origin);
    }
    let spellDC = chris.getSpellDC(workflow.item);
    let effectData = {
        'name': 'Guardian of Faith',
        'icon': workflow.item.img,
        'duration': {
            'seconds': 28800
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': 'Dismiss Summon'
                }
            }
        }
    };
    let name = chris.getConfiguration(workflow.item, 'name') ?? 'Guardian of Faith';
    if (name === '') name = 'Guardian of Faith';
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Guardian of Faith - Damage', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Guardian of Faith - Damage');
    featureData.system.save.dc = spellDC;
    let updates = {
        'actor': {
            'name': name,
            'prototypeToken': {
                'name': name
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition
        },
        'embedded': {
            'ActiveEffect': {
                [effectData.name]: effectData
            },
            'Item': {
                [featureData.name]: featureData
            }
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar');
    if (avatarImg) updates.actor.img = avatarImg;
    let tokenImg = chris.getConfiguration(workflow.item, 'token');
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? 'celestial';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    let spawnedTokens = await chris.spawn(sourceActor, updates, {}, workflow.token, 30, animation);
    if (!spawnedTokens) return;
    let spawnedToken = game.canvas.scene.tokens.get(spawnedTokens[0]);
    if (!spawnedToken) return;
    let targetEffect = chris.findEffect(spawnedToken.actor, 'Guardian of Faith');
    if (!targetEffect) return;
    let casterEffectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 28800
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': 'let effect = await fromUuid("' + targetEffect.uuid + '"); if (effect) await chrisPremades.helpers.removeEffect(effect); await warpgate.revert(token.document, "Guardian of Faith");'
                }
            }
        }
    };
    await chris.createEffect(workflow.actor, casterEffectData);
    await tokenMove.add('guardianOfFaith', workflow.castData.castLevel, spellDC, null, null, spawnedToken.id, 10, true, true, null, targetEffect.uuid);
    let color = chris.getConfiguration(workflow.item, 'color') ?? 'yellow';
    new Sequence().effect().file('jb2a.bless.400px.loop.' + color).size(spawnedToken.width + 6, {'gridUnits': true}).attachTo(spawnedToken).persist().name('GuardianOfFaith-' + workflow.token.id).fadeIn(300).fadeOut(300).play();
}
async function guardianOfFaith_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    let appliedDamage = workflow.damageList[0].appliedDamage;
    if (!appliedDamage) return;
    await workflow.item.update({'system.uses.value': workflow.item.system.uses.value - appliedDamage});
    if (workflow.item.system.uses.value > 0) return;
    let effect = chris.findEffect(workflow.actor, 'Guardian of Faith');
    if (!effect) return;
    await chris.removeEffect(effect);
}
async function guardianOfFaith_remove(token, origin) {
    let originActor = origin.actor;
    let castEffect = chrisPremades.helpers.findEffect(originActor, origin.name);
    if (castEffect) await chrisPremades.helpers.removeEffect(castEffect);
    await tokenMove.remove('guardianOfFaith', token.id);
    Sequencer.EffectManager.endEffects({ 'name': 'GuardianOfFaith-' + token.id, 'object': token});
    await warpgate.dismiss(token.id);
}
async function guardianOfFaith_moved(token, castLevel, spellDC, damage, damageType, sourceTokenID) {
    let doDamage = false;
    if (!chris.inCombat()) {
        doDamage = true;
    } else {
        let combatant = game.combat.combatants.get(game.combat.current.combatantId);
        let lastTriggerTurn = combatant.flags?.['chris-premades']?.spell?.guardianOfFaith?.[sourceTokenID]?.lastTriggerTurn;
        let currentTurn = game.combat.current.round + '-' + game.combat.current.turn;
        if (!lastTriggerTurn || lastTriggerTurn != currentTurn) {
            doDamage = true;
            await combatant.setFlag('chris-premades', 'spell.guardianOfFaith.' + sourceTokenID + '.lastTriggerTurn', currentTurn);
        }
    }
    if (!doDamage) return;
    let attacker = canvas.scene.tokens.get(sourceTokenID);
    if (!attacker) return;
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.uuid]);
    let feature = attacker.actor.items.getName('Guardian of Faith - Damage');
    if (!feature) return;
    await MidiQOL.completeItemUse(feature, config, options);
}
let guardianOfFaith = {
    'item': guardianOfFaith_item,
    'attack': guardianOfFaith_attack,
    'remove': guardianOfFaith_remove,
    'moved': guardianOfFaith_moved
}
;// CONCATENATED MODULE: ./scripts/macros/spells/guardianOfNature.js

async function guardianOfNature({speaker, actor, token, character, item, args, scope, workflow}) {
    let selection = await chris.dialog(workflow.item.name, [['🐺 Primal Beast', 'beast'], ['🌳 Great Tree', 'tree']], 'What form do you assume?');
    if (!selection) return;
    let effectData;
    if (selection === 'beast') {
        effectData = {
            'label': workflow.item.name,
            'icon': workflow.item.img,
            'origin': workflow.item.uuid,
            'duration': {
                'seconds': 60
            },
            'changes': [
                {
                    'key': 'system.attributes.movement.walk',
                    'mode': 2,
                    'value': '+10',
                    'priority': 20
                },
                {
                    'key': 'system.attributes.senses.darkvision',
                    'mode': 4,
                    'value': '120',
                    'priority': 20
                },
                {
                    'key': 'ATL.dimSight',
                    'mode': 4,
                    'value': '120',
                    'priority': 20
                },
                {
                    'key': 'flags.midi-qol.advantage.attack.str',
                    'mode': 0,
                    'value': '1',
                    'priority': 20
                },
                {
                    'key': 'system.bonuses.mwak.damage',
                    'mode': 2,
                    'value': '+1d6[force]',
                    'priority': 20
                }
            ]
        };
    } else {
        effectData = {
            'label': workflow.item.name,
            'icon': workflow.item.img,
            'origin': workflow.item.uuid,
            'duration': {
                'seconds': 60
            },
            'changes': [
                {
                    'key': 'flags.midi-qol.advantage.ability.save.con',
                    'mode': 0,
                    'value': '1',
                    'priority': 20
                },
                {
                    'key': 'flags.midi-qol.advantage.attack.dex',
                    'mode': 0,
                    'value': '1',
                    'priority': 20
                },
                {
                    'key': 'flags.midi-qol.advantage.attack.wis',
                    'mode': 0,
                    'value': '1',
                    'priority': 20
                }
            ]
        };
        if (workflow.token) await chris.applyDamage(workflow.token, 10, 'temphp');
    }
    await chris.createEffect(workflow.actor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/hailOfThorns.js


async function hailOfThorns({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (workflow.item?.system?.actionType != 'rwak') return;
    let effect = chris.findEffect(workflow.actor, 'Hail of Thorns');
    if (!effect) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Hail of Thorns - Burst', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Hail of Thorns - Burst');
    let damageDice = Math.min(effect.flags['midi-qol'].castData.castLevel, 6);
    featureData.system.damage.parts = [
        [
            damageDice + 'd10[piercing]',
            'piercing'
        ]
    ];
    let originItem = await fromUuid(effect.origin);
    if (!originItem) return;
    featureData.system.save.dc = chris.getSpellDC(originItem);
    setProperty(featureData, 'chris-premades.spell.castData.school', originItem.system.school);
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let targetToken = workflow.targets.first();
    let targetUuids = await chris.findNearby(targetToken, 5).concat(targetToken).map(t => t.document.uuid);
    let [config, options] = constants_constants.syntheticItemWorkflowOptions(targetUuids);
    await MidiQOL.completeItemUse(feature, config, options);
    await chris.removeCondition(workflow.actor, 'Concentrating');
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/cleric/harnessDivinePower.js

async function harnessDivinePower({speaker, actor, token, character, item, args, scope, workflow}) {
    let maxLevel = Math.ceil(workflow.actor.system.attributes.prof /2);
    let validLevels = [];
    for (let i = 1; i <= maxLevel; i++) {
        let key2 = 'spell' + i;
        let key = 'system.spells.' + key2 + '.value';
        if ((workflow.actor.system.spells[key2].value < workflow.actor.system.spells[key2].max) && workflow.actor.system.spells[key2].max > 0) validLevels.push({'level': i, 'key': key});
    }
    let pact = workflow.actor.system.spells.pact;
    if (pact.max > 0 && pact.level <= maxLevel && pact.value < pact.max) validLevels.push({'level': 'p', 'key': 'system.spells.pact.value'});
    if (!validLevels.length) {
        ui.notifications.info('You have no spell slots to regain!');
        return;
    }
    let options = validLevels.map(i => [(i.level != 'p' ? chris.nth(i.level) + ' Level' : 'Pact Slot'), i.key]);
    let selection = options.length > 1 ? await chris.dialog(workflow.item.name, options, 'Regain what spell slot?') : options[0][1];
    if (!selection) return;
    let value = getProperty(workflow.actor, selection);
    if (isNaN(value)) return;
    workflow.actor.update({[selection]: value + 1});
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/warlock/celestial/healingLight.js


async function healingLight({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let queueSetup = await queue_queue.setup(workflow.uuid, 'healingLight', 50);
    if (!queueSetup) return;
    let healingLightFeatureUses = workflow.item.system.uses.value + 1;
    let healingLightMenuUses = Math.min(Math.max(1, workflow.actor.system.abilities.cha.mod), healingLightFeatureUses);
    let lightMenu = [];
    for (let i = healingLightMenuUses; i > 0; i--) {
        let diceString = i + 'd6';
        lightMenu.push([diceString, i]);
    }
    let selection = await chris.dialog('How many dice do you want to use?', lightMenu)
    await workflow.item.update({
        'system.uses.value': healingLightFeatureUses - selection
     });
     let diceRoll = await new Roll(selection + 'd6[healing]').roll({async: true});
     await workflow.setDamageRoll(diceRoll);
     queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/healingSpirit.js


async function healingSpirit_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let sourceActor = game.actors.getName('CPR - Healing Spirit');
    if (!sourceActor) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Healing Spirit - Heal', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Healing Spirit - Heal');
    featureData.system.damage.parts[0][0] = (workflow.castData.castLevel - 1) + 'd6[healing]';
    let uses = Math.max(2, chris.getSpellMod(workflow.item) + 1);
    featureData.system.uses.max = uses;
    featureData.system.uses.value = uses;
    setProperty(featureData, 'flags.chris-premades.spell.healingSpirit.name', workflow.item.name);
    async function effectMacro() {
        let originActor = origin.actor;
        await warpgate.dismiss(token.id);
        let castEffect = chrisPremades.helpers.findEffect(originActor, origin.name);
        if (castEffect) await chrisPremades.helpers.removeEffect(castEffect);
    }
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    let updates = {
        'actor': {
            'name': workflow.item.name,
            'prototypeToken': {
                'name': workflow.item.name
            }
        },
        'token': {
            'name': workflow.item.name
        },
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar');
    if (avatarImg) updates.actor.img = avatarImg;
    let tokenImg = chris.getConfiguration(workflow.item, 'token');
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    let options = {
        'controllingActor': workflow.token.actor
    };
    let tokenDocument = await sourceActor.getTokenDocument();
    let spawnedTokens = await warpgate.spawn(tokenDocument, updates, {}, options);
    if (!spawnedTokens) return;
    let spawnedToken = game.canvas.scene.tokens.get(spawnedTokens[0]);
    if (!spawnedToken) return;
    let targetEffect = chris.findEffect(spawnedToken.actor, workflow.item.name);
    if (!targetEffect) return;
    let casterEffectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': 'let effect = await fromUuid("' + targetEffect.uuid + '"); if (effect) await chrisPremades.helpers.removeEffect(effect); await warpgate.revert(token.document, "Healing Spirit");'
                }
            },
            'chris-premades': {
                'vae': {
                    'button': 'Healing Spirit - Move'
                }
            }
        }
    };
    let moveFeatureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Healing Spirit - Move', false);
    if (!moveFeatureData) return;
    moveFeatureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Healing Spirit - Move');
    let updates2 = {
        'embedded': {
            'Item': {
                [moveFeatureData.name]: moveFeatureData
            },
            'ActiveEffect': {
                [casterEffectData.name]: casterEffectData
            }
        }
    };
    let options2 = {
        'permanent': false,
        'name': 'Healing Spirit',
        'description': 'Healing Spirit'
    };
    await warpgate.mutate(workflow.token.document, updates2, {}, options2);
    let command = 'await chrisPremades.macros.healingSpirit.template(template, token);';
    let templateData = {
        'angle': 0,
        'direction': 45,
        'distance': 7.071,
        'x': spawnedToken.x,
        'y': spawnedToken.y,
        't': 'rect',
        'user': game.user,
        'fillColor': game.user.color,
        'flags': {
            'templatemacro': {
                'whenEntered': {
                    'asGM': false,
                    'command': command
                },
                'whenThrough': {
                    'asGM': false,
                    'command': command
                },
                'whenTurnStart': {
                    'asGM': false,
                    'command': command
                }
            },
            'dnd5e': {
                'origin': workflow.item.uuid
            },
            'midi-qol': {
                'originUuid': workflow.item.uuid
            },
            'chris-premades': {
                'spell': {
                    'healingSpirit': {
                        'origin': spawnedToken.uuid,
                        'touchedTokens': {}
                    }
                }
            }
        }
    };
    let template = await chris.createTemplate(templateData);
    await tokenAttacher.attachElementsToToken([template], spawnedToken.object, false);
}
async function template(template, token) {
    let sourceToken = await fromUuid(template.flags['chris-premades'].spell.healingSpirit.origin);
    if (!sourceToken) return;
    let sourceDisposition = sourceToken.disposition;
    if (token.document.disposition != sourceDisposition) return;
    let touchedTokens = template.flags['chris-premades'].spell.healingSpirit.touchedTokens;
    if (chris.inCombat()) {
        let tokenTurn = touchedTokens[token.id];
        let currentTurn = game.combat.round + '-' + game.combat.turn;
        if (tokenTurn === currentTurn) return;
    }
    let selection = await chris.dialog('Healing Spirit: Apply healing?', [['Yes', true], ['No', false]]);
    if (!selection) return;
    let feature = sourceToken.actor.items.getName('Healing Spirit - Heal');
    if (!feature) return;
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.document.uuid]);
    await MidiQOL.completeItemUse(feature, config, options);
    if (chris.inCombat()) {
        touchedTokens[token.id] = game.combat.round + '-' + game.combat.turn;
        await template.setFlag('chris-premades', 'spell.healingSpirit.touchedTokens', touchedTokens);
    }
}
async function healingSpirit_healing({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.item.system.uses.value != 0) return;
    let effectName = workflow.item.flags['chris-premades']?.spell?.healingSpirit?.name;
    if (!effectName) return;
    let effect = chris.findEffect(workflow.actor, effectName);
    if (!effect) return;
    await chris.removeEffect(effect);
}
let healingSpirit = {
    'item': healingSpirit_item,
    'template': template,
    'healing': healingSpirit_healing
};
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/sorcerer/stormSorcery/heartOfTheStorm.js


async function heartOfTheStorm_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size === 0 || workflow.item.type != 'spell' || workflow.item.system.level === 0) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'heartOfTheStorm', 250);
    if (!queueSetup) return;
    let damageTypes = chris.getRollDamageTypes(workflow.damageRoll);
    if (!(damageTypes.has('lightning') || damageTypes.has('thunder'))) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let effect = chris.findEffect(workflow.actor, 'Heart of the Storm');
    if (!effect) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let originItem = await fromUuid(effect.origin);
    await originItem.use();
    queue_queue.remove(workflow.item.uuid);
}
async function heartOfTheStorm_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size === 0) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'heartOfTheStormItem', 50);
    if (!queueSetup) return;
    let selection = await chris.dialog('What damage type?', [['Lightning', 'lightning'], ['Thunder', 'thunder']]);
    if (!selection) selection = 'lightning';
    let damageFormula = workflow.damageRoll._formula;
    damageFormula += '[' + selection + ']';
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
let heartOfTheStorm = {
    'attack': heartOfTheStorm_attack,
    'item': heartOfTheStorm_item
}
;// CONCATENATED MODULE: ./scripts/macros/spells/heatMetal.js


async function heatMetal_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    let damageDice = workflow.castData.castLevel + 'd8[fire]';
    let targetUuid = targetToken.document.uuid;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Heat Metal Pulse', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Heat Metal Pulse');
    let spellDC = chris.getSpellDC(workflow.item);
    featureData.flags['chris-premades'] = {
        'spell': {
            'heatMetal': {
                'damageDice': damageDice,
                'targetUuid': targetUuid,
                'spellDC': spellDC,
                'originUuid': workflow.item.uuid
            },
            'castData': workflow.castData
        }
    };
    featureData.flags['chris-premades'].spell.castData.school = workflow.item.system.school;
    async function effectMacro () {
        await warpgate.revert(token.document, 'Heat Metal');
        await chrisPremades.macros.heatMetal.removed(effect);
    }
    let effectData = {
        'name': 'Heat Metal',
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'spell': {
                    'heatMetal': {
                        'targetTokenUuid': targetUuid
                    }
                },
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': effectData.name,
        'description': featureData.name,
        'origin': workflow.item.uuid
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
    let effectData2 = {
        'name': 'Heat Metal Dialogue',
        'icon': workflow.item.img,
        'duration': {
            'seconds': 6
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onCreate': {
                    'script': 'await chrisPremades.macros.heatMetal.dialogue(token, actor, effect, origin);'
                }
            },
            'chris-premades': {
                'spell': {
                    'heatMetal': {
                        'spellDC': spellDC,
                        'originUuid': workflow.item.uuid
                    }
                }
            }
        }
    }
    await chris.createEffect(targetToken.actor, effectData2);
}
async function pulseItem({speaker, actor, token, character, item, args, scope, workflow}) {
    let targetTokenUuid = workflow.item.flags['chris-premades']?.spell?.heatMetal?.targetUuid;
    let damageDice = workflow.item.flags['chris-premades']?.spell?.heatMetal?.damageDice;
    let spellDC = workflow.item.flags['chris-premades']?.spell?.heatMetal?.spellDC;
    let originUuid = workflow.item.flags['chris-premades']?.spell?.heatMetal?.originUuid;
    if (!damageDice || !targetTokenUuid || !spellDC || !originUuid) return;
    let targetToken = await fromUuid(targetTokenUuid);
    if (!targetToken) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Heat Metal Damage', false);
    if (!featureData) return;
    featureData.system.damage.parts = [
        [
            damageDice,
            'fire'
        ]
    ];
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Heat Metal Damage');
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetTokenUuid]);
    await MidiQOL.completeItemUse(feature, config, options);
    let effectData = {
        'name': 'Heat Metal Dialogue',
        'icon': workflow.item.img,
        'duration': {
            'seconds': 6
        },
        'origin': originUuid,
        'flags': {
            'effectmacro': {
                'onCreate': {
                    'script': 'await chrisPremades.macros.heatMetal.dialogue(token, actor, effect, origin);'
                }
            },
            'chris-premades': {
                'spell': {
                    'heatMetal': {
                        'spellDC': spellDC,
                        'originUuid': originUuid
                    }
                }
            }
        }
    }
    await chris.createEffect(targetToken.actor, effectData);
}
async function dialogue(token, actor, effect, origin) {
    let selection = await chris.dialog('Drop heated object?', [['Yes', true], ['No', false], ['Unable (Armor)', 'unable']]);
    if (selection === true) {
        await effect.delete();
        return;
    }
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Heat Metal Held', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Heat Metal Held');
    let spellDC = effect.flags['chris-premades']?.spell?.heatMetal?.spellDC;
    if (!spellDC) return;
    featureData.system.save.dc = spellDC;
    let spell = new CONFIG.Item.documentClass(featureData, {'parent': origin.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.document.uuid]);
    let heatMetalWorkflow = await MidiQOL.completeItemUse(spell, config, options);
    if (heatMetalWorkflow.failedSaves.size != 0 && selection != 'unable') {
        await effect.delete();
        return;
    }
    let originUuid = effect.flags['chris-premades']?.spell?.heatMetal?.originUuid;
    if (!originUuid) return;
    let effectData = {
        'name': 'Heat Metal Held',
        'icon': origin.img,
        'changes': [
            {
                'key': 'flags.midi-qol.disadvantage.attack.all',
                'value': '1',
                'mode': 0,
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.disadvantage.ability.all',
                'value': '1',
                'mode': 0,
                'priority': 20
            }
        ],
        'duration': {
            'seconds': 6
        },
        'origin': originUuid,
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    'turnStartSource'
                ],
                'stackable': 'multi',
                'macroRepeat': 'none'
            }
        }
    }
    await chris.createEffect(actor, effectData);
    await effect.delete();
}
async function removed(effect) {
    let targetTokenUuid = effect.flags['chris-premades']?.spell?.heatMetal?.targetTokenUuid;
    if (!targetTokenUuid) return;
    let targetToken = await fromUuid(targetTokenUuid);
    if (!targetToken) return;
    let targetEffect = chris.findEffect(targetToken.actor, 'Heat Metal Held');
    if (!targetEffect) return;
    await chris.removeEffect(targetEffect);
}
let heatMetal = {
    'item': heatMetal_item,
    'pulseItem': pulseItem,
    'dialogue': dialogue,
    'removed': removed
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/warlock/hexblade/hexWarrior.js

async function hexWarrior({speaker, actor, token, character, item, args, scope, workflow}) {
    let weapons = workflow.actor.items.filter(i => i.type === 'weapon' && !i.system.properties?.two && i.system.equipped);
    if (!weapons.length) {
        ui.notifications.info('No valid equipped weapons to pick!');
    }
    let selection;
    if (weapons.length === 1) {
        selection = weapons[0];
    } else {
        [selection] = await chris.selectDocument('Select a Weapon', weapons);
    }
    if (!selection) return;
    let weaponData = duplicate(selection.toObject());
    let cha = workflow.actor.system.abilities.cha.mod;
    let ability = weaponData.system.ability === '' ? 'str' : weaponData.system.ability;
    let score = workflow.actor.system.abilities[ability].mod;
    let dex = workflow.actor.system.abilities.dex.mod;
    let changed = false;
    if (weaponData.system.properties.fin) {
        let mod = dex > score ? dex : score;
        if (mod <= cha) {
            ability = 'cha';
            changed = true;
        }
    } else {
        if (score <= cha) {
            ability = 'cha';
            changed = true;
        }
    }
    if (changed) weaponData.system.ability = ability;
    async function effectMacro () {
        await warpgate.revert(token.document, 'Hex Warrior');
    }
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 604800
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': weaponData.name
                }
            },
            'dae': {
                'specialDuration': [
                    'longRest'
                ]
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [weaponData.name]: weaponData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Hex Warrior',
        'description': 'Hex Warrior'
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/warlock/hexblade/hexbladesCurse.js


async function hexbladesCurse_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let targetId = workflow.actor.flags['chris-premades']?.feature?.hexbladesCurse;
    if (!targetId) return;
    let targetToken = workflow.hitTargets.first();
    if (targetId != targetToken.id) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'hexbladesCurse', 250);
    if (!queueSetup) return;
    let damageFormula = workflow.damageRoll._formula + ' + ' + workflow.actor.system.attributes.prof + '[' + workflow.defaultDamageType + ']';
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
    return;
}
async function hexbladesCurse_damageApplication({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size < 2) return;
    let targetId = workflow.actor.flags['chris-premades']?.feature?.hexbladesCurse;
    if (!targetId) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'hexbladesCurse', 250);
    if (!queueSetup) return;
    let targetDamage = workflow.damageList.find(i => i.tokenId === targetId);
    if (!targetDamage) return;
    let targetActor = canvas.scene.tokens.get(targetDamage.tokenId).actor;
    if (!targetActor) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let hasDI = chris.checkTrait(targetActor, 'di', workflow.defaultDamageType);
    if (hasDI) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let damageTotal = workflow.actor.system.attributes.prof;
    let hasDR = chris.checkTrait(targetActor, 'dr', workflow.defaultDamageType);
    if (hasDR) damageTotal = Math.floor(damageTotal / 2);
    targetDamage.damageDetail[0].push(
        {
            'damage': damageTotal,
            'type': workflow.defaultDamageType
        }
    );
    targetDamage.totalDamage += damageTotal;
    targetDamage.appliedDamage += damageTotal;
    targetDamage.hpDamage += damageTotal;
    if (targetDamage.oldTempHP > 0) {
        if (targetDamage.oldTempHP >= damageTotal) {
            targetDamage.newTempHP -= damageTotal;
        } else {
            let leftHP = damageTotal - targetDamage.oldTempHP;
            targetDamage.newTempHP = 0;
            targetDamage.newHP -= leftHP;
        }
    } else {
        targetDamage.newHP -= damageTotal;
    }
    queue_queue.remove(workflow.item.uuid);
}
async function hexbladesCurse_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    let validTypes = [
        'mwak',
        'msak',
        'rwak',
        'rsak'
    ];
    if (workflow.targets.size != 1 || !validTypes.includes(workflow.item.system.actionType)) return;
    let targetId = workflow.actor.flags['chris-premades']?.feature?.hexbladesCurse;
    if (!targetId) return;
    if (workflow.targets.first().id != targetId) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'hexbladesCurse', 250);
    if (!queueSetup) return;
    let effectData = {
        'label': 'Critical Threshold',
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'duration': {
            'seconds': 1
        },
        'changes': [
            {
                'key': 'flags.midi-qol.grants.criticalThreshold',
                'value': '19',
                'mode': 5,
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    'isAttacked'
                ],
                'stackable': 'multi',
                'macroRepeat': 'none'
            }
        }
    }
    await chris.createEffect(workflow.targets.first().actor, effectData);
    queue_queue.remove(workflow.item.uuid);
}
async function hexbladesCurse_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let effectData = {
        'label': workflow.item.name,
        'icon': workflow.item.img,
        'changes': [
            {
                'key': 'flags.chris-premades.feature.hexbladesCurse',
                'mode': 5,
                'value': workflow.targets.first().id,
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.hexbladesCurse.damage,postDamageRoll',
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.hexbladesCurse.damageApplication,preDamageApplication',
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.hexbladesCurse.attack,preambleComplete',
                'priority': 20
            }
        ],
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 60
        },
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    'zeroHP'
                ],
                'stackable': 'multi',
                'macroRepeat': 'none'
            }
        }
    }
    await chris.createEffect(workflow.actor, effectData);
}
async function defeated(origin, effect) {
    await warpgate.wait(100);
    let warlockLevels = origin.actor.classes.warlock?.system?.levels;
    if (warlockLevels >= 14) {
        async function effectMacro() {
            let selection = await chrisPremades.helpers.dialog('Master of Hexes: Heal self?', [['Yes', true], ['No', false]]);
            if (selection) {
                let damage = Math.max(origin.actor.system.abilities.cha.mod, 1);
                let warlockLevels = origin.actor.classes.warlock?.system?.levels;
                if (warlockLevels) damage += warlockLevels;
                await chrisPremades.helpers.applyDamage(token, damage, 'healing');
                let targetEffect = chrisPremades.helpers.findEffect(actor, origin.name);
                if (targetEffect) await chrisPremades.helpers.removeEffect(effect);
            } else {
                await origin.update({'system.uses.value': 1});
            }
            await effect.delete();
        }
        let effectData = {
            'label': origin.name + ': Healing',
            'icon': origin.img,
            'origin': origin.uuid,
            'duration': {
                'seconds': 1
            },
            'flags': {
                'effectmacro': {
                    'onCreate': {
                        'script': chris.functionToString(effectMacro)
                    }
                }
            }
        }
        await chris.createEffect(origin.actor, effectData);
        await chris.removeEffect(effect);
        return;
    }
    let damage = Math.max(origin.actor.system.abilities.cha.mod, 1);
    if (warlockLevels) damage += warlockLevels;
    let tokens = origin.actor.getActiveTokens();
    if (tokens.length != 0) await chris.applyDamage(tokens[0], damage, 'healing');
    await chris.removeEffect(effect);
}
async function hexbladesCurse_removed(origin) {
    let targetEffect = chris.findEffect(origin.actor, origin.name);
    if (!targetEffect) return;
    await chris.removeEffect(targetEffect);
}
let hexbladesCurse = {
    'item': hexbladesCurse_item,
    'damage': hexbladesCurse_damage,
    'damageApplication': hexbladesCurse_damageApplication,
    'attack': hexbladesCurse_attack,
    'defeated': defeated,
    'removed': hexbladesCurse_removed
}
;// CONCATENATED MODULE: ./scripts/macros/spells/hex.js


async function hexItem({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Hex - Move', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Hex - Move');
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'hex', 50);
    if (!queueSetup) return;
    let selection = await chris.dialog(workflow.item.name, [
        ['Strength', 'str'],
        ['Dexterity', 'dex'],
        ['Constitution', 'con'],
        ['Intelligence', 'int'],
        ['Wisdom', 'wis'],
        ['Charisma', 'cha']
    ], 'What ability should have disadvantage?');
    if (!selection) selection = 'str';
    let seconds;
    switch (workflow.castData.castLevel) {
        case 3:
        case 4:
            seconds = 28800;
            break;
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
            seconds = 86400;
            break;
        default:
            seconds = 3600;
    }
    let targetEffectData = {
        'name': 'Hexed',
        'icon': 'icons/magic/perception/silhouette-stealth-shadow.webp',
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': seconds
        },
        'changes': [
            {
                'key': 'flags.midi-qol.disadvantage.ability.check.' + selection,
                'mode': 5,
                'value': '1',
                'priority': 20
            }
        ]
    };
    await chris.createEffect(workflow.targets.first().actor, targetEffectData);
    async function effectMacro() {
        await warpgate.revert(token.document, 'Hex');
        let targetTokenId = effect.changes[0].value;
        let targetToken = canvas.scene.tokens.get(targetTokenId);
        if (!targetToken) return;
        let targetActor = targetToken.actor;
        let targetEffect =  chrisPremades.helpers.findEffect(targetActor, 'Hexed');
        if (!targetEffect) return;
        await chrisPremades.helpers.removeEffect(targetEffect);
    }
    let sourceEffectData = {
        'name': 'Hex',
        'icon': workflow.item.img,
        'changes': [
            {
                'key': 'flags.chris-premades.spell.hex',
                'mode': 5,
                'value': workflow.targets.first().id,
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.hex.attack,postDamageRoll',
                'priority': 20
            }
        ],
        'transfer': false,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': seconds
        },
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [sourceEffectData.name]: sourceEffectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': sourceEffectData.name,
        'description': sourceEffectData.name
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
    let conEffect = chris.findEffect(workflow.actor, 'Concentrating');
    if (conEffect) {
        let updates = {
            'duration': {
                'seconds': seconds
            }
        };
        await chris.updateEffect(conEffect, updates);
    }
    queue_queue.remove(workflow.item.uuid);
}
async function hexAttack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let validTypes = ['msak', 'rsak', 'mwak', 'rwak'];
    if (!validTypes.includes(workflow.item.system.actionType)) return;
    let sourceActor = workflow.actor;
    let hexedTarget = sourceActor.flags['chris-premades']?.spell?.hex;
    let targetToken = workflow.hitTargets.first();
    if (targetToken.id != hexedTarget) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'hex', 250);
    if (!queueSetup) return;
    let oldFormula = workflow.damageRoll._formula;
    let bonusDamageFormula = '1d6[necrotic]';
    if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
    let damageFormula = oldFormula + ' + ' + bonusDamageFormula;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function hexMoveItem({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    let oldTargetTokenId = workflow.actor.flags['chris-premades']?.spell?.hex;
    let oldTargetToken = canvas.scene.tokens.get(oldTargetTokenId);
    let oldTargetOrigin;
    let selection = 'flags.midi-qol.disadvantage.ability.check.str';
    if (oldTargetToken) {
        let oldTargetActor = oldTargetToken.actor;
        let oldTargetEffect =  chris.findEffect(oldTargetActor, 'Hexed');
        if (oldTargetEffect) {
            await chris.removeEffect(oldTargetEffect);
            oldTargetOrigin = oldTargetEffect.origin;
            selection = oldTargetEffect.changes[0].key;
        }
    }
    let effect = chris.findEffect(workflow.actor, 'Hex');
    let duration = 3600;
    if (effect) duration = effect.duration.remaining;
    let effectData = {
        'name': 'Hexed',
        'icon': 'icons/magic/perception/silhouette-stealth-shadow.webp',
        'origin': oldTargetOrigin,
        'duration': {
            'seconds': duration
        },
        'changes': [
            {
                'key': selection,
                'mode': 5,
                'value': '1',
                'priority': 20
            }
        ]
    };
    await chris.createEffect(targetActor, effectData);
    if (effect) {
        let changes = effect.changes;
        changes[0].value = targetToken.id;
        let updates = {changes};
        await chris.updateEffect(effect, updates);
    }
}
let hex = {
    'item': hexItem,
    'attack': hexAttack,
    'move': hexMoveItem
};
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/hezrou/hezrou.js

let hezrou = {
    'stench': stench
}
;// CONCATENATED MODULE: ./scripts/macros/raceFeatures/firbolg/hiddenStep.js


async function hiddenStep({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.item) return;
    if (!(constants_constants.attacks.includes(workflow.item.actionType) || workflow.item.system.save.ability || workflow.damageRoll)) return;
    let effect = chris.findEffect(workflow.actor, 'Hidden Step');
    if (effect) await chris.removeEffect(effect);
}
;// CONCATENATED MODULE: ./scripts/macros/feats/strikeOfTheGiants/hillStrike.js




async function hillStrike_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (workflow.item.system.actionType != 'mwak') return;
    let originFeature = chris.getItem(workflow.actor, 'Strike of the Giants: Hill Strike');
    if (!originFeature) return;
    if (!originFeature.system.uses.value) return;
    let turnCheck = chris.perTurnCheck(originFeature, 'feat', 'hillStrike', false, workflow.token.id);
    if (!turnCheck) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'hillStrike', 150);
    if (!queueSetup) return;
    let selection = await chris.dialog(originFeature.name, [['Yes', true], ['No', false]], 'Use ' + originFeature.name + '?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await originFeature.update({'system.uses.value': originFeature.system.uses.value - 1});
    if (chris.inCombat()) await originFeature.setFlag('chris-premades', 'feat.hillStrike.turn', game.combat.round + '-' + game.combat.turn);
    let damageFormula = workflow.damageRoll._formula;
    let bonusDamage = '1d6[' + translate.damageType(workflow.defaultDamageType) + ']';
    if (workflow.isCritical) bonusDamage = chris.getCriticalFormula(bonusDamage);
    let damageRoll = await new Roll(damageFormula + ' + ' + bonusDamage).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    let saveDC = Math.max(workflow.actor.system.abilities.con.dc, workflow.actor.system.abilities.str.dc);
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Feat Features', 'Strike of the Giants: Hill Strike', false);
    if (!featureData) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Strike of the Giants: Hill Strike');
    featureData.system.save.dc = saveDC;
    delete featureData._id;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    feature.prepareData();
    feature.prepareFinalAttributes();
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.hitTargets.first().document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature, config, options);
    queue_queue.remove(workflow.item.uuid);
}
async function hillStrike_end(origin) {
    await origin.setFlag('chris-premades', 'feat.hillStrike.turn', '');
}
let hillStrike = {
    'damage': hillStrike_damage,
    'end': hillStrike_end
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/hobgoblin/martialAdvantage.js



async function martialAdvantage_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (!constants_constants.weaponAttacks.includes(workflow.item.system.actionType)) return;
    let feature = chris.getItem(workflow.actor, 'Martial Advantage');
    if (!feature) return;
    let turnCheck = chris.perTurnCheck(feature, 'feature', 'martialAdvantage', false);
    if (!turnCheck) return;
    let nearbyTargets = chris.findNearby(workflow.targets.first(), 5, 'enemy', false, false).filter(i => i.document.uuid != workflow.token.document.uuid);
    if (!nearbyTargets.length) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'martialAdvantage', 250);
    if (!queueSetup) return;
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Use ' + feature.name + '?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    if (chris.inCombat()) await feature.setFlag('chris-premades', 'feature.martialAdvantage.turn', game.combat.round + '-' + game.combat.turn);
    let damageFormula = workflow.damageRoll._formula;
    let bonusDamage = feature.system.damage.parts[0][0] + '[' + workflow.defaultDamageType + ']';
    if (workflow.isCritical) bonusDamage = chris.getCriticalFormula(bonusDamage);
    let damageRoll = await new Roll(damageFormula + ' + ' + bonusDamage).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function martialAdvantage_end(origin) {
    await origin.setFlag('chris-premades', 'feature.martialAdvantage.turn', '');
}
let martialAdvantage = {
    'attack': martialAdvantage_attack,
    'end': martialAdvantage_end
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/hobgoblin/hobgoblin.js

let hobgoblin = {
    'martialAdvantage': martialAdvantage
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/paladin/oathOfDevotion/holyNimbus.js


function holyNimbus_save(saveId, options) {
    return {'label': 'This a save is from a spell cast by a fiend or undead.', 'type': 'advantage'};
}
async function holyNimbus_turn(token) {
    let targetToken = game.canvas.tokens.get(game.combat.current.tokenId);
    if (!targetToken) return;
    if (targetToken.document.disposition === token.document.disposition) return;
    let distance = chris.getDistance(token, targetToken);
    if (distance > 30) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Holy Nimbus - Damage', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Sacred Weapon - Dismiss');
    delete featureData._id;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': token.actor});let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature, config, options);
}
let holyNimbus = {
    'save': holyNimbus_save,
    'turn': holyNimbus_turn
}
;// CONCATENATED MODULE: ./scripts/macros/spells/holyWeapon.js

async function holyWeapon_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    let targetWeapons = targetToken.actor.items.filter(i => i.type === 'weapon' && i.system.equipped);
    if (targetWeapons.length === 0) return;
    let selection;
    if (targetWeapons.length === 1) selection = targetWeapons[0];
    if (!selection) [selection] = await chris.remoteDocumentDialog(chris.firstOwner(targetToken).id, 'What weapon gets imbued?', targetWeapons);
    if (!selection) return;
    async function effectMacro () {
        await warpgate.revert(token.document, 'Holy Weapon - Target');
    }
    let effectData = {
        'name': 'Holy Weapon - Target',
        'icon': workflow.item.img,
        'duration': {
            'seconds': 3600
        },
        'origin': workflow.item.uuid,
        'changes': [
            {
                'key': 'ATL.light.bright',
                'mode': 4,
                'value': 30,
                'priority': 20
            },
            {
                'key': 'ATL.light.dim',
                'mode': 4,
                'value': 60,
                'priority': 20
            }
        ],
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            }
        }
    };
    let damageParts = selection.system.damage.parts;
    damageParts.push(['2d8[radiant]']);
    let updates = {
        'embedded': {
            'Item': {
                [selection.name]: {
                    'system': {
                        'damage.parts': damageParts,
                        'properties.mgc': true
                    }
                }
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Holy Weapon - Target',
        'description': 'Holy Weapon - Target'
    };
    await warpgate.mutate(targetToken.document, updates, {}, options);
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Holy Weapon - Dismiss', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Holy Weapon - Dismiss', false);
    setProperty(featureData, 'flags.chris-premades.spell.castData', workflow.castData);
    setProperty(featureData, 'flags.chris-premades.spell.castData.school', workflow.item.system.school);
    async function effectMacro2 () {
        await warpgate.revert(token.document, 'Holy Weapon');
    }
    let effectData2 = {
        'name': 'Holy Weapon',
        'icon': workflow.item.img,
        'duration': {
            'seconds': 3600
        },
        'origin': workflow.item.uuid,
        'changes': [
            {
                'key': 'flags.chris-premades.spell.holyWeapon',
                'mode': 5,
                'value': targetToken.document.uuid,
                'priority': 20
            }
        ],
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro2)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    let updates2 = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData2.name]: effectData2
            }
        }
    };
    let options2 = {
        'permanent': false,
        'name': 'Holy Weapon',
        'description': 'Holy Weapon'
    };
    await warpgate.mutate(workflow.token.document, updates2, {}, options2);
}
async function holyWeapon_dismiss({speaker, actor, token, character, item, args, scope, workflow}) {
    let targetTokenUuid = workflow.actor.flags['chris-premades']?.spell?.holyWeapon;
    if (!targetTokenUuid) return;
    let targetToken = await fromUuid(targetTokenUuid);
    if (!targetToken) return;
    let featureData = await chrisPremades.helpers.getItemFromCompendium('chris-premades.CPR Spell Features', 'Holy Weapon - Burst', false);
    if (!featureData) return;
    let effect = chris.findEffect(workflow.actor, 'Holy Weapon');
    if (!effect) return;
    let originItem = await fromUuid(effect.origin);
    if (!originItem) return;
    let spellDC = chris.getSpellDC(originItem);
    featureData.system.description.value = chrisPremades.helpers.getItemDescription('CPR - Descriptions', 'Holy Weapon - Burst', false);
    featureData.effects[0].changes[0].value = 'label=Holy Weapon - Burst (End of Turn),turn=end,saveDC=' + spellDC + ',saveAbility=con,savingThrow=true,saveMagic=true,saveRemove=true';
    featureData.system.save.dc = spellDC;
    featureData.flags['chris-premades'] = {
        'spell': {
            'castData': {
                'castLevel': 5,
                'school': originItem.system.school
            }
        }
    };
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': targetToken.actor});
    await feature.use();
    await chris.removeEffect(effect);
    await chris.removeCondition(workflow.actor, 'Concentrating');
}
let holyWeapon = {
    'item': holyWeapon_item,
    'dismiss': holyWeapon_dismiss
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/artificer/infusions/homunculusServant.js


async function homunculusServant_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let sourceActor = game.actors.getName('CPR - Homunculus Servant');
    if (!sourceActor) return;
    let mendingData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Mending', false);
    if (!mendingData) return;
    mendingData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Mending');
    let forceStrikeData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Force Strike', false);
    if (!forceStrikeData) return;
    forceStrikeData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Force Strike');
    let channelMagicData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Channel Magic', false);
    if (!channelMagicData) return;
    channelMagicData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Channel Magic');
    let evasionData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Evasion', false);
    if (!evasionData) return;
    evasionData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Evasion');
    let dodgeData = await chris.getItemFromCompendium('chris-premades.CPR Actions', 'Dodge', false);
    if (!dodgeData) return;
    dodgeData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Dodge');
    let artificerLevel = workflow.actor.classes?.artificer?.system?.levels;
    if (!artificerLevel) return;
    let hpFormula = artificerLevel + ' + ' + (1 + chris.getSpellMod(workflow.item));
    let hpValue = await new Roll(hpFormula).evaluate({async: true});
    let name = chris.getConfiguration(workflow.item, 'name') ?? 'Homunculus Servant';
    if (name === '') name = 'Homunculus Servant';
    let meleeAttackBonus = await new Roll(workflow.actor.system.bonuses.msak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let rangedAttackBonus = await new Roll(workflow.actor.system.bonuses.rsak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'details': {
                    'cr': tashaSummon.getCR(workflow.actor.system.attributes.prof)
                },
                'attributes': {
                    'hp': {
                        'formula': hpFormula,
                        'max': hpValue.total,
                        'value': hpValue.total
                    }
                }
            },
            'prototypeToken': {
                'name': name,
                'disposition': workflow.token.document.disposition
            },
            'flags': {
                'chris-premades': {
                    'summon': {
                        'attackBonus': {
                            'melee': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.int.mod + meleeAttackBonus.total,
                            'ranged': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.int.mod + rangedAttackBonus.total
                        }
                    }
                }
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition
        },
        'embedded': {
            'Item': {
                [mendingData.name]: mendingData,
                [forceStrikeData.name]: forceStrikeData,
                [channelMagicData.name]: channelMagicData,
                [evasionData.name]: evasionData,
                [dodgeData.name]: dodgeData,
            }
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar');
    if (avatarImg) updates.actor.img = avatarImg;
    let tokenImg = chris.getConfiguration(workflow.item, 'token');
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? 'earth';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    let homunculusToken = await tashaSummon.spawn(sourceActor, updates, 86400, workflow.item, 120, workflow.token, animation);
    if (!homunculusToken) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Homunculus Servant - Command', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Homunculus Servant - Command');
    let channelMagicCasterData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Channel Magic (Caster)', false);
    if (!channelMagicCasterData) return;
    channelMagicCasterData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Channel Magic (Caster)');
    channelMagicCasterData.name = 'Channel Magic'
    let updates2 = {
        'embedded': {
            'Item': {
                [channelMagicCasterData.name]: channelMagicCasterData,
                [featureData.name]: featureData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Homunculus Servant',
        'description': featureData.name
    };
    await warpgate.mutate(workflow.token.document, updates2, {}, options);
    let effect = chris.findEffect(workflow.actor, workflow.item.name);
    if (!effect) return;
    let currentScript = effect.flags.effectmacro?.onDelete?.script;
    if (!currentScript) return;
    let effectUpdates = {
        'flags': {
            'effectmacro': {
                'onDelete': { 
                    'script': currentScript + ' await warpgate.revert(token.document, "Homunculus Servant");'
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                },
                'feature': {
                    'homunculusServant': homunculusToken.id
                }
            }
        }
    };
    await chris.updateEffect(effect, effectUpdates);
}
async function homunculusServant_attackApply({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = workflow.actor.effects.find((e) => e?.flags['chris-premades']?.feature?.homunculusServant);
    if (!effect) return;
    let homunculusId = effect.flags['chris-premades']?.feature?.homunculusServant;
    if (!homunculusId) return;
    let homunculusToken = canvas.scene.tokens.get(homunculusId);
    if (!homunculusToken) return;
    if (chris.getDistance(workflow.token, homunculusToken) > 120) {
        ui.notifications.info('Homunculus Too Far Away!');
        return;
    }
    let effectData = {
        'name': 'Channel Magic',
        'icon': workflow.item.img,
        'origin': effect.origin.uuid,
        'duration': {
            'seconds': 1
        },
        'changes': [
            {
                'key': 'flags.midi-qol.rangeOverride.attack.all',
                'mode': 0,
                'value': 1,
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'priority': 20,
                'value': 'function.chrisPremades.macros.homunculusServant.attackEarly,preambleComplete'
            }
        ],
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    '1Attack'
                ],
                'stackable': 'none',
                'macroRepeat': 'none'
            }
        }
    }
    await chris.createEffect(workflow.actor, effectData);
    await chris.createEffect(homunculusToken.actor, effectData);
}
async function homunculusServant_attackEarly({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.item.type != 'spell' || workflow.item.system.range.units != 'touch') {
        ui.notifications.info('Invalid Spell Type!');
        return false;
    }
    let effect = workflow.actor.effects.find((e) => e?.flags['chris-premades']?.feature?.homunculusServant);
    if (!effect) return;
    let homunculusId = effect.flags['chris-premades']?.feature?.homunculusServant;
    if (!homunculusId) return;
    let homunculusToken = canvas.scene.tokens.get(homunculusId);
    if (!homunculusToken) return;
    await chris.addCondition(homunculusToken.actor, 'Reaction');
}
let homunculusServant = {
    'item': homunculusServant_item,
    'attackApply': homunculusServant_attackApply,
    'attackEarly': homunculusServant_attackEarly
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/homunculus/bite.js

async function bite({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let saveResult = workflow.saveResults[0].total;
    let saveDC = workflow.item.system.save.dc;
    if (saveDC - saveResult < 5) return;
    let targetActor = workflow.targets.first().actor;
    let effect = chris.findEffect(targetActor, 'Poisoned Bite');
    let roll = await new Roll('1d10').roll({async: true});
    roll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: workflow.item.name
    });
    let seconds = roll.total * 60;
    let updates = {
        'duration': {
            'seconds': seconds
        }
    };
    await chris.updateEffect(effect, updates);
    await chris.addCondition(targetActor, 'Unconscious', false, workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/homunculus/homunculus.js

let homunculus = {
    'bite': bite
}
;// CONCATENATED MODULE: ./scripts/macros/spells/hungerOfHadar.js



async function hungerOfHadar_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let template = canvas.scene.collections.templates.get(workflow.templateId);
    if (!template) return;
    await template.update({
        'flags': {
            'chris-premades': {
                'template': {
                    'name': 'hungerOfHadar',
                    'castLevel': workflow.castData.castLevel,
                    'saveDC': chris.getSpellDC(workflow.item),
                    'macroName': 'hungerOfHadar',
                    'templateUuid': template.uuid,
                    'turn': 'both'
                }
            },
            'limits': {
                'light': {
                    'enabled': true,
                    'range': 0
                }
            },
            'walledtemplates': {
                'wallRestriction': 'move',
                'wallsBlock': 'walled'
            }
        }
    });
    let tokens = chris.templateTokens(template).map(i => game.canvas.scene.tokens.get(i)).filter(j => !chris.findEffect(j.actor, 'Hunger of Hadar'));
    let effectData = {
        'label': 'Hunger of Hadar',
        'icon': workflow.item.img,
        'origin': template.uuid,
        'duration': {
            'seconds': 600
        },
        'changes': [
            {
                'key': 'macro.CE',
                'mode': 0,
                'value': 'Blinded',
                'priority': 20
            }
        ]
    };
    for (let t of tokens) await chris.createEffect(t.actor, effectData);
}
async function hungerOfHadar_trigger(token, trigger, reason) {
    let template = await fromUuid(trigger.templateUuid);
    if (!template) return;
    let originUuid = template.flags.dnd5e?.origin;
    if (!originUuid) return;
    let originItem = await fromUuid(originUuid);
    if (!originItem) return;
    if (reason === 'move') {
        let templates = chris.tokenTemplates(token).map(i => canvas.scene.templates.get(i)).filter(i => i.flags['chris-premades']?.template?.name === 'hungerOfHadar');
        if (!templates.length) {
            let effect = chris.findEffect(token.actor, 'Hunger of Hadar');
            if (!effect) return;
            await chris.removeEffect(effect);
        } else {
            let effect = chris.findEffect(token.actor, 'Hunger of Hadar');
            if (effect) {
                if (effect.origin === template.uuid) return;
                await chris.removeEffect(effect);
            }
            let effectData = {
                'label': 'Hunger of Hadar',
                'icon': originItem.img,
                'origin': template.uuid,
                'duration': {
                    'seconds': 600
                },
                'changes': [
                    {
                        'key': 'macro.CE',
                        'mode': 0,
                        'value': 'Blinded',
                        'priority': 20
                    }
                ]
            };
            await chris.createEffect(token.actor, effectData);
        }
    } else {
        let queueSetup = await queue_queue.setup(trigger.templateUuid, 'hunterOfHadar-' + reason, 50);
        if (!queueSetup) return;
        let itemName = reason === 'turnStart' ? 'Hunger of Hadar - Cold' : 'Hunger of Hadar - Tentacles';
        let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', itemName, false);
        if (!featureData) {
            queue_queue.remove(trigger.templateUuid);
            return;
        }
        featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', itemName);
        if (itemName === 'Hunger of Hadar - Tentacles') featureData.system.save.dc = trigger.saveDC;
        delete featureData._id;
        let feature = new CONFIG.Item.documentClass(featureData, {'parent': originItem.actor});
        let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.uuid]);
        await MidiQOL.completeItemUse(feature, config, options);
        queue_queue.remove(trigger.templateUuid);
    }
}
async function hungerOfHadar_removed(template) {
    let tokens = game.canvas.scene.tokens.filter(i => i.actor.effects.find(j => j.origin === template.uuid));
    for (let token of tokens) {
        let templates = chris.tokenTemplates(token).map(i => canvas.scene.templates.get(i)).filter(j => j.flags.dnd5e?.origin != template.flags.dnd5e.origin);
        if (templates.length) return;
        let effect = chris.findEffect(token.actor, 'Hunger of Hadar');
        await chris.removeEffect(effect);
    }
}
let hungerOfHadar = {
    'item': hungerOfHadar_item,
    'trigger': hungerOfHadar_trigger,
    'removed': hungerOfHadar_removed
}
;// CONCATENATED MODULE: ./scripts/macros/raceFeatures/lizardfolk/hungryJaws.js

async function hungryJaws({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size === 0) return;
    let profBonus = workflow.actor.system.attributes.prof;
    await chris.applyDamage(workflow.token, profBonus, 'temphp');
}
;// CONCATENATED MODULE: ./scripts/macros/spells/huntersMark.js


async function huntersMark_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Hunter\'s Mark - Move', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Hunter\'s Mark - Move');
    let seconds;
    switch (workflow.castData.castLevel) {
        case 3:
        case 4:
            seconds = 28800;
            break;
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
            seconds = 86400;
            break;
        default:
            seconds = 3600;
    }
    let targetEffectData = {
        'name': 'Marked',
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': seconds
        }
    };
    await chris.createEffect(workflow.targets.first().actor, targetEffectData);
    async function effectMacro() {
        await warpgate.revert(token.document, 'Hunter\'s Mark');
        let targetTokenId = effect.changes[0].value;
        let targetToken = canvas.scene.tokens.get(targetTokenId);
        if (!targetToken) return;
        let targetActor = targetToken.actor;
        let targetEffect =  chrisPremades.helpers.findEffect(targetActor, 'Marked');
        if (!targetEffect) return;
        await chrisPremades.helpers.removeEffect(targetEffect);
    }
    let sourceEffectData = {
        'name': 'Hunter\'s Mark',
        'icon': workflow.item.img,
        'changes': [
            {
                'key': 'flags.chris-premades.spell.huntersMark',
                'mode': 5,
                'value': workflow.targets.first().id,
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.huntersMark.attack,postDamageRoll',
                'priority': 20
            }
        ],
        'transfer': false,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': seconds
        },
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    }
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [sourceEffectData.name]: sourceEffectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': sourceEffectData.name,
        'description': sourceEffectData.name
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
    let conEffect = chris.findEffect(workflow.actor, 'Concentrating');
    if (conEffect) {
        let updates = {
            'duration': {
                'seconds': seconds
            }
        };
        await chris.updateEffect(conEffect, updates);
    }
}
async function huntersMark_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let attackType = workflow.item.system.actionType;
    if (!(attackType === 'mwak' || attackType === 'rwak')) return;
    let sourceActor = workflow.actor;
    let markedTarget = sourceActor.flags['chris-premades']?.spell?.huntersMark;
    let targetToken = workflow.hitTargets.first();
    if (targetToken.id != markedTarget) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'huntersMark', 250);
    if (!queueSetup) return;
    let oldFormula = workflow.damageRoll._formula;
    let bonusDamageFormula = '1d6[' + workflow.defaultDamageType + ']'
    if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
    let damageFormula = oldFormula + ' + ' + bonusDamageFormula;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function huntersMark_move({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    let oldTargetTokenId = workflow.actor.flags['chris-premades']?.spell?.huntersMark;
    let oldTargetToken = canvas.scene.tokens.get(oldTargetTokenId);
    let oldTargetOrigin;
    if (oldTargetToken) {
        let oldTargetActor = oldTargetToken.actor;
        let oldTargetEffect =  chris.findEffect(oldTargetActor, 'Marked');
        if (oldTargetEffect) {
            await chris.removeEffect(oldTargetEffect);
            oldTargetOrigin = oldTargetEffect.origin;
        }
    }
    let effect = chris.findEffect(workflow.actor, 'Hunter\'s Mark');
    let duration = 3600;
    if (effect) duration = effect.duration.remaining;
    let effectData = {
        'name': 'Marked',
        'icon': workflow.item.img,
        'origin': oldTargetOrigin,
        'duration': {
            'seconds': duration
        }
    };
    await chris.createEffect(targetActor, effectData);
    if (effect) {
        let changes = effect.changes;
        changes[0].value = targetToken.id;
        let updates = {changes};
        await chris.updateEffect(effect, updates);
    }
}
let huntersMark = {
    'item': huntersMark_item,
    'attack': huntersMark_attack,
    'move': huntersMark_move
};
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/bloodHunter/orderOfTheLycan/hybridTransformation.js



async function hybridTransformation_turnStart(token, actor) {
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.document.uuid]);
    let levels = actor.classes['blood-hunter'].system.levels;
    if (!levels) return;
    let bonusHealth = 0;
    if (levels >= 11 && (actor.system.attributes.hp.max / 2) > actor.system.attributes.hp.value) {
        let featureData2 = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Lycan Regeneration', false);
        featureData2.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Lycan Regeneration');
        let feature2 = new CONFIG.Item.documentClass(featureData2, {'parent': workflow.actor});
        if (levels >= 15) {
            let effectData2 = {
                'name': 'Condition Advantage',
                'icon': 'icons/magic/time/arrows-circling-green.webp',
                'duration': {
                    'seconds': 1,
                },
                'changes': [
                    {
                        'key': 'flags.midi-qol.advantage.ability.save.wis',
                        'mode': 5,
                        'value': '1',
                        'priority': 20
                    }
                ]
            }
            await chris.createEffect(actor, effectData2);
        }
        let featureWorkflow = await MidiQOL.completeItemUse(feature2, config, options);
        if (levels >= 15) {
            let advEffect = chris.findEffect(actor, 'Condition Advantage')
            if (advEffect) await advEffect.delete();
        } 
        bonusHealth = featureWorkflow.damageTotal;
    }
    if ((actor.system.attributes.hp.max / 2) <= actor.system.attributes.hp.value + bonusHealth) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Bloodlust', false);
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Bloodlust');
    if (!featureData) return;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': token.actor});
    await MidiQOL.completeItemUse(feature, config, options);
}
async function transformation({speaker, actor, token, character, item, args, scope, workflow}) {
    let levels = workflow.actor.classes['blood-hunter'].system.levels;
    if (!levels) return;
    let weaponData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Predatory Strike', false);
    if (!weaponData) return;
    weaponData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Predatory Strike');
    if (levels >= 7) {
        weaponData.system.attackBonus = '+1';
        weaponData.system.properties.mgc = true;
    }
    async function effectMacro () {
        await warpgate.revert(token.document, 'Hybrid Transformation');
    }
    let bonuses = '+1';
    if (levels >= 11) {
        bonuses = '+2';
        weaponData.system.attackBonus = '+2';
        weaponData.system.damage.parts = [
            [
                '1d8[bludgeoning] + @mod',
                'bludgeoning'
            ]
        ];
    }
    let seconds = 3600;
    if (levels >= 18) {
        bonuses = '+3';
        weaponData.system.attackBonus = '+3';
        seconds = 604800
    }
    let changes = [
        {
            'key': 'flags.midi-qol.advantage.ability.check.str',
            'mode': 5,
            'value': '1',
            'priority': 20
        },
        {
            'key': 'flags.midi-qol.advantage.ability.save.str',
            'mode': 5,
            'value': '1',
            'priority': 20
        },
        {
            'key': 'system.traits.dr.custom',
            'mode': 0,
            'value': 'Non-Magical Damage',
            'priority': 20
        },
        {
            'key': 'system.attributes.ac.bonus',
            'mode': 2,
            'value': '+1',
            'priority': 20
        },
        {
            'key': 'system.bonuses.mwak.damage',
            'mode': 2,
            'value': bonuses,
            'priority': 20
        }
    ];
    if (levels >= 15) {
        changes.push(
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.await chrisPremades.macros.hybridTransformation.voracious,preAttackRoll',
                'priority': 20
            }
        );
    }
    let effectData = {
        'name': 'Hybrid Transformation',
        'icon': workflow.item.img,
        'changes': changes,
        'disabled': false,
        'duration': {
            'seconds': seconds
        },
        'origin': workflow.item.uuid,
        'flags': {
            'dae': {
                'selfTarget': true,
                'selfTargetAlways': false,
                'stackable': 'none',
                'durationExpression': '',
                'macroRepeat': 'none',
                'specialDuration': [
                    'zeroHP'
                ]
            },
            'effectmacro': {
                'onTurnStart': {
                    'script': 'await chrisPremades.macros.hybridTransformation.turnStart(token, actor);'
                },
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'dae': {
                'transfer': true
            }
        }
    }
    let updates = {
        'embedded': {
            'Item': {
                [weaponData.name]: weaponData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar');
    if (avatarImg) setProperty(updates, 'actor.img', avatarImg);
    let tokenImg = chris.getConfiguration(workflow.item, 'token');
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    let options = {
        'permanent': false,
        'name': effectData.name,
        'description': effectData.name
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
async function voracious({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetActor = workflow.targets.first().actor;
    let effect = chris.findEffect(targetActor, 'Brand of Castigation');
    if (!effect) return;
    let originItem = await fromUuid(effect.origin);
    if (!originItem) return;
    if (originItem.actor.uuid != workflow.actor.uuid) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'voracious',150);
    if (!queueSetup) return;
    workflow.advantage = true;
    workflow.attackAdvAttribution.add('Advantage: Brand of the Voracious');
    queue_queue.remove(workflow.item.uuid);
}
let hybridTransformation = {
    'item': transformation,
    'turnStart': hybridTransformation_turnStart,
    'voracious': voracious
}
;// CONCATENATED MODULE: ./scripts/macros/spells/iceStorm.js

async function iceStorm({speaker, actor, token, character, item, args, scope, workflow}) {
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? chris.jb2aCheck() === 'patreon';
    if (!animation) return
    if (!workflow.templateId) return;
    let template = canvas.scene.collections.templates.get(workflow.templateId)?.object;
    if (!template) return;
    //Animations by: eskiemoh
    await new Sequence()
        .effect()
        .file('jb2a.magic_signs.circle.02.evocation.loop.blue')
        .atLocation(template)
        .scaleIn(0, 500, {'ease': 'easeOutCubic'})
        .fadeIn(750)
        .fadeOut(1000)
        .size(9, {'gridUnits': true})
        .duration(11000)
        .belowTokens()
        .zIndex(0.1)

        .effect()
        .file('jb2a.magic_signs.circle.02.evocation.loop.blue')
        .atLocation(template)
        .scaleIn(0, 500, {'ease': 'easeOutCubic'})
        .fadeIn(150, {'delay': 500})
        .size(9, {'gridUnits': true})
        .duration(1000)
        .fadeOut(250)
        .belowTokens()
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 2})
        .filter('Blur', {'blurX': 5, 'blurY': 10})
        .zIndex(0.11)

        .effect()
        .file('jb2a.extras.tmfx.border.circle.outpulse.01.fast')
        .scaleIn(0, 500, {'ease': 'easeOutQuint'})
        .delay(400)
        .fadeOut(1000)
        .atLocation(template)
        .duration(1000)
        .size(12, {'gridUnits': true})
        .zIndex(1)

        .wait(1000)

        .play();
    new Sequence()
        .effect()
        .file('jb2a.sleet_storm.blue')
        .atLocation(template)
        .size(9.5, {'gridUnits': true})
        .persist()
        .attachTo(template)
        .fadeIn(6000)
        .fadeOut(1000)
        .delay(500)
        .belowTokens()

        .effect()
        .file('jb2a.smoke.ring.01.white')
        .atLocation(template)
        .size(12, {'gridUnits': true})
        .fadeIn(4000)
        .opacity(0.2)
        .duration(6000)
        .playbackRate(0.75)
        .fadeOut(1000)
        .delay(500)
        .zIndex(1)

        .effect()
        .file('jb2a.magic_signs.circle.02.evocation.loop.blue')
        .atLocation(template)
        .fadeIn(6000)
        .fadeOut(1000)
        .delay(500)
        .size(9, {'gridUnits': true})
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 0})
        .opacity(0.2)
        .persist()
        .attachTo(template)
        .belowTokens()
        .zIndex(0.1)

        .play();
    for (let e = 0; e < 44; e++) {
        let offsetX = (Math.random() * (3.5 + 3.5) - 3.5) * canvas.grid.size;
        let offsetY = (Math.random() * (3.5 + 3.5) - 3.5) * canvas.grid.size;
        new Sequence()
            .wait(150 * e + 1)

            .effect()
            .file('jb2a.spell_projectile.ice_shard')
            .scale(1)
            .atLocation({'x':template.x + offsetX, 'y': template.y + offsetY}, {'offset': {'y': -7}, 'gridUnits': true})
            .stretchTo({'x':template.x + offsetX, 'y': template.y + offsetY},{ 'offset': {'y':0}, 'gridUnits': true})
            .zIndex(6)

            .play();
    }
    Array.from(workflow.targets).forEach(target => {
        new Sequence()
            .wait(1150)

            .effect()
            .from(target)
            .atLocation(target)
            .loopProperty('sprite', 'position.x', {'from': -0.025, 'to': 0.025, 'duration': 75, 'pingPong': true, 'gridUnits': true})
            .fadeIn(100)
            .fadeOut(400)
            .duration(500)
            .scaleToObject(target.document.scale)
            .opacity(0.5)
            .repeats(22,300,300)

            .effect()
            .file('jb2a.impact.008.blue')
            .atLocation(target, {'randomOffset': 1})
            .randomRotation()
            .scaleToObject(2)
            .filter('ColorMatrix', {'saturate': -0.75, 'brightness': 1.5})
            .repeats(22,300,300)

            .play();
    });
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/barbarian/beast/infectiousFury.js




async function infectiousFury_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (!chris.findEffect(workflow.actor, 'Rage')) return;
    let naturalWeapon = workflow.item.flags['chris-premades']?.feature?.formOfTheBeast?.natural;
    if (!naturalWeapon) return;
    let feature = chris.getItem(workflow.actor, 'Infectious Fury');
    if (!feature) return;
    if (!feature.system.uses.value) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'formOfTheBeast', 450);
    if (!queueSetup) return;
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Use ' + feature.name + '?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await feature.update({'system.uses.value': feature.system.uses.value - 1});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature, config, options);
    queue_queue.remove(workflow.item.uuid);
}
async function infectiousFury_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size != 1) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'infectiousFuryItem', 50);
    if (!queueSetup) return;
    let selection = await chris.dialog(workflow.item.name, [['Attack a Nearby Target', false], ['Take Damage', 'damage']], 'How do you curse your target?') ?? 'damage';
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let damageRoll = await new Roll('2d12[' + translate.damageType('psychic') + ']').roll({async: true});
    await chris.applyWorkflowDamage(workflow.token, damageRoll, 'psychic', [workflow.targets.first()], workflow.item.name, workflow.itemCardId);
    queue_queue.remove(workflow.item.uuid);
}
let infectiousFury = {
    'attack': infectiousFury_attack,
    'item': infectiousFury_item
}
;// CONCATENATED MODULE: ./scripts/macros/spells/insectPlague.js



async function insectPlague_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let template = canvas.scene.collections.templates.get(workflow.templateId);
    if (!template) return;
    await template.setFlag('chris-premades', 'template', {
        'name': 'insectPlague',
        'castLevel': workflow.castData.castLevel,
        'saveDC': chris.getSpellDC(workflow.item),
        'macroName': 'insectPlague',
        'templateUuid': template.uuid,
        'turn': 'end',
        'ignoreMove': false,
        'ignoreStart': true
    });
}
async function insectPlague_trigger(token, trigger) {
    let template = await fromUuid(trigger.templateUuid);
    if (!template) return;
    if (chris.inCombat()) {
        let turn = game.combat.round + '-' + game.combat.turn;
        let lastTurn = template.flags['chris-premades']?.spell?.insectPlague?.[token.id]?.turn;
        if (turn === lastTurn) return;
        await template.setFlag('chris-premades', 'spell.insectPlague.' + token.id + '.turn', turn);
    }
    let originUuid = template.flags.dnd5e?.origin;
    if (!originUuid) return;
    let originItem = await fromUuid(originUuid);
    if (!originItem) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Insect Plague - Damage', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Insect Plague - Damage');
    featureData.system.save.dc = trigger.saveDC;
    featureData.system.damage.parts = [
        [
            (trigger.castLevel - 1) + 'd10[' + translate.damageType('piercing') + ']',
            'piercing'
        ]
    ];
    delete featureData._id;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': originItem.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.uuid]);
    await MidiQOL.completeItemUse(feature, config, options);
}
let insectPlague = {
    'item': insectPlague_item,
    'trigger': insectPlague_trigger
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/rogue/inquisitive/insightfulFighting.js

async function insightfulFighting({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    if (chris.findEffect(targetToken.actor, 'Incapacitated')) return;
    let sourceRoll = await workflow.actor.rollSkill('ins');
    let targetRoll = await chris.rollRequest(targetToken, 'skill', 'dec');
    if (targetRoll.total >= sourceRoll.total) return;
    let effectData = {
        'label': 'Insightful Fighting',
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 60
        },
        'changes': [
            {
                'key': 'flags.chris-premades.feature.insightfulFightning.target',
                'mode': 5,
                'value': targetToken.document.uuid,
                'priority': 20
            }
        ]
    }
    let effect = chris.findEffect(workflow.actor, 'Insightful Fighting');
    if (effect) await chris.removeEffect(effect);
    await chris.createEffect(workflow.actor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/paladin/oathOfGlory/inspiringSmite.js

async function inspiringSmite({speaker, actor, token, character, item, args, scope, workflow}) {
    let targets = await chris.findNearby(workflow.token, 30, 'ally');
    if (workflow.token) targets.push(workflow.token);
    if (targets.length === 0) return;
    let classLevels = workflow.actor.classes.paladin?.system.levels;
    if (!classLevels) return;
    let rollFormula = '2d8[temphp] + ' + classLevels;
    let damageRoll = await new Roll(String(rollFormula)).evaluate({async: true});
    damageRoll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: workflow.item.name
    });
    let buttons = [
        {
            'label': 'Ok',
            'value': true
        }, {
            'label': 'Cancel',
            'value': false
        }
    ];
    let selection = await chris.selectTarget('Who is getting healing? (Max: ' + damageRoll.total + ')', buttons, targets, null, 'number');
    if (!selection.buttons) return;
    let total = 0;
    for (let i of selection.inputs) {
        if (!isNaN(i)) total += i;
    }
    if (total > damageRoll.total) {
        ui.notifications.info('You can\'t heal that much!');
        return;
    }
    let count = 0;
    for (let i of targets) {
        if (!isNaN(selection.inputs[count])) {
            await chris.applyDamage([i], selection.inputs[count], 'temphp');
            new Sequence().effect().atLocation(i).file('jb2a.cure_wounds.400px.blue').play();
        }
        count++;
    }
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/intellectDevourer/bodyThief.js

async function bodyThief({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetActor = workflow.targets.first().actor;
    let actorCheck = await workflow.actor.rollAbilityTest('int');
    let targetCheck = await targetActor.rollAbilityTest('int');
    if (actorCheck.total <= targetCheck.total) return;
    let effectData = {
        'label': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 604800
        }
    };
    await chris.createEffect(targetActor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/intellectDevourer/devourIntellect.js

async function devourIntellect({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size != 1) return;
    let roll = await new Roll('3d6').roll({async: true});
    roll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: workflow.item.name
    });
    let targetActor = workflow.targets.first().actor;
    if (targetActor.system.abilities.int.value > roll.total) return;
    let effectData = {
        'label': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 604800
        },
        'changes': [
            {
                'key': 'system.abilities.int.value',
                'mode': 3,
                'value': '0',
                'priority': 20
            },
            {
                "key": "macro.CE",
                "mode": 0,
                "value": "Stunned",
                "priority": 20
            },
            {
                "key": "macro.CE",
                "mode": 0,
                "value": "Incapacitated",
                "priority": 20
            }
        ]
    };
    await chris.createEffect(targetActor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/intellectDevourer/intellectDevourer.js


let intellectDevourer = {
    'devourIntellect': devourIntellect,
    'bodyThief': bodyThief
}
;// CONCATENATED MODULE: ./scripts/macros/spells/investitureOfFlame.js




async function investitureOfFlame_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.token) return;
    async function effectMacro() {
        await warpgate.revert(token.document, 'Investiture of Flame');
        await chrisPremades.tokenMove.remove('investitureOfFlame', token.id);
        let animation = chrisPremades.helpers.getConfiguration(origin, 'animation') ?? chrisPremades.helpers.jb2aCheck() === 'patreon';
        if (!animation) return;
        await Sequencer.EffectManager.endEffects({'name': 'Investiture of Flame', 'object': token});
    }
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Investiture of Flame - Fire', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Investiture of Flame - Fire');
    featureData.system.save.dc = chris.getSpellDC(workflow.item);
    featureData.flags['chris-premades'] = {
        'spell': {
            'castData': {
                'baseLevel': 6,
                'castLevel': workflow.castData.castLevel,
                'school': 'trs'
            }
        }
    }
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 600
        },
        'changes': [
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'value': 'cold',
                'priority': 20
            },
            {
                'key': 'system.traits.di.value',
                'mode': 0,
                'value': 'fire',
                'priority': 20
            },
            {
                'key': 'ATL.light.dim',
                'mode': 4,
                'value': '60',
                'priority': 20
            },
            {
                'key': 'ATL.light.bright',
                'mode': 4,
                'value': '30',
                'priority': 20
            }
        ],
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            },
            'autoanimations': {
                'isEnabled': false,
                'version': 5
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Investiture of Flame',
        'description': 'Investiture of Flame'
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
    let castLevel = workflow.castData.castLevel;
    let spellDC = chris.getSpellDC(workflow.item);
    let sourceTokenID = workflow.token.id;
    let range = 5;
    let damage = '4d8';
    let damageType = 'fire';
    let effect = chris.findEffect(workflow.actor, workflow.item.name);
    if (!effect) return;
    await tokenMove.add('investitureOfFlame', castLevel, spellDC, damage, damageType, sourceTokenID, range, true, true, 'end', effect.uuid);
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? chris.jb2aCheck() === 'patreon';
    if (!animation) return;
    await fireShield.animation(workflow.token, 'fire', 'Investiture of Flame');
}
async function investitureOfFlame_moved(token, castLevel, spellDC, damage, damageType, sourceTokenID, reason) {
    let doDamage = false;
    if (!chris.inCombat()) {
        doDamage = true;
    } else {
        let turnName = reason === 'move' ? 'current' : 'previous';
        let combatant = game.combat.combatants.get(game.combat[turnName].combatantId);
        let lastTriggerTurn = combatant.flags?.['chris-premades']?.spell?.investitureOfFlame?.[sourceTokenID]?.lastTriggerTurn;
        let currentTurn = game.combat[turnName].round + '-' + game.combat[turnName].turn;
        if (!lastTriggerTurn || lastTriggerTurn != currentTurn) {
            doDamage = true;
            await combatant.setFlag('chris-premades', 'spell.investitureOfFlame.' + sourceTokenID + '.lastTriggerTurn', currentTurn);
        }
    }
    if (!doDamage) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Investiture of Flame - Heat', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Investiture of Flame - Heat');
    featureData.system.save.dc = spellDC;
    featureData.flags['chris-premades'] = {
        'spell': {
            'castData': {
                'baseLevel': 6,
                'castLevel': castLevel,
                'school': 'trs'
            }
        }
    }
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.uuid]);
    let sourceToken = canvas.tokens.get(sourceTokenID);
    if (!sourceToken) return;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': sourceToken.actor});
    await MidiQOL.completeItemUse(feature, config, options);
}
let investitureOfFlame = {
    'item': investitureOfFlame_item,
    'moved': investitureOfFlame_moved
}
;// CONCATENATED MODULE: ./scripts/macros/spells/investitureOfIce.js


async function investitureOfIce({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.token) return;
    async function effectMacro() {
        await warpgate.revert(token.document, 'Investiture of Ice');
        let animation = chrisPremades.helpers.getConfiguration(origin, 'animation') ?? chrisPremades.helpers.jb2aCheck() === 'patreon';
        if (!animation) return;
        await Sequencer.EffectManager.endEffects({'name': 'Investiture of Ice', 'object': token});
    }
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Investiture of Ice - Cone', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Investiture of Ice - Cone');
    featureData.system.save.dc = chris.getSpellDC(workflow.item);
    featureData.flags['chris-premades'] = {
        'spell': {
            'castData': {
                'baseLevel': 6,
                'castLevel': workflow.castData.castLevel,
                'school': 'trs'
            }
        }
    }
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 600
        },
        'changes': [
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'value': 'fire',
                'priority': 20
            },
            {
                'key': 'system.traits.di.value',
                'mode': 0,
                'value': 'cold',
                'priority': 20
            }
        ],
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            },
            'autoanimations': {
                'isEnabled': false,
                'version': 5
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Investiture of Ice',
        'description': 'Investiture of Ice'
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? chris.jb2aCheck() === 'patreon';
    if (!animation) return;
    await fireShield.animation(workflow.token, 'cold', 'Investiture of Ice');
}
;// CONCATENATED MODULE: ./scripts/macros/spells/investitureOfStone.js

async function investitureOfStone({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.token) return;
    async function effectMacro() {
        await warpgate.revert(token.document, 'Investiture of Stone');
    }
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Investiture of Stone - Earthquake', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Investiture of Stone - Earthquake');
    featureData.system.save.dc = chris.getSpellDC(workflow.item);
    featureData.flags['chris-premades'] = {
        'spell': {
            'castData': {
                'baseLevel': 6,
                'castLevel': workflow.castData.castLevel,
                'school': 'trs'
            }
        }
    }
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 600
        },
        'changes': [
            {
                'key': 'system.traits.dr.custom',
                'mode': 0,
                'value': 'Non-Magical Physical',
                'priority': 20
            }
        ],
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Investiture of Stone',
        'description': 'Investiture of Stone'
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/warlock/invocations/investmentOfTheChainMaster.js

async function reaction({speaker, actor, token, character, item, args, scope, workflow}) {
    let reactionEffect = chris.findEffect(workflow.actor, 'Reaction');
    if (reactionEffect) await chris.removeEffect(reactionEffect);
    let effect = chris.findEffect(workflow.actor, 'Summoned Creature');
    if (!effect) return;
    let origin = await fromUuid(effect.origin);
    if (!origin) return;
    await chris.addCondition(origin.actor, 'Reaction');
    await workflow.item.update({'system.uses.max': 1});
}
async function investmentOfTheChainMaster_turnStart(effect) {
    let familiarId = effect.flags['chris-premades']?.summons?.ids[effect.name][0];
    if (!familiarId) return;
    let familiarToken = canvas.scene.tokens.get(familiarId);
    if (!familiarToken) return;
    let targetItem = familiarToken.actor.items.find(i => i.name === 'Investment of the Chain Master - Familiar Resistance');
    if (!targetItem) return;
    await targetItem.update({'system.uses.max': 0});
}
let investmentOfTheChainMaster = {
    'reaction': reaction,
    'turnStart': investmentOfTheChainMaster_turnStart
}
;// CONCATENATED MODULE: ./scripts/macros/items/javelinOfLightning.js




async function javelinOfLightning({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.item.system.uses.value || !workflow.targets.size) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'javelinOfLightning', 50);
    if (!queueSetup) return;
    let selection = await chris.dialog(workflow.item.name, constants_constants.yesNo, 'Use ' + workflow.item.name + '?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await workflow.item.update({'system.uses.value': 0});
    let targetToken = workflow.targets.first();
    let ray = new Ray(workflow.token.center, targetToken.center);
    if (ray.distance === 0) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let templateData = {
        'angle': 0,
        'direction': Math.toDegrees(ray.angle),
        'distance': ray.distance / canvas.scene.grid.size * 5,
        'x': ray.A.x,
        'y': ray.A.y,
        't': 'ray',
        'user': game.user,
        'fillColor': game.user.color,
        'width': 5
    };
    let bonusDamageFormula = '4d6[' + translate.damageType('lightning') + ']';
    if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
    let damageFormula = workflow.damageRoll._formula + ' + ' + bonusDamageFormula;
    let damageRoll = await new Roll(damageFormula).roll({'async': true});
    await workflow.setDamageRoll(damageRoll);
    let {template, tokens} = await chris.createTemplate(templateData, true);
    let effectData = {
        'name': workflow.item.name + ' Bolt Template',
        'icon': workflow.item.img,
        'changes': [
            {
                'key': 'flags.dae.deleteUuid',
                'mode': 5,
                'priority': 20,
                'value': template.uuid
            }
        ],
        'duration': {
            'seconds': 1
        }
    };
    new Sequence()
        .effect()
        .atLocation(workflow.token)
        .stretchTo(targetToken)
        .file('jb2a.lightning_bolt.wide.blue')
        .play();
    await chris.createEffect(workflow.actor, effectData);
    let targets = tokens.filter(i => i.uuid != workflow.token.document.uuid && i.uuid != targetToken.document.uuid);
    if (!targets.length) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Item Features', 'Javelin of Lightning - Bolt', false);
    if (!featureData) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Javelin of Lightning - Bolt');
    delete featureData._id;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions(targets.map(i => i.uuid));
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature, config, options);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/kobold/packTactics.js


async function pactTactics({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let nearbyTargets = chris.findNearby(workflow.targets.first(), 5, 'enemy', false).filter(i => i.document.uuid != workflow.token.document.uuid);
    if (nearbyTargets.length === 0) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'pactTactics', 150);
    if (!queueSetup) return;
    workflow.advantage = true;
    workflow.attackAdvAttribution.add('Advantage: Pack Tactics');
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/kobold/kobold.js

let kobold = {
    'packTactics': pactTactics
}
;// CONCATENATED MODULE: ./scripts/macros/raceFeatures/minotaur/labyrinthineRecall.js
function labyrinthineRecall(skillId, options) {
    return skillId != 'sur' ? false : {'label': 'This check is to navigate or track.', 'type': 'advantage'};
}
;// CONCATENATED MODULE: ./scripts/macros/items/lanternOfRevealing.js


async function lanternOfRevealing_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Lantern Of Revealing - Aura');
    let mode = effect?.flags?.['chris-premades']?.item?.lanternOfRevealing?.mode;
    let options = [];
    if (mode != 'bright') options.push(['Light Lantern (Bright)', 'bright']);
    if (mode != 'dim') options.push(['Light Lantern (Dim)', 'dim']);
    if (mode != 'extinguish') options.push(['Extinguish', 'extinguish']);
    let selection = await chris.dialog('Lantern of Revealing', options);
    if (!selection) return;
    let effectData;
    switch (selection) {
        case 'bright':
            if (effect) {
                if (mode === 'bright') return;
                await chris.removeEffect(effect);
            }
            async function effectMacro() {
                await chrisPremades.macros.lanternOfRevealing.end(token);
            }
            effectData = {
                'name': 'Lantern Of Revealing - Aura',
                'icon': workflow.item.img,
                'duration': {
                    'seconds': 21600
                },
                'origin': workflow.item.uuid,
                'changes': [
                    {
                        'key': 'ATL.light.dim',
                        'mode': 4,
                        'value': 60,
                        'priority': 20
                    },
                    {
                        'key': 'ATL.light.bright',
                        'mode': 4,
                        'value': 30,
                        'priority': 20
                    },
                    {
                        'key': 'flags.chris-premades.aura.lanternOfRevealing.name',
                        'mode': 5,
                        'value': 'lanternOfRevealing',
                        'priority': 20
                    },
                    {
                        'key': 'flags.chris-premades.aura.lanternOfRevealing.castLevel',
                        'mode': 5,
                        'value': 1,
                        'priority': 20
                    },
                    {
                        'key': 'flags.chris-premades.aura.lanternOfRevealing.range',
                        'mode': 5,
                        'value': 30,
                        'priority': 20
                    },
                    {
                        'key': 'flags.chris-premades.aura.lanternOfRevealing.disposition',
                        'mode': 5,
                        'value': 'all',
                        'priority': 20
                    },
                    {
                        'key': 'flags.chris-premades.aura.lanternOfRevealing.effectName',
                        'mode': 5,
                        'value': 'Lantern Of Revealing - Revealed',
                        'priority': 20
                    },
                    {
                        'key': 'flags.chris-premades.aura.lanternOfRevealing.macroName',
                        'mode': 5,
                        'value': 'lanternOfRevealing',
                        'priority': 20
                    }
                ],
                'flags': {
                    'effectmacro': {
                        'onDelete': {
                            'script': chris.functionToString(effectMacro)
                        }
                    },
                    'chris-premades': {
                        'item': {
                            'lanternOfRevealing': {
                                'mode': 'bright'
                            }
                        }
                    }
                }
            };
            await chris.createEffect(workflow.actor, effectData);
            let flagAuras = {
                'lanternOfRevealing': {
                    'name': 'lanternOfRevealing',
                    'castLevel': 1,
                    'range': 30,
                    'disposition': 'all',
                    'effectName': 'Lantern Of Revealing - Revealed',
                    'macroName': 'lanternOfRevealing'
                }
            }
            effectAuras.add(flagAuras, workflow.token.document.uuid, true);
            return;
        case 'dim':
            if (effect) {
                if (mode === 'dim') return;
                await chris.removeEffect(effect);
            }
            effectData = {
                'name': 'Lantern Of Revealing - Aura',
                'icon': workflow.item.img,
                'duration': {
                    'seconds': 21600
                },
                'origin': workflow.item.uuid,
                'changes': [
                    {
                        'key': 'ATL.light.dim',
                        'mode': 4,
                        'value': 5,
                        'priority': 20
                    }
                ],
                'flags': {
                    'chris-premades': {
                        'item': {
                            'lanternOfRevealing': {
                                'mode': 'dim'
                            }
                        }
                    }
                }
            };
            await chris.createEffect(workflow.actor, effectData);
            return;
        case 'extinguish':
            if (effect) await chris.removeEffect(effect);
            return;
    }
}
async function lanternOfRevealing_aura(token, selectedAura) {
    let originToken = await fromUuid(selectedAura.tokenUuid);
    if (!originToken) return;
    let originActor = originToken.actor;
    let auraEffect = chris.findEffect(originActor, 'Lantern Of Revealing - Aura');
    if (!auraEffect) return;
    let originItem = await fromUuid(auraEffect.origin);
    if (!originItem) return;
    let effectData = {
        'name': 'Lantern Of Revealing - Revealed',
        'icon': originItem.img,
        'origin': originItem.uuid,
        'duration': {
            'seconds': 604800
        },
        'changes': [
            {
                'key': 'system.traits.ci.value',
                'value': 'invisible',
                'mode': 0,
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'aura': true,
                'effect': {
                    'noAnimation': true
                }
            }
        }
    }
    let effect = chris.findEffect(token.actor, effectData.name);
    if (effect?.origin === effectData.origin) return;
    if (effect) chris.removeEffect(effect);
    await chris.createEffect(token.actor, effectData);
}
async function lanternOfRevealing_end(token) {
    effectAuras.remove('lanternOfRevealing', token.document.uuid);
}
let lanternOfRevealing = {
    'item': lanternOfRevealing_item,
    'aura': lanternOfRevealing_aura,
    'end': lanternOfRevealing_end
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/fighter/echoKnight/legionOfOne.js

async function legionOfOne(actor) {
    let item = chris.getItem(actor, 'Unleash Incarnation');
    if (!item?.system?.uses?.value) return;
    await item.update({'system.uses.value': 1});
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/leucrotta/leucrotta.js

let leucrotta = {
    'stench': stench
}
;// CONCATENATED MODULE: ./scripts/macros/spells/lifeTransference.js


async function lifeTransference({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let damageFormula = (workflow.castData.castLevel + 1) + 'd8[none]';
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    damageRoll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: workflow.item.name
    });
    await chris.applyDamage(workflow.token, damageRoll.total, 'none');
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'lifeTransference', 50);
    if (!queueSetup) return;
    let healing = damageRoll.total * 2;
    let healingRoll = await new Roll(healing + '[healing]').roll({async: true});
    await workflow.setDamageRoll(healingRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/lightningArrow.js



async function lightningArrowDamage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.item.name === 'Lightning Arrow - Burst') return;
    if (workflow.targets.size != 1) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'lightningArrow', 50);
    if (!queueSetup) return;
    let targetToken = workflow.targets.first();
    if (!(workflow.item.system.properties?.thr || workflow.item.system.actionType === 'rwak')) return;
    let diceNumber = 4;
    let itemAbility = workflow.item.system.ability;
    if (itemAbility === '') {
        itemAbility = 'str';
        if (workflow.item.system.properties?.fin && workflow.actor.system.abilities.dex.mod > workflow.actor.system.abilities.str) itemAbility = 'dex';
    }
    let modifier = workflow.actor.system.abilities[itemAbility].mod;
    let damageFormula = diceNumber + 'd8[lightning] + ' + modifier;
    let effect = chris.findEffect(workflow.actor, 'Lightning Arrow');
    let castLevel = 3;
    if (effect) {
        castLevel = effect.flags['midi-qol'].castData.castLevel;
        let extraDiceNumber = castLevel - 3;
        if (castLevel > 3) damageFormula = damageFormula + ' + ' + extraDiceNumber + 'd8[lightning]';
    }
    if (workflow.isCritical) damageFormula = chris.getCriticalFormula(damageFormula);
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    if (workflow.hitTargets.size === 0) await chris.applyDamage([targetToken], Math.floor(damageRoll.total / 2), 'lightning');
    let itemData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Lightning Arrow - Burst', false);
    if (!itemData) {
        if (effect) effect.delete();
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let saveDiceNumber = castLevel - 1;
    itemData.system.damage.parts = [
        [
            saveDiceNumber + 'd8[lightning]',
            'lightning'
        ]
    ];
    if (effect) {
        let originItem = await fromUuid(effect.origin);
        itemData.system.save.dc = chris.getSpellDC(originItem);
    }
    itemData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Lightning Arrow - Burst');
    itemData.flags['chris-premades'] = {
        'spell': {
            'castData': workflow.castData
        }
    }
    itemData.flags['chris-premades'].spell.castData.school = workflow.item.system.school;
    let areaFeature = new CONFIG.Item.documentClass(itemData, {'parent': workflow.actor});
    let newTargets = chris.findNearby(targetToken, 10, null);
    let newTargetUuids =[];
    new Sequence().effect().atLocation(workflow.token).stretchTo(targetToken).file('jb2a.chain_lightning.secondary.blue').play();
    for (let i of newTargets) {
        newTargetUuids.push(i.document.uuid);
        new Sequence().effect().atLocation(targetToken).stretchTo(i).file('jb2a.chain_lightning.secondary.blue').play();
    }
    let [config, options] = constants_constants.syntheticItemWorkflowOptions(newTargetUuids);
    await MidiQOL.completeItemUse(areaFeature, config, options);
    if (effect) effect.delete();
    queue_queue.remove(workflow.item.uuid);
}
async function lightningArrowAttack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.isFumble) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'lightningArrow', 50);
    if (!queueSetup) return;
    workflow.isFumble = false;
    let updatedRoll = await new Roll('-100').evaluate({async: true});
    workflow.setAttackRoll(updatedRoll);
    queue_queue.remove(workflow.item.uuid);
}
let lightningArrow = {
    'attack': lightningArrowAttack,
    'damage': lightningArrowDamage
}
;// CONCATENATED MODULE: ./scripts/macros/spells/lightningLure.js


async function lightningLure({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'lightningLure', 50);
    if (!queueSetup) return;
    let target = workflow.targets.first();
    let sourceToken = workflow.token;
    let useAnimation = chris.getConfiguration(workflow.item, 'animation') ?? chris.aseCheck();
    let mDistance = chris.getDistance(workflow.token, target);
    let pullDistance = 0;
    if (workflow.failedSaves.size) {
        if (mDistance >= 0 && mDistance <= 5) {
            pullDistance = 0;
        } else if (mDistance > 5 && mDistance <= 10) {
            pullDistance = -5;
        } else {
            pullDistance = -10;
        }
    }
    if (!useAnimation && workflow.failedSaves.size) {
        await chris.pushToken(sourceToken, target, pullDistance);
    } else if (!useAnimation && !workflow.failedSaves.size) {
        queue_queue.remove(workflow.item.uuid);
        return;
    } else {
        let position = chris.getGridBetweenTokens(sourceToken, target, pullDistance);
        await new Sequence()
            .effect()
            .atLocation(sourceToken)
            .file('animated-spell-effects-cartoon.electricity.discharge.03')
            .stretchTo(target, {'attachTo': true})
            .delay(0)
            .filter('ColorMatrix', {'saturate':1, 'hue': 25})
            .scaleIn(0, 750, {'ease': 'easeOutQuint'})
            .repeats(2, 600, 600)

            .wait(250)

            .effect()
            .file('animated-spell-effects-cartoon.electricity.25')
            .atLocation(target)
            .scaleToObject(2 * target.document.width)
            .playbackRate(1)
            .spriteRotation(90)
            .mirrorX()
            .filter('ColorMatrix', {'saturate': 1, 'hue': -15})
            .moveTowards({'x': position.x + (canvas.grid.size * target.document.width) / 2, 'y': position.y + (canvas.grid.size * target.document.height) / 2}, {'ease': 'easeInOutBack', 'rotate': false})
            .zIndex(2)

            .animation()
            .on(target)
            .opacity(0)

            .animation()
            .on(target)
            .moveTowards({'x': position.x, 'y': position.y})
            .opacity(0)
            .delay(250)

            .effect()
            .from(target)
            .atLocation(target)
            .moveTowards({'x': position.x + (canvas.grid.size * target.document.width) / 2, 'y': position.y + (canvas.grid.size * target.document.height) / 2 }, {'ease': 'easeInOutBack', 'rotate': false})
            .zIndex(0.1)
            .scaleToObject(target.document.texture.scaleX * target.document.width)
            .extraEndDuration(500)
            .waitUntilFinished(-300)

            .animation()
            .on(target)
            .fadeIn(250)
            .opacity(1)

            .effect()
            .from(target)
            .atLocation(target)
            .loopProperty('sprite', 'position.x', {'from': -0.05, 'to': 0.05, 'duration': 75, 'pingPong': true, 'gridUnits': true})
            .scaleToObject(target.document.texture.scaleX)
            .delay(250)
            .opacity(0.5)
            .playIf(() => {
                let distanceToTargetX = Math.abs(sourceToken.x - position.x);
                let distanceToTargetY = Math.abs(sourceToken.y - position.y);
                return distanceToTargetX <= canvas.grid.size && distanceToTargetY <= canvas.grid.size;
            })

            .effect()
            .file('animated-spell-effects-cartoon.electricity.19')
            .atLocation(sourceToken)
            .scaleToObject(2)
            .rotateTowards(target)
            .filter('ColorMatrix', {'saturate':1, 'hue': -15 })
            .zIndex(0.2)
            .playIf(() => {
                let distanceToTargetX = Math.abs(sourceToken.x - position.x);
                let distanceToTargetY = Math.abs(sourceToken.y - position.y);
                return distanceToTargetX <= canvas.grid.size && distanceToTargetY <= canvas.grid.size;
            })

            .play();
    }
    let fDistance = chris.getDistance(workflow.token, target);
    if (fDistance > 5) {
        workflow.damageItem.appliedDamage = 0;
        workflow.damageItem.hpDamage = 0;
        workflow.damageItem.newHP = workflow.damageItem.oldHP;
        workflow.damageItem.newTempHP = workflow.damageItem.oldTempHP;
        workflow.damageItem.tempDamage = 0;
        workflow.damageItem.totalDamage = 0;
    }
    queue_queue.remove(workflow.item.uuid);
}

;// CONCATENATED MODULE: ./scripts/macros/raceFeatures/bugbear/longLimbed.js

async function longLimbed(origin, actor) {
    let effectData = {
        'icon': origin.img,
        'origin': origin.uuid,
        'duration': {
            'seconds': 1
        },
        'name': origin.name,
        'changes': [
            {
                'key': 'flags.midi-qol.range.mwak',
                'mode': 2,
                'value': '+5',
                'priority': 20
            }
        ],
        'transfer': true
    };
    await chris.createEffect(actor, effectData);
    if (chris.getConfiguration(origin, 'displaycard') ?? true) await origin.displayCard();
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/warlock/invocations/maddeningHex.js

async function maddeningHex({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targets = chris.findNearby(workflow.targets.first(), 5, 'ally');
    if (targets.length === 0) return;
    await chris.applyDamage(targets, workflow.damageTotal, workflow.defaultDamageType);
}
;// CONCATENATED MODULE: ./scripts/macros/feats/maelstromAura.js



async function maelstromAura(token, origin) {
    console.log('here');
    let targetToken = game.canvas.tokens.get(game.combat.current.tokenId);
    if (!targetToken) return;
    console.log('here');
    if (targetToken.document.disposition === token.document.disposition) return;
    console.log('here');
    let distance = chris.getDistance(token, targetToken);
    if (distance > 10) return;
    console.log('here');
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Feat Features', 'Maelstrom Aura', false);
    if (!featureData) return;
    console.log('here');
    featureData.system.save.dc = chris.getSpellDC(origin);
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Maelstrom Aura');
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': token.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.document.uuid]);
    let queueSetup = await queue_queue.setup(origin.uuid, 'maelstromAura', 50);
    if (!queueSetup) return;
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature, config, options);
    queue_queue.remove(origin.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/magicMissile.js


async function magicMissile({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size === 0) return;
    let maxMissiles = 3 + (workflow.castData.castLevel - 1);
    let targets = Array.from(workflow.targets);
    let selection = await chris.selectTarget('How many? (Max: ' + maxMissiles + ')', constants_constants.okCancel, targets, true, 'number');
    if (!selection.buttons) return;
    let total = 0;
    for (let i of selection.inputs) {
        if (!isNaN(i)) total += i;
    }
    if (total > maxMissiles) {
        ui.notifications.info('You can\'t use that many missiles!');
        return;
    }
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Magic Missile Bolt', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Magic Missile Bolt');
    featureData.flags['chris-premades'] = {
        'spell': {
            'castData': workflow.castData
        }
    };
    featureData.flags['chris-premades'].spell.castData.school = workflow.item.system.school;
    delete featureData._id;
    if (!game.settings.get('chris-premades', 'Magic Missile Toggle') && !chris.getConfiguration(workflow.item, 'homebrew')) {
        let damageFormula = '1d4[force] + 1';
        if (chris.getItem(workflow.actor, 'Empowered Evocation')) damageFormula += ' + ' + workflow.actor.system.abilities.int.mod;
        let damageRoll = await new Roll(damageFormula).roll({async: true});
        damageRoll.toMessage({
            rollMode: 'roll',
            speaker: {alias: name},
            flavor: workflow.item.name
        });
        featureData.system.damage.parts = [
            [
                damageRoll.total + '[force]',
                'force'
            ]
        ];
    }
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([]);
    let colors = [
        'grey',
        'dark_red',
        'orange',
        'yellow',
        'green',
        'blue',
        'purple'
    ];
    let colorSelection = chris.getConfiguration(workflow.item, 'color') ?? 'purple';
    if (colorSelection === 'random' || colorSelection === 'cycle') await Sequencer.Preloader.preload('jb2a.magic_missile');
    let lastColor = Math.floor(Math.random() * colors.length);
    for (let i = 0; i < selection.inputs.length; i++) {
        if (isNaN(selection.inputs[i]) || selection.inputs[i] === 0) continue;
        options.targetUuids = [targets[i].document.uuid];
        for (let j = 0; j < selection.inputs[i]; j++) {
            let path = 'jb2a.magic_missile.';
            if (colorSelection === 'random') {
                path += colors[Math.floor((Math.random() * colors.length))];
            } else if (colorSelection === 'cycle') {
                path += colors[lastColor];
                lastColor++;
                if (lastColor >= colors.length) lastColor = 0;
            } else {
                path += colorSelection;
            }
            new Sequence().effect().file(path).atLocation(workflow.token).stretchTo(targets[i]).randomizeMirrorY().play();
            await MidiQOL.completeItemUse(feature, config, options);
        }
    }
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/fighter/battleMaster/maneuvers.js




async function baitAndSwitch({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    if (targetToken.id === workflow.token.id) return;
    let selection = await chris.dialog('Who gets the AC bonus?', [['Yourself', false], ['Target', true]]);
    if (selection === undefined) return;
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'changes': [
            {
                'key': 'system.attributes.ac.bonus',
                'mode': 2,
                'value': workflow.damageTotal,
                'priority': 20
            }
        ],
        'duration': {
            'rounds': 1
        },
        'origin': workflow.item.uuid
    };
    let sourceToken = workflow.token;
    let sourceUpdate = {
        'token': {
            'x': targetToken.x,
            'y': targetToken.y
        }
    };
    let targetUpdate = {
        'token': {
            'x': sourceToken.x,
            'y': sourceToken.y
        }
    };
    if (selection) {
        targetUpdate['embedded'] = {
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    } else {
        sourceUpdate['embedded'] = {
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    }
    let options = {
        'permanent': true,
        'name': workflow.item.name,
        'description': workflow.item.name
    };
    await warpgate.mutate(sourceToken.document, sourceUpdate, {}, options);
    await warpgate.mutate(targetToken.document, targetUpdate, {}, options);
}
async function refund({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 0) return;
    let originItem = chris.getItem(workflow.actor, 'Superiority Dice');
    if (!originItem) return;
    await originItem.update({'system.uses.value': originItem.system.uses.value + 1});
}
async function distractingStrike({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Maneuvers: Distracting Strike');
    if (!effect) return;
    if (workflow.hitTargets.size === 0) {
        await refund.bind(this)({speaker, actor, token, character, item, args, scope, workflow});
        await chris.removeEffect(effect);
        return;
    }
    let targetToken = workflow.hitTargets.first();
    let effectData = {
        'name': effect.name,
        'icon': effect.icon,
        'changes': [
            {
                'key': 'flags.midi-qol.grants.advantage.attack.all',
                'mode': 0,
                'value': 'workflow.token.id != "' + workflow.token.id + '"',
                'priority': 20
            },
            {
                'key': 'flags.chris-premades.feature.onHit.distractingStrike',
                'mode': 5,
                'value': true,
                'priority': 20
            }
        ],
        'duration': {
            'rounds': 1
        },
        'flags': {
            'dae': {
                'specialDuration': [
                    'turnStartSource'
                ]
            }
        },
        'origin': workflow.actor.uuid
    };
    await chris.createEffect(targetToken.actor, effectData);
    await chris.removeEffect(effect);
}
async function distractingStrikeOnHit(workflow, targetToken) {
    if (workflow.hitTargets.size != 1) return;
    let effect = chris.findEffect(targetToken.actor, 'Maneuvers: Distracting Strike');
    if (!effect) return;
    if (effect.origin === workflow.actor.uuid) return;
    await chris.removeEffect(effect);
}
async function goadingAttack({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Maneuvers: Goading Attack');
    if (!effect) return;
    if (workflow.hitTargets.size === 0) {
        await refund.bind(this)({speaker, actor, token, character, item, args, scope, workflow});
        await chris.removeEffect(effect);
        return;
    } else {
        let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Maneuvers: Goading Attack', false);
        if (!featureData) return;
        featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Maneuvers: Goading Attack');
        let originItem = await fromUuid(effect.origin);
        if (!originItem) return;
        featureData.system.save.dc = chris.getSpellDC(originItem);
        let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
        await chris.removeEffect(effect);
        let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
        await MidiQOL.completeItemUse(feature, config, options);
    }
}
async function goadingAttackTarget({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let sourceId = workflow.actor.flags['chris-premades']?.feature?.goadingAttack;
    if (!sourceId) return;
    if (sourceId === workflow.targets.first().id) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'goadingAttack', 50);
    if (!queueSetup) return;
    workflow.disadvantage = true;
    workflow.attackAdvAttribution.add('Disadvantage: Goading Attack');
    queue_queue.remove(workflow.item.uuid);
}
async function lungingAttack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let generatedMenu = [];
    workflow.actor.items.forEach(item => {
        if (item.type === 'weapon' && item.system.equipped === true) {
            generatedMenu.push([item.name, item.id]);
        }
    });
    let selection;
    if (generatedMenu.length === 0) return;
    if (generatedMenu.length === 1) selection = generatedMenu[0][1];
    if (!selection) selection = await chris.dialog('What weapon?', generatedMenu);
    if (!selection) return;
    let weaponData = duplicate(workflow.actor.items.get(selection).toObject());
    weaponData.system.range.value += 5;
    let weapon = new CONFIG.Item.documentClass(weaponData, {'parent': workflow.actor});
    let options = {
        'targetUuids': [workflow.targets.first().document.uuid],
        'workflowOptions': {
            'autoRollDamage': 'always',
            'autoFastDamage': true
        }
    };
    await MidiQOL.completeItemUse(weapon, {}, options);
}
async function menacingAttack({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Maneuvers: Menacing Attack');
    if (!effect) return;
    if (workflow.hitTargets.size === 0) {
        await refund.bind(this)({speaker, actor, token, character, item, args, scope, workflow});
        await chris.removeEffect(effect);
        return;
    } else {
        let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Maneuvers: Menacing Attack', false);
        if (!featureData) return;
        featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Maneuvers: Menacing Attack');
        let originItem = await fromUuid(effect.origin);
        if (!originItem) return;
        featureData.system.save.dc = chris.getSpellDC(originItem);
        let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
        let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
        await chris.removeEffect(effect);
        await MidiQOL.completeItemUse(feature, config, options);
    }
}
async function maneuvers_parry(effect, origin) {
    let changeValue = Number(effect.changes[0].value.substring(6));
    let diceFormula = origin.actor.system.scale['battle-master']?.['combat-superiority-die']?.formula;
    if (!diceFormula) return;
    let dexMox = origin.actor.system.abilities.dex.mod;
    let roll = await new Roll(dexMox + ' + ' + diceFormula).roll({async: true});
    roll.terms[2].results[0].result = changeValue;
    roll._total = dexMox + changeValue;
    roll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: origin.name
    });
}
async function pushingAttack({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Maneuvers: Pushing Attack');
    if (!effect) return;
    if (workflow.hitTargets.size === 0) {
        await refund.bind(this)({speaker, actor, token, character, item, args, scope, workflow});
        await chris.removeEffect(effect);
        return;
    } else {
        let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Maneuvers: Pushing Attack', false);
        if (!featureData) return;
        featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Maneuvers: Pushing Attack');
        let originItem = await fromUuid(effect.origin);
        if (!originItem) return;
        featureData.system.save.dc = chris.getSpellDC(originItem);
        let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
        let targetToken = workflow.targets.first();
        let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.document.uuid]);
        await chris.removeEffect(effect);
        let pushWorkflow = await MidiQOL.completeItemUse(feature, config, options);
        if (pushWorkflow.failedSaves.size != 1) return;
        let selection = await chris.dialog('How far do you push the target?', [['5 ft.', 5], ['10 ft.', 10], ['15 ft.', 15]]);
        if (!selection) return;
        let knockBackFactor;
        let ray;
        let newCenter;
        let hitsWall = true;
        while (hitsWall) {
            knockBackFactor = selection / canvas.dimensions.distance;
            ray = new Ray(workflow.token.center, targetToken.center);
            if (ray.distance === 0) {
                ui.notifications.info('Target is unable to be moved!');
                return;
            }
            newCenter = ray.project(1 + ((canvas.dimensions.size * knockBackFactor) / ray.distance));
            hitsWall = targetToken.checkCollision(newCenter, {origin: ray.A, type: "move", mode: "any"});
            if (hitsWall) {
                selection -= 5;
                if (selection === 0) {
                    ui.notifications.info('Target is unable to be moved!');
                    return;
                }
            }
        }
        newCenter = canvas.grid.getSnappedPosition(newCenter.x - targetToken.w / 2, newCenter.y - targetToken.h / 2, 1);
        let targetUpdate = {
            'token': {
                'x': newCenter.x,
                'y': newCenter.y
            }
        };
        let options2 = {
            'permanent': true,
            'name': workflow.item.name,
            'description': workflow.item.name
        };
        await warpgate.mutate(targetToken.document, targetUpdate, {}, options2);
    }
}
async function sweepingAttackItem({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Maneuvers: Sweeping Attack');
    if (!effect) return;
    if (workflow.hitTargets.size === 0) {
        await refund.bind(this)({speaker, actor, token, character, item, args, scope, workflow});
        await chris.removeEffect(effect);
        return;
    } else {
        let sourceNearbyTargets = chris.findNearby(workflow.token, 5, 'enemy');
        let targetNearbyTargets = chris.findNearby(workflow.targets.first(), 5, 'ally');
        if (sourceNearbyTargets.length === 0 || targetNearbyTargets.length === 0) {
            await refund.bind(this)({speaker, actor, token, character, item, args, scope, workflow});
            await chris.removeEffect(effect);
            return;
        }
        let overlappingTargets = targetNearbyTargets.filter(function (obj) {
            return sourceNearbyTargets.indexOf(obj) !== -1;
        });
        if (overlappingTargets.length === 0) {
            await refund.bind(this)({speaker, actor, token, character, item, args, scope, workflow});
            await chris.removeEffect(effect);
            return;
        }
        let selection = await chris.selectTarget('What target?', constants_constants.okCancel, overlappingTargets, true, 'one');
        if (selection.buttons === false) {
            await refund.bind(this)({speaker, actor, token, character, item, args, scope, workflow});
            await chris.removeEffect(effect);
            return;
        }
        let targetTokenID = selection.inputs.find(id => id != false);
        if (!targetTokenID) {
            await refund.bind(this)({speaker, actor, token, character, item, args, scope, workflow});
            await chris.removeEffect(effect);
            return;
        }
        let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Maneuvers: Sweeping Attack', false);
        if (!featureData) return;
        featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Maneuvers: Sweeping Attack');
        featureData.flags['chris-premades'] = {
            'feature': {
                'sweepingAttackRoll': workflow.attackTotal
            }
        };
        featureData.system.damage.parts = [
            [
                '@scale.battle-master.combat-superiority-die[' + workflow.defaultDamageType + ']',
                workflow.defaultDamageType
            ]
        ];
        let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
        let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetTokenID]);
        await chris.removeEffect(effect);
        await MidiQOL.completeItemUse(feature, config, options);
    }
}
async function sweepingAttackAttack({speaker, actor, token, character, item, args, scope, workflow}) {
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'sweepingAttack', 50);
    if (!queueSetup) return;
    let attackRoll = workflow.item.flags['chris-premades']?.feature?.sweepingAttackRoll;
    if (!attackRoll) return;
    let updatedRoll = await new Roll(String(attackRoll)).evaluate({async: true});
    workflow.setAttackRoll(updatedRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function tripAttack({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Maneuvers: Trip Attack');
    if (!effect) return;
    if (workflow.hitTargets.size === 0) {
        await refund.bind(this)({speaker, actor, token, character, item, args, scope, workflow});
        await chris.removeEffect(effect);
        return;
    } else {
        let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Maneuvers: Trip Attack', false);
        if (!featureData) return;
        featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Maneuvers: Trip Attack');
        let originItem = await fromUuid(effect.origin);
        if (!originItem) return;
        featureData.system.save.dc = chris.getSpellDC(originItem);
        let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
        let targetToken = workflow.targets.first();
        let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.document.uuid]);
        await chris.removeEffect(effect);
        let tripWorkflow = await MidiQOL.completeItemUse(feature, config, options);
        if (tripWorkflow.failedSaves.size != 1) return;
        let targetEffect = chris.findEffect(targetToken.actor, 'Prone');
        if (targetEffect) return;
        await chris.addCondition(targetToken.actor, 'Prone', false, workflow.item.uuid);
    }
}
let maneuvers = {
    'baitAndSwitch': baitAndSwitch,
    'refund': refund,
    'distractingStrike': distractingStrike,
    'goadingAttackTarget': goadingAttackTarget,
    'goadingAttack': goadingAttack,
    'grapplingStrike': grapple,
    'lungingAttack': lungingAttack,
    'menacingAttack': menacingAttack,
    'parry': maneuvers_parry,
    'pushingAttack': pushingAttack,
    'sweepingAttackItem': sweepingAttackItem,
    'sweepingAttackAttack': sweepingAttackAttack,
    'tripAttack': tripAttack,
    'distractingStrikeOnHit': distractingStrikeOnHit
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/fighter/echoKnight/manifestEcho.js



async function manifestEcho_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let sourceActor = game.actors.getName('CPR - Echo Knight');
    if (!sourceActor) return;
    let sceneEchos = canvas.scene.tokens.filter(i => i.actor?.flags?.['chris-premades']?.feature?.manifestEcho?.ownerUuid === workflow.actor.uuid);
    let name = chris.getConfiguration(workflow.item, 'name');
    if (name === '' || !name) name = workflow.actor.name + ' Echo';
    let actorData = duplicate(workflow.actor.toObject());
    async function effectMacro3() {
        await chrisPremades.macros.manifestEcho.defeated(token, effect);
    }
    let effectData2 = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 604800
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro3)
                }
            },
            'dae': {
                'specialDuration': [
                    'zeroHP'
                ]
            },
            'chris-premades': {
                'vae': {
                    'button': 'Dismiss Summon'
                },
                'feature': {
                    'manifestEcho': {
                        'ownerTokenUuid': workflow.token.document.uuid
                    }
                }
            }
        }
    };
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'abilities': {
                    'str': {
                        'value': workflow.actor.system.abilities.str.value
                    },
                    'con': {
                        'value': workflow.actor.system.abilities.con.value
                    },
                    'dex': {
                        'value': workflow.actor.system.abilities.dex.value
                    },
                    'int': {
                        'value': workflow.actor.system.abilities.int.value
                    },
                    'wis': {
                        'value': workflow.actor.system.abilities.wis.value
                    },
                    'cha': {
                        'value': workflow.actor.system.abilities.cha.value
                    }
                },
                'details': {
                    'cr': tashaSummon.getCR(workflow.actor.system.attributes.prof),
                    'type': {
                        'value': chris.raceOrType(workflow.actor)
                    }
                },
                'attributes': {
                    'ac': {
                        'flat': 14 + workflow.actor.system.attributes.prof
                    },
                    'senses': workflow.actor.system.senses
                }
            },
            'prototypeToken': {
                'name': name,
                'sight': actorData.prototypeToken.sight
            },
            'flags': {
                'chris-premades': {
                    'feature': {
                        'manifestEcho': {
                            'ownerUuid': workflow.actor.uuid
                        }
                    }
                }
            }
        },
        'token': {
            'name': name,
            'sight': actorData.prototypeToken.sight
        },
        'embedded': {
            'ActiveEffect': {
                [effectData2.name]: effectData2
            }
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar');
    let tokenImg = chris.getConfiguration(workflow.item, 'token');
    if (avatarImg) updates.actor.img = avatarImg;
    if (tokenImg && tokenImg != '') {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    } else {
        setProperty(updates, 'token.texture.src', workflow.token.document.texture.src);
        setProperty(updates, 'actor.prototypeToken.texture.src', workflow.token.document.texture.src);
    }
    let animationName = chris.getConfiguration(workflow.item, 'animation') ?? 'default';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animationName = 'none';
    let spawnedTokens = await chris.spawn(sourceActor, updates, {}, workflow.token, 15, animationName);
    if (!spawnedTokens) return;
    let spawnedToken = canvas.tokens.get(spawnedTokens[0]);
    if (animationName != 'none') {
        new Sequence()
            .effect()
            .file('jb2a.smoke.puff.centered.grey')
            .atLocation(spawnedToken)
            .scale(0.5)
            .randomRotation()
            .delay(1200)
            .play();
    }
    let applyFilter = chris.getConfiguration(workflow.item, 'filter') ?? true;
    if (game.modules.get('tokenmagic')?.active && applyFilter) {
        let filter = [
            {
                'filterType': 'oldfilm',
                'filterId': 'myOldfilm',
                'sepia': 0.6,
                'noise': 0.2,
                'noiseSize': 1.0,
                'scratch': 0.8,
                'scratchDensity': 0.5,
                'scratchWidth': 1.2,
                'vignetting': 0.9,
                'vignettingAlpha': 0.6,
                'vignettingBlur': 0.2,
                'animated':
                {
                    'seed': { 
                        'active': true, 
                        'animType': 'randomNumber', 
                        'val1': 0, 
                        'val2': 1 
                    },
                    'vignetting': { 
                        'active': true, 
                        'animType': 'syncCosOscillation' , 
                        'loopDuration': 2000, 
                        'val1': 0.2, 
                        'val2': 0.4
                    }
                }
            },
            {
                'filterType': 'outline',
                'filterId': 'oldfilmOutline',
                'color': 0x000000,
                'thickness': 0,
                'zOrder': 61
            ,
            },
            {
                'filterType': 'fog',
                'filterId': 'myFog',
                'color': 0x000000,
                'density': 0.65,
                'time': 0,
                'dimX': 1,
                'dimY': 1,
                'animated': {
                    'time': { 
                        'active': true, 
                        'speed': 2.2, 
                        'animType': 'move' 
                    }
                }
            }
        ];
        TokenMagic.addFilters(spawnedToken, filter);
    }
    if (sceneEchos.length) {
        let legionOfOne = chris.getItem(workflow.actor, 'Legion of One');
        let max = legionOfOne ? 2: 1;
        if (sceneEchos.length >= max) for (let i of sceneEchos) {
            manifestEcho_animation(i);
            await warpgate.wait(700);
            await warpgate.dismiss(i.id);
        }
    }
    let effect = workflow.actor.effects.find(i => i.flags['chris-premades']?.feature?.manifestEcho);
    if (effect) return;
    let mutationStack = warpgate.mutationStack(workflow.token.document);
    if (mutationStack.getName('Manifest Echo')) await warpgate.revert(workflow.token.document, 'Manifest Echo');
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Manifest Echo - Dismiss', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Manifest Echo - Dismiss');
    let featureData2 = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Manifest Echo - Teleport', false);
    if (!featureData2) return;
    featureData2.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Manifest Echo - Teleport');
    let featureData3 = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Manifest Echo - Attack', false);
    if (!featureData3) return;
    featureData3.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Manifest Echo - Attack');
    async function effectMacro () {
        await chrisPremades.macros.manifestEcho.dismiss({'workflow': {actor, token}});
    }
    async function effectMacro2() {
        await chrisPremades.macros.manifestEcho.turnEnd(token);
    }
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 604800
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                },
                'onTurnEnd': {
                    'script': chris.functionToString(effectMacro2)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData3.name
                },
                'feature': {
                    'manifestEcho': true
                }
            }
        }
    };
    let updates2 = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData,
                [featureData2.name]: featureData2,
                [featureData3.name]: featureData3
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Manifest Echo',
        'description': 'Manifest Echo'
    };
    await warpgate.mutate(workflow.token.document, updates2, {}, options);
}
async function manifestEcho_dismiss({speaker, actor, token, character, item, args, scope, workflow}) {
    let sceneEchos = canvas.scene.tokens.filter(i => i.actor?.flags?.['chris-premades']?.feature?.manifestEcho?.ownerUuid === workflow.actor.uuid);
    if (!sceneEchos.length) return;
    for (let i of sceneEchos) {
        manifestEcho_animation(i);
        await warpgate.wait(700);
        await warpgate.dismiss(i.id);
    }
    await warpgate.revert(workflow.token.document, 'Manifest Echo');
}
async function manifestEcho_teleport({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.token) return;
    let sceneEchos = canvas.scene.tokens.filter(i => i.actor?.flags?.['chris-premades']?.feature?.manifestEcho?.ownerUuid === workflow.actor.uuid);
    if (!sceneEchos.length) return;
    let targetToken;
    if (sceneEchos.length > 1) {
        let selection = await chris.selectTarget(workflow.item.name, constants_constants.okCancel, sceneEchos.map(i => i.object), true, 'one', null, false, 'Which Echo?');
        if (!selection.buttons) return;
        let targetTokenUuid = selection.inputs.find(i => i);
        if (!targetTokenUuid) return;
        targetToken = await fromUuid(targetTokenUuid);
        if (!targetToken) return;
    } else {
        targetToken = sceneEchos[0];
    }
    if (chris.jb2aCheck() === 'patreon') {
        await swapAnimation(workflow.token, targetToken.object);
    } else {
        let updates = {
            'token': {
                'x': targetToken.x,
                'y': targetToken.y,
                'elevation': targetToken.elevation
            }
        }
        let updates2 = {
            'token': {
                'x': workflow.token.document.x,
                'y': workflow.token.document.y,
                'elevation': workflow.token.document.elevation
            }
        }
        let options = {
            'permanent': true,
            'name': 'Manifest Echo - Teleport',
            'description': 'Manifest Echo - Teleport',
            'updateOpts': {'token': {'animate': false}}
        };
        manifestEcho_animation(targetToken.object);
        manifestEcho_animation(workflow.token);
        await warpgate.wait(700);
        warpgate.mutate(workflow.token.document, updates, {}, options);
        warpgate.mutate(targetToken, updates2, {}, options);
    }
}
async function manifestEcho_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.targets.size) return;
    let sceneEchos = canvas.scene.tokens.filter(i => i.actor?.flags?.['chris-premades']?.feature?.manifestEcho?.ownerUuid === workflow.actor.uuid);
    if (!sceneEchos.length) return;
    let targetToken;
    if (sceneEchos.length > 1) {
        let selection = await chris.selectTarget(workflow.item.name, constants_constants.okCancel, sceneEchos, true, 'one', null, false, 'Which Echo?');
        if (!selection.buttons) return;
        let targetTokenUuid = selection.inputs.find(i => i);
        if (!targetTokenUuid) return;
        let targetToken = await fromUuid(targetTokenUuid);
        if (!targetToken) return;
    } else {
        targetToken = sceneEchos[0];
    }
    let features = workflow.actor.items.filter(i => constants_constants.weaponAttacks.includes(i.system.actionType) && (i.type === 'weapon' ? i.system.equipped : true));
    let feature;
    if (!features.length) {
        ui.notifications.info('You have no equipped weapons to attack with!');
        return;
    } else if (features.length > 1) {
        let selection = await chris.selectDocument(workflow.item.name, features);
        if (!selection) return;
        feature = selection[0];
    } else {
        feature = features[0];
    }
    let effectData = {
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 1
        },
        'name': 'Manifest Echo - Range Override',
        'changes': [
            {
                'key': 'flags.midi-qol.rangeOverride.attack.all',
                'mode': 0,
                'value': '1',
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'effect': {
                    'noAnimation': true
                }
            }
        }
    };
    let effect = await chris.createEffect(workflow.actor, effectData);
    let effect2 = await chris.createEffect(targetToken.actor, effectData);
    let options = {
        'targetUuids': [workflow.targets.first().document.uuid]
    }
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature, {}, options);
    await chris.removeEffect(effect);
    await chris.removeEffect(effect2);
}
async function manifestEcho_turnEnd(token) {
    let sceneEchos = canvas.scene.tokens.filter(i => i.actor?.flags?.['chris-premades']?.feature?.manifestEcho?.ownerUuid === token.actor.uuid);
    if (!sceneEchos.length) return;
    let maxRange = chris.findEffect(token.actor, 'Echo Avatar') ? 1000 : 30;
    let echosLeft = sceneEchos.length;
    for (let i of sceneEchos) {
        let distance = chris.getDistance(token, i, false);
        if (distance > maxRange) {
            let selection = await chris.remoteDialog('Echo Knight', constants_constants.yesNo, chris.lastGM(), token.actor.name + '\'s echo has moved far away. Remove it?');
            if (!selection) continue;
            await warpgate.dismiss(i.id);
            echosLeft -= 1;
        }
    }
    if (!echosLeft) await warpgate.revert(token.document, 'Manifest Echo');
}
async function manifestEcho_save(actor, roll, ability) {
    let ownerUuid = actor.flags['chris-premades']?.feature?.manifestEcho?.ownerUuid;
    if (!ownerUuid) return;
    let owner = fromUuidSync(ownerUuid);
    if (!owner) return;
    let selfBonuses = actor.system.abilities[ability].bonuses.save;
    let ownerBonuses = owner.system.abilities[ability].bonuses.save;
    let selfBonuses2 = actor.system.bonuses.abilities.save;
    let ownerBonuses2 = owner.system.bonuses.abilities.save;
    if (selfBonuses === ownerBonuses && selfBonuses2 === ownerBonuses2) return;
    let formula = '';
    if (selfBonuses != ownerBonuses) formula += ' + ' + ownerBonuses;
    if (selfBonuses2 != ownerBonuses2) formula += ' + ' + ownerBonuses2;
    let newRoll = new Roll('0 + ' + formula, owner.getRollData()).evaluate({'async': false});
    for (let i = 1; i < newRoll.terms.length; i++) roll.terms.push(newRoll.terms[i]);
    roll._total += newRoll.total;
    roll._formula = roll._formula + formula;
}
async function manifestEcho_defeated(token, effect) {
    let sceneEchos = canvas.scene.tokens.filter(i => i.actor?.flags?.['chris-premades']?.feature?.manifestEcho?.ownerUuid === token.actor.flags['chris-premades'].feature.manifestEcho.ownerUuid && i.id != token.id);
    if (!sceneEchos.length) {
        let ownerTokenUuid = effect.flags['chris-premades']?.feature?.manifestEcho?.ownerTokenUuid;
        if (ownerTokenUuid) {
            let ownerToken = await fromUuid(ownerTokenUuid);
            if (ownerToken) {
                let effect2 = ownerToken.actor.effects.find(i => i.flags['chris-premades']?.feature?.manifestEcho);
                if (effect2) await chris.removeEffect(effect2);
                return;
            }
        }
    }
    manifestEcho_animation(token);
    await warpgate.wait(700);
    warpgate.dismiss(token.id);
}
async function manifestEcho_animation(token) {
    let animationName = chris.jb2aCheck() === 'patreon' ? 'jb2a.misty_step.01.grey' : 'jb2a.misty_step.01.blue'
    new Sequence()
        .effect()
        .file(animationName)
        .atLocation(token)
        .randomRotation()
        .scaleToObject(2)
        .play();
}
async function swapAnimation(source, target) {
    async function swap(source, target){
        new Sequence()
            .effect()
            .file('jb2a.misty_step.01.grey')
            .atLocation(source)
            .randomRotation()
            .scaleToObject(2)
            .wait(750)
            .animation()
            .on(source)
            .opacity(0.0)
            .waitUntilFinished()
            .effect()
            .file('jb2a.chain_lightning.primary.yellow')
            .atLocation(source)
            .stretchTo(target)
            .animation()
            .on(source)
            .teleportTo(target)
            .snapToGrid()
            .waitUntilFinished()
            .effect()
            .file('jb2a.misty_step.02.grey')
            .attachTo( source )
            .randomRotation()
            .scaleToObject(2)
            .wait(1500)
            .animation()
            .on(source)
            .opacity(1.0)
            .play();
    }
    await swap(source, target);
    await swap(target, source);
}
let manifestEcho = {
    'item': manifestEcho_item,
    'dismiss': manifestEcho_dismiss,
    'teleport': manifestEcho_teleport,
    'attack': manifestEcho_attack,
    'turnEnd': manifestEcho_turnEnd,
    'save': manifestEcho_save,
    'defeated': manifestEcho_defeated,
    'animation': manifestEcho_animation,
    'swapAnimation': swapAnimation
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/wizard/orderOfScribes/manifestMind.js


async function manifestMind_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let sourceActor = game.actors.getName('CPR - Manifest Mind');
    if (!sourceActor) return;
    let name = chris.getConfiguration(workflow.item, 'name') ?? 'Manifest Mind';
    if (name === '') name = 'Manifest Mind';
    let updates = {
        'actor': {
            'name': name,
            'prototypeToken': {
                'name': name,
                'disposition': workflow.token.document.disposition
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar');
    if (avatarImg) updates.actor.img = avatarImg;
    let tokenImg = chris.getConfiguration(workflow.item, 'token');
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? 'default';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    let manifestMindToken = await tashaSummon.spawn(sourceActor, updates, 86400, workflow.item, 60, workflow.token, animation);
    let moveData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Manifest Mind: Move', false);
    if (!moveData) return;
    moveData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Manifest Mind: Move');
    let castData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Manifest Mind: Cast Spell', false);
    if (!castData) return;
    castData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Manifest Mind: Cast Spell');
    let castUsesValue = workflow.actor.flags['chris-premades']?.feature?.manifestMind;
    if (!castUsesValue) {
        castUsesValue = workflow.actor.system.attributes.prof;
        workflow.actor.setFlag('chris-premades', 'feature.manifestMind', castUsesValue);
    }
    castData.system.uses.value = castUsesValue;
    castData.system.uses.max = workflow.actor.system.attributes.prof;
    let updates2 = {
        'embedded': {
            'Item': {
                [castData.name]: castData,
                [moveData.name]: moveData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Manifest Mind',
        'description': 'Manifest Mind'
    };
    await warpgate.mutate(workflow.token.document, updates2, {}, options);
    let effect = chris.findEffect(workflow.actor, workflow.item.name);
    if (!effect) return;
    let currentScript = effect.flags.effectmacro?.onDelete?.script;
    if (!currentScript) return;
    let effectUpdates = {
        'flags': {
            'effectmacro': {
                'onDelete': { 
                    'script': currentScript + ' await warpgate.revert(token.document, "Manifest Mind");'
                }
            },
            'chris-premades': {
                'vae': {
                    'button': castData.name
                },
                'feature': {
                    'manifestMind': manifestMindToken.id
                }
            }
        }
    };
    await chris.updateEffect(effect, effectUpdates);
}
async function manifestMind_attackApply({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = workflow.actor.effects.find((e) => e?.flags['chris-premades']?.feature?.manifestMind);
    if (!effect) return;
    let manifestMindId = effect.flags['chris-premades']?.feature?.manifestMind;
    if (!manifestMindId) return;
    let manifestMindToken = canvas.scene.tokens.get(manifestMindId);
    if (!manifestMindToken) return;
    if (chris.getDistance(workflow.token, manifestMindToken) > 300) {
        ui.notifications.info('Manifest Mind Too Far Away!');
        return;
    }
    let effectData = {
        'label': 'Manifest Mind Spell',
        'icon': '',
        'origin': effect.origin.uuid,
        'duration': {
            'turns': 1
        },
        'changes': [
            {
                'key': 'flags.midi-qol.rangeOverride.attack.all',
                'mode': 0,
                'value': 1,
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'priority': 20,
                'value': 'function.chrisPremades.macros.manifestMind.attackEarly,preambleComplete'
            }
        ],
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    '1Attack'
                ],
                'stackable': 'none',
                'macroRepeat': 'none'
            }
        }
    }
    await chris.createEffect(workflow.actor, effectData);
    await chris.createEffect(manifestMindToken.actor, effectData);
}
async function manifestMind_attackEarly({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.item.type != 'spell') {
        ui.notifications.info('Invalid Action Type!');
        return false;
    }
    let effect = workflow.actor.effects.find((e) => e?.flags['chris-premades']?.feature?.manifestMind);
    if (!effect) return;
    let manifestMindId = effect.flags['chris-premades']?.feature?.manifestMind;
    if (!manifestMindId) return;
    workflow.actor.setFlag('chris-premades', 'feature.manifestMind', workflow.item.system?.uses?.value)
}
async function manifestMind_longRest(actor, data) {
    if (!data.longRest) return;
    if (actor.classes?.wizard?.system?.levels < 6) return;
    let item = actor.items.getName('Order of Scribes');
    if (!item) return;
    if (item.type != 'subclass') return;
    workflow.actor.setFlag('chris-premades', 'feature.manifestMind', actor.system.attributes.prof);
}
let manifestMind = {
    'item': manifestMind_item,
    'attackApply': manifestMind_attackApply,
    'attackEarly': manifestMind_attackEarly,
    'longRest': manifestMind_longRest,
}
;// CONCATENATED MODULE: ./scripts/macros/mechanics/manualRolls.js



class chrisRoll extends Roll {
    get isCritical() {
        if (this.options.fakeType === 'critical') return true;
        return false;
    }
    get isFumble() {
        if (this.options.fakeType === 'fumble') return true;
        return false;
    }
}
async function attackRoll(workflow) {
    if (!workflow.attackRoll) return;
    let firstOwner = warpgate.util.firstOwner(workflow.token);
    let ignoreGM = game.settings.get('chris-premades', 'Ignore GM');
    if (ignoreGM && firstOwner.isGM) return;
    let rollSettings = game.settings.get('chris-premades', 'Manual Rolling Players');
    let rollSetting = rollSettings[firstOwner.id] ?? 'default';
    if (rollSetting === 'default') return;
    let targetUser = (rollSetting === 'player') ? firstOwner : game.users.get(chris.lastGM());
    let queueSetup = await queue_queue.setup(workflow.uuid, 'manualRoll', 0);
    if (!queueSetup) return;
    let inputs = [
        {
            'label': 'Roll Total:',
            'type': 'number'
        },
        {
            'label': 'Type:',
            'type': 'select',
            'options': [
                {'value': 'fumble', 'html': 'Fumble'},
                {'value': 'normal', 'html': 'Normal', 'selected': true},
                {'value': 'critical', 'html': 'Critical'}
            ]
        }
    ];
    if (game.user.id != targetUser.id) await chris.thirdPartyReactionMessage(targetUser, true);
    let selection = await chris.remoteMenu('Attack Roll', constants_constants.okCancel, inputs, true, targetUser.id, workflow.attackRoll._formula, null);
    if (game.user.id != targetUser.id) await chris.clearThirdPartyReactionMessage();
    if (!selection.buttons) {
        queue_queue.remove(workflow.uuid);
        return;
    }
    if (isNaN(selection.inputs[0])) {
        queue_queue.remove(workflow.uuid);
        return;
    }
    let attackRollNumber = selection.inputs[0];
    let attackRoll = await new chrisRoll(String(attackRollNumber), {}, {'fakeType': selection.inputs[0]}).evaluate();
    if (selection.inputs[1] === 'critical' && !workflow.actor.flags['midi-qol']?.critical?.all) {
        await workflow.actor.setFlag('midi-qol', 'critical.all', true);
        Hooks.once('midi-qol.RollComplete', async () => {
            await workflow.actor.unsetFlag('midi-qol', 'critical.all');
        });
    } else if (selection.inputs[1] === 'fumble' && !workflow.actor.flags['midi-qol']?.fail?.attack?.all) {
        await workflow.actor.setFlag('midi-qol', 'fail.attack.all', true);
        Hooks.once('midi-qol.RollComplete', async () => {
            await workflow.actor.unsetFlag('midi-qol', 'fail.attack.all');
        });
    }
    await workflow.setAttackRoll(attackRoll);
    queue_queue.remove(workflow.uuid);
}
async function damageRoll(workflow) {
    if (!workflow.damageRoll || !workflow.hitTargets.size) return;
    let firstOwner = warpgate.util.firstOwner(workflow.token);
    let ignoreGM = game.settings.get('chris-premades', 'Ignore GM');
    if (ignoreGM && firstOwner.isGM) return;
    let rollSettings = game.settings.get('chris-premades', 'Manual Rolling Players');
    let rollSetting = rollSettings[firstOwner.id] ?? 'default';
    if (rollSetting === 'default') return;
    let targetUser = (rollSetting === 'player') ? firstOwner : game.users.get(chris.lastGM());
    let queueSetup = await queue_queue.setup(workflow.uuid, 'manualRoll', 1000);
    if (!queueSetup) return;
    let damageTypes = new Set([]);
    for (let i of workflow.damageRoll.terms) {
        if (i.flavor) damageTypes.add(i.flavor.toLowerCase());
    }
    let generatedMenu = [];
    let damageTypeArray = [];
    for (let i of Array.from(damageTypes)) {
        generatedMenu.push({
            'label': i.charAt(0).toUpperCase() + i.slice(1) + ':',
            'type': 'number'
        });
        damageTypeArray.push(i);
    }
    if (game.user.id != targetUser.id) await chris.thirdPartyReactionMessage(targetUser, true);
    let selection = await chris.remoteMenu('Damage Roll', constants_constants.okCancel, generatedMenu, true, targetUser.id, workflow.damageRoll._formula);
    if (game.user.id != targetUser.id) await chris.clearThirdPartyReactionMessage();
    if (!selection.buttons) {
        queue_queue.remove(workflow.uuid);
        return;
    }
    let damageFormula = '';
    for (let i = 0; i < selection.inputs.length; i++) {
        if (isNaN(selection.inputs[i])) continue;
        if (damageFormula != '') damageFormula += ' + ';
        let input = selection.inputs[i];
        damageFormula += (input != '' ? input : '0') + '[' + damageTypeArray[i] + ']';
    }
    if (damageFormula === '') {
        queue_queue.remove(workflow.uuid);
        return
    }
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.uuid);
}
async function saveRoll(workflow) {
    if (!workflow.saveResults) return;
    let queueSetup = await queue_queue.setup(workflow.uuid, 'manualRoll', 0);
    if (!queueSetup) return;
    let rollSettings = game.settings.get('chris-premades', 'Manual Rolling Players');
    let userTargets = {};
    let gmTargets = [];
    for (let i of Array.from(workflow.hitTargets)) {
        let firstOwner = warpgate.util.firstOwner(i);
        let rollSetting = rollSettings[firstOwner.id] ?? 'default';
        if (rollSetting === 'default' || rollSetting === 'gm') {
            gmTargets.push(i);
        } else {
            if (!userTargets[firstOwner.id]) userTargets[firstOwner.id] = [];
            userTargets[firstOwner.id].push(i);
        }
    }
    let ignoreGM = game.settings.get('chris-premades', 'Ignore GM');
    if (!Object.keys(userTargets).length && ignoreGM) return;
    userTargets[chris.lastGM()] = gmTargets;
    let results = {};
    let info = CONFIG.DND5E.abilities[workflow.item.system.save.ability].label + ' Saving Throw';
    let dc = chris.getSpellDC(workflow.item);
    await Promise.all(Object.keys(userTargets).map(async userId => {
        let tokens = userTargets[userId];
        let inputs = tokens.map(i => ({'label': i.name, 'type': 'number', 'tokenId': i.id}));
        let user = game.users.get(userId);
        let message = user.isGM ? info + '(DC: ' + dc + ')' : info;
        if (game.user.id != userId) await chris.thirdPartyReactionMessage(user, true, userId);
        let selection = await chris.remoteMenu('Save Rolls', constants_constants.okCancel, inputs, true, userId, message);
        if (game.user.id != userId) await chris.clearThirdPartyReactionMessage(userId);
        if (!selection.buttons) return;
        for (let i = 0; inputs.length > i; i++) {
            let result = selection.inputs[i];
            if (isNaN(result)) continue;
            let tokenId = inputs[i].tokenId;
            results[tokenId] = result;
        }
    }));
    let tokens = Array.from(workflow.hitTargets);
    for (let i = 0; i < tokens.length; i++) {
        let tokenId = tokens[i].id;
        if (!results[tokenId]) continue;
        let result = results[tokenId];
        if (result >= dc) {
            workflow.failedSaves.delete(tokens[i]);
            workflow.saves.add(tokens[i]);
            workflow.saveDisplayData[i].saveString = ' succeeds';
            workflow.saveDisplayData[i].saveStyle = 'color: green;'
            workflow.saveDisplayData[i].rollTotal = result;
        } else {
            workflow.failedSaves.add(tokens[i]);
            workflow.saveDisplayData[i].saveString = ' fails';
            workflow.saveDisplayData[i].saveStyle = 'color: red;';
            workflow.saveDisplayData[i].rollTotal = result;
        }
        workflow.saveResults[i]._total = result;
    }
    await workflow.displaySaves(false, true);
    queue_queue.remove(workflow.uuid);
}
async function userOptions() {
    let users = game.users.filter(i => !i.isGM);
    if (!users.length) {
        ui.notifications.info('There are no players to configure!');
        return;
    }
    let oldSettings = game.settings.get('chris-premades', 'Manual Rolling Players');
    function getOptions(userId) {
        let oldSetting = oldSettings[userId];
        let options = [
            {'value': 'default', 'html': 'Auto / Default', 'selected': oldSetting === 'default' ?? true},
            {'value': 'player', 'html': 'Prompt Player', 'selected': oldSetting === 'player' ?? false},
            {'value': 'gm', 'html': 'Prompt Game Master', 'selected': oldSetting === 'gm' ?? false}
        ];
        return options;
    }
    let inputs = users.map(i => ({'label': i.name, 'type': 'select', 'options': getOptions(i.id), 'id': i.id}));
    let selection = await chris.menu('Player Options', constants_constants.okCancel, inputs, true);
    if (!selection) return;
    let newSettings = {};
    for (let i = 0; inputs.length > i; i++) setProperty(newSettings, inputs[i].id, selection.inputs[i]);
    await game.settings.set('chris-premades', 'Manual Rolling Players', newSettings);
}
let manualRolls = {
    'attackRoll': attackRoll,
    'damageRoll': damageRoll,
    'saveRolls': saveRoll,
    'userOptions': userOptions
}
;// CONCATENATED MODULE: ./scripts/macros/spells/massCureWounds.js

async function massCureWounds({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size === 0) return;
    let sourceDisposition = workflow.token.document.disposition;
    let targetTokens = [];
    for (let i of workflow.targets) {
        if (i.document.disposition === sourceDisposition) targetTokens.push(i);
    }
    if (targetTokens.length === 0) return;
    let diceNumber = 8 - workflow.castData.castLevel;
    let damageFormula = diceNumber + 'd8[healing] + ' + chris.getSpellMod(workflow.item);
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    if (targetTokens.length <= 6) {
        await chris.applyWorkflowDamage(workflow.token, damageRoll, 'healing', targetTokens, workflow.item.name, workflow.itemCardId);
    } else {
        let buttons = [
            {
                'label': 'Yes',
                'value': true
            }, {
                'label': 'No',
                'value': false
            }
        ];
        let selection = await chris.selectTarget('What targets would you like to heal? Max: 6', buttons, targetTokens, true, 'multiple');
        if (!selection.buttons) return;
        let selectedTokens = [];
        for (let i of selection.inputs) {
            if (i) selectedTokens.push(await fromUuid(i));
        }
        if (selectedTokens.length > 6) {
            ui.notifications.info('Too many targets selected!');
            return;
        }
        chris.applyWorkflowDamage(workflow.token, damageRoll, 'healing', selectedTokens, workflow.item.name, workflow.itemCardId);
    }
}
;// CONCATENATED MODULE: ./scripts/macros/items/mastersAmulet.js



async function mastersAmulet(token, {item, workflow, ditem}) {
    if (!workflow) return;
    let effect = chris.findEffect(token.actor, 'Shield Guardian - Bound');
    if (!effect) return;
    let targetActorId = token.actor.flags['chris-premades']?.item?.mastersAmulet?.bound;
    if (!targetActorId) return;
    let nearbyTokens = chris.findNearby(token, 60, 'ally');
    if (nearbyTokens.length === 0) return;
    let targetToken = nearbyTokens.find((tok => tok.actor.id === targetActorId));
    if (!targetToken) return;
    let queueSetup = await queue_queue.setup(workflow.uuid, 'mastersAmulet', 400);
    if (!queueSetup) return;
    if (ditem.newHP > ditem.oldHP) {
        queue_queue.remove(workflow.uuid);
        return;
    }
    let keptDamage = Math.floor(ditem.appliedDamage / 2);
    let originalDamage = duplicate(keptDamage);
    if (ditem.oldTempHP > 0) {
        if (keptDamage > ditem.oldTempHP) {
            ditem.newTempHP = 0;
            keptDamage -= ditem.oldTempHP;
            ditem.tempDamage = ditem.oldTempHP;
        } else {
            ditem.newTempHP = ditem.oldTempHP - keptDamage;
            ditem.tempDamage = keptDamage;
            keptDamage = 0;
        }
    }
    let maxHP = token.actor.system.attributes.hp.max;
    ditem.hpDamage = Math.clamped(keptDamage, 0, maxHP);
    ditem.newHP = Math.clamped(ditem.oldHP - keptDamage, 0, maxHP);
    ditem.appliedDamage = keptDamage;
    ditem.totalDamage = keptDamage;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Item Features', 'Shield Guardian - Bound', false);
    if (!featureData) {
        queue_queue.remove(workflow.uuid);
        return;
    }
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Shield Guardian - Bound');
    featureData.system.damage.parts = [
        [
            originalDamage,
            'none'
        ]
    ];
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': targetToken.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.document.uuid]);
    await MidiQOL.completeItemUse(feature, config, options);
    queue_queue.remove(workflow.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/sorcerer/metaMagic.js



async function carefulSpell({speaker, actor, token, character, item, args, scope, workflow}){
    if (workflow.targets.size === 0 ||  workflow.item.type != 'spell' || !workflow.hasSave) return;
    let effect = chris.findEffect(workflow.actor, 'Sorcery Points');
    if (!effect) {
        ui.notifications.info('Sorcery Points Item Effect Not Found!');
        return;
    }
    let sorcPointsItem = await fromUuid(effect.origin);
    if (!sorcPointsItem) return;
    let sorcPointsValue = sorcPointsItem.system.uses.value;
    if (sorcPointsValue < 1) return;
    if (!sorcPointsValue) {
        ui.notifications.info('No Sorcery Points Available!');
        return;
    }
    let max = workflow.actor.system.abilities.cha.mod;
    if (!max) return;
    let targets = Array.from(workflow.targets);
    let selectedTargets = [];
    for (let i of targets) {
        if (i.document.disposition === workflow.token.document.disposition) selectedTargets.push(i);
    }
    if (selectedTargets.length > max) {
        let selection = await chris.selectTarget('What targets automatically save? (Max ' + max + ')', constants_constants.okCancel, selectedTargets, true, 'multiple');
        if (!selection.buttons) return;
        selectedTargets = [];
        for (let i of selection.inputs) {
            if (i) selectedTargets.push(await fromUuid(i));
        }
        if (selectedTargets.length > max) {
            ui.notifications.info('Too many targets selected!');
            return;
        }
    }
    let effectData = {
        'label': 'Careful Spell Auto Save',
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'duration': {
            'seconds': 6
        },
        'changes': [
            {
                'key': 'flags.midi-qol.min.ability.save.all',
                'mode': 5,
                'value': '100',
                'priority': 120
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    'isSave'
                ]
            }
        }
    }
    selectedTargets.forEach(async i => await chris.createEffect(i.actor, effectData))
    await sorcPointsItem.update({'system.uses.value': sorcPointsValue - 1});
}
async function empoweredSpell({speaker, actor, token, character, item, args, scope, workflow}){
    if (workflow.hitTargets.size === 0 ||  workflow.item.type != 'spell') return;
    let effect = chris.findEffect(workflow.actor, 'Sorcery Points');
    if (!effect) {
        ui.notifications.info('Sorcery Points Item Effect Not Found!');
        return;
    }
    let sorcPointsItem = await fromUuid(effect.origin);
    if (!sorcPointsItem) return;
    let sorcPointsValue = sorcPointsItem.system.uses.value;
    if (!sorcPointsValue) return;
    let max = workflow.actor.system.abilities.cha.mod;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'empoweredSpell', 350);
    if (!queueSetup) return;
    let newDamageRoll = workflow.damageRoll;
    let lowest = [];
    for (let i = 0; newDamageRoll.terms.length > i; i++) {
        if (newDamageRoll.terms[i].isDeterministic === false) {
            let currentTerm = newDamageRoll.terms[i];
            let faces = currentTerm.faces;
            for (let j = 0; currentTerm.values.length > j; j++) {
                let modifiers = currentTerm.modifiers?.toString();
                if (lowest.length === 0) {
                    lowest.push({
                        'result': currentTerm.values[j],
                        'position': j,
                        'faces': faces,
                        'term': i,
                        'modifiers': modifiers,
                        'flavor': currentTerm.flavor
                    });
                }
                else if (lowest.length > 0) {
                    for (let k = 0; lowest.length > k; k++) {
                        if (currentTerm.values[j] <= lowest[k].result) {
                            lowest.splice(k, 0, {
                                'result': currentTerm.values[j],
                                'position': j,
                                'faces': faces,
                                'term': i,
                                'modifiers': modifiers,
                                'flavor': currentTerm.flavor
                            });
                            if (lowest.length > max) {
                                lowest.splice(max, 1);
                            }
                            break;
                        }
                        if (currentTerm.values[j] > lowest[lowest.length - 1].result && lowest.length != max) {
                            lowest.push({
                                'result': currentTerm.values[j],
                                'position': j,
                                'faces': faces,
                                'term': i,
                                'modifiers': modifiers,
                                'flavor': currentTerm.flavor
                            });
                            break;
                        }
                    }
                }
            }
        }
    }
    function dialogRender(html) {
        let ths = html[0].getElementsByTagName('th');
        for (let t of ths) {
            t.style.width = 'auto';
            t.style.textAlign = 'left';
        }
        let tds = html[0].getElementsByTagName('td');
        for (let t of tds) {
            t.style.width = '200px';
            t.style.textAlign = 'right';
            t.style.paddingRight = '5px';
        }
    }
    let generatedMenu = [];
    for (let i of lowest) {
        generatedMenu.push({
            'label': '1d' + i.faces + '[' + i.flavor + ']: ' + i.result,
            'type': 'checkbox',
            'options': false
        });
    }
    let config = {
        'title': 'Empowered Spell: Reroll lowest dice?',
        'render': dialogRender
    };
    let selection = await warpgate.menu(
        {
            'inputs': generatedMenu,
            'buttons': constants_constants.yesNoButton
        },
        config
    );
    if (!selection.buttons) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    if (selection.inputs.filter(i => i != false).length === 0) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    for (let i = 0; lowest.length > i; i++) {
        if (!selection.inputs[i]) continue;
        let currentDie = lowest[i];
        let damageFormula = '1d' + currentDie.faces + currentDie.modifiers;
        let damageRoll = await new Roll(damageFormula).roll({async: true});
        let messageData = {
            'speaker': ChatMessage.getSpeaker(workflow.actor), 
            'flavor': 'Rerolling: ' + currentDie.result, 
            'rollMode': game.settings.get('core', 'rollMode')
        }
        await damageRoll.toMessage(messageData);
        newDamageRoll.terms[currentDie.term].results[currentDie.position].result = damageRoll.total;
    }
    newDamageRoll._total = newDamageRoll._evaluateTotal();
    await workflow.setDamageRoll(newDamageRoll);
    await sorcPointsItem.update({'system.uses.value': sorcPointsValue - 1});
    queue_queue.remove(workflow.item.uuid);
}
async function heightenedSpell({speaker, actor, token, character, item, args, scope, workflow}){
    if (workflow.targets.size === 0 ||  workflow.item.type != 'spell' || !workflow.hasSave) return;
    let effect = chris.findEffect(workflow.actor, 'Sorcery Points');
    if (!effect) {
        ui.notifications.info('Sorcery Points Item Effect Not Found!');
        return;
    }
    let sorcPointsItem = await fromUuid(effect.origin);
    if (!sorcPointsItem) return;
    let sorcPointsValue = sorcPointsItem.system?.uses?.value;
    if (sorcPointsValue < 3) {
        ui.notifications.info('No Sorcery Points Available!');
        return;
    }
    let max = workflow.actor.system.abilities.cha.mod;
    let selectedTargets = Array.from(workflow.targets);
    if (selectedTargets.length > max) {
        let selection = await chris.selectTarget('Give what targets disadvantage? (Max ' + max + ')', constants_constants.okCancel, selectedTargets, true, 'multiple');
        if (!selection.buttons) return;
        selectedTargets = [];
        for (let i of selection.inputs) {
            if (i) selectedTargets.push(await fromUuid(i));
        }
        if (selectedTargets.length > max) {
            ui.notifications.info('Too many targets selected!');
            return;
        }
    }
    let effectData = {
        'label': 'Heightened Spell Disadvantage',
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'duration': {
            'seconds': 6
        },
        'changes': [
            {
                'key': 'flags.midi-qol.disadvantage.ability.save.all',
                'mode': 5,
                'value': '1',
                'priority': 120
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    'isSave'
                ]
            }
        }
    }
    selectedTargets.forEach(async i => await chris.createEffect(i.actor, effectData))
    await sorcPointsItem.update({'system.uses.value': sorcPointsValue - 3});
}
async function seekingSpell({speaker, actor, token, character, item, args, scope, workflow}){
    if (workflow.item.flags['chris-premades']?.seekingSpell) {
        let queueSetup = await queue_queue.setup(workflow.item.uuid, 'seekingSpell', 340);
        if (!queueSetup) return;
        await workflow.setDamageRoll(workflow.item.flags['chris-premades'].seekingSpell);
        queue_queue.remove(workflow.item.uuid);
    }
    if (workflow.targets.size === 0 || workflow.targets.size === workflow.hitTargets.size || workflow.item.flags['chris-premades']?.seekingSpell || workflow.item.type != 'spell') return;
    let effect = chris.findEffect(workflow.actor, 'Sorcery Points');
    if (!effect) {
        ui.notifications.info('Sorcery Points Item Effect Not Found!');
        return;
    }
    let sorcPointsItem = await fromUuid(effect.origin);
    if (!sorcPointsItem) return;
    let sorcPointsValue = sorcPointsItem.system?.uses?.value;
    if (sorcPointsValue < 2) {
        ui.notifications.info('No Sorcery Points Available!');
        return;
    }
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'seekingSpell', 360);
    if (!queueSetup) return;
    let selection = await chris.dialog('Use Seeking Spell to reroll miss of ' + workflow.attackTotal + '?', [['Yes', true], ['No', false]]);
    if (!selection) return;
    let spellLevel = workflow.castData?.castLevel;
    if (spellLevel === undefined) return;
    let targetToken = workflow.targets.first();
    let targetTokenUuid = targetToken.document.uuid;
    if (!targetTokenUuid) return;
    let damageRoll = workflow.damageRoll;
    if (!damageRoll) return;
    let spellData = duplicate(workflow.item.toObject());
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetTokenUuid], false, spellLevel);
    if (!options) return;
    setProperty(spellData, 'flags.chris-premades.metaMagic', true);
    setProperty(spellData, 'flags.chris-premades.seekingSpell', damageRoll);
    spellData.name = workflow.item.name + ' Re-Roll';
    let spell = new CONFIG.Item.documentClass(spellData, {'parent': workflow.actor});
    await MidiQOL.completeItemUse(spell, config, options);
    let damageFormula = ('0');
    let newDamageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(newDamageRoll);
    await sorcPointsItem.update({'system.uses.value': sorcPointsValue - 1});
    queue_queue.remove(workflow.item.uuid);
}
async function transmutedSpell({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size === 0) return;
    if (workflow.item.type != 'spell') return;
    let effect = chris.findEffect(workflow.actor, 'Sorcery Points');
    if (!effect) {
        ui.notifications.info('Sorcery Points Item Effect Not Found!');
        return;
    }
    let sorcPointsItem = await fromUuid(effect.origin);
    if (!sorcPointsItem) return;
    let sorcPointsValue = sorcPointsItem.system?.uses?.value;
    if (!sorcPointsValue) {
        ui.notifications.info('No Sorcery Points Available!');
        return;
    }
    let values = ['acid', 'cold', 'fire', 'lightning', 'poison', 'thunder'];
    let oldDamageRoll = workflow.damageRoll;
    let oldFlavor = [];
    for (let i of oldDamageRoll.terms) {
        let isDeterministic = i.isDeterministic;
        if (values.includes(i.flavor.toLowerCase()) && isDeterministic === false) {
            oldFlavor.push(i.flavor);
        }
    }
    function valuesToOptions(arr){
        let optionsPush = [];
        for (let i = 0; arr.length > i; i++) {
            if (typeof arr[i] != 'string') return;
            optionsPush.push([arr[i].charAt(0).toUpperCase() + arr[i].slice(1), arr[i]]);
        }
        return optionsPush;
    }
    let optionsOriginal = valuesToOptions(oldFlavor);
    let selectionOriginal = await chris.dialog('Change what damage type?', optionsOriginal);
    if (!selectionOriginal) return;
    let options = []
    for (let i of values) {
        if (i != selectionOriginal) {
            options.push(i);
        }
    }
    options = valuesToOptions(options);
    let selection = await chris.dialog('Change to what damage type?', options)
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'transmutedSpell', 50);
    if (!queueSetup) return;
    workflow.damageRoll._formula = workflow.damageRoll._formula.replace(selectionOriginal, selection);
    workflow.damageRoll.terms.forEach(term => term.options.flavor = term.options?.flavor?.replace(selectionOriginal, selection))
    await workflow.setDamageRoll(workflow.damageRoll);
    await sorcPointsItem.update({'system.uses.value': sorcPointsValue - 1});
    queue_queue.remove(workflow.item.uuid);
}
async function twinnedSpell({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    if (workflow.item.type != 'spell' || workflow.item.system.range.units === 'self' || workflow.item.flags['chris-premades']?.metaMagic) return;
    let spellLevel = workflow.castData.castLevel;
    if (spellLevel === undefined) return;
    let effect = chris.findEffect(workflow.actor, 'Sorcery Points');
    if (!effect) {
        ui.notifications.info('Sorcery Points Item Effect Not Found!');
        return;
    }
    let sorcPointsItem = await fromUuid(effect.origin);
    if (!sorcPointsItem) return;
    let sorcPointsValue = sorcPointsItem.system.uses.value;
    if (!sorcPointsValue) {
        ui.notifications.info('No Sorcery Points Available!');
        return;
    }
    if (sorcPointsValue < spellLevel) return;
    let itemRange = workflow.item.system?.range?.value;
    if (!itemRange) {
        if (workflow.item.system.range.units === 'touch') {
            itemRange = 5;
        } else {
            return;
        }
    }
    let actionType = workflow.item.system.actionType;
    if (!actionType) return;
    let disposition;
    switch (actionType) {
        case 'rsak':
        case 'msak':
        case 'savingThrow':
            disposition = 'enemy';
            break;
        case 'heal':
            disposition = 'ally';
            break;
        case 'utility':
        case 'other':
            disposition = null;
            break;
    }
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'twinnedSpell', 450);
    if (!queueSetup) return;
    let nearbyTargets = chris.findNearby(workflow.token, itemRange, disposition, false, true).filter(t => t.id != workflow.targets.first().id);
    if (nearbyTargets.length === 0) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let selected = await chris.selectTarget('Use Twinned Spell?', constants_constants.yesNoButton, nearbyTargets, true, 'one');
    if (!selected.buttons) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let targetTokenUuid = selected.inputs.find(id => id);
    if (!targetTokenUuid) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let spellData = duplicate(workflow.item.toObject());
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetTokenUuid], false, spellLevel);
    setProperty(spellData, 'flags.chris-premades.metaMagic', true);
    spellData.system.components.concentration = false;
    let spell = new CONFIG.Item.documentClass(spellData, {'parent': workflow.actor});
    spell.prepareData();
    spell.prepareFinalAttributes();
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(spell, config, options);
    if (spellLevel === 0) spellLevel = 1;
    await sorcPointsItem.update({'system.uses.value': sorcPointsValue - spellLevel});
    if (workflow.item.system.components.concentration) {
        let concentrationsTargets = workflow.actor?.flags['midi-qol']['concentration-data']?.targets;
        concentrationsTargets.splice(0, 0, {'tokenUuid': targetTokenUuid, 'actorUuid': targetTokenUuid});
        await workflow.actor.setFlag('midi-qol', 'concentration-data.targets', concentrationsTargets);
    }
    queue_queue.remove(workflow.item.uuid);
}
let metaMagic = {
    carefulSpell: carefulSpell,
    empoweredSpell: empoweredSpell,
    heightenedSpell: heightenedSpell,
    seekingSpell: seekingSpell,
    transmutedSpell: transmutedSpell,
    twinnedSpell: twinnedSpell
}
;// CONCATENATED MODULE: ./scripts/macros/raceFeatures/dragonborn/metallic/metallicBreathWeapon.js


let type = 'enervating';
async function metallicBreathWeapon_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'metallicBreathWeapon', 50);
    if (!queueSetup) return;
    type = await chris.dialog(workflow.item.name, [['Enervating Breath', 'enervating'], ['Repulsion Breath', 'repulsion']]) ?? 'enervating';
    let ability = duplicate(workflow.item.system.save.ability);
    if (type === 'enervating') {
        ability = 'con';
    } else {
        ability = 'str';
    }
    workflow.item = workflow.item.clone({'system.save.ability': ability}, {'keepId': true});
    workflow.item.prepareData();
    workflow.item.prepareFinalAttributes();
    queue_queue.remove(workflow.item.uuid);
}
async function metallicBreathWeapon_save({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.failedSaves.size) return;
    if (type === 'enervating') {
        let effectData = {
            'label': workflow.item.name,
            'icon': workflow.item.img,
            'origin': workflow.item.uuid,
            'duration': {
                'seconds': 12
            },
            'changes': [
                {
                    'key': 'macro.CE',
                    'mode': 0,
                    'value': 'Incapacitated',
                    'priority': 20
                }
            ],
            'flags': {
                'dae': {
                    'specialDuration': [
                        'turnStartSource'
                    ]
                }
            }
        };
        for (let i of Array.from(workflow.failedSaves)) await chris.createEffect(i.actor, effectData);
    } else {
        let queueSetup = await queue_queue.setup(workflow.item.uuid, 'metallicBreathWeaponSave', 50);
        if (!queueSetup) return;
        for (let i of Array.from(workflow.failedSaves)) {
            chris.pushToken(workflow.token, i, 20);
            if (!(chris.checkTrait(i.actor, 'ci', 'prone') || chris.findEffect(i.actor, 'Prone'))) chris.addCondition(i.actor, 'Prone', false, workflow.item.uuid);
        }
        queue_queue.remove(workflow.item.uuid);
    }
}
let metallicBreathWeapon = {
    'item': metallicBreathWeapon_item,
    'save': metallicBreathWeapon_save
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/barbarian/giant/mightyImpel.js

async function mightyImpel({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.failedSaves.size) return;
    let targetToken = workflow.targets.first();
    let targetSize = chris.getSize(targetToken.actor);
    let demiurgicColossus = chris.getItem(workflow.actor, 'Demiurgic Colossus');
    let maxSize = demiurgicColossus ? 3 : 2;
    if (targetSize > maxSize) return;
    await workflow.actor.sheet.minimize();
    let icon = targetToken.document.texture.src;
    let interval = targetToken.document.width % 2 === 0 ? 1 : -1;
    let position = await chris.aimCrosshair(targetToken, 30, icon, interval, targetToken.document.width);
    if (position.cancelled) {
        await workflow.actor.sheet.maximize();
        return;
    }
    let newCenter = canvas.grid.getSnappedPosition(position.x - targetToken.w / 2, position.y - targetToken.h / 2, 1);
    let targetUpdate = {
        'token': {
            'x': newCenter.x,
            'y': newCenter.y
        }
    };
    let options = {
        'permanent': true,
        'name': 'Mighty Impel',
        'description': 'Mighty Impel'
    };
    await warpgate.mutate(targetToken.document, targetUpdate, {}, options);
    await workflow.actor.sheet.maximize();
}
;// CONCATENATED MODULE: ./scripts/macros/spells/mirrorImage.js


async function mirrorImage(workflow) {
    if (workflow.targets.size != 1) return;
    if (workflow.isFumble === true) return;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    let targetEffect = chris.findEffect(targetActor, 'Mirror Image');
    if (!targetEffect) return;
    let duplicates = targetActor.flags['chris-premades']?.spell?.mirrorImage;
    if (!duplicates) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'mirrorImage', 49);
    if (!queueSetup) return;
    let roll = await new Roll('1d20').roll({async: true});
    roll.toMessage({
        rollMode: 'roll',
        speaker: {'alias': name},
        flavor: 'Mirror Image'
    });
    let rollTotal = roll.total;
    let rollNeeded;
    switch (duplicates) {
        case 3:
            rollNeeded = 6;
            break;
        case 2:
            rollNeeded = 8;
            break;
        case 1:
            rollNeeded = 11;
            break;
    }
    if (rollTotal < rollNeeded) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    workflow.isFumble = true;
    let duplicateAC = 10 + targetActor.system.abilities.dex.mod;
    if (workflow.attackTotal >= duplicateAC) {
        ChatMessage.create({
            speaker: {'alias': name},
            content: 'Attack hit a duplicate and destroyed it.'
        });
        if (duplicates === 1) {
            await chris.removeEffect(targetEffect);
        } else {
            let updates = {
                'changes': [
                    {
                        'key': 'macro.tokenMagic',
                        'mode': 0,
                        'value': 'images',
                        'priority': 20
                    },
                    {
                        'key': 'flags.chris-premades.spell.mirrorImage',
                        'mode': 5,
                        'value': duplicates - 1,
                        'priority': 20
                    }
                ]
            };
            await chris.updateEffect(targetEffect, updates);
        }
    } else {
        ChatMessage.create({
            speaker: {'alias': name},
            content: 'Attack targeted a duplicate and missed.'
        });
    }
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/moonbeam.js


async function moonbeam_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let template = canvas.scene.collections.templates.get(workflow.templateId);
    if (!template) return;
    await template.setFlag('chris-premades', 'template', {
        'name': 'moonbeam',
        'castLevel': workflow.castData.castLevel,
        'saveDC': chris.getSpellDC(workflow.item),
        'macroName': 'moonbeam',
        'templateUuid': template.uuid,
        'turn': 'start',
        'ignoreMove': false
    });
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Moonbeam - Move', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Moonbeam - Move');
    async function effectMacro () {
        await warpgate.revert(token.document, 'Moonbeam');
    }
    let effectData = {
        'name': 'Moonbeam',
        'icon': workflow.item.img,
        'transfer': false,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 60
        },
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'spell': {
                    'moonbeam': {
                        'templateUuid': template.uuid
                    }
                },
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': effectData.name,
        'description': effectData.name
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
async function moonbeam_trigger(token, trigger) {
    let template = await fromUuid(trigger.templateUuid);
    if (!template) return;
    if (chris.inCombat()) {
        let turn = game.combat.round + '-' + game.combat.turn;
        let lastTurn = template.flags['chris-premades']?.spell?.moonbeam?.[token.id]?.turn;
        if (turn === lastTurn) return;
        await template.setFlag('chris-premades', 'spell.moonbeam.' + token.id + '.turn', turn);
    }
    let originUuid = template.flags.dnd5e?.origin;
    if (!originUuid) return;
    let originItem = await fromUuid(originUuid);
    if (!originItem) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Moonbeam - Damage', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Moonbeam - Damage');
    featureData.system.save.dc = trigger.saveDC;
    featureData.system.damage.parts = [
        [
            trigger.castLevel + 'd10[radiant]',
            'radiant'
        ]
    ];
    delete featureData._id;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': originItem.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.uuid]);
    let changeShape = token.actor.items.getName('Change Shape');
    let shapechanger = token.actor.items.getName('Shapechanger');
    if (changeShape || shapechanger) {
        await chris.createEffect(token.actor, constants_constants.disadvantageEffectData);
    }
    await MidiQOL.completeItemUse(feature, config, options);
    if (shapechanger || shapechanger) {
        let effect = chris.findEffect(token.actor, 'Save Disadvantage');
        if (effect) await chris.removeEffect(effect);
    }
}
async function moonbeam_move({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Moonbeam');
    if (!effect) return;
    let templateUuid = effect.flags['chris-premades']?.spell?.moonbeam?.templateUuid;
    if (!templateUuid) return;
    let template = await fromUuid(templateUuid);
    if (!template) return;
    await workflow.actor.sheet.minimize();
    let position = await chris.aimCrosshair(workflow.token, 60, workflow.item.img, 2, 2);
    await workflow.actor.sheet.maximize();
    if (position.cancelled) return;
    let updates = {
        'x': position.x,
        'y': position.y
    };
    await template.update(updates);
}
let moonbeam = {
    'item': moonbeam_item,
    'trigger': moonbeam_trigger,
    'move': moonbeam_move
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/bard/collegeOfCreation/moteOfPotential.js


async function moteOfPotential({speaker, actor, token, character, item, args, scope, workflow}) {
    //Can't do much here yet!
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/mudMephit/deathBurst.js

async function targets({speaker, actor, token, character, item, args, scope, workflow}) {
    let validTargets = Array.from(workflow.targets).filter(i => chris.getSize(i.actor) <= 2).map(i => i.id);
    chris.updateTargets(validTargets);
}
async function deathBurst_defeated(origin) {
    await origin.use();
}
let deathBurst = {
    'targets': targets,
    'defeated': deathBurst_defeated
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/mudMephit/mudMephit.js

let mudMephit = {
    'deathBurst': deathBurst
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/bloodHunter/bloodCurses/muddledMind.js

async function muddledMind({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let amplify = await chris.dialog('Amplify Blood Curse?', [['Yes', true], ['No', false]]);
    if (!amplify) return;
    let damageDice = workflow.actor.system.scale['blood-hunter']['crimson-rite'];
    if (!damageDice) {
        ui.notifications.warn('Source actor does not appear to have a Crimson Rite scale!');
        return;
    }
    let roll = await new Roll(damageDice + '[none]').roll({async: true});
    roll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: workflow.item.name
    });
    await chris.applyDamage(workflow.token, roll.total, 'none');
    let effect = chris.findEffect(workflow.targets.first().actor, 'Blood Curse of the Muddled Mind');
    if (!effect) return;
    let updates = {
        'duration': {
            'duration': 6,
            'label': '6 Seconds',
            'remaining': 6,
            'rounds': 1,
            'seconds': 6
        },
        'flags': {
            'dae': {
                'specialDuration': []
            }
        }
    };
    await chris.updateEffect(effect, updates);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/bloodHunter/orderOfTheMutant/mutagencraft.js

async function mutagencraft_effectMacro() {
    await chrisPremades.macros.mutagencraft.remove(origin);
}
async function celerity({speaker, actor, token, character, item, args, scope, workflow}) {
    let classLevels = workflow.actor.classes['blood-hunter']?.system?.levels;
    if (!classLevels) return;
    let effectData = {
        'name': 'Mutagen - Celerity: Positive Effects',
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 604800
        },
        'changes': [
            {
                'key': 'system.abilities.dex.value',
                'value': '+3',
                'mode': 2,
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    'longRest',
                    'shortRest'
                ],
                'stackable': 'multi',
                'macroRepeat': 'none'
            },
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(mutagencraft_effectMacro)
                }
            }
        }
    }
    if (classLevels >= 11 && classLevels < 18) effectData.changes[0].value = '+4';
    else if (classLevels >= 18) effectData.changes[0].value = '+5';
    await chris.createEffect(workflow.actor, effectData);
}
async function mobility({speaker, actor, token, character, item, args, scope, workflow}) {
    let classLevels = workflow.actor.classes['blood-hunter']?.system?.levels;
    if (!classLevels) return;
    let effectData = {
        'name': 'Mutagen - Mobility: Positive Effects',
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 604800
        },
        'changes': [
            {
                'key': 'system.traits.ci.value',
                'value': 'grappled',
                'mode': 0,
                'priority': 20
            },
            {
                'key': 'system.traits.ci.value',
                'value': 'restrained',
                'mode': 0,
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    'longRest',
                    'shortRest'
                ],
                'stackable': 'multi',
                'macroRepeat': 'none'
            },
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(mutagencraft_effectMacro)
                }
            }
        }
    }
    if (classLevels >= 11 && classLevels < 18) effectData.changes.push({
        'key': 'system.traits.ci.value',
        'value': 'paralyzed',
        'mode': 0,
        'priority': 20
    });
    await chris.createEffect(workflow.actor, effectData);
}
async function potency({speaker, actor, token, character, item, args, scope, workflow}) {
    let classLevels = workflow.actor.classes['blood-hunter']?.system?.levels;
    if (!classLevels) return;
    let effectData = {
        'name': 'Mutagen - Potency: Positive Effects',
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 604800
        },
        'changes': [
            {
                'key': 'system.abilities.str.value',
                'value': '+3',
                'mode': 2,
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    'longRest',
                    'shortRest'
                ],
                'stackable': 'multi',
                'macroRepeat': 'none'
            },
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(mutagencraft_effectMacro)
                }
            }
        }
    }
    if (classLevels >= 11 && classLevels < 18) effectData.changes[0].value = '+4';
    else if (classLevels >= 18) effectData.changes[0].value = '+5';
    await chris.createEffect(workflow.actor, effectData);
}
async function rapidity({speaker, actor, token, character, item, args, scope, workflow}) {
    let classLevels = workflow.actor.classes['blood-hunter']?.system?.levels;
    if (!classLevels) return;
    let effectData = {
        'name': 'Mutagen - Rapidity: Positive Effects',
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 604800
        },
        'changes': [
            {
                'key': 'system.attributes.movement.all',
                'value': '+10',
                'mode': 0,
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    'longRest',
                    'shortRest'
                ],
                'stackable': 'multi',
                'macroRepeat': 'none'
            },
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(mutagencraft_effectMacro)
                }
            }
        }
    }
    if (classLevels >= 11 && classLevels < 18) effectData.changes[0].value = '+4';
    else if (classLevels >= 18) effectData.changes[0].value = '+15';
    await chris.createEffect(workflow.actor, effectData);
}
async function reconstruction(token, actor) {
    let currentHP = actor.system.attributes.hp.value;
    let maxHalfHP = Math.floor(actor.system.attributes.hp.max / 2);
    if (currentHP > maxHalfHP || actor.system.attributes.hp.value === 0) return;
    await chris.applyDamage([token], actor.system.attributes.prof, 'healing');
}
async function sagacity({speaker, actor, token, character, item, args, scope, workflow}) {
    let classLevels = workflow.actor.classes['blood-hunter']?.system?.levels;
    if (!classLevels) return;
    let effectData = {
        'name': 'Mutagen - Sagacity: Positive Effects',
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 604800
        },
        'changes': [
            {
                'key': 'system.abilities.int.value',
                'value': '+3',
                'mode': 2,
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    'longRest',
                    'shortRest'
                ],
                'stackable': 'multi',
                'macroRepeat': 'none'
            },
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(mutagencraft_effectMacro)
                }
            }
        }
    }
    if (classLevels >= 11 && classLevels < 18) effectData.changes[0].value = '+4';
    else if (classLevels >= 18) effectData.changes[0].value = '+5';
    await chris.createEffect(workflow.actor, effectData);
}
async function createMutagen({speaker, actor, token, character, item, args, scope, workflow}) {
    let generatedMenu = [];
    if (workflow.actor.items.getName('Formulas: Aether')) generatedMenu.push(['Aether', 'Formulas: Aether']);
    if (workflow.actor.items.getName('Formulas: Alluring')) generatedMenu.push(['Alluring', 'Formulas: Alluring']);
    if (workflow.actor.items.getName('Formulas: Celerity')) generatedMenu.push(['Celerity', 'Formulas: Celerity']);
    if (workflow.actor.items.getName('Formulas: Conversant')) generatedMenu.push(['Conversant', 'Formulas: Conversant']);
    if (workflow.actor.items.getName('Formulas: Cruelty')) generatedMenu.push(['Cruelty', 'Formulas: Cruelty']);
    if (workflow.actor.items.getName('Formulas: Deftness')) generatedMenu.push(['Deftness', 'Formulas: Deftness']);
    if (workflow.actor.items.getName('Formulas: Embers')) generatedMenu.push(['Embers', 'Formulas: Embers']);
    if (workflow.actor.items.getName('Formulas: Gelid')) generatedMenu.push(['Gelid', 'Formulas: Gelid']);
    if (workflow.actor.items.getName('Formulas: Impermeable')) generatedMenu.push(['Impermeable', 'Formulas: Impermeable']);
    if (workflow.actor.items.getName('Formulas: Mobility')) generatedMenu.push(['Mobility', 'Formulas: Mobility']);
    if (workflow.actor.items.getName('Formulas: Nighteye')) generatedMenu.push(['Nighteye', 'Formulas: Nighteye']);
    if (workflow.actor.items.getName('Formulas: Percipient')) generatedMenu.push(['Percipient', 'Formulas: Percipient']);
    if (workflow.actor.items.getName('Formulas: Potency')) generatedMenu.push(['Potency', 'Formulas: Potency']);
    if (workflow.actor.items.getName('Formulas: Precision')) generatedMenu.push(['Precision', 'Formulas: Precision']);
    if (workflow.actor.items.getName('Formulas: Rapidity')) generatedMenu.push(['Rapidity', 'Formulas: Rapidity']);
    if (workflow.actor.items.getName('Formulas: Reconstruction')) generatedMenu.push(['Reconstruction', 'Formulas: Reconstruction']);
    if (workflow.actor.items.getName('Formulas: Sagacity')) generatedMenu.push(['Sagacity', 'Formulas: Sagacity']);
    if (workflow.actor.items.getName('Formulas: Shielded')) generatedMenu.push(['Shielded', 'Formulas: Shielded']);
    if (workflow.actor.items.getName('Formulas: Unbreakable')) generatedMenu.push(['Unbreakable', 'Formulas: Unbreakable']);
    if (workflow.actor.items.getName('Formulas: Vermillion')) generatedMenu.push(['Vermillion', 'Formulas: Vermillion']);
    if (generatedMenu.length === 0) return;
    let selection = await chris.dialog('What Mutagen do you create?', generatedMenu);
    if (!selection) return;
    let feature = workflow.actor.items.getName(selection);
    if (!feature) return;
    let uses = feature.system.uses.value + 1;
    let max = Number(feature.system.uses.max + 1);
    await feature.update(
        {
            'system.uses.value': uses,
            'system.uses.max': max
        }
    );
}
async function mutagencraft_remove(origin) {
    let max = Number(origin.system.uses.max) - 1;
    await origin.update(
        {
            'system.uses.max': max
        }
    );
}
async function strangeMetabolism({speaker, actor, token, character, item, args, scope, workflow}) {
    let effects = workflow.actor.effects.filter(effect => effect.name.includes('Mutagen - ') && effect.name.includes('Negative Effects'));
    let generatedMenu = [];
    for (let i of effects) {
        let originItem = await fromUuid(i.origin);
        if (!originItem) continue;
        generatedMenu.push([originItem.name, i.id]);
    }
    if (generatedMenu.length === 0) return;
    let selection;
    if (generatedMenu.length === 1) selection = generatedMenu[0][1];
    if (!selection) selection = await chris.dialog('What Mutagen?', generatedMenu);
    if (!selection) return;
    let effect = workflow.actor.effects.get(selection);
    if (!effect) return;
    await effect.update({'disabled': true});
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 60
        },
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': 'await actor.effects.get("' + selection + '").update({"disabled": false});'
                }
            }
        }
    }
    await chris.createEffect(workflow.actor, effectData);
}
let mutagencraft = {
    'celerity': celerity,
    'mobility': mobility,
    'potency': potency,
    'rapidity': rapidity,
    'reconstruction': reconstruction,
    'sagacity': sagacity,
    'createMutagen': createMutagen,
    'remove': mutagencraft_remove,
    'strangeMetabolism': strangeMetabolism
}
;// CONCATENATED MODULE: ./scripts/macros/raceFeatures/aasimar/necroticShroud.js



async function necroticShroud_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    let pass = args[0].macroPass;
    if (workflow.hitTargets.size === 0) return;
    if (!(pass === 'postDamageRoll' || pass === 'preDamageApplication')) return;
    let feature = chris.getItem(workflow.actor, 'Celestial Revelation (Necrotic Shroud)')
    if (!feature) return;
    let useFeature = chris.perTurnCheck(feature, 'feature', 'necroticShroud', true, workflow.token.id);
    if (!useFeature) return;
    switch (pass) {
        case 'postDamageRoll':
            if (workflow.hitTargets.size != 1) return;
            let queueSetup = await queue_queue.setup(workflow.item.uuid, 'necroticShroud', 249);
            if (!queueSetup) return;
            let selected = await chris.dialog(feature.name, constants_constants.yesNo, 'Add extra damage from ' + feature.name + '?');
            if (!selected) {
                queue_queue.remove(workflow.item.uuid);
                return;
            }
            await chris.setTurnCheck(feature, 'feature', 'necroticShroud');
            let damageFormula = workflow.damageRoll._formula + ' + ' + workflow.actor.system.attributes.prof + '[necrotic]';
            let damageRoll = await new Roll(damageFormula).roll({async: true});
            await workflow.setDamageRoll(damageRoll);
            queue_queue.remove(workflow.item.uuid);
            return;
        case 'preDamageApplication':
            if (workflow.hitTargets.size <= 1) return;
            let queueSetup2 = queue_queue.setup(workflow.item.uuid, 'necroticShroud', 249);
            if (!queueSetup2) return;
            let selection = await chris.selectTarget('Celestial Revelation: Add extra damage?', constants_constants.yesNoButton, workflow.targets, true, 'one');
            if (selection.buttons === false) {
                queue_queue.remove(workflow.item.uuid);
                return;
            }
            await chris.setTurnCheck(feature, 'feature', 'necroticShroud');
            let targetTokenUuid = selection.inputs.find(i => i);
            if (!targetTokenUuid) {
                queue_queue.remove(workflow.item.uuid);
                return;
            }
            let targetToken = await fromUuid(targetTokenUuid);
            if (!targetToken) {
                queue_queue.remove(workflow.item.uuid);
                return;
            }
            chris.addDamageDetailDamage(targetToken, workflow.actor.system.attributes.prof, 'necrotic', workflow);
            await feature.displayCard();
            queue_queue.remove(workflow.item.uuid);
            return;
    }
}
async function necroticShroud_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let effectData = {
        'label': workflow.item.name,
        'icon': workflow.item.img,
        'changes': [
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.necroticShroud.attack,all',
                'priority': 20
            }
        ],
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 60
        }
    };
    await chris.createEffect(workflow.actor, effectData);
}
async function necroticShroud_turn(origin) {
    await chris.setTurnCheck(origin, 'feature', 'necroticShroud', true);
}
let necroticShroud = {
    'attack': necroticShroud_attack,
    'turn': necroticShroud_turn,
    'item': necroticShroud_item
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/nightwalker/annihilatingAura.js


async function annihilatingAura(token, origin) {
    let targetToken = game.canvas.tokens.get(game.combat.current.tokenId);
    if (!targetToken) return;
    if (targetToken.document.uuid === token.document.uuid) return;
    if (chris.raceOrType(targetToken.actor) === 'undead') return;
    let distance = chris.getDistance(token, targetToken);
    if (distance > 30) return;
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.document.uuid]);
    await MidiQOL.completeItemUse(origin, config, options);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/nightwalker/enervatingFocus.js

async function enervatingFocus({speaker, actor, token, character, item, args, scope, workflow}) {
    console.log(workflow);
    if (workflow.failedSaves.size != 1) return;
    let targetActor = workflow.targets.first().actor;
    let damage = -chris.totalDamageType(targetActor, workflow.damageDetail, 'necrotic');
    if (damage === 0) return;
    let targetMaxHP = targetActor.system.attributes.hp.max;
    let effect = chris.findEffect(targetActor, workflow.item.name);
    if (!effect) {
        let effectData = {
            'label': workflow.item.name,
            'icon': workflow.item.img,
            'duration': {
                'seconds': 604800
            },
            'changes': [
                {
                    'key': 'system.attributes.hp.tempmax',
                    'mode': 2,
                    'value': Math.max(damage, -targetMaxHP),
                    'priority': 20
                }
            ],
            'flags': {
                'dae': {
                    'specialDuration': [
                        'longRest'
                    ]
                }
            }
        };
        await chris.createEffect(targetActor, effectData);
    } else {
        let oldDamage = parseInt(effect.changes[0].value);
        damage += oldDamage;
        let updates = {
            'changes': [
                {
                    'key': 'system.attributes.hp.tempmax',
                    'mode': 2,
                    'value': Math.max(damage, -targetMaxHP),
                    'priority': 20
                }
            ]
        };
        await chris.updateEffect(effect, updates);
    }
    if (Math.abs(damage) >= targetMaxHP) {
        let unconscious = chris.findEffect(targetActor, 'Unconscious');
        if (!unconscious) return;
        await chris.removeCondition(targetActor, 'Unconscious');
        await chris.addCondition(targetActor, 'Dead', true, null)
    }
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/nightwalker/fingerOfDoom.js

async function target({speaker, actor, token, character, item, args, scope, workflow}) {
    let sourceActor = game.actors.get(workflow.token.document.actorId);
    if (!sourceActor) return;
    let monsterName = sourceActor.name.split(' ').join('-').toLowerCase();
    let featureName = workflow.item.name.split(' ').join('-').toLowerCase();
    let validTargets = Array.from(workflow.targets).filter(i => !i.actor.flags['chris-premades']?.monster?.[monsterName]?.feature?.[featureName]?.immune).map(i => i.id);
    chris.updateTargets(validTargets);
}
async function fingerOfDoom_save({speaker, actor, token, character, item, args, scope, workflow}) {
    let sourceActor = game.actors.get(workflow.token.document.actorId);
    if (!sourceActor) return;
    let monsterName = sourceActor.name.split(' ').join('-').toLowerCase();
    let featureName = workflow.item.name.split(' ').join('-').toLowerCase();
    let effectData1 = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 12
        },
        'changes': [
            {
                'key': 'macro.CE',
                'mode': 0,
                'value': 'Frightened',
                'priority': 20
            },
            {
                'key': 'macro.CE',
                'mode': 0,
                'value': 'Paralyzed',
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    'turnEndSource'
                ]
            }
        }
    };
    let effectData2 = {
        'name': workflow.item.name + ' Immune',
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 86400
        },
        'changes': [
            {
                'key': 'flags.chris-premades.monster.' + monsterName + '.feature.' + featureName + '.immune',
                'mode': 5,
                'value': 1,
                'priority': 20
            }
        ]
    }
    for (let i of workflow.targets) {
        if (workflow.failedSaves.has(i)) {
            let effect = chris.findEffect(i.actor, effectData1.name);
            if (effect) {
                await chris.updateEffect(effect, {'duration.seconds': effectData1.duration.seconds});
            } else {
                if (!chris.checkTrait(i.actor, 'ci', 'frightened')) await chris.createEffect(i.actor, effectData1);
            }
        } else {
            let effect = chris.findEffect(i.actor, effectData2.name);
            if (effect) {
                await chris.updateEffect(effect, {'duration.seconds': effectData2.duration.seconds});
            } else {
                await chris.createEffect(i.actor, effectData2);
            }
        }
    }
}
let fingerOfDoom = {
    'target': target,
    'save': fingerOfDoom_save
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/nightwalker/lifeEater.js

async function lifeEater({speaker, actor, token, character, item, args, scope, workflow}) {
    let displayFeature = false;
    for (let i of workflow.damageList) {
        if (i.oldHP === 0 || i.newHP > 0) continue;
        let targetToken = await fromUuid(i.tokenUuid);
        if (!targetToken) continue;
        let effect = chris.findEffect(targetToken.actor, 'Unconscious');
        if (!effect) continue;
        await chris.removeEffect(effect);
        await chris.addCondition(targetToken.actor, 'Dead', true);
        displayFeature = true;
    }
    if (!displayFeature) return;
    let effect = chris.findEffect(workflow.actor, 'Life Eater');
    if (!effect) return;
    if (!effect.origin) return;
    let originItem = await fromUuid(effect.origin);
    if (!originItem) return;
    await originItem.displayCard();
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/nightwalker/nightwalker.js




let nightwalker = {
    'enervatingFocus': enervatingFocus,
    'fingerOfDoom': fingerOfDoom,
    'annihilatingAura': annihilatingAura,
    'lifeEater': lifeEater
}
;// CONCATENATED MODULE: ./scripts/macros/generic/noConfiguration.js
async function noConfiguration({speaker, actor, token, character, item, args, scope, workflow}) {
    workflow.options.configureDialog = false;
}
;// CONCATENATED MODULE: ./scripts/macros/items/oilOfSharpness.js

async function oilOfSharpness({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let tokenDoc = workflow.targets.first().document;
    let generatedMenu = [];
    let mutationStack = warpgate.mutationStack(tokenDoc);
    let targetActor = workflow.targets.first().actor;
    targetActor.items.forEach(item => {
        if (item.type === 'weapon' && item.system.equipped === true) {
            let mutateItem = mutationStack.getName('Oil of Sharpness: ' + item.name);
            if (!mutateItem) generatedMenu.push([item.name, item.id]);
        }
    });
    let selection;
    if (generatedMenu.length === 0) return;
    if (generatedMenu.length === 1) selection = generatedMenu[0][1];
    if (!selection) selection = await chris.dialog('What weapon?', generatedMenu);
    if (!selection) return;
    let weaponData = duplicate(targetActor.items.get(selection).toObject());
    let oldAttackBonus = weaponData.system.attackBonus;
    weaponData.system.attackBonus = '3';
    switch (oldAttackBonus) {
        case '':
        case '0':
            weaponData.system.damage.parts[0][0] += ' + 3';
            break;
        case '1':
            weaponData.system.damage.parts[0][0] += ' + 2';
            break;
        case '2':
            weaponData.system.damage.parts[0][0] =+ ' + 1';
            break;
    }
    weaponData.system.properties.mgc = true;
    let updates = {
        'embedded': {
            'Item': {
                [weaponData.name]: weaponData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Oil of Sharpness: ' + weaponData.name,
        'description': 'Oil of Sharpness: ' + weaponData.name
    };
    await warpgate.mutate(tokenDoc, updates, {}, options);
    let effectData = {
        'label': 'Oil of Sharpness: ' + weaponData.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 3600
        },
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': "warpgate.revert(token.document, '" + 'Oil of Sharpness: ' + weaponData.name + "');"
                }
            }
        }
    };
    await chris.createEffect(targetActor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/raceFeatures/dragonborn/oldBreathWeapon.js


async function oldBreathWeapon({speaker, actor, token, character, item, args, scope, workflow}) {
    let level = Math.max(chris.levelOrCR(workflow.actor), 1);
    if (level < 6) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'oldBreathWeapon', 50);
    if (!queueSetup) return;
    let dice = level >= 16 ? 5 : level >= 11 ? 4 : 3;
    let parts = duplicate(workflow.item.system.damage.parts);
    parts[0][0] = dice + 'd6[' + parts[0][1] + ']';
    workflow.item = workflow.item.clone({'system.damage.parts': parts}, {'keepId': true});
    workflow.item.prepareData();
    workflow.item.prepareFinalAttributes();
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/feats/orcishFury.js


async function orcishFury({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size === 0 || !workflow.damageRoll || workflow.item.type != 'weapon') {
        let effect = chris.findEffect(workflow.actor, 'Orcish Fury - Extra Damage');
        if (!effect) return;
        let originItem = await fromUuid(effect.origin);
        if (!originItem) return;
        await originItem.update({'system.uses.value': 1});
        return;
    } else {
        let weaponDice = workflow.damageRoll.terms[0].faces;
        if (!weaponDice) return;
        let diceNumber = 1;
        if (workflow.isCritical) diceNumber = 2;
        let queueSetup = await queue_queue.setup(workflow.item.uuid, 'orcishFury', 250);
        if (!queueSetup) return;
        let damageFormula = workflow.damageRoll._formula + ' + ' + diceNumber + 'd' + weaponDice + '[' + workflow.damageRoll.terms[0].flavor + ']';
        let damageRoll = await new Roll(damageFormula).roll({async: true});
        await workflow.setDamageRoll(damageRoll);
        queue_queue.remove(workflow.item.uuid);
    }
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/wizard/schoolOfEvocation/overchannel.js



async function overchannel_cast({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.item.type != 'spell') return;
    if (workflow.castData.castLevel === 0 || workflow.castData.castLevel > 5) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'overchannel', 350);
    if (!queueSetup) return;
    let oldDamageRoll = workflow.damageRoll;
    if (oldDamageRoll.terms.length === 0) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let newDamageRoll = '';
    for (let i = 0; oldDamageRoll.terms.length > i; i++) {
        let flavor = oldDamageRoll.terms[i].flavor;
        let isDeterministic = oldDamageRoll.terms[i].isDeterministic;
        if (isDeterministic) {
            newDamageRoll += oldDamageRoll.terms[i].formula;
        } else {
            newDamageRoll += '(' + oldDamageRoll.terms[i].number + '*' + oldDamageRoll.terms[i].faces + ')[' + flavor + ']';
        }
    }
    let damageRoll = await new Roll(newDamageRoll).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function castComplete({speaker, actor, token, character, item, args, scope, workflow}) {
    let damageMult = workflow.actor.flags['chris-premades']?.feature?.overchannel;
    if (!damageMult) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Overchannel - Damage', false);
    if (!featureData) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'overchannel', 350);
    if (!queueSetup) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Overchannel - Damage');
    delete featureData._id;
    let diceNum = (damageMult + 1) * workflow.castData.castLevel;
    featureData.system.damage.parts[0][0] = diceNum + 'd12[none]';
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.token.document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature, config, options);
    queue_queue.remove(workflow.item.uuid);
}
async function overchannel_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Overchannel - Used');
    if (!effect) {
        let effectData = {
            'label': 'Overchannel - Used',
            'icon': workflow.item.img,
            'origin': workflow.item.uuid,
            'duration': {
                'seconds': 604800
            },
            'changes': [
                {
                    'key': 'flags.chris-premades.feature.overchannel',
                    'mode': 5,
                    'value': 0,
                    'priority': 20
                }
            ],
            'flags': {
                'dae': {
                    'specialDuration': [
                        'longRest'
                    ],
                    'macroRepeat': 'none'
                }
            },
            'transfer': true
        };
        await chris.createEffect(workflow.actor, effectData);
    } else {
        let updates = {
            'changes': [
                {
                    'key': 'flags.chris-premades.feature.overchannel',
                    'mode': 5,
                    'value': Number(effect.changes[0].value) + 1,
                    'priority': 20
                }
            ]
        }
        await chris.updateEffect(effect, updates);
    }
}
let overchannel = {
    'item': overchannel_item,
    'cast': overchannel_cast,
    'castComplete': castComplete
}
;// CONCATENATED MODULE: ./scripts/macros/feats/piercer.js


async function reroll({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size === 0 || !workflow.damageRoll || !['mwak', 'rwak', 'msak', 'rsak'].includes(workflow.item.system.actionType)) return;
    let effect = chris.findEffect(workflow.actor, 'Piercer: Reroll Damage');
    if (!effect) return;
    let originItem = await fromUuid(effect.origin);
    if (!originItem) return;
    let doExtraDamage = chris.perTurnCheck(originItem, 'feat', 'piercer', false, workflow.token.id);
    if (!doExtraDamage) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'piercerReroll', 390);
    if (!queueSetup) return;
    let damageTypes = chris.getRollDamageTypes(workflow.damageRoll);
    if (!damageTypes.has(CONFIG.DND5E.damageTypes.piercing.toLowerCase())) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let autoPiercer = chris.getConfiguration(originItem, 'auto') ?? false;
    if (autoPiercer) autoPiercer = chris.getConfiguration(originItem, 'reroll') ?? false;
    let lowRoll = null;
    let lowRollDice = null;
    let resultI;
    let resultJ;
    for (let i = 0; workflow.damageRoll.terms.length > i; i++) {
        let term = workflow.damageRoll.terms[i];
        if (!term.faces) continue;
        for (let j = 0; term.results.length > j; j++) {
            if (term.results[j].result > lowRoll && lowRoll != null) continue;
            if (term.results[j].result === lowRoll && term.faces < lowRollDice) continue;
            lowRoll = term.results[j].result;
            lowRollDice = term.faces;
            resultI = i;
            resultJ = j;
        }
    }
    if (autoPiercer) {
        if (lowRoll > autoPiercer) {
            queue_queue.remove(workflow.item.uuid);
            return;
        }
    } else {
        let selection = await chris.dialog('Piercer: Reroll low roll of ' + lowRoll + '?', [['Yes', true], ['No', false]]);
        if (!selection) {
            queue_queue.remove(workflow.item.uuid);
            return;
        }
    }
    if (chris.inCombat()) await originItem.setFlag('chris-premades', 'feat.piercer.turn', game.combat.round + '-' + game.combat.turn);
    let roll = await new Roll('1d' + lowRollDice).roll({async: true});
    let newDamageRoll = workflow.damageRoll;
    newDamageRoll.terms[resultI].results[resultJ].result = roll.total;
    newDamageRoll._total = newDamageRoll._evaluateTotal();
    await workflow.setDamageRoll(newDamageRoll);
    await originItem.use();
    queue_queue.remove(workflow.item.uuid);
}
async function piercer_combatEnd(origin) {
    await origin.setFlag('chris-premades', 'feat.piercer.turn', '');
}
async function piercer_critical({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.isCritical || !workflow.damageRoll) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'piercerCritical', 250);
    if (!queueSetup) return;
    let damageTypes = chris.getRollDamageTypes(workflow.damageRoll);
    if (!damageTypes.has(CONFIG.DND5E.damageTypes.piercing.toLowerCase())) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let largeDice;
    let flavor;
    for (let i of workflow.damageRoll.terms) {
        if (!i.faces) continue;
        if (largeDice > i.faces) continue;
        largeDice = i.faces;
        flavor = i.flavor.toLowerCase();
    }
    let damageFormula = workflow.damageRoll._formula + ' + 1d' + largeDice + '[' + flavor + ']';
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    let effect = chris.findEffect(workflow.actor, 'Piercer: Critical Hit');
    if (effect) {
        let originItem = await fromUuid(effect.origin);
        if (originItem) await originItem.use();
    }
    queue_queue.remove(workflow.item.uuid);
}
let piercer = {
    'reroll': reroll,
    'combatEnd': piercer_combatEnd,
    'critical': piercer_critical
}
;// CONCATENATED MODULE: ./scripts/macros/feats/planarWanderer.js


async function portalCracker({speaker, actor, token, character, item, args, scope, workflow}) {
    let roll = await workflow.actor.rollSkill('arc');
    if (roll.total >= 20) return;
    if (!workflow.token) return;
    let damageRoll = await new Roll('3d8[' + translate.damageType('psychic') + ']').roll({async: true});
    await chris.applyWorkflowDamage(workflow.token, damageRoll, 'psychic', [workflow.token], workflow.item.name, workflow.itemCardId);
}
async function planarAdaptation({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Planar Wanderer: Planar Adaptation');
    if (!effect) return;
    let selection = await chris.dialog(workflow.item.name, [['Acid', 'acid'], ['Cold', 'cold'], ['Fire', 'fire']], 'What resistance?');
    if (!selection) return;
    let updates = {
        'changes': [
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'value': selection,
                'priority': 20
            }
        ]
    }
    await chris.updateEffect(effect, updates);
}
let planarWanderer = {
    'portalCracker': portalCracker,
    'planarAdaptation': planarAdaptation
}
;// CONCATENATED MODULE: ./scripts/macros/items/potionOfDiminution.js

async function potionOfDiminution({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    let roll = await new Roll('1d4').roll({async: true});
    roll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: 'Potion of Diminution'
    });
    let changes = [
        {
            'key': 'system.bonuses.mwak.damage',
            'mode': 2,
            'priority': 20,
            'value': '-1d4'
        },
        {
            'key': 'system.bonuses.rwak.damage',
            'mode': 2,
            'priority': 20,
            'value': '-1d4'
        }
    ];
    let targetSize = targetActor.system.traits.size;
    let keyX;
    let keyY;
    let value;
    let size;
    switch (targetSize) {
        case 'sm':
            keyX = 'ATL.texture.scaleX';
            keyY = 'ATL.texture.scaleY';
            value = '0.5';
            size = 'tiny';
            break;
        case 'med':
            keyX = 'ATL.texture.scaleX';
            keyY = 'ATL.texture.scaleY';
            value = '0.8';
            size = 'sm';
            break;
        case 'lg':
            size = 'med';
            value = 1;
            break;
        case 'huge':
            size = 'lg';
            value = 2;
            break;
        case 'grg':
            size = 'huge';
            value = 3;
            break;
    }
    if (!keyX) keyX = 'ATL.height';
    if (!keyY) keyY = 'ATL.width';
    changes.push({
        'key': keyX,
        'mode': 5,
        'priority': 20,
        'value': value
    });
    changes.push({
        'key': keyY,
        'mode': 5,
        'priority': 20,
        'value': value
    });
    changes.push({
        'key': 'system.traits.size',
        'mode': 5,
        'priority': 20,
        'value': size
    });
    let effectData = {
        'label': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 3600 * roll.total
        },
        'changes': changes
    };
    await chris.createEffect(targetActor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/items/potionOfFireBreath.js

async function potionOfFireBreath_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Item Features', 'Potion of Fire Breath Attack', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Potion of Fire Breath Attack');
    async function effectMacro () {
        await warpgate.revert(token.document, 'Potion of Fire Breath');
    }
    let effectData = {
        'name': 'Potion of Fire Breath',
        'icon': workflow.item.img,
        'duration': {
            'seconds': 3600
        },
        'origin': workflow.actor.uuid, //Not the item UUID due to being a consumable.
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': effectData.name,
        'description': featureData.name
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
async function breath({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.item.system.uses.value != 0) return;
    await warpgate.revert(workflow.token.document, 'Potion of Fire Breath');
}
let potionOfFireBreath = {
    'item': potionOfFireBreath_item,
    'breath': breath
}
;// CONCATENATED MODULE: ./scripts/macros/items/potionOfGiantSize.js


async function potionOfGiantSize_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    let effect = chris.findEffect(targetActor, 'Potion of Giant Size');
    if (!effect) return;
    let changes = effect.changes;
    changes[3].value = targetActor.system.attributes.hp.max * 2;
    let updates = {changes};
    await chris.updateEffect(effect, updates);
    await chris.applyDamage(targetToken, targetActor.system.attributes.hp.value, 'healing');
}
async function potionOfGiantSize_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (workflow.item.type != 'weapon') return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'potionOfGiantSize', 375);
    if (!queueSetup) return;
    let bonusDamageNumber = workflow.damageRoll.terms[0].number * 3 - workflow.damageRoll.terms[0].number;
    let bonusDamageDice = workflow.damageRoll.terms[0].faces;
    let flavor = workflow.damageRoll.terms[0].options.flavor;
    let bonusDamageFormula = ' + ' + bonusDamageNumber + 'd' + bonusDamageDice + '[' + flavor + ']';
    let damageFormula = workflow.damageRoll._formula + bonusDamageFormula;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function potionOfGiantSize_end(token, actor) {
    let hpValue = actor.system.attributes.hp.value;
    let hpMax = actor.system.attributes.hp.max;
    let hpTemp = hpValue - hpMax;
    if (hpValue <= hpMax) return;
    let updates = {
        'system.attributes.hp.value': hpMax
    };
    await actor.update(updates);
    await chris.applyDamage(token, hpTemp, 'temphp');
}
let potionOfGiantSize = {
    'item': potionOfGiantSize_item,
    'damage': potionOfGiantSize_damage,
    'end': potionOfGiantSize_end
}
;// CONCATENATED MODULE: ./scripts/macros/items/potionOfGrowth.js

async function potionOfGrowth({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    let roll = await new Roll('1d4').roll({async: true});
    roll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: 'Potion of Growth'
    });
    let changes =[
        {
            'key': 'system.bonuses.mwak.damage',
            'mode': 2,
            'priority': 20,
            'value': '+1d4'
        },
        {
            'key': 'system.bonuses.rwak.damage',
            'mode': 2,
            'priority': 20,
            'value': '+1d4'
        }
    ];
    let targetSize = targetActor.system.traits.size;
    let keyX;
    let keyY;
    let value;
    let size;
    switch (targetSize) {
        case 'tiny':
            keyX = 'ATL.texture.scaleX';
            keyY = 'ATL.texture.scaleY';
            value = '0.8';
            size = 'sm';
            break;
        case 'sm':
            keyX = 'ATL.texture.scaleX';
            keyY = 'ATL.texture.scaleY';
            value = '1';
            size = 'med';
            break;
        case 'med':
            size = 'lg'
            break;
        case 'lg':
            size = 'huge';
            break;
        case 'huge':
            size = 'grg';
            break;
    }
    if (!keyX) keyX = 'ATL.height';
    if (!keyY) keyY = 'ATL.width';
    if (!value) value = targetToken.document.height + 1;
    changes.push({
        'key': keyX,
        'mode': 5,
        'priority': 20,
        'value': value
    });
    changes.push({
        'key': keyY,
        'mode': 5,
        'priority': 20,
        'value': value
    });
    changes.push({
        'key': 'system.traits.size',
        'mode': 5,
        'priority': 20,
        'value': size
    });
    let effectData = {
        'label': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 3600 * roll.total
        },
        'changes': changes
    };
    await chris.createEffect(targetActor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/items/potionOfMaximumPower.js


async function potionOfMaximumPower({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size === 0) return;
    if (workflow.item.type != 'spell') return;
    if (workflow.castData.castLevel > 4) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'potionOfMaximumPower', 480);
    if (!queueSetup) return;
    let oldDamageRoll = workflow.damageRoll;
    let newDamageRoll = '';
    for (let i = 0; oldDamageRoll.terms.length > i; i++) {
            let flavor = oldDamageRoll.terms[i].flavor;
            let isDeterministic = oldDamageRoll.terms[i].isDeterministic;
            if (isDeterministic === true) {
                newDamageRoll += oldDamageRoll.terms[i].formula;
            } else {
                newDamageRoll += '(' + oldDamageRoll.terms[i].number + '*' + oldDamageRoll.terms[i].faces + ')[' + flavor + ']';
            }
    }
    let roll = await new Roll(newDamageRoll).roll({async: true});
    await workflow.setDamageRoll(roll);
    let effect = chris.findEffect(workflow.actor, 'Potion of Maximum Power');
    if (effect) await chris.removeEffect(effect);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/items/potionOfPoison.js



async function potionOfPoison_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size === 0 || chris.inCombat()) return;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    let stacks = 3;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Item Features', 'Potion of Poison - Damage', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Potion of Poison - Damage');
    featureData.system.save.dc = workflow.item.system.save.dc;
    delete featureData._id;
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.token.document.uuid]);
    while (stacks > 0) {
        if (targetActor.system.attributes.hp.value === 0) break;
        let damageList = {
            3: '3d6[poison]',
            2: '2d6[poison]',
            1: '1d6[poison]'
        };
        featureData.system.damage.parts = [
            [
                damageList[stacks],
                'poison'
            ]
        ];
        let feature = new CONFIG.Item.documentClass(featureData, {'parent': targetActor});
        await warpgate.wait(500);
        let featureWorkflow = await MidiQOL.completeItemUse(feature, config, options);
        if (featureWorkflow.failedSaves.size === 0) {
            stacks -= 1;
        }
        if (stacks === 0) {
            let effect = chris.findEffect(targetActor, 'Potion of Poison');
            if (effect) await chris.removeEffect(effect);
            return;
        }
    }
}
async function potionOfPoison_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'potionOfPoison', 50);
    if (!queueSetup) return;
    if (workflow.targets.size != 1) return;
    let damageFormula = '3d6[poison]';
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function potionOfPoison_turnStart(token, actor, effect, origin) {
    let poisonedEffect = chris.findEffect(actor, 'Poisoned');
    if (!poisonedEffect) {
        effect.delete();
        return;
    }
    let stacks = await effect.getFlag('chris-premades', 'item.potionOfPosion.stacks');
    if (!stacks) stacks = 3;
    let damageList = {
        3: '3d6[poison]',
        2: '2d6[poison]',
        1: '1d6[poison]'
    };
    let damageFormula = damageList[stacks];
    let damageRoll = await new Roll(damageFormula).evaluate({async: true})
    damageRoll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: origin.name
    });
    await chris.applyDamage([token], damageRoll.total, 'poison');
}
async function potionOfPoison_turnEnd(token, actor, effect, origin) {
    let poisonedEffect = chris.findEffect(actor, 'Poisoned');
    if (!poisonedEffect) {
        effect.delete();
        return;
    }
    let stacks = await effect.getFlag('chris-premades', 'item.potionOfPosion.stacks');
    if (!stacks) stacks = 3;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Item Features', 'Potion of Poison - Damage', false);
    if (!featureData) return;
    featureData.system.save.dc = origin.system.save.dc;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Potion of Poison - Damage');
    featureData.name = 'Potion of Poision';
    featureData.system.damage.parts = [];
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.document.uuid]);
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': actor});
    let featureWorkflow = await MidiQOL.completeItemUse(feature, config, options);
    if (featureWorkflow.failedSaves.size === 0) {
        stacks -= 1;
        if (stacks === 0) {
            effect.delete()
            return;
        }
        await effect.setFlag('chris-premades', 'item.potionOfPosion.stacks', stacks);
    }
}
let potionOfPoison = {
    'item': potionOfPoison_item,
    'turnStart': potionOfPoison_turnStart,
    'turnEnd': potionOfPoison_turnEnd,
    'damage': potionOfPoison_damage
}
;// CONCATENATED MODULE: ./scripts/macros/items/potionOfVitality.js

async function potionOfVitality({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetActor = workflow.targets.first().actor;
    await chris.removeCondition(targetActor, 'Poisoned');
    await chris.removeCondition(targetActor, 'Exhaustion 1');
    await chris.removeCondition(targetActor, 'Exhaustion 2');
    await chris.removeCondition(targetActor, 'Exhaustion 3');
    await chris.removeCondition(targetActor, 'Exhaustion 4');
    await chris.removeCondition(targetActor, 'Exhaustion 5');
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/cleric/lifeDomain/preserveLife.js

async function preserveLife({speaker, actor, token, character, item, args, scope, workflow}) {
    let targets = await chris.findNearby(workflow.token, 30, 'ally', true);
    if (workflow.token) targets.push(workflow.token);
    if (targets.length === 0) return;
    let classLevels = workflow.actor.classes.cleric?.system.levels;
    if (!classLevels) return;
    let maxHeal = classLevels * 5;
    let buttons = [
        {
            'label': 'Ok',
            'value': true
        }, {
            'label': 'Cancel',
            'value': false
        }
    ];
    let selection = await chris.selectTarget('Who is getting healing? (Max: ' + maxHeal + ')', buttons, targets, null, 'number');
    if (!selection.buttons) return;
    let total = 0;
    for (let i of selection.inputs) {
        if (!isNaN(i)) total += i;
    }
    if (total > maxHeal) {
        ui.notifications.info('You can\'t heal that much!');
        return;
    }
    let count = 0;
    for (let i of targets) {
        if (!isNaN(selection.inputs[count])) {
            let currentHP = i.actor.system.attributes.hp.value;
            let maxHPHalf = Math.floor(i.actor.system.attributes.hp.max / 2);
            let healing = selection.inputs[count];
            if (currentHP >= maxHPHalf) continue;
            if (currentHP + healing > maxHPHalf) {
                healing = maxHPHalf - currentHP;
            }
            await chris.applyDamage([i], healing, 'healing');
            new Sequence().effect().atLocation(i).file('jb2a.cure_wounds.400px.blue').play();
        }
        count++;
    }
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/ranger/beastMaster/primalCompanion.js



async function primalCompanion_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let selection = await chris.dialog('What companion type?', [['Land', 'Land'], ['Sea', 'Sea'], ['Sky', 'Sky']]);
    if (!selection) return;
    let sourceActor = game.actors.getName('CPR - Primal Companion');
    if (!sourceActor) return;
    let rangerLevel = workflow.actor.classes?.ranger?.system?.levels;
    if (!rangerLevel) return;
    let primalBondData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Primal Bond', false);
    if (!primalBondData) return;
    primalBondData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Primal Bond');
    let commandData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Primal Companion - Command', false);
    if (!commandData) return;
    commandData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Primal Companion - Command');
    let dodgeData = await chris.getItemFromCompendium('chris-premades.CPR Actions', 'Dodge', false);
    if (!dodgeData) return;
    dodgeData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Dodge');
    let hpFormula = 5 + (rangerLevel * 5);
    let name = chris.getConfiguration(workflow.item, 'name-' + selection) ?? 'Beast of the ' + selection;
    if (name === '') name = 'Beast of the ' + selection;
    let meleeAttackBonus = await new Roll(workflow.actor.system.bonuses.msak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let rangedAttackBonus = await new Roll(workflow.actor.system.bonuses.rsak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'details': {
                    'cr': tashaSummon.getCR(workflow.actor.system.attributes.prof)
                },
                'attributes': {
                    'hp': {
                        'formula': hpFormula,
                        'max': hpFormula,
                        'value': hpFormula
                    },
                    'ac': {
                        'flat': 14 + workflow.actor.system.attributes.prof
                    }
                },
                'traits': {
                    'languages': workflow.actor.system?.traits?.languages
                }
            },
            'prototypeToken': {
                'name': name,
                'disposition': workflow.token.document.disposition
            },
            'flags': {
                'chris-premades': {
                    'summon': {
                        'attackBonus': {
                            'melee': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.wis.mod + meleeAttackBonus.total,
                            'ranged': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.wis.mod + rangedAttackBonus.total
                        }
                    }
                }
            }
        },
        'embedded': {
            'Item': {
                [primalBondData.name]: primalBondData,
                [dodgeData.name]: dodgeData
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition
        }
    }
    let updates2 = {};
    switch (selection) {
        case 'Land':
            let chargeData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Charge', false);
            if (!chargeData) return;
            chargeData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Charge');
            chargeData.system.save.dc = chris.getSpellDC(workflow.item);
            let maulData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Maul', false);
            if (!maulData) return;
            maulData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Maul');
            updates2 = {
                'actor': {
                    'system': {
                        'attributes': {
                            'movement': {
                                'walk': '40',
                                'climb': '40'
                            }
                        }
                    }
                },
                'embedded': {
                    'Item': {
                        [chargeData.name]: chargeData,
                        [maulData.name]: maulData
                    }
                }
            }
            if (rangerLevel >= 7) {
                updates2.embedded.Item[chargeData.name].flags.midiProperties.magicdam = true,
                updates2.embedded.Item[maulData.name].flags.midiProperties.magicdam = true
            }
        break;
        case 'Sea':
            let amphibiousData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Amphibious', false);
            if (!amphibiousData) return;
            amphibiousData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Amphibious');
            let bindingStrikeData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Binding Strike', false);
            if (!bindingStrikeData) return;
            bindingStrikeData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Binding Strike');
            updates2 = {
                'actor': {
                    'system': {
                        'attributes': {
                            'movement': {
                                'walk': '5',
                                'swim': '60'
                            }
                        }
                    }
                },
                'embedded': {
                    'Item': {
                        [amphibiousData.name]: amphibiousData,
                        [bindingStrikeData.name]: bindingStrikeData
                    }
                }
            };
            if (rangerLevel >= 7) {
                updates2.embedded.Item[bindingStrikeData.name].flags.midiProperties.magicdam = true
            }
        break;
        case 'Sky':
            hpFormula = 4 + 4 * rangerLevel;
            let flybyData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Flyby', false);
            if (!flybyData) return;
            flybyData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Flyby');
            let shredData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Shred', false);
            if (!shredData) return;
            shredData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Shred');
            updates2 = {
                'actor': {
                    'system': {
                        'abilities': {
                            'str': {
                                'value': 6
                            },
                            'dex': {
                                'value': 16
                            },
                            'con': {
                                'value': 13
                            }
                        },
                        'attributes': {
                            'hp': {
                                'formula': hpFormula,
                                'max': hpFormula,
                                'value': hpFormula
                            },
                            'movement': {
                                'walk': '10',
                                'fly': '60'
                            }
                        },
                        'traits': {
                            'size': 'sm'
                        }
                    }
                },
                'token': {
                    'texture': {
                        'scaleX': 0.8,
                        'scaleY': 0.8
                    }
                },
                'embedded': {
                    'Item': {
                        [flybyData.name]: flybyData,
                        [shredData.name]: shredData
                    }
                }
            };
            if (rangerLevel >= 7) {
                updates2.embedded.Item[shredData.name].flags.midiProperties.magicdam = true
            }
        break;
    }
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar-' + selection);
    let tokenImg = chris.getConfiguration(workflow.item, 'token-' + selection);
    if (avatarImg) updates.actor.img = avatarImg;
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    updates = mergeObject(updates, updates2, {'recursive': true});
    let defaultAnimations = {
        'Sky': 'air',
        'Land': 'earth',
        'Sea': 'water'
    };
    let animation = chris.getConfiguration(workflow.item, 'animation-' + selection) ?? defaultAnimations[selection];
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await tashaSummon.spawn(sourceActor, updates, 86400, workflow.item, 30, workflow.token, animation);
    let updates3 = {
        'embedded': {
            'Item': {
                [commandData.name]: commandData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Primal Companion',
        'description': commandData.name
    };
    await warpgate.mutate(workflow.token.document, updates3, {}, options);
    let effect = chris.findEffect(workflow.actor, workflow.item.name);
    if (!effect) return;
    let currentScript = effect.flags.effectmacro?.onDelete?.script;
    if (!currentScript) return;
    let effectUpdates = {
        'flags': {
            'effectmacro': {
                'onDelete': { 
                    'script': currentScript + ' await warpgate.revert(token.document, "Primal Companion");'
                }
            },
            'chris-premades': {
                'vae': {
                    'button': commandData.name
                }
            }
        }
    };
    await chris.updateEffect(effect, effectUpdates); 
}
async function bindingStrike({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'bindingStrike', 50);
    if (!queueSetup) return;
    let selection = await chris.dialog('What damage type?', [['Piercing', 'piercing'], ['Bludgeoning', 'bludgeoning']]);
    if (!selection) selection = 'piercing';
    let damageFormula = workflow.damageRoll._formula.replace('none', selection);
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
let primalCompanion = {
    'item': primalCompanion_item,
    'bindingStrike': bindingStrike,
}
;// CONCATENATED MODULE: ./scripts/macros/spells/protectionFromEvilAndGood.js


async function protectionFromEvilAndGood(workflow) {
    if (workflow.targets.size != 1 || workflow.disadvantage) return;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    let targetEffect = chris.findEffect(targetActor, 'Protection from Evil and Good');
    if (!targetEffect) return;
    let actorRace = chris.raceOrType(workflow.actor);
    let races = ['aberration', 'celestial', 'elemental', 'fey', 'fiend', 'undead'];
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'protectionFromEvilAndGood', 49);
    if (!queueSetup) return;
    if (races.includes(actorRace)) workflow.disadvantage = true;
    workflow.attackAdvAttribution.add('Disadvantage: Protection From Evil And Good');
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/raceFeatures/aasimar/radiantConsumption.js


async function radiantConsumption(token, origin) {
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Race Feature Items', 'Radiant Consumption - Damage', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Radiant Consumption - Damage');
    delete featureData._id;
    let nearbyTargets = chris.findNearby(token, 10, 'all', true).map(i => i.document.uuid);
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': token.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions(nearbyTargets);
    setProperty(options, 'workflowOptions.allowIncapacitated', true);
    await MidiQOL.completeItemUse(feature, config, options);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/warlock/celestial/radiantSoul.js


async function radiantSoul_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    let pass = args[0].macroPass;
    if (workflow.item.type != 'spell' || workflow.hitTargets.size === 0) return;
    if (!(pass === 'postDamageRoll' || pass === 'preDamageApplication')) return;
    let effect = chris.findEffect(workflow.actor, 'Radiant Soul');
    if (!effect) return;
    let feature = await fromUuid(effect.origin);
    if (!feature) return;
    let useFeature = chris.perTurnCheck(feature, 'feature', 'radiantSoul', false);
    if (!useFeature) return;
    switch (pass) {
        case 'postDamageRoll':
            if (workflow.hitTargets.size != 1) return;
            let queueSetup = await queue_queue.setup(workflow.item.uuid, 'radiantSoul', 250);
            if (!queueSetup) return;
            let damageTypes = chris.getRollDamageTypes(workflow.damageRoll);
            if (!(damageTypes.has('fire') || damageTypes.has('radiant'))) {
                queue_queue.remove(workflow.item.uuid);
                return;
            }
            let options = [];
            if (damageTypes.has('fire')) options.push(['Yes (Fire)', 'fire']);
            if (damageTypes.has('radiant')) options.push(['Yes (Radiant)', 'radiant']);
            options.push(['No', false]);
            let selected = await chris.dialog('Radiant Soul', options, 'Radiant Soul: Add extra damage?');
            if (!selected) {
                queue_queue.remove(workflow.item.uuid);
                return;
            }
            if (chris.inCombat()) await feature.setFlag('chris-premades', 'feature.radiantSoul.turn', game.combat.round + '-' + game.combat.turn);
            let damageFormula = workflow.damageRoll._formula + ' + ' + workflow.actor.system.abilities.cha.mod + '[' + selected + ']';
            let damageRoll = await new Roll(damageFormula).roll({async: true});
            await workflow.setDamageRoll(damageRoll);
            queue_queue.remove(workflow.item.uuid);
            return;
        case 'preDamageApplication':
            if (workflow.hitTargets.size <= 1) return;
            let queueSetup2 = queue_queue.setup(workflow.item.uuid, 'radiantSoul', 250);
            if (!queueSetup2) return;
            let damageTypes2 = chris.getRollDamageTypes(workflow.damageRoll);
            if (!(damageTypes2.has('fire') || damageTypes2.has('radiant'))) {
                queue_queue.remove(workflow.item.uuid);
                return;
            }
            let buttons = [
                {
                    'label': 'Yes',
                    'value': true
                }, {
                    'label': 'No',
                    'value': false
                }
            ];
            let selection = await chris.selectTarget('Radiant Soul: Add extra damage?', buttons, workflow.targets, false, 'one');
            if (selection.buttons === false) {
                queue_queue.remove(workflow.item.uuid);
                return;
            }
            if (chris.inCombat()) await feature.setFlag('chris-premades', 'feature.radiantSoul.turn', game.combat.round + '-' + game.combat.turn);
            let targetTokenID = selection.inputs.find(id => id != false);
            if (!targetTokenID) {
                queue_queue.remove(workflow.item.uuid);
                return;
            }
            let targetDamage = workflow.damageList.find(i => i.tokenId === targetTokenID);
            let options2 = [];
            if (damageTypes2.has('fire')) options2.push(['Yes (Fire)', 'fire']);
            if (damageTypes2.has('radiant')) options2.push(['Yes (Radiant)', 'radiant']);
            let selected2;
            if (options2.length === 2) {
                selected2 = await chris.dialog('Radiant Soul', options2, 'What damage type?');
            } else if (damageTypes2.has('fire')) {
                selected2 = 'fire';
            } else {
                selected2 = 'radiant';
            }
            if (!selected2) selected2 = 'radiant';
            let targetActor = canvas.scene.tokens.get(targetDamage.tokenId).actor;
            if (!targetActor) {
                queue_queue.remove(workflow.item.uuid);
                return;
            }
            let hasDI = chris.checkTrait(targetActor, 'di', selected2);
            if (hasDI) {
                queue_queue.remove(workflow.item.uuid);
                return;
            }
            let damageTotal = workflow.actor.system.abilities.cha.mod;
            let hasDR = chris.checkTrait(targetActor, 'dr', selected2);
            if (hasDR) damageTotal = Math.floor(damageTotal / 2);
            targetDamage.damageDetail[0].push(
                {
                    'damage': damageTotal,
                    'type': selected2
                }
            );
            targetDamage.totalDamage += damageTotal;
            targetDamage.appliedDamage += damageTotal;
            targetDamage.hpDamage += damageTotal;
            if (targetDamage.oldTempHP > 0) {
                if (targetDamage.oldTempHP >= damageTotal) {
                    targetDamage.newTempHP -= damageTotal;
                } else {
                    let leftHP = damageTotal - targetDamage.oldTempHP;
                    targetDamage.newTempHP = 0;
                    targetDamage.newHP -= leftHP;
                }
            } else {
                targetDamage.newHP -= damageTotal;
            }
            queue_queue.remove(workflow.item.uuid);
            return;
    }
}
async function radiantSoul_turn(origin) {
    await origin.setFlag('chris-premades', 'feature.radiantSoul.turn', false);
}
let radiantSoul = {
    'attack': radiantSoul_attack,
    'turn': radiantSoul_turn
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/artificer/infusions/radiantWeapon.js


async function radiantWeapon_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let infusionId = workflow.item.flags['chris-premades']?.feature?.infusion?.radiantWeapon?.id;
    if (!infusionId) {
        let validWeapons = workflow.actor.items.filter(i => i.type === 'weapon' && !i.system.properties?.mgc);
        if (chris.getItem(actor, 'Armor Modifications')) {
            let gauntlets = chris.getItem(workflow.actor, 'Guardian Armor: Thunder Gauntlets');
            if (gauntlets) validWeapons.push(gauntlets);
        }
        if (validWeapons.length === 0) {
            ui.notifications.info('No valid weapon to infuse!');
            return;
        }
        let [selection] = await chris.selectDocument('Infuse what weapon?', validWeapons, false);
        if (!selection) return;
        await workflow.item.setFlag('chris-premades', 'feature.infusion.radiantWeapon.id', selection.id);
    } else {
        let selection = await chris.dialog(workflow.item.name, [['Yes', true], ['No', false]], 'Remove radiant weapon infusion?');
        if (!selection) return;
        await workflow.item.setFlag('chris-premades', 'feature.infusion.radiantWeapon.id', null);
    }
}
async function radiantWeapon_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    let originItem = chris.getItem(workflow.actor, 'Radiant Weapon');
    if (!originItem) return;
    if (workflow.item.id != originItem.flags['chris-premades']?.feature?.infusion?.radiantWeapon?.id) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'radiantWeapon', 150);
    if (!queueSetup) return;
    let parts = duplicate(workflow.item.system.damage.parts);
    parts[0][0] = parts[0][0] + ' + 1';
    let properties = duplicate(workflow.item.system.properties);
    let attackBonus = duplicate(workflow.item.system.attackBonus);
    attackBonus = 1;
    properties.mgc = true;
    workflow.item = workflow.item.clone({'system.damage.parts': parts, 'system.properties': properties, 'system.attackBonus': attackBonus}, {'keepId': true});
    workflow.item.prepareData();
    workflow.item.prepareFinalAttributes();
    queue_queue.remove(workflow.item.uuid);
}
async function blind({speaker, actor, token, character, item, args, scope, workflow}) {
    let originItem = chris.getItem(workflow.actor, 'Radiant Weapon');
    if (!originItem) return;
    let saveDC = chris.getConfiguration(originItem, 'savedc');
    if (!saveDC) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'radiantWeaponBlind', 50);
    if (!queueSetup) return;
    workflow.item = workflow.item.clone({'system.save.dc': saveDC}, {'keepId': true});
    queue_queue.remove(workflow.item.uuid);
}
let radiantWeapon = {
    'item': radiantWeapon_item,
    'attack': radiantWeapon_attack,
    'blind': blind
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/barbarian/rage.js



async function rage_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.actor || !workflow.token) return;
    let effect = chris.findEffect(workflow.actor, 'Concentrating');
    if (effect) chris.removeEffect(effect);
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Rage - End', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Rage - End');
    async function effectMacro () {
        if (chrisPremades.helpers.getItem(actor, 'Call the Hunt')) await chrisPremades.macros.callTheHunt.rageEnd(effect);
        await warpgate.revert(token.document, 'Rage');
        await chrisPremades.macros.rage.animationEnd(token, origin);
        if (chrisPremades.helpers.getItem(actor, 'Giant\'s Havoc: Giant Stature')) await warpgate.revert(token.document, 'Giant Stature');
        let effect2 = chrisPremades.helpers.findEffect(actor, 'Elemental Cleaver');
        if (effect2) await chrisPremades.helpers.removeEffect(effect2);
    }
    async function effectMacro2 () {
        await chrisPremades.macros.rage.animationStart(token, origin);
    }
    let effectData = {
        'changes': [
            {
                'key': 'flags.midi-qol.advantage.ability.check.str',
                'mode': 0,
                'value': '1',
                'priority': 0
            },
            {
                'key': 'flags.midi-qol.advantage.ability.save.str',
                'mode': 0,
                'value': '1',
                'priority': 0
            },
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'value': 'slashing',
                'priority': 20
            },
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'value': 'piercing',
                'priority': 20
            },
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'value': 'bludgeoning',
                'priority': 20
            },
            {
                'key': 'system.bonuses.mwak.damage',
                'mode': 2,
                'value': '+ @scale.barbarian.rage-damage',
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.fail.spell.vocal',
                'value': '1',
                'mode': 0,
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.fail.spell.somatic',
                'value': '1',
                'mode': 0,
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.fail.spell.material',
                'value': '1',
                'mode': 0,
                'priority': 20
            }
        ],
        'duration': {
            'seconds': 60
        },
        'icon': workflow.item.img,
        'name': workflow.item.name,
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                },
                'onCreate': {
                    'script': chris.functionToString(effectMacro2)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            },
            'dae': {
                'specialDuration': [
                    'zeroHP'
                ]
            }
        }
    }
    if (!chris.getItem(actor, 'Persistent Rage')) {
        effectData.changes = effectData.changes.concat([
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.rage.attack,postActiveEffects',
                'priority': 20
            },
            {
                'key': 'flags.chris-premades.feature.onHit.rage',
                'mode': 5,
                'value': true,
                'priority': 20
            }
        ]);
        effectData.flags.effectmacro.onTurnEnd = {
            'script': 'await chrisPremades.macros.rage.turnEnd(effect, actor);'
        }
        effectData.flags.effectmacro.onCombatStart = {
            'script': 'await chrisPremades.macros.rage.combatStart(effect);'
        }
        if (chris.inCombat()) setProperty(effectData, 'flags.chris-premades.feature.rage.attackOrAttacked', {'turn': game.combat.turn, 'round': game.combat.round});
    }
    let totemBear = chris.getItem(workflow.actor, 'Totem Spirit: Bear');
    if (totemBear) {
        effectData.changes = effectData.changes.concat([
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'value': 'acid',
                'priority': 20
            },
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'value': 'cold',
                'priority': 20
            },
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'value': 'fire',
                'priority': 20
            },
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'value': 'force',
                'priority': 20
            },
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'value': 'lightning',
                'priority': 20
            },
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'value': 'necrotic',
                'priority': 20
            },
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'value': 'poison',
                'priority': 20
            },
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'value': 'radiant',
                'priority': 20
            },
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'value': 'thunder',
                'priority': 20
            }
        ]);
    }
    let crushingThrow = chris.getItem(workflow.actor, 'Giant\'s Havoc: Crushing Throw');
    if (crushingThrow) {
        effectData.changes = effectData.changes.concat([
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.crushingThrow,postDamageRoll',
                'priority': 20
            }
        ]);
    }
    let giantStature = chris.getItem(workflow.actor, 'Giant\'s Havoc: Giant Stature');
    let demiurgicColossus = chris.getItem(workflow.actor, 'Demiurgic Colossus');
    if (giantStature && chris.getSize(workflow.actor) < (demiurgicColossus ? 4 : 3)) {
        let lrgRoom = chris.checkForRoom(workflow.token, 1);
        let lrgDirection = chris.findDirection(lrgRoom);
        if (lrgDirection != 'none') {
            let hgRoom;
            let hgDirection;
            let dCSelection = 'lg';
            if (demiurgicColossus) {
                hgRoom = chris.checkForRoom(workflow.token, 2);
                if (!lrgRoom.n && !lrgRoom.e && !lrgRoom.s && !lrgRoom.w) hgDirection = 'outward';
                if (hgDirection != 'outward') hgDirection = chris.findDirection(hgRoom);
                if (hgDirection != 'none') dCSelection = await chris.dialog(demiurgicColossus.name, [['Large', 'lg'], ['Huge', 'huge']], 'What size?') ?? 'lg';
            }
            if (dCSelection === 'huge') await demiurgicColossus.displayCard();
            let updates2 = {
                'token': {
                    'width': dCSelection === 'lg' ? 2 : 3,
                    'height': dCSelection === 'lg' ? 2 : 3
                },
                'actor': {
                    'system': {
                        'traits': {
                            'size': dCSelection
                        }
                    }
                }
            }
            let direction = dCSelection === 'lg' ? lrgDirection : hgDirection;
            let scale = dCSelection === 'lg' ? 1 : 2;
            switch(direction) {
                case 'none':
                    break;
                case 'ne':
                    setProperty(updates2.token, 'y', workflow.token.y - canvas.grid.size * scale);
                    break;
                case 'sw':
                    setProperty(updates2.token, 'x', workflow.token.x - canvas.grid.size * scale);
                    break;
                case 'outward':
                    scale = 1;
                case 'nw':
                    setProperty(updates2.token, 'x', workflow.token.x - canvas.grid.size * scale);
                    setProperty(updates2.token, 'y', workflow.token.y - canvas.grid.size * scale);
                    break;
            }
            let callbacks = {
                'delta': (delta, tokenDoc) => {
                    if ('x' in delta.token) delete delta.token.x;
                    if ('y' in delta.token) delete delta.token.y;
                }
            };
            if (chris.jb2aCheck() === 'patreon') {
                await enlargeReduce.enlargeAnimation(workflow.token, updates2, 'Giant Stature', callbacks);
            } else {
                let options = {
                    'permanent': false,
                    'name': 'Giant Stature',
                    'description': 'Giant Stature'
                };
                await warpgate.mutate(workflow.token.document, updates2, callbacks, options);
            }
            effectData.changes = effectData.changes.concat([
                {
                    'key': 'flags.midi-qol.range.mwak',
                    'mode': 2,
                    'value': (demiurgicColossus ? 10 : 5),
                    'priority': 20
                }
            ]);
            await giantStature.displayCard();
        }
    }
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let formOfBeastFeature = chris.getItem(workflow.actor, 'Form of the Beast');
    if (formOfBeastFeature) {
        let selection = await chris.dialog(formOfBeastFeature.name, [['Bite', 'Form of the Beast: Bite'], ['Claws', 'Form of the Beast: Claws'], ['Tail', 'Form of the Beast: Tail'], ['None', false]], 'Manifest a natural weapon?');
        if (selection) {
            let featureData2 = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', selection);
            if (!featureData2) return;
            featureData2.system.description.value = chris.getItemDescription('CPR - Descriptions', selection);
            if (chris.getItem(workflow.actor, 'Bestial Soul')) setProperty(featureData2, 'flags.midiProperties.magicdam', true);
            setProperty(featureData2, 'flags.chris-premades.feature.formOfTheBeast.natural', true);
            updates.embedded.Item[selection] = featureData2;
            if (selection === 'Form of the Beast: Tail') {
                let featureData3 = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Form of the Beast: Tail Reaction');
                if (!featureData3) return;
                featureData3.system.description.value = chris.getItemDescription('CPR - Descriptions', featureData3.name);
                updates.embedded.Item[featureData3.name] = featureData3;
            }
            await formOfBeastFeature.use();
        }
    }
    let options = {
        'permanent': false,
        'name': 'Rage',
        'description': featureData.name
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
    let callTheHunt = chris.getItem(workflow.actor, 'Call the Hunt');
    if (callTheHunt) {
        if (callTheHunt.system.uses.value) {
            let selection = await chris.dialog(callTheHunt.name, constants_constants.yesNo, 'Use ' + callTheHunt.name + '?');
            if (selection) await callTheHunt.use();
        }
    }
    let wildSurge = chris.getItem(workflow.actor, 'Wild Surge');
    if (wildSurge) await wildSurge.use();
    let elementalCleaver = chris.getItem(workflow.actor, 'Elemental Cleaver');
    if (elementalCleaver) await elementalCleaver.use();
}
async function rage_end({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.actor) return;
    let effect = chris.findEffect(workflow.actor, 'Rage');
    if (!effect) return;
    await chris.removeEffect(effect);
}
async function rage_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Rage');
    if (!effect) return;
    if (!chris.inCombat()) return;
    if (!constants_constants.attacks.includes(workflow.item.system.actionType)) return;
    await effect.setFlag('chris-premades', 'feature.rage.attackOrAttacked', {'turn': game.combat.turn, 'round': game.combat.round});
}
async function rage_attacked(workflow, token) {
    let effect = chris.findEffect(token.actor, 'Rage');
    if (!effect) return;
    if (!chris.inCombat()) return;
    if (!workflow.damageRoll) return;
    let damageItem = workflow.damageList.find(i => i.tokenId === token.id);
    if (!damageItem) return;
    if (damageItem.newHP >= damageItem.oldHP) return;
    let updates = {
        'flags': {
            'chris-premades': {
                'feature': {
                    'rage': {
                        'attackOrAttacked': {
                            'turn': game.combat.turn,
                            'round': game.combat.round
                        }
                    }
                }
            }
        }
    };
    await chris.updateEffect(effect, updates);
}
async function rage_turnEnd(effect, actor) {
    let lastRound = effect.flags['chris-premades']?.feature?.rage?.attackOrAttacked?.round;
    let lastTurn = effect.flags['chris-premades']?.feature?.rage?.attackOrAttacked?.turn;
    if (lastRound === undefined || lastTurn === undefined) return;
    let currentRound = game.combat.previous.round;
    let currentTurn = game.combat.previous.turn;
    let roundDiff = currentRound - lastRound;
    if (roundDiff >= 1) {
        if (currentTurn >= lastTurn) {
            let userId = chris.lastGM();
            let selection = await chris.remoteDialog('Rage', constants_constants.yesNo, userId, actor.name + ' has not attacked an enemy or taken damage since their last turn. Remove Rage?');
            if (!selection) return;
            await chris.removeEffect(effect);
        }
    }
}
async function combatStart(effect) {
    await effect.setFlag('chris-premades', 'feature.rage.attackOrAttacked', {'turn': 0, 'round': 0});
}
async function rage_animationStart(token, origin) {
    //Animations by: eskiemoh
    let animation = chris.getConfiguration(origin, 'animation') ?? 'default';
    if (animation === 'none' || chris.jb2aCheck() === 'free') return;
    switch (animation) {
        case 'default':
            new Sequence()
                
                .effect()
                .file('jb2a.extras.tmfx.outpulse.circle.02.normal')
                .atLocation(token)
                .size(4, {'gridUnits': true})
                .opacity(0.25)
                
                .effect()
                .file('jb2a.impact.ground_crack.orange.02')
                .atLocation(token)
                .belowTokens()
                .filter('ColorMatrix', {'hue': -15,'saturate': 1})
                .size(3.5, {'gridUnits': true})
                .zIndex(1)
                
                .effect()
                .file('jb2a.impact.ground_crack.still_frame.02')
                .atLocation(token)
                .belowTokens()
                .fadeIn(1000)
                .filter('ColorMatrix', {'hue': -15,'saturate': 1})
                .size(3.5, {'gridUnits': true})
                .zIndex(0)
                .duration(8000)
                .fadeOut(3000)
                
                .effect()
                .file('jb2a.wind_stream.white')
                .atLocation(token, {'offset': {y:-0.05}, 'gridUnits': true})
                .size(1.75, {'gridUnits': true})
                .rotate(90)
                .opacity(0.9)
                .filter('ColorMatrix', {'saturate': 1})
                .tint('#FF0000')
                .loopProperty('sprite', 'position.y', {'from': -5, 'to': 5, 'duration': 50, 'pingPong': true})
                .duration(8000)
                .fadeOut(3000)
                
                .effect()
                .file('jb2a.particles.outward.orange.01.03')
                .atLocation(token)
                .scaleToObject(2.5)
                .opacity(1)
                .fadeIn(200)
                .fadeOut(3000)
                .loopProperty('sprite', 'position.x', {'from': -5, 'to': 5, 'duration': 50, 'pingPong': true})
                .animateProperty('sprite', 'position.y', {'from': 0, 'to': -100, 'duration': 6000, 'pingPong': true, 'delay': 2000})
                .duration(8000)
                
                .effect()
                .file('jb2a.wind_stream.white')
                .atLocation(token)
                .name('Rage')
                .attachTo(token)
                .scaleToObject()
                .rotate(90)
                .opacity(1)
                .filter('ColorMatrix', {'saturate': 1})
                .tint('#FF0000')
                .persist()
                .private()
                
                .effect()
                .file('jb2a.token_border.circle.static.orange.012')
                .atLocation(token)
                .name('Rage')
                .attachTo(token)
                .opacity(0.6)
                .scaleToObject(1.9)
                .filter('ColorMatrix', {'saturate': 1})
                .tint('#FF0000')
                .persist()

                .play()
            break;
        case 'lightning':
            new Sequence()

                .effect()
                .file('jb2a.extras.tmfx.outpulse.circle.02.normal')
                .atLocation(token)
                .size(4, {'gridUnits': true})
                .opacity(0.25)

                .effect()
                .file('jb2a.impact.ground_crack.purple.02')
                .atLocation(token)
                .belowTokens()
                .filter('ColorMatrix', {'hue': -15,'saturate': 1})
                .size(3.5, {'gridUnits': true})
                .zIndex(1)

                .effect()
                .file('jb2a.impact.ground_crack.still_frame.02')
                .atLocation(token)
                .belowTokens()
                .fadeIn(1000)
                .filter('ColorMatrix', {'hue': -15,'saturate': 1})
                .size(3.5, {'gridUnits': true})
                .duration(8000)
                .fadeOut(3000)
                .zIndex(0)

                .effect()
                .file('jb2a.static_electricity.03.purple')
                .atLocation(token)
                .size(3, {'gridUnits': true})
                .rotate(90)
                .randomRotation()
                .opacity(0.75)
                .belowTokens()
                .duration(8000)
                .fadeOut(3000)

                .effect()
                .file('jb2a.particles.outward.purple.01.03')
                .atLocation(token)
                .scaleToObject(2.5)
                .opacity(1)
                .fadeIn(200)
                .fadeOut(3000)
                .loopProperty('sprite', 'position.x', {'from': -5, 'to': 5, 'duration': 50, 'pingPong': true})
                .animateProperty('sprite', 'position.y', {'from': 0, 'to': -100, 'duration': 6000, 'pingPong': true, 'delay': 2000})
                .duration(8000)

                .effect()
                .file('jb2a.static_electricity.03.purple')
                .atLocation(token)
                .name('Rage')
                .attachTo(token)
                .scaleToObject()
                .rotate(90)
                .opacity(1)
                .persist()
                .private()

                .effect()
                .file('jb2a.token_border.circle.static.purple.009')
                .atLocation(token)
                .name('Rage')
                .attachTo(token)
                .belowTokens()
                .opacity(1)
                .scaleToObject(2.025)
                .persist()
                .zIndex(5)

                .play()
            break;
        case 'saiyan':
            new Sequence()

                .effect()
                .file('jb2a.extras.tmfx.outpulse.circle.02.normal')
                .atLocation(token)
                .size(4, {'gridUnits': true})
                .opacity(0.25)

                .effect()
                .file('jb2a.impact.ground_crack.orange.02')
                .atLocation(token)
                .belowTokens()
                .filter('ColorMatrix', {'hue': 20,'saturate': 1})
                .size(3.5, {'gridUnits': true})
                .zIndex(1)

                .effect()
                .file('jb2a.impact.ground_crack.still_frame.02')
                .atLocation(token)
                .belowTokens()
                .fadeIn(2000)
                .filter('ColorMatrix', {'hue': -15,'saturate': 1})
                .size(3.5, {'gridUnits': true})
                .duration(8000)
                .fadeOut(3000)
                .zIndex(0)

                .effect()
                .file('jb2a.wind_stream.white')
                .atLocation(token, {'offset':{'y':75}})
                .size(1.75, {'gridUnits': true})
                .rotate(90)
                .opacity(1)
                .loopProperty('sprite', 'position.y', {'from': -5, 'to': 5, 'duration': 50, 'pingPong': true})
                .duration(8000)
                .fadeOut(3000)
                .tint('#FFDD00')

                .effect()
                .file('jb2a.particles.outward.orange.01.03')
                .atLocation(token)
                .scaleToObject(2.5)
                .opacity(1)
                .fadeIn(200)
                .fadeOut(3000)
                .loopProperty('sprite', 'position.x', {'from': -5, 'to': 5, 'duration': 50, 'pingPong': true})
                .animateProperty('sprite', 'position.y', {'from': 0, 'to': -100, 'duration': 6000, 'pingPong': true, 'delay': 2000})
                .duration(8000)

                .effect()
                .file('jb2a.wind_stream.white')
                .atLocation(token)
                .name('Rage')
                .attachTo(token)
                .scaleToObject()
                .rotate(90)
                .opacity(1)
                .filter('ColorMatrix', {'saturate': 1})
                .tint('#FFDD00')
                .persist()
                .private()

                .effect()
                .file('jb2a.token_border.circle.static.orange.012')
                .atLocation(token)
                .name('Rage')
                .attachTo(token)
                .opacity(0.7)
                .scaleToObject(1.9)
                .filter('ColorMatrix', {'hue': 30, 'saturate': 1 , 'contrast': 0, 'brightness': 1})
                .persist()

                .play();
            break;
    }
}
async function rage_animationEnd(token, origin) {
    let animation = chris.getConfiguration(origin, 'animation') ?? 'default';
    if (animation === 'none') return;
    await Sequencer.EffectManager.endEffects({'name': 'Rage', 'object': token});
    new Sequence()
        .animation()
        .on(token)
        .opacity(1)

        .play();
}
let rage = {
    'item': rage_item,
    'end': rage_end,
    'animationStart': rage_animationStart,
    'animationEnd': rage_animationEnd,
    'attack': rage_attack,
    'attacked': rage_attacked,
    'turnEnd': rage_turnEnd,
    'combatStart': combatStart
}
;// CONCATENATED MODULE: ./scripts/macros/spells/rayOfEnfeeblement.js

async function rayOfEnfeeblement({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.isFumble || workflow.item.type != 'weapon') return;
    if (workflow.item.system.properties?.fin) {
        let str = workflow.actor.system.abilities.str.value;
        let dex = workflow.actor.system.abilities.dex.value;
        if (str < dex) return;
    }
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'rayOfEnfeeblement', 360);
    if (!queueSetup) return;
    let damageRollFormula = 'floor((' + workflow.damageRoll._formula + ') / 2)';
    let damageRoll = await new Roll(damageRollFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/cleric/deathDomain/reaper.js



async function reaper({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    if (workflow.item.type != 'spell' || workflow.item.system.level != 0 || workflow.item.system.school != 'nec' || workflow.item.flags['chris-premades']?.reap) return;
    let targetToken = workflow.targets.first();
    let nearbyTargets = chris.findNearby(targetToken, 5, 'ally');
    if (nearbyTargets.length === 0) return;
    let buttons = [
        {
            'label': 'Yes',
            'value': true
        }, {
            'label': 'No',
            'value': false
        }
    ];
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'reaper', 450);
    if (!queueSetup) return;
    let selected = await chris.selectTarget('Use Reaper?', buttons, nearbyTargets, true, 'one');
    if (selected.buttons === false) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let targetTokenUuid = selected.inputs.find(id => id != false);
    if (!targetTokenUuid) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let effect = chris.findEffect(workflow.actor, 'Reaper');
    let originItem = await fromUuid(effect.origin);
    if (originItem)    await originItem.use();
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetTokenUuid]);
    let spellData = duplicate(workflow.item.toObject());
    spellData.flags['chris-premades'] = {
        'reap': true
    };
    let spell = new CONFIG.Item.documentClass(spellData, {'parent': workflow.actor});
    spell.prepareData();
    spell.prepareFinalAttributes();
    await MidiQOL.completeItemUse(spell, config, options);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/raceFeatures/orc/relentlessEndurance.js


async function relentlessEndurance(token, {item, workflow, ditem}) {
    if (ditem.newHP != 0 || ditem.oldHP === 0) return;
    let tokenActor = token.actor;
    let effect = chris.findEffect(tokenActor, 'Relentless Endurance');
    if (!effect) return;
    let maxHP = tokenActor.system.attributes?.hp?.max;
    if (!maxHP) return;
    if (ditem.appliedDamage > (maxHP + ditem.oldHP)) return;
    let originItem = await fromUuid(effect.origin);
    if (!originItem) return;
    if (originItem.system.uses.value === 0) return;
    let selection = await chris.remoteDialog(originItem.name, [['Yes', true], ['No', false]], chris.firstOwner(token.document).id, 'Use Relentless Endurance?');
    if (!selection) return;
    let queueSetup = await queue_queue.setup(workflow.uuid, 'relentlessEndurance', 389);
    if (!queueSetup) return;
    await originItem.update({
        'system.uses.value': originItem.system.uses.value -1
    });
    ditem.newHP = 1;
    ditem.hpDamage = Math.abs(ditem.newHP - ditem.oldHP);
    queue_queue.remove(workflow.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/fighter/battleMaster/relentless.js

async function relentless(actor) {
    let feature = chris.getItem(actor, 'Superiority Dice');
    if (!feature) return;
    if (!feature.system.uses.value) await feature.update({'system.uses.value': 1})
}
;// CONCATENATED MODULE: ./scripts/macros/generic/removeTemplate.js

async function removeTemplate({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, workflow.item.name + ' Template');
    if (!effect) return;
    let updates = {
        'flags': {
            'effectmacro': {
                'onTurnEnd': {
                    'script': 'await effect.delete();'
                }
            }
        }
    };
    await chris.updateEffect(effect, updates);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/artificer/infusions/repeatingShot.js



async function repeatingShot_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let infusionId = workflow.item.flags['chris-premades']?.feature?.infusion?.repeatingShot?.id;
    if (!infusionId) {
        let validWeapons = workflow.actor.items.filter(i => i.type === 'weapon' && !i.system.properties?.mgc && i.system.properties?.amm);
        if (validWeapons.length === 0) {
            ui.notifications.info('No valid weapon to infuse!');
            return;
        }
        let [selection] = await chris.selectDocument('Infuse what weapon?', validWeapons, false);
        if (!selection) return;
        await workflow.item.setFlag('chris-premades', 'feature.infusion.repeatingShot.id', selection.id);
    } else {
        let selection = await chris.dialog(workflow.item.name, constants_constants.yesNo, 'Remove repeating shot infusion?');
        if (!selection) return;
        await workflow.item.setFlag('chris-premades', 'feature.infusion.repeatingShot.id', null);
    }
}
async function repeatingShot_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    let originItem = chris.getItem(workflow.actor, 'Repeating Shot');
    if (!originItem) return;
    if (workflow.item.id != originItem.flags['chris-premades']?.feature?.infusion?.repeatingShot?.id) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'repeatingShot', 150);
    if (!queueSetup) return;
    let parts = duplicate(workflow.item.system.damage.parts);
    parts[0][0] = parts[0][0] + ' + 1';
    let properties = duplicate(workflow.item.system.properties);
    let attackBonus = duplicate(workflow.item.system.attackBonus);
    attackBonus = 1;
    properties.mgc = true;
    workflow.item = workflow.item.clone({'system.damage.parts': parts, 'system.properties': properties, 'system.attackBonus': attackBonus}, {'keepId': true});
    workflow.item.prepareData();
    workflow.item.prepareFinalAttributes();
    queue_queue.remove(workflow.item.uuid);
}
let repeatingShot = {
    'item': repeatingShot_item,
    'attack': repeatingShot_attack
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/warlock/invocations/repellingBlast.js


async function repellingBlast({speaker, actor, token, character, item, args, scope, workflow}) {
    let spellName = workflow.actor.flags['chris-premades']?.feature?.repellingBlast?.name;
    if (!spellName) spellName = 'Eldritch Blast';
    if (workflow.item.name != spellName || workflow.hitTargets.size != 1) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'repellingBlast', 450);
    if (!queueSetup) return;
    let selection = await chris.dialog('Repelling Blast', [['10 ft.', 10], ['5 ft.', 5], ['0 ft.', false]], 'How far do you push the target?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let targetToken = workflow.targets.first();
    let knockBackFactor;
    let ray;
    let newCenter;
    let hitsWall = true;
    while (hitsWall) {
        knockBackFactor = selection / canvas.dimensions.distance;
        ray = new Ray(workflow.token.center, targetToken.center);
        newCenter = ray.project(1 + ((canvas.dimensions.size * knockBackFactor) / ray.distance));
        hitsWall = targetToken.checkCollision(newCenter, {origin: ray.A, type: "move", mode: "any"});
        if (hitsWall) {
            selection -= 5;
            if (selection === 0) {
                ui.notifications.info('Target is unable to be moved!');
                queue_queue.remove(workflow.item.uuid);
                return;
            }
        }
    }
    newCenter = canvas.grid.getSnappedPosition(newCenter.x - targetToken.w / 2, newCenter.y - targetToken.h / 2, 1);
    let targetUpdate = {
        'token': {
            'x': newCenter.x,
            'y': newCenter.y
        }
    };
    let options = {
        'permanent': true,
        'name': workflow.item.name,
        'description': workflow.item.name
    };
    await warpgate.mutate(targetToken.document, targetUpdate, {}, options);
    let effect = chris.findEffect(workflow.actor, 'Eldritch Invocations: Repelling Blast');
    if (effect) {
        let originItem = await fromUuid(effect.origin);
        if (originItem) await originItem.use();
    }
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/artificer/infusions/repulsionShield.js


async function repulsionShield({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'repulsionShield', 50);
    if (!queueSetup) return;
    let selection = await chris.dialog(workflow.item.name, [['15 ft.', 15], ['10 ft.', 10], ['5 ft.', 5]], 'How far do you push the target?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let targetToken = workflow.targets.first();
    let knockBackFactor;
    let ray;
    let newCenter;
    let hitsWall = true;
    while (hitsWall) {
        knockBackFactor = selection / canvas.dimensions.distance;
        ray = new Ray(workflow.token.center, targetToken.center);
        newCenter = ray.project(1 + ((canvas.dimensions.size * knockBackFactor) / ray.distance));
        hitsWall = targetToken.checkCollision(newCenter, {origin: ray.A, type: "move", mode: "any"});
        if (hitsWall) {
            selection -= 5;
            if (selection === 0) {
                ui.notifications.info('Target is unable to be moved!');
                queue_queue.remove(workflow.item.uuid);
                return;
            }
        }
    }
    newCenter = canvas.grid.getSnappedPosition(newCenter.x - targetToken.w / 2, newCenter.y - targetToken.h / 2, 1);
    let targetUpdate = {
        'token': {
            'x': newCenter.x,
            'y': newCenter.y
        }
    };
    let options = {
        'permanent': true,
        'name': workflow.item.name,
        'description': workflow.item.name
    };
    await warpgate.mutate(targetToken.document, targetUpdate, {}, options);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/artificer/infusions/resistantArmor.js

async function resistantArmor(origin, effect) {
    let resistance = chris.getConfiguration(origin, 'resistance');
    if (!resistance) return;
    if (effect.changes[0].value === resistance) return;
    let updates = {
        'changes': [
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'priority': 20,
                'value': resistance
            }
        ]
    }
    await chris.updateEffect(effect, updates);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/artificer/infusions/returningWeapon.js


async function returningWeapon_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let infusionId = workflow.item.flags['chris-premades']?.feature?.infusion?.returningWeapon?.id;
    if (!infusionId) {
        let validWeapons = workflow.actor.items.filter(i => i.type === 'weapon' && !i.system.properties?.mgc && i.system.properties?.thr);
        if (validWeapons.length === 0) {
            ui.notifications.info('No valid weapon to infuse!');
            return;
        }
        let [selection] = await chris.selectDocument('Infuse what weapon?', validWeapons, false);
        if (!selection) return;
        await workflow.item.setFlag('chris-premades', 'feature.infusion.returningWeapon.id', selection.id);
    } else {
        let selection = await chris.dialog(workflow.item.name, [['Yes', true], ['No', false]], 'Remove returning weapon infusion?');
        if (!selection) return;
        await workflow.item.setFlag('chris-premades', 'feature.infusion.returningWeapon.id', null);
    }
}
async function returningWeapon_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    let originItem = chris.getItem(workflow.actor, 'Returning Weapon');
    if (!originItem) return;
    if (workflow.item.id != originItem.flags['chris-premades']?.feature?.infusion?.returningWeapon?.id) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'returningWeapon', 150);
    if (!queueSetup) return;
    let parts = duplicate(workflow.item.system.damage.parts);
    parts[0][0] = parts[0][0] + ' + 1';
    let properties = duplicate(workflow.item.system.properties);
    let attackBonus = duplicate(workflow.item.system.attackBonus);
    attackBonus = 1;
    properties.mgc = true;
    workflow.item = workflow.item.clone({'system.damage.parts': parts, 'system.properties': properties, 'system.attackBonus': attackBonus}, {'keepId': true});
    workflow.item.prepareData();
    workflow.item.prepareFinalAttributes();
    queue_queue.remove(workflow.item.uuid);
}
let returningWeapon = {
    'item': returningWeapon_item,
    'attack': returningWeapon_attack
}
;// CONCATENATED MODULE: ./scripts/macros/spells/rimesBindingIce.js

async function rimesBindingIce_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? chris.jb2aCheck() === 'patreon';
    if (!animation) return
    if (!workflow.templateId) return;
    let template = canvas.scene.collections.templates.get(workflow.templateId)?.object;
    if (!template) return;
    //Animations by: eskiemoh
    new Sequence()
        .effect()
        .atLocation(workflow.token)
        .file('jb2a.magic_signs.circle.02.evocation.loop.blue')
        .scaleToObject(1.25)
        .rotateIn(180, 600, {'ease': 'easeOutCubic'})
        .scaleIn(0, 600, {'ease': 'easeOutCubic'})
        .loopProperty('sprite', 'rotation', {'from': 0, 'to': -360, 'duration': 10000})
        .belowTokens()
        .fadeOut(2000)
        .zIndex(0)

        .effect()
        .atLocation(workflow.token)
        .file('jb2a.magic_signs.circle.02.evocation.loop.blue')
        .scaleToObject(1.25)
        .rotateIn(180, 600, {'ease': 'easeOutCubic'})
        .scaleIn(0, 600, {'ease': 'easeOutCubic'})
        .loopProperty('sprite', 'rotation', {'from': 0, 'to': -360, 'duration': 10000})
        .belowTokens(true)
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 2})
        .filter('Blur', {'blurX': 5, 'blurY': 10 })
        .zIndex(1)
        .duration(1200)
        .fadeIn(200, {'ease': 'easeOutCirc', 'delay': 500})
        .fadeOut(300, {'ease': 'linear'})

        .effect()
        .file('jb2a.particles.outward.white.01.02')
        .scaleIn(0, 500, {'ease': 'easeOutQuint'})
        .delay(500)
        .fadeOut(1000)
        .atLocation(workflow.token)
        .duration(1000)
        .size(1.75, {'gridUnits': true})
        .animateProperty('spriteContainer', 'position.y', {'from': 0 , 'to': -0.5, 'gridUnits': true, 'duration': 1000})
        .zIndex(1)
        .waitUntilFinished(250)

        .effect()
        .file('jb2a.dancing_light.blueteal')
        .atLocation(workflow.token)
        .rotateTowards(template)
        .filter('ColorMatrix', {'hue': 10, 'saturate': -0.5, 'brightness': 1.5})
        .size(0.9 * workflow.token.document.width, {'gridUnits': true})
        .spriteScale({'x': 0.5, 'y': 1.0})
        .spriteOffset({'x': 0.25}, { 'gridUnits': true})
        .scaleIn(0, 500, {'ease': 'easeOutCubic'})
        .fadeIn(500)
        .fadeOut(1000)
        .duration(5000)

        .effect()
        .file('jb2a.extras.tmfx.border.circle.outpulse.01.fast')
        .atLocation(workflow.token)
        .rotateTowards(template)
        .size(0.9 * workflow.token.document.width, {'gridUnits': true})
        .spriteScale({'x': 0.5, 'y': 1.0})
        .spriteOffset({'x': 0.25}, {'gridUnits': true})

        .effect()
        .file('jb2a.particles.outward.white.02.03')
        .size({'width': 6, 'height': 6}, {'gridUnits': true})
        .atLocation(workflow.token, {'cacheLocation': true})
        .scaleIn(0, 1500, {'ease': 'easeOutSine'})
        .duration(1500)
        .delay(250)
        .fadeIn(250)
        .fadeOut(1250)
        .randomizeMirrorY()
        .moveTowards(template)
        .filter('ColorMatrix', {'hue': 10, 'saturate': -1, 'brightness': 2})
        .repeats(7,500,500)
        .zIndex(2)

        .effect()
        .file('jb2a.breath_weapons.poison.cone.blue')
        .size(6.5, {'gridUnits': true})
        .atLocation(workflow.token, {'cacheLocation': true})
        .rotateTowards(template, {'cacheLocation': true})
        .fadeIn(1100)
        .fadeOut(1100)
        .belowTokens()
        .opacity(0.8)
        .playbackRate(0.9)
        .filter('ColorMatrix', {'hue': 10, 'saturate': -1, 'brightness': 1.8})
        .startTime(3000)
        .duration(5000)
        .zIndex(1)

        .effect()
        .file('jb2a.breath_weapons.poison.cone.blue')
        .size(6.5, {'gridUnits': true})
        .atLocation(workflow.token, {'cacheLocation': true})
        .rotateTowards(template, {'cacheLocation': true})
        .mirrorY()
        .zIndex(1)
        .fadeOut(1100)
        .opacity(0.1)
        .playbackRate(0.9)
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 1.1})
        .startTime(3000)

        .play();
}
async function saves({speaker, actor, token, character, item, args, scope, workflow}) {
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? chris.jb2aCheck() === 'patreon';
    if (!animation) return
    if (!workflow.failedSaves.size) return;
    let targets = Array.from(workflow.failedSaves)
    targets.forEach(target => {  
        new Sequence()
            .effect()
            .delay(1250)
            .name('bindingIce')
            .file('jb2a.extras.tmfx.outflow.circle.02')
            .attachTo(target)
            .belowTokens()
            .scaleToObject(target.document.texture.scaleX * 1.55)
            .opacity(0.45)
            .scaleIn(0, 6000, {'ease': 'easeOutExpo'})
            .fadeIn(6000, {'delay': 1000, 'ease': 'easeOutExpo'})
            .persist()
            
            .effect()
            .delay(1250)
            .name('bindingIce')
            .file('jb2a.spirit_guardians.blue.particles')
            .attachTo(target)
            .scaleToObject(target.document.texture.scaleX * 1.3)
            .opacity(0.55)
            .filter('ColorMatrix', { 'saturate':  -0.35, 'brightness': 1.2})
            .scaleIn(0, 6000, {'ease': 'easeOutExpo'})
            .fadeIn(6000, {'delay': 1000, 'ease': 'easeOutExpo'})
            .persist()
            
            .effect()
            .delay(1250)
            .name('bindingIce')
            .file('jb2a.celestial_bodies.asteroid.single.ice.blue.02')
            .attachTo(target)
            .spriteOffset({'x': -0.05}, {'gridUnits': true})
            .scaleToObject(target.document.texture.scaleX * 1.5)
            .opacity(0.5)
            .scaleIn(0, 6000, {'ease': 'easeOutExpo'})
            .fadeIn(6000, {'delay': 1000, 'ease': 'easeOutExpo'})
            .randomRotation()
            .repeats(1,100,100)
            .noLoop()
            .persist()
            .endTime(19950)
            .filter('ColorMatrix', {'contrast':0})
            .shape('circle', {
                'lineSize': canvas.grid.size / 2.5,
                'lineColor': '#FF0000',
                'radius': 0.55,
                'gridUnits': true,
                'name': 'bindingIce',
                'isMask': true
            })

            .play();
    });
}
async function rimesBindingIce_end(token, origin) {
    let animation = chris.getConfiguration(origin, 'animation') ?? chris.jb2aCheck() === 'patreon';
    if (!animation) return
    Sequencer.EffectManager.endEffects({'name': 'bindingIce', 'object': token});
    new Sequence()
        .effect()
        .file('jb2a.impact_themed.ice_shard.blue')
        .atLocation(token)
        .belowTokens()
        .scaleToObject(token.document.texture.scaleX*2)

        .play();
}
let rimesBindingIce = {
    'item': rimesBindingIce_item,
    'saves': saves,
    'end': rimesBindingIce_end
}
;// CONCATENATED MODULE: ./scripts/macros/items/ringOfSpellStoring.js


async function ringOfSpellStoring_item({speaker, actor, token, character, item, args, scope, workflow}) {
    async function deleteSpells(actor, onlyEmpty) {
        let rossSpells =[];
        actor.items.forEach(item => {
            if (item.flags['chris-premades']?.item?.ross?.isStored) rossSpells.push(item);
        });
        if (rossSpells.length === 0) return;
        for (let i of rossSpells) {
            if (onlyEmpty && i.system.uses.value) continue;
            await i.delete();
        }
    }
    let pickOption = await chris.dialog('Ring of Spell Storing', [['Store a spell.', 'store'], ['Toggle showing stored spells.', 'toggle'], ['Clear used spells.', 'clear'], ['Reset stored spells.', 'reset']]);
    if (!pickOption) return;
    let showSpells = workflow.item.flags['chris-premades']?.item?.ross?.showSpells
    if (showSpells === undefined) showSpells = true;
    if (pickOption === 'store') {
        let storedSpellLevels = workflow.item.flags['chris-premades']?.item?.ross?.spellSlots;
        if (!storedSpellLevels) storedSpellLevels = 0;
        if (storedSpellLevels === 5) {
            ui.notifications.info('Ring is full!');
            return;
        }
        let generatedMenu = [];
        workflow.actor.items.forEach(item => {
            let prepared = item.system.preparation?.prepared;
            let mode = item.system.preparation?.mode;
            let hasUses = true;
            let uses = Number(item.system.uses?.value || 0);
            let max = Number(item.system.uses?.max || 0);
            if (max > 0 && uses === 0) hasUses = false;
            if (mode === 'atwill' || mode === 'innate' || mode === 'pact' || mode === 'always') prepared = true;
            if (item.type === 'spell' && item.system.level > 0 && 5 - storedSpellLevels >= item.system.level && prepared && hasUses) generatedMenu.push(item);
        });
        if (generatedMenu.length === 0) {
            ui.notifications.info('No spells available to store!');
            return;
        }
        generatedMenu.sort((a, b) => a.name.localeCompare(b.name));
        let range = 0;
        let selectedSpell = false;
        let spellData;
        let spellDC;
        let spellMod = '';
        let originalSpell;
        while (!selectedSpell) {
            let listMenu = [];
            if (range != 0) listMenu.push(['- Previous -', 'previous']);
            let rangeTop = Math.min(range + 10, generatedMenu.length);
            for (let i = range; rangeTop > i; i++) {
                listMenu.push([generatedMenu[i].name, i]);
            }
            if (rangeTop != generatedMenu.length) listMenu.push(['- Next -', 'next']);
            let spellKey = await chris.dialog('Store what spell?', listMenu);
            if (!(spellKey || spellKey === 0)) return;
            if (spellKey === 'previous') {
                range -= 10;
            } else if (spellKey === 'next') {
                range += 10;
            } else {
                spellData = generatedMenu[spellKey].toObject();
                spellDC = chris.getSpellDC(generatedMenu[spellKey]);
                if (generatedMenu[spellKey].system.actionType === 'rsak' || generatedMenu[spellKey].system.actionType === 'msak') {
                    let dummyWorkflow = await (new MidiQOL.DummyWorkflow(workflow.actor, generatedMenu[spellKey], workflow.token, new Set([workflow.token])).simulateAttack(workflow.token));
                    spellMod = dummyWorkflow.attackRoll.formula.split('1d20')[1];
                }
                originalSpell = generatedMenu[spellKey];
                selectedSpell = true;
            }
        }
        let castLevel;
        if (spellData.system.preparation.mode === 'prepared' || spellData.system.preparation.mode === 'pact' || spellData.system.preparation.mode === 'always') {
            let generatedCastMenu = [];
            if (workflow.actor.system.spells.pact.value && 5 - storedSpellLevels >= workflow.actor.system.spells.pact.level && spellData.system.level <= workflow.actor.system.spells.pact.level) generatedCastMenu.push(['Pact', 'pact']);
            if (workflow.actor.system.spells.spell1.value && 5 - storedSpellLevels >= 1 && spellData.system.level <= 1) generatedCastMenu.push(['1st Level', 'spell1']);
            if (workflow.actor.system.spells.spell2.value && 5 - storedSpellLevels >= 2 && spellData.system.level <= 2) generatedCastMenu.push(['2nd Level', 'spell2']);
            if (workflow.actor.system.spells.spell3.value && 5 - storedSpellLevels >= 3 && spellData.system.level <= 3) generatedCastMenu.push(['3rd Level', 'spell3']);
            if (workflow.actor.system.spells.spell4.value && 5 - storedSpellLevels >= 4 && spellData.system.level <= 4) generatedCastMenu.push(['4th Level', 'spell4']);
            if (workflow.actor.system.spells.spell5.value && 5 - storedSpellLevels >= 5 && spellData.system.level <= 5) generatedCastMenu.push(['5th Level', 'spell5']);
            if (generatedCastMenu.length === 0) {
                ui.notifications.info('No spell slots available!');
                return;
            }
            let selection = await chris.dialog('Cast at what level?', generatedCastMenu);
            if (!selection) return;
            switch (selection) {
                case 'pact':
                    castLevel = workflow.actor.system.spells.pact.level;
                    break;
                case 'spell1':
                    castLevel = 1;
                    break;
                case 'spell2':
                    castLevel = 2;
                    break;
                case 'spell3':
                    castLevel = 3;
                    break;
                case 'spell4':
                    castLevel = 4;
                    break;
                case 'spell5':
                    castLevel = 5;
                    break;
            }
            await workflow.actor.update({['system.spells.' + selection +'.value']: workflow.actor.system.spells[selection].value - 1});
        } else {
            castLevel = spellData.system.level;
        }
        if (originalSpell.system.uses.max > 0) await originalSpell.update({'system.uses.value': originalSpell.system.uses.value - 1});
        spellData.name = 'Ring of Spell Storing: ' + spellData.name;
        spellData.system.uses.per = 'charges';
        spellData.system.uses.max = 1;
        spellData.system.uses.value = 1;
        spellData.system.preparation.mode = 'atwill';
        spellData.system.preparation.prepared = true;
        if (spellData.system.save.ability != '') {
            spellData.system.save.scaling = 'flat';
            spellData.system.save.dc = spellDC;
        }
        spellData.flags['chris-premades'] = {
            'item': {
                'ross': {
                    'isStored': true,
                    'castLevel': castLevel,
                    'dc': spellDC,
                    'mod': spellMod,
                    'itemUuid': workflow.item.uuid
                }
            }
        };
        spellData.flags['custom-character-sheet-sections'] = {
            'sectionName': 'Ring of Spell Storing'
        };
        let testFlag = spellData.flags['midi-qol'];
        if (!testFlag) spellData.flags['midi-qol'] = {
            'onUseMacroName': '',
            'onUseMacroParts': {
                'items': []
            }
        };
        let onUseString = spellData.flags['midi-qol'].onUseMacroName;
        let appendString = '[preItemRoll]function.chrisPremades.macros.ringOfSpellStoring.cast,[preCheckHits]function.chrisPremades.macros.ringOfSpellStoring.attack';
        if (onUseString === undefined) {
            spellData.flags['midi-qol'].onUseMacroName = appendString;
        } else {
            spellData.flags['midi-qol'].onUseMacroName = onUseString + ',' + appendString;
        }
        let onUseMacroParts = spellData.flags['midi-qol'].onUseMacroParts;
        if (!onUseMacroParts) onUseMacroParts = {'items': []};
        onUseMacroParts.items.push({
            'macroName': 'function.chrisPremades.macros.ringOfSpellStoring.cast',
            'option': 'preItemRoll'
        });
        onUseMacroParts.items.push({
            'macroName': 'function.chrisPremades.macros.ringOfSpellStoring.attack',
            'option': 'preCheckHits'
        });
        spellData.flags['midi-qol'].onUseMacroParts = onUseMacroParts;
        let storedSpells = workflow.item.flags['chris-premades']?.item?.ross?.storedSpells;
        if (!storedSpells) storedSpells = [];
        storedSpells.push(spellData);
        await workflow.item.setFlag('chris-premades', 'item.ross.storedSpells', storedSpells);
        let spellSlots = storedSpellLevels + castLevel;
        await workflow.item.setFlag('chris-premades', 'item.ross.spellSlots', spellSlots);
        if (showSpells) await workflow.actor.createEmbeddedDocuments('Item', [spellData]);
        await workflow.item.update({'name': 'Ring of Spell Storing (' + spellSlots + '/5)'});
        ui.notifications.info(originalSpell.name + ' stored.');
    } else if (pickOption === 'toggle') {
        await workflow.item.setFlag('chris-premades', 'item.ross.showSpells', !showSpells);
        if (showSpells) {
            deleteSpells(workflow.actor);
            ui.notifications.info('Spells toggled off.');
        } else {
            let storedSpells = workflow.item.flags['chris-premades']?.item?.ross?.storedSpells;
            if (!storedSpells) return;
            ui.notifications.info('Spells toggled on.');
            if (storedSpells.length === 0) return;
            for (let i of storedSpells) {
                i.flags['chris-premades'].item.ross.itemUuid = workflow.item.uuid;
            }
            await workflow.actor.createEmbeddedDocuments('Item', storedSpells);
        }
    } else if (pickOption === 'reset') {
        await workflow.item.setFlag('chris-premades', 'item.ross', {'storedSpells': [], 'spellSlots': 0, 'showSpells': true});
        if (showSpells) deleteSpells(workflow.actor);
        await workflow.item.update({'name': 'Ring of Spell Storing (0/5)'});
        ui.notifications.info('Ring Reset.');
    } else if (pickOption === 'clear') {
        deleteSpells(workflow.actor, true);
        ui.notifications.info('Used spells cleared.');
    }
}
async function ringOfSpellStoring_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    let mod = workflow.item.flags['chris-premades']?.item?.ross?.mod;
    if (!mod) mod = '0';
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'ringOfSpellStoring', 50);
    if (!queueSetup) return;
    let updatedRoll = await new Roll('1d20' + mod).evaluate({async: true});
    workflow.setAttackRoll(updatedRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function ringOfSpellStoring_cast({speaker, actor, token, character, item, args, scope, workflow}) {
    workflow.config.consumeSpellSlot = false;
    workflow.config.needsConfiguration = false;
    workflow.options.configureDialog = false;
    let castLevel = workflow.item.flags['chris-premades']?.item?.ross?.castLevel;
    if (!castLevel) return;
    workflow.config.consumeSpellLevel = castLevel;
    let sourceItemUuid = workflow.item.flags['chris-premades']?.item?.ross?.itemUuid;
    if (!sourceItemUuid) return;
    let sourceItem = await fromUuid(sourceItemUuid);
    if (!sourceItem) return;
    let storedSpells = sourceItem.flags['chris-premades']?.item?.ross?.storedSpells;
    if (!storedSpells) storedSpells = [];
    let arrayIndex = storedSpells.findIndex(i => i.name === workflow.item.name);
    if (arrayIndex == -1) return;
    storedSpells.splice(arrayIndex, 1);
    await sourceItem.setFlag('chris-premades', 'item.ross.storedSpells', storedSpells);
    let storedSpellLevels = sourceItem.flags['chris-premades']?.item?.ross?.spellSlots;
    if (!storedSpellLevels) storedSpellLevels = 0;
    await sourceItem.setFlag('chris-premades', 'item.ross.spellSlots', storedSpellLevels - castLevel);
    await sourceItem.update({'name': 'Ring of Spell Storing (' + (storedSpellLevels - castLevel) + '/5)'});
    async function effectMacro () {
        if (!origin) return;
        await origin.delete();
    }
    let effectData = {
        'label': workflow.item.name + ' Deletion',
        'icon': '',
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 604800
        },
        flags: {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            }
    /*          'dae': {
                'transfer': false,
                'specialDuration': [
                    'longRest'
                ],
                'stackable': 'multi',
                'macroRepeat': 'none'
            } */
        }
    };
    await chris.createEffect(workflow.actor, effectData);
}
let ringOfSpellStoring = {
    'item': ringOfSpellStoring_item,
    'attack': ringOfSpellStoring_attack,
    'cast': ringOfSpellStoring_cast
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/bloodHunter/orderOfTheGhostslayer/riteOfTheDawn.js


async function riteOfTheDawn({speaker, actor, token, character, item, args, scope, workflow}) {
    let hasFeature = workflow.item.flags['chris-premades']?.feature?.rotd;
    if (!hasFeature) return;
    if (workflow.hitTargets.size != 1) return;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    let targetType = chris.raceOrType(targetActor);
    if (targetType != 'undead') return;
    let damageDice = workflow.actor.system.scale['blood-hunter']['crimson-rite'];
    if (!damageDice) {
        ui.notifications.warn('Source actor does not appear to have a Crimson Rite scale!');
        return;
    }
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'riteOfTheDawn', 250);
    if (!queueSetup) return;
    let bonusDamageFormula = damageDice.formula + '[radiant]';
    if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
    let damageFormula = workflow.damageRoll._formula + ' + ' + bonusDamageFormula;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/rugOfSmothering/smother.js



async function smotherDamage(origin, token, actor) {
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Monster Feature Items', 'Rug of Smothering - Smother', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Rug of Smothering - Smother');
    featureData.system.damage.parts = [
        [
            '2d6+3[' + translate.damageType('bludgeoning') + ']',
            'bludgeoning'
        ]
    ];
    featureData.system.save.dc = chris.getSpellDC(origin);
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': origin.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.document.uuid]);
    await MidiQOL.completeItemUse(feature, config, options);
}
async function smother({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.hitTargets.size) return
    let targetToken = workflow.targets.first();
    if (game.modules.get('Rideable')?.active) {
        let targetUpdate = {
            'token': {
                'x': targetToken.x,
                'y': targetToken.y
            }
        };
        let options = {
            'permanent': true,
            'name': workflow.item.name,
            'description': workflow.item.name
        };
        await warpgate.mutate(workflow.token.document, targetUpdate, {}, options);
        game.Rideable.Mount([targetToken.document], workflow.token.document, {'Grappled': true, 'MountingEffectsOverride': []});
    }
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/rugOfSmothering/damageTransfer.js


async function damageTransfer({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.hitTargets.size) return;
    let sourceToken = args[0].options.token;
    let targetHasEffect = chris.findNearby(sourceToken, 5, 'all', true)?.find(t=>chris.findEffect(t.actor, 'Smother')?.origin === sourceToken.actor.items.getName('Smother')?.uuid);
    if (!targetHasEffect) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'smother', 400);
    if (!queueSetup) return;
    let ditem = workflow.damageItem;
    if (ditem.newHP > ditem.oldHP) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let keptDamage = Math.floor(ditem.appliedDamage / 2);
    await chris.applyDamage([targetHasEffect], keptDamage, 'none');
    if (ditem.oldTempHP > 0) {
        if (keptDamage > ditem.oldTempHP) {
            ditem.newTempHP = 0;
            keptDamage -= ditem.oldTempHP;
            ditem.tempDamage = ditem.oldTempHP;
        } else {
            ditem.newTempHP = ditem.oldTempHP - keptDamage;
            ditem.tempDamage = keptDamage;
            keptDamage = 0;
        }
    }
    let maxHP = sourceToken.actor.system.attributes.hp.max;
    ditem.hpDamage = Math.clamped(keptDamage, 0, maxHP);
    ditem.newHP = Math.clamped(ditem.oldHP - keptDamage, 0, maxHP);
    ditem.appliedDamage = keptDamage;
    ditem.totalDamage = keptDamage;
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/rugOfSmothering/rugOfSmothering.js


let rugOfSmothering = {
    'smotherDamage': smotherDamage,
    'smother': smother,
    'damageTransfer': damageTransfer
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/paladin/oathOfDevotion/sacredWeapon.js

async function sacredWeapon_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let mutationStack = warpgate.mutationStack(workflow.token.document);
    let weapons = workflow.actor.items.filter(i => i.type === 'weapon' && i.system.equipped && !mutationStack.getName(i.name));
    if (weapons.length === 0) return;
    let selection;
    if (weapons.length != 1) {
        let selection2 = await chris.selectDocument(workflow.item.name, weapons, false);
        if (selection2) selection = selection2[0];
    } else {
        selection = weapons[0];
    }
    if (!selection) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Sacred Weapon - Dismiss', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Sacred Weapon - Dismiss');
    async function effectMacro() {
        await warpgate.revert(token.document, 'Sacred Weapon');
    }
    let effectData = {
        'name': 'Sacred Weapon',
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'changes': [
            {
                'key': 'ATL.light.dim',
                'mode': 4,
                'value': '40',
                'priority': 20
            },
            {
                'key': 'ATL.light.bright',
                'mode': 4,
                'value': '20',
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    'zeroHP'
                ]
            },
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    let attackBonus = Math.max(1, workflow.actor.system.abilities.cha.mod);
    if (selection.system.attackBonus != '') {
        attackBonus = selection.system.attackBonus + ' + ' + attackBonus;
    }
    let updates = {
        'embedded': {
            'Item': {
                [selection.name]: {
                    'system': {
                        'attackBonus': attackBonus,
                        'properties': {
                            'mgc': true
                        }
                    }
                },
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Sacred Weapon',
        'description': 'Sacred Weapon'
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
async function sacredWeapon_dismiss({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Sacred Weapon');
    if (!effect) return;
    await chris.removeEffect(effect);
}
let sacredWeapon = {
    'item': sacredWeapon_item,
    'dismiss': sacredWeapon_dismiss
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/salamander/tail.js


async function tail({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    let effect = chris.findEffect(targetToken.actor, 'Tail');
    if (!effect) return;
    let originItem = await fromUuid(effect.origin);
    if (originItem.actor.id != workflow.actor.id) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'salamanderTail', 50);
    if (!queueSetup) return;
    let updatedRoll = await new Roll('100').evaluate({async: true});
    workflow.setAttackRoll(updatedRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/salamander/salamander.js


let salamander = {
    'heatedBody': heatedBody,
    'tail': tail
}
;// CONCATENATED MODULE: ./scripts/macros/spells/sanctuary.js



async function sanctuary_hook(workflow) {
    if (!workflow.token) return;
    if (workflow.targets.size != 1) return;
    let invalidTypes = [
        'cone',
        'cube',
        'cylinder',
        'line',
        'radious',
        'sphere',
        'square',
        'wall'
    ];
    if (invalidTypes.includes(workflow.item.system.target?.type)) return;
    let targetToken = workflow.targets.first();
    if (targetToken.document.disposition === workflow.token.document.disposition) return;
    let targetActor = targetToken.actor;
    let targetEffect = chris.findEffect(targetActor, 'Sanctuary');
    if (!targetEffect) return;
    let targetItem = await fromUuid(targetEffect.origin);
    if (!targetItem) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Sanctuary - Save', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Sanctuary - Save');
    featureData.system.save.dc = chris.getSpellDC(targetItem);
    setProperty(featureData, 'flags.chris-premades.spell.sanctuary.ignore', true);
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': targetItem.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.token.document.uuid]);
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'sanctuary', 48);
    if (!queueSetup) return;
    await warpgate.wait(100);
    let spellWorkflow = await MidiQOL.completeItemUse(feature, config, options);
    if (spellWorkflow.failedSaves.size != 1) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    queue_queue.remove(workflow.item.uuid);
    new Sequence().effect().atLocation(targetToken).scaleToObject(1.25).fadeIn(500).fadeOut(500).playbackRate(2).file('jb2a.energy_field.02.above.blue').play();
    return false;
}
async function sanctuary_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.item.flags['chris-premades']?.spell?.sanctuary?.ignore) return;
    let remove = false;
    if (workflow.damageRoll && !(workflow.defaultDamageType === 'healing' || workflow.defaultDamageType === 'temphp')) {
        remove = true;
    }
    if (!remove && constants_constants.attacks.includes(workflow.item.system.actionType)) remove = true;
    if (!remove && workflow.item.type === 'spell') {
        for (let i of Array.from(workflow.targets)) {
            if (workflow.token.document.disposition != i.document.disposition) {
                remove = true;
                break;
            }
        }
    }
    if (!remove) return;
    let effect = chris.findEffect(workflow.actor, 'Sanctuary');
    if (!effect) return;
    await chris.removeEffect(effect);
}
async function sanctuary_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let effectData = {
        'name': 'Sanctuary',
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 60,
        },
        'changes': [
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.sanctuary.attack,postActiveEffects',
                'priority': 20
            }
        ]
    };
    await chris.createEffect(workflow.targets.first().actor, effectData);
}
let sanctuary = {
    'item': sanctuary_item,
    'hook': sanctuary_hook,
    'attack': sanctuary_attack
}
;// CONCATENATED MODULE: ./scripts/macros/feats/savageAttacker.js



async function savageAttacker_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || workflow.item.system.actionType != 'mwak' || !workflow.token || !workflow.damageRoll) return;
    let feature = chris.getItem(workflow.actor, 'Savage Attacker');
    if (!feature) return;
    let turnCheck = chris.perTurnCheck(feature, 'feat', 'savageAttacker', false, workflow.token.id);
    if (!turnCheck) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'savageAttacker', 101);
    if (!queueSetup) return;
    let dummyRollFormula = '';
    for (let i of workflow.item.system.damage.parts) dummyRollFormula += i[0] + ' + ';
    let dummyRoll = await new Roll(dummyRollFormula).roll({'async': true});
    let damageTotal = 0;
    for (let i = 0; i < dummyRoll.terms.length; i++) {
        let total = workflow.damageRoll.terms[i].total;
        if (!isNaN(total)) damageTotal += total;
    }
    let autoReroll = chris.getConfiguration(feature, 'auto') ?? false;
    let autoNumber = chris.getConfiguration(feature, 'reroll') ?? 1;
    let selection = false;
    if (!autoReroll) {
        selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Weapon Damage Total: <b>' + damageTotal + '</b><br>Use ' + feature.name + '?');
    } else {
        if (autoNumber >= damageTotal) selection = true;
    }
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await feature.use();
    if (chris.inCombat()) await feature.setFlag('chris-premades', 'feat.savageAttacker.turn', game.combat.round + '-' + game.combat.turn);
    let damageRoll = await new Roll(workflow.damageRoll._formula).roll({'async': true});
    let newTotal = 0;
    for (let i = 0; i < dummyRoll.terms.length; i++) {
        let total = damageRoll.terms[i].total;
        if (!isNaN(total)) newTotal += total;
    }
    if (newTotal <= damageTotal) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function savageAttacker_end(origin) {
    await origin.setFlag('chris-premades', 'feat.savageAttacker.turn', null);
}
let savageAttacker = {
    'damage': savageAttacker_damage,
    'end': savageAttacker_end
}
;// CONCATENATED MODULE: ./scripts/macros/generic/saveConditionImmune.js

async function saveConditionImmune_targets(condition, workflow) {
    if (!workflow.targets.size) return;
    let effectData = {
        'label': 'Immune',
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 1
        },
        'changes': [
            {
                'key': 'flags.midi-qol.min.ability.save.all',
                'mode': 5,
                'value': '99',
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    'isSave'
                ],
            }
        }
    };
    for (let i of workflow.targets) {
        if (chris.checkTrait(i.actor, 'ci', condition)) await chris.createEffect(i.actor, effectData);
    }
}
async function blinded({speaker, actor, token, character, item, args, scope, workflow}) {
    await saveConditionImmune_targets('blinded', workflow);
}
async function charmed({speaker, actor, token, character, item, args, scope, workflow}) {
    await saveConditionImmune_targets('charmed', workflow);
}
async function deafened({speaker, actor, token, character, item, args, scope, workflow}) {
    await saveConditionImmune_targets('deafened', workflow);
}
async function diseased({speaker, actor, token, character, item, args, scope, workflow}) {
    await saveConditionImmune_targets('diseased', workflow);
}
async function frightened({speaker, actor, token, character, item, args, scope, workflow}) {
    await saveConditionImmune_targets('frightened', workflow);
}
async function grappled({speaker, actor, token, character, item, args, scope, workflow}) {
    await saveConditionImmune_targets('grappled', workflow);
}
async function incapacitated({speaker, actor, token, character, item, args, scope, workflow}) {
    await saveConditionImmune_targets('incapacitated', workflow);
}
async function invisible({speaker, actor, token, character, item, args, scope, workflow}) {
    await saveConditionImmune_targets('invisible', workflow);
}
async function paralyzed({speaker, actor, token, character, item, args, scope, workflow}) {
    await saveConditionImmune_targets('paralyzed', workflow);
}
async function peterified({speaker, actor, token, character, item, args, scope, workflow}) {
    await saveConditionImmune_targets('peterified', workflow);
}
async function poisoned({speaker, actor, token, character, item, args, scope, workflow}) {
    await saveConditionImmune_targets('poisoned', workflow);
}
async function saveConditionImmune_prone({speaker, actor, token, character, item, args, scope, workflow}) {
    await saveConditionImmune_targets('prone', workflow);
}
async function restrained({speaker, actor, token, character, item, args, scope, workflow}) {
    await saveConditionImmune_targets('restrained', workflow);
}
async function stunned({speaker, actor, token, character, item, args, scope, workflow}) {
    await saveConditionImmune_targets('stunned', workflow);
}
async function unconscious({speaker, actor, token, character, item, args, scope, workflow}) {
    await saveConditionImmune_targets('unconscious', workflow);
}
let saveConditionImmune = {
    'blinded': blinded,
    'charmed': charmed,
    'deafened': deafened,
    'diseased': diseased,
    'frightened': frightened,
    'grappled': grappled,
    'incapacitated': incapacitated,
    'invisible': invisible,
    'paralyzed': paralyzed,
    'peterified': peterified,
    'poisoned': poisoned,
    'prone': saveConditionImmune_prone,
    'restrained': restrained,
    'stunned': stunned,
    'unconscious': unconscious
}
;// CONCATENATED MODULE: ./scripts/macros/spells/scorchingRay.js



async function scorchingRay({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.token) return;
    let maxRays = 3 + (workflow.castData.castLevel - 2);
    let skipDead = false;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Scorching Ray Bolt', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Scorching Ray Bolt');
    featureData.system.ability = workflow.item.system.ability;
    featureData.flags['chris-premades'] = {
        'spell': {
            'castData': workflow.castData
        }
    }
    featureData.flags['chris-premades'].spell.castData.school = workflow.item.system.school;
    delete featureData._id;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    feature.prepareData();
    feature.prepareFinalAttributes();
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([]);
    let animation = chris.jb2aCheck() === 'patreon' ? chris.getConfiguration(workflow.item, 'animation') ?? 'complex' : 'simple';
    let color = chris.jb2aCheck() === 'patreon' ? chris.getConfiguration(workflow.item, 'color') ?? 'orange' : 'orange';
    let particle = 'jb2a.particles.outward.orange.01.03';
    if (animation === 'complex') {
        //Animations by: eskiemoh
        if (color === 'cycle' || color === 'random') await Sequencer.Preloader.preload('jb2a.scorching_ray');
        await new Sequence()
            .effect()
            .atLocation(workflow.token)
            .file('jb2a.magic_signs.circle.02.evocation.loop.yellow')
            .scaleToObject(1.25)
            .rotateIn(180, 600, {'ease': 'easeOutCubic'})
            .scaleIn(0, 600, {'ease': 'easeOutCubic'})
            .loopProperty('sprite', 'rotation', {'from': 0, 'to': -360, 'duration': 10000})
            .belowTokens()
            .fadeOut(2000)
            .zIndex(0)
            .persist()
            .attachTo(workflow.token)
            .name('Scorching Ray')

            .effect()
            .atLocation(workflow.token)
            .file('jb2a.magic_signs.circle.02.evocation.loop.yellow')
            .scaleToObject(1.25)
            .rotateIn(180, 600, {'ease': 'easeOutCubic'})
            .scaleIn(0, 600, {'ease': 'easeOutCubic'})
            .loopProperty('sprite', 'rotation', {'from': 0, 'to': -360, 'duration': 10000})
            .belowTokens(true)
            .filter('ColorMatrix', {'saturate': -1, 'brightness': 2})
            .filter('Blur', {'blurX': 5, 'blurY': 10 })
            .zIndex(1)
            .duration(1200)
            .fadeIn(200, {'ease': 'easeOutCirc', 'delay': 500})
            .fadeOut(300, {'ease': 'linear'})
            .persist()
            .attachTo(workflow.token)
            .name('Scorching Ray')

            .effect()
            .file('jb2a.particles.outward.white.01.02')
            .scaleIn(0, 500, {'ease': 'easeOutQuint'})
            .delay(500)
            .fadeOut(1000)
            .atLocation(workflow.token)
            .duration(1000)
            .size(1.75 * workflow.token.document.width, {'gridUnits': true})
            .animateProperty('spriteContainer', 'position.y', {'from':0 , 'to': -0.5, 'gridUnits': true, 'duration': 1000})
            .zIndex(1)
            .waitUntilFinished(-200)

            .play()
    }
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'scorchingRay', 50);
    if (!queueSetup) return;
    let colors = [
        'orange',
        'blue',
        'green',
        'pink',
        'purple',
    ];
    let lastColor;
    if (color === 'random' || color === 'cycle') {
        lastColor = Math.floor(Math.random() * colors.length);
    }
    while (maxRays > 0) {
        let nearbyTargets = chris.findNearby(workflow.token, workflow.item.system.range.value, 'enemy', true);
        let targets = skipDead ? nearbyTargets.filter(i => i.actor.system.attributes.hp.value > 0) : nearbyTargets;
        let selection = await chris.selectTarget(workflow.item.name, constants_constants.okCancel, targets, true, 'number', null, true, 'Select your targets (max: ' + maxRays + '):');
        if (!selection.buttons) {
            queue_queue.remove(workflow.item.uuid);
            await Sequencer.EffectManager.endEffects({'name': 'Scorching Ray', 'object': workflow.token});
            return;
        }
        let total = 0;
        for (let i = 0; i < (selection.inputs.length - 1); i++) {
            if (!isNaN(selection.inputs[i])) total += selection.inputs[i];
        }
        if (total > maxRays) {
            ui.notifications.info('You can\'t use that many rays!');
            continue;
        }
        skipDead = selection.inputs[selection.inputs.length - 1];
        for (let i = 0; i < selection.inputs.length - 1; i++) {
            let target = fromUuidSync(targets[i].document.uuid).object;
            if (isNaN(selection.inputs[i]) || selection.inputs[i] === 0) continue;
            if (skipDead) {
                if (target.actor?.system?.attributes?.hp?.value === 0) continue;
            }
            options.targetUuids = [target.document.uuid];
            let rayCount = 0;
            for (let j = 0; j < selection.inputs[i]; j++) {
                await warpgate.wait(100);
                maxRays -= 1;
                let featureWorkflow = await MidiQOL.completeItemUse(feature, config, options);
                rayCount += 1;
                if (animation === 'simple') {
                    new Sequence()
                        .effect()
                        .file('jb2a.scorching_ray.01.' + color)
                        .atLocation(workflow.token)
                        .stretchTo(target)
                        .missed(!featureWorkflow.hitTargets.size)
                        .play();
                } else if (animation === 'complex') {
                    let path = 'jb2a.scorching_ray.{{num}}.';
                    if (color === 'random') {
                        path += colors[Math.floor((Math.random() * colors.length))];
                    } else if (color === 'cycle') {
                        path += colors[lastColor];
                        lastColor++;
                        if (lastColor >= colors.length) lastColor = 0;
                    } else {
                        path += color;
                    }
                    let tokenCenter = workflow.token.center;
                    let targetCenter = target.center;
                    let directionVector = {
                        x: targetCenter.x - tokenCenter.x,
                        y: targetCenter.y - tokenCenter.y,
                    };
                    let distance = Math.sqrt(directionVector.x ** 2 + directionVector.y ** 2);
                    let normalizedDirectionVector = {
                        x: directionVector.x / distance,
                        y: directionVector.y / distance,
                    };
                    let magicCircleDistance = canvas.grid.size/3;
                    let magicCircle = {
                        x: tokenCenter.x + normalizedDirectionVector.x * magicCircleDistance,
                        y: tokenCenter.y + normalizedDirectionVector.y * magicCircleDistance,
                    };
                    new Sequence()
    
                    .wait(150)
                    
                    .effect()
                    .file(path)
                    .atLocation(magicCircle)
                    .scale(0.6)
                    .stretchTo(target, {'randomOffset': 0.75})
                    .setMustache({
                        'num': () => {
                            let nums = ['01','02', '02'];
                            if (color === 'rainbow01' || color === 'rainbow02') return '01';
                            return nums[Math.floor(Math.random()*nums.length)];
                        }
                    })
                    .randomizeMirrorY()
                    .zIndex(1)
                    .missed(!featureWorkflow.hitTargets.size)
                    
                    .effect()
                    .delay(200)
                    .from(target)
                    .attachTo(target)
                    .fadeIn(200)
                    .fadeOut(500)
                    .loopProperty('sprite', 'position.x', {'from': -0.05, 'to': 0.05, 'duration': 50, 'pingPong': true, 'gridUnits': true})
                    .scaleToObject(target.document.texture.scaleX)
                    .duration(1800)
                    .opacity(0.25)
                    .tint('#fb8b23')
                    
                    .effect()
                    .delay(200,500)
                    .file(particle)
                    .attachTo(target, {'randomOffset': 0.2})
                    .zIndex(1)
                    .fadeIn(500)
                    .fadeOut(1200)
                    .duration(4500)
                    .scaleToObject(1.5)
                    .randomRotation()
                    
                    .play()
                }
            }
        }
    }
    queue_queue.remove(workflow.item.uuid);
    if (animation === 'complex') {
        await warpgate.wait(1500);
        await Sequencer.EffectManager.endEffects({'name': 'Scorching Ray', 'object': workflow.token});
    }
}
;// CONCATENATED MODULE: ./scripts/macros/spells/searingSmite.js


async function searingSmite_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || !workflow.item) return;
    if (workflow.item.system.actionType != 'mwak') return;
    let effect = workflow.actor.effects.find(i => i.flags['chris-premades']?.spell?.searingSmite);
    if (!effect) return;
    if (effect.flags['chris-premades'].spell.searingSmite.used) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'searingSmite', 250);
    if (!queueSetup) return;
    let oldFormula = workflow.damageRoll._formula;
    let bonusDamageFormula = effect.flags['chris-premades'].spell.searingSmite.level + 'd6[fire]';
    if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
    let damageFormula = oldFormula + ' + ' + bonusDamageFormula;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    async function effectMacro() {
        let originEffect = await fromUuid(effect.origin);
        if (!originEffect) return;
        await chrisPremades.helpers.removeEffect(originEffect);
    }
    let effectData = {
        'icon': effect.icon,
        'origin': effect.uuid,
        'duration': {
            'seconds': effect.duration.seconds
        },
        'name': effect.name + ' Fire',
        'changes': [
            {
                'key': 'flags.midi-qol.OverTime',
                'mode': 0,
                'value': 'turn=start, saveAbility=con, saveDC=' + effect.flags['chris-premades'].spell.searingSmite.dc + ' , saveMagic=true, damageRoll=1d6[fire], damageType=fire, name=Searing Smite',
                'priority': 20
            }
        ],
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            }
        }
    };
    let targetEffect = await chris.createEffect(workflow.targets.first().actor, effectData);
    let updates = {
        'flags': {
            'chris-premades': {
                'spell': {
                    'searingSmite': {
                        'used': true,
                        'targetEffectUuid': targetEffect.uuid
                    }
                }
            }
        }
    };
    await chris.updateEffect(effect, updates);
    queue_queue.remove(workflow.item.uuid);
}
async function searingSmite_item({speaker, actor, token, character, item, args, scope, workflow}) {
    async function effectMacro() {
        await (warpgate.wait(200));
        let targetEffectUuid = effect.flags['chris-premades']?.spell?.searingSmite?.targetEffectUuid;
        if (!targetEffectUuid) return;
        let targetEffect = await fromUuid(targetEffectUuid);
        if (!targetEffect) return;
        await chrisPremades.helpers.removeEffect(targetEffect);
    }
    let effectData = {
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 60
        },
        'name': workflow.item.name,
        'changes': [
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.searingSmite.damage,postDamageRoll',
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'spell': {
                    'searingSmite': {
                        'dc': chris.getSpellDC(workflow.item),
                        'level': workflow.castData.castLevel,
                        'used': false
                    }
                }
            },
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            }
        }
    };
    let effect = await chris.createEffect(workflow.actor, effectData);
    let updates = {
        'flags.chris-premades.spell.searingSmite.targetEffectUuid': effect.uuid
    };
    await chris.updateEffect(effect, updates);
}
let searingSmite = {
    'damage': searingSmite_damage,
    'item': searingSmite_item
}
;// CONCATENATED MODULE: ./scripts/macros/spells/shadowBlade.js

async function shadowBlade({speaker, actor, token, character, item, args, scope, workflow}) {
    let targetToken = workflow.token;
    let spellLevel = workflow.castData.castLevel;
    let weaponData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Shadow Blade Sword', false);
    if (!weaponData) return;
    let diceNum = 2;
    switch (spellLevel) {
        case 3:
        case 4:
            diceNum = 3;
            break;
        case 5:
        case 6:
            diceNum = 4;
            break;
        case 7:
        case 8:
        case 9:
            diceNum = 5;
            break;
    }
    weaponData.system.damage.parts = [
        [
            diceNum + 'd8[psychic ] + @mod',
            'psychic'
        ]
    ];
    weaponData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Shadow Blade Sword');
    async function effectMacro () {
        await warpgate.revert(token.document, 'Shadow Blade Sword');
    }
    let effectData = {
        'label': weaponData.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': weaponData.name
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [weaponData.name]: weaponData
            },
            'ActiveEffect': {
                [weaponData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': weaponData.name,
        'description': weaponData.name
    };
    await warpgate.mutate(targetToken.document, updates, {}, options);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/shadowDemon/claws.js

async function claws_claws({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (workflow.advantage != true) return;
    if (workflow.advantage && workflow.disadvantage) return;
    let damageDice = 4;
    let damageFormula = damageDice + 'd6[psychic] + 3';
    if (workflow.isCritical) damageFormula = chris.getCriticalFormula(damageFormula);
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/shadowDemon/shadowDemon.js

let shadowDemon = {
    'claws': claws_claws
}
;// CONCATENATED MODULE: ./scripts/macros/spells/shadowOfMoil.js



async function shadowOfMoil_hook(workflow) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first().document;
    if (!targetToken) return;
    let sourceToken = workflow.token.document;
    let targetActor = targetToken.actor;
    let sourceActor = sourceToken.actor;
    let targetEffect = chris.findEffect(targetActor, 'Shadow of Moil');
    let sourceEffect = chris.findEffect(sourceActor, 'Shadow of Moil');
    if (!targetEffect && !sourceEffect) return;
    let distance = chris.getDistance(sourceToken, targetToken);
    let sourceCanSeeTarget = false;
    let targetCanSeeSource = false;
    if (sourceEffect) sourceCanSeeTarget = true;
    if (targetEffect) targetCanSeeSource = true;
    if (sourceEffect && targetEffect) {
        sourceCanSeeTarget = false;
        targetCanSeeSource = false;
    }
    let sourceSenses = sourceToken.actor.system.attributes.senses;
    let targetSenses = targetToken.actor.system.attributes.senses;
    if ((sourceSenses.tremorsense >= distance) || (sourceSenses.blindsight >= distance)) sourceCanSeeTarget = true;
    if ((targetSenses.tremorsense >= distance) || (targetSenses.blindsight >= distance)) targetCanSeeSource = true;
    if (sourceCanSeeTarget && targetCanSeeSource) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'shadowOfMoil', 50);
    if (!queueSetup) return;
    if (sourceCanSeeTarget && !targetCanSeeSource) {
        workflow.advantage = true;
        workflow.attackAdvAttribution.add('Shadow of Moil: Target Can\'t See Source');
    }
    if (!sourceCanSeeTarget && targetCanSeeSource) {
        workflow.disadvantage = true;
        workflow.flankingAdvantage = false;
        workflow.attackAdvAttribution.add('Shadow of Moil: Source Can\'t See Target');
    }
    if (!sourceCanSeeTarget && !targetCanSeeSource) {
        workflow.advantage = true;
        workflow.disadvantage = true;
        workflow.attackAdvAttribution.add('Shadow of Moil: Target And Source Can\'t See Eachother');
    }
    queue_queue.remove(workflow.item.uuid);
}
async function shadowOfMoil_onHit(workflow, targetToken) {
    if (workflow.hitTargets.size === 0) return;
    let validTypes = ['msak', 'rsak', 'mwak', 'rwak'];
    if (!validTypes.includes(workflow.item.system.actionType)) return;
    let distance = chris.getDistance(workflow.token, targetToken);
    if (distance > 10) return;
    let targetActor = targetToken.actor;
    let effect = chris.findEffect(targetActor, 'Shadow of Moil');
    if (!effect) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Shadow of Moil Damage', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Shadow of Moil Damage');
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    if (!feature) return;
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.token.document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature, config, options);
}
let shadowOfMoil = {
    'hook': shadowOfMoil_hook,
    'onHit': shadowOfMoil_onHit,
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/shadowSpirit/terrorFrenzy.js


async function terrorFrenzy({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1 || workflow.advantage) return;
    let effect = chris.findEffect(workflow.targets.first().actor, 'Frightened');
    if (!effect) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'terrorFrenzy', 150);
    if (!queueSetup) return;
    workflow.advantage = true;
    workflow.attackAdvAttribution.add('Advantage: Terror Frenzy');
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/shadowSpirit/weightOfSorrow.js


async function weightOfSorrow(token, origin) {
    let targetToken = game.canvas.tokens.get(game.combat.current.tokenId);
    if (!targetToken) return;
    if (targetToken.id === token.id) return;
    let distance = chris.getDistance(token, targetToken);
    if (distance > 5) return;
    let effect = chris.findEffect(token.actor, 'Summoned Creature');
    if (!effect) return;
    let originItem = await fromUuid(effect.origin);
    if (originItem.actor.id === targetToken.actor.id) return;
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.document.uuid]);
    await MidiQOL.completeItemUse(origin, config, options);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/shadowSpirit/shadowSpirit.js


let shadowSpirit = {
    'terrorFrenzy': terrorFrenzy,
    'weightOfSorrow': weightOfSorrow
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/shadowghast/shadowghast.js

let shadowghast = {
    'stench': stench
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/shadow/strengthDrain.js

async function strengthDrain({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || workflow.isFumble) return;
    let roll = await new Roll('1d4').roll({async: true});
    roll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: workflow.item.name
    });
    let damage = -roll.total;
    let targetActor = workflow.targets.first().actor;
    let effect = chris.findEffect(targetActor, workflow.item.name);
    if (!effect) {
        let effectData = {
            'label': workflow.item.name,
            'icon': workflow.item.img,
            'duration': {
                'seconds': 604800
            },
            'changes': [
                {
                    'key': 'system.abilities.str.value',
                    'mode': 2,
                    'value': damage,
                    'priority': 20
                }
            ],
            'flags': {
                'dae': {
                    'transfer': false,
                    'specialDuration': [
                        'shortRest'
                    ],
                    'stackable': 'multi',
                    'macroRepeat': 'none'
                }
            }
        };
        await chris.createEffect(targetActor, effectData);
    } else {
        let oldDamage = parseInt(effect.changes[0].value);
        damage += oldDamage;
        let updates = {
            'changes': [
                {
                    'key': 'system.abilities.str.value',
                    'mode': 2,
                    'value': damage,
                    'priority': 20
                }
            ]
        };
        await chris.updateEffect(effect, updates);
    }
    if (targetActor.system.abilities.str.value <= 0) {
        let unconscious = chris.findEffect(targetActor, 'Unconscious');
        if (unconscious) await chris.removeCondition(targetActor, 'Unconscious');
        await chris.addCondition(targetActor, 'Dead', true, null)
    }
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/shadow/shadow.js

let shadow_shadow = {
    'strengthDrain': strengthDrain
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/shamblingMound/engulf.js



async function engulf(origin, token, actor) {
    let sourceTokenId = actor.flags['chris-premades']?.monster?.shamblingMound?.engulf
    if (!sourceTokenId) return;
    if (game.combat.current.tokenId != sourceTokenId) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Monster Feature Items', 'Shambling Mound - Engulf', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Shambling Mound - Engulf');
    featureData.system.damage.parts = [
        [
            '2d8[' + translate.damageType('bludgeoning') + ']',
            'bludgeoning'
        ]
    ];
    featureData.system.save.dc = chris.getSpellDC(origin);
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': origin.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.document.uuid]);
    await MidiQOL.completeItemUse(feature, config, options);
}
async function engulfGrapple({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.hitTargets.size) return
    let targetToken = workflow.targets.first();
    if (game.modules.get('Rideable')?.active) {
        let targetUpdate = {
            'token': workflow.token.document.center
        };
        let options = {
            'permanent': true,
            'name': workflow.item.name,
            'description': workflow.item.name
        };
        await warpgate.mutate(targetToken.document, targetUpdate, {}, options);
        game.Rideable.Mount([targetToken.document], workflow.token.document, {'Grappled': true, 'MountingEffectsOverride': []});
    }
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/shamblingMound/slam.js


async function slam_slam({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let effect = chris.findEffect(workflow.targets.first().actor, 'Shambling Mound - Slam');
    if (!effect) return;
    let selection = await chris.dialog('Engulf target?', [['Yes', true], ['No', false]]);
    if (!selection) return;
    let engulfEffect = chris.findEffect(workflow.actor, 'SM - Engulf');
    if (!engulfEffect) return;
    let feature = await fromUuid(engulfEffect.origin);
    if (!feature) return;
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
    await MidiQOL.completeItemUse(feature, config, options);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/shamblingMound/shamblingMound.js


let shamblingMound = {
    'engulf': engulf,
    'slam': slam_slam,
    'engulfGrapple': engulfGrapple
}
;// CONCATENATED MODULE: ./scripts/macros/spells/shockingGrasp.js

async function shockingGrasp({speaker, actor, token, character, item, args, scope, workflow}) {
    let targetToken = workflow.targets.first();
    if (workflow.hitTargets.size) {
        let effect = chris.findEffect(targetToken.actor, 'Reaction');
        if (!effect) await chris.addCondition(targetToken.actor, 'Reaction', false, workflow.item.uuid);
    }
    let color = chris.getConfiguration(workflow.item, 'color') ?? 'blue';
    if (color === 'none') return;
    if (chris.jb2aCheck() != 'patreon') color = blue;
    let colors = [
        'blue',
        'blue02',
        'dark_purple',
        'dark_red',
        'green',
        'green02',
        'orange',
        'purple',
        'red',
        'yellow'
    ];
    if (color === 'random') {
        color = colors[Math.floor(Math.random() * colors.length)];
    }
    //Animations by: eskiemoh
    new Sequence()
        .effect()
        .file('jb2a.static_electricity.01.' + color)
        .scaleToObject(1.2) 
        .atLocation(targetToken)
        .waitUntilFinished(-1000)

        .effect()
        .file('jb2a.impact.011.' + color)
        .scaleToObject(1.9) 
        .atLocation(targetToken)

        .play();
}
;// CONCATENATED MODULE: ./scripts/macros/spells/sickeningRadiance.js


async function sickeningRadiance_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let template = canvas.scene.collections.templates.get(workflow.templateId);
    if (!template) return;
    await template.setFlag('chris-premades', 'template', {
        'name': 'sickeningRadiance',
        'castLevel': workflow.castData.castLevel,
        'saveDC': chris.getSpellDC(workflow.item),
        'macroName': 'sickeningRadiance',
        'templateUuid': template.uuid,
        'turn': 'start',
        'ignoreMove': false
    });
}
async function sickeningRadiance_trigger(token, trigger) {
    let template = await fromUuid(trigger.templateUuid);
    if (!template) return;
    if (chris.inCombat()) {
        let turn = game.combat.round + '-' + game.combat.turn;
        let lastTurn = template.flags['chris-premades']?.spell?.sickeningRadiance?.[token.id]?.turn;
        if (turn === lastTurn) return;
        await template.setFlag('chris-premades', 'spell.sickeningRadiance.' + token.id + '.turn', turn);
    }
    let originUuid = template.flags.dnd5e?.origin;
    if (!originUuid) return;
    let originItem = await fromUuid(originUuid);
    if (!originItem) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Sickening Radiance - Damage', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Sickening Radiance - Damage');
    featureData.system.save.dc = trigger.saveDC;
    delete featureData._id;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': originItem.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.uuid]);
    let workflow = await MidiQOL.completeItemUse(feature, config, options);
    if (workflow.failedSaves.size === 0) return;
    let exhaustionLevel = template.flags['chris-premades']?.spell?.sickeningRadiance?.[token.id]?.exhaustionLevel;
    if (exhaustionLevel === undefined) {
        let originalLevel = 0;
        let effect = token.actor.effects.find(eff => eff.name.includes('Exhaustion'));
        if (effect) {
            originalLevel = Number(effect.name.substring(11));
            if (isNaN(originalLevel)) originalLevel = 0;
        }
        await template.setFlag('chris-premades', 'spell.sickeningRadiance.' + token.id + '.exhaustionLevel', originalLevel);
    }
    await chris.increaseExhaustion(token.actor, originUuid);
}
async function sickeningRadiance_removed(template) {
    let tokens = template.flags['chris-premades']?.spell?.sickeningRadiance;
    if (!tokens) return;
    for (let [key, value] of Object.entries(tokens)) {
        let token = game.canvas.tokens.get(key);
        if (!token) continue;
        let effect = token.actor.effects.find(eff => eff.name.includes('Exhaustion'));
        if (!effect) continue;
        await chris.removeEffect(effect);
        if (value.exhaustionLevel === 0) continue;
        await chris.addCondition(token.actor, 'Exhaustion ' + value.exhaustionLevel, false);
    }
}
let sickeningRadiance = {
    'item': sickeningRadiance_item,
    'trigger': sickeningRadiance_trigger,
    'removed': sickeningRadiance_removed
}
;// CONCATENATED MODULE: ./scripts/macros/spells/skillEmpowerment.js


async function skillEmpowerment({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetActor = workflow.targets.first().actor;
    function dialogRender(html) {
        let ths = html[0].getElementsByTagName('th');
        for (let t of ths) {
            t.style.width = 'auto';
            t.style.textAlign = 'left';
        }
        let tds = html[0].getElementsByTagName('td');
        for (let t of tds) {
            t.style.width = '50px';
            t.style.textAlign = 'center';
            t.style.paddingRight = '5px';
        }
    }
    let selection = await warpgate.menu({
    'inputs': [
        {
            'label': 'Skill:',
            'type': 'select',
            'options': Object.entries(CONFIG.DND5E.skills).filter(([key, value]) => targetActor.system.skills[key].value < 2).map(([i, j]) => ({'value': i, 'html': j.label}))
        },
    ],
    'buttons': constants_constants.okCancel
    }, {
        'title': workflow.item.name,
        'render': dialogRender
    });
    if (!selection.buttons) return;
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 3600
        },
        'changes': [
            {
                'key': 'system.skills.' + selection.inputs[0] +'.value',
                'mode': 4,
                'value': 2,
                'priority': 20
            }
        ]
    };
    let effect = chris.findEffect(targetActor, workflow.item.name);
    if (effect) await chris.removeEffect(effect);
    await chris.createEffect(targetActor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/feats/slasher.js


async function slow({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || !workflow.damageRoll || !['mwak', 'rwak', 'msak', 'rsak'].includes(workflow.item.system.actionType)) return;
    let effect = chris.findEffect(workflow.actor, 'Slasher: Reduce Speed');
    if (!effect) return;
    let originItem = await fromUuid(effect.origin);
    if (!originItem) return;
    let doExtraDamage = chris.perTurnCheck(originItem, 'feat', 'slasher', false, workflow.token.id);
    if (!doExtraDamage) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'slasherSlow', 250);
    if (!queueSetup) return;
    let damageTypes = chris.getRollDamageTypes(workflow.damageRoll);
    if (!damageTypes.has('slashing')) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let autoSlasher = workflow.actor.flags['chris-premades']?.feat?.slasher?.auto;
    if (!autoSlasher) {
        let selection = await chris.dialog('Slasher: Slow target?', [['Yes', true], ['No', false]]);
        if (!selection) {
            queue_queue.remove(workflow.item.uuid);
            return;
        }
    }
    if (chris.inCombat()) await originItem.setFlag('chris-premades', 'feat.slasher.turn', game.combat.round + '-' + game.combat.turn);
    let effectData = {
        'name': originItem.name,
        'icon': originItem.img,
        'origin': originItem.uuid,
        'duration': {
            'seconds': 12
        },
        'changes': [
            {
                'key': 'system.attributes.movement.all',
                'mode': 0,
                'value': '-10',
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    'turnStartSource'
                ],
                'stackable': 'multi',
                'macroRepeat': 'none'
            }
        }
    }
    await chris.createEffect(workflow.targets.first().actor, effectData);
    queue_queue.remove(workflow.item.uuid);
}
async function slasher_critical({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || !workflow.isCritical || !workflow.damageRoll) return;
    let effect = chris.findEffect(workflow.actor, 'Slasher: Critical Hit');
    if (!effect) return;
    let originItem = await fromUuid(effect.origin);
    if (!originItem) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'slasherCritical', 251);
    if (!queueSetup) return;
    let damageTypes = chris.getRollDamageTypes(workflow.damageRoll);
    if (!damageTypes.has('slashing')) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let effectData = {
        'name': originItem.name,
        'icon': originItem.img,
        'origin': originItem.uuid,
        'duration': {
            'seconds': 12
        },
        'changes': [
            {
                'key': 'flags.midi-qol.disadvantage.attack.all',
                'mode': 0,
                'value': '1',
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    'turnStartSource'
                ],
                'stackable': 'multi',
                'macroRepeat': 'none'
            }
        }
    }
    await chris.createEffect(workflow.targets.first().actor, effectData);
    queue_queue.remove(workflow.item.uuid);
}
let slasher = {
    'slow': slow,
    'critical': slasher_critical
}
;// CONCATENATED MODULE: ./scripts/macros/spells/sleetStorm.js


async function sleetStorm_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.templateId) return;
    let template = canvas.scene.collections.templates.get(workflow.templateId);
    if (!template) return;
    await template.update({
        'flags': {
            'chris-premades': {
                'template': {
                    'name': 'sleetStorm',
                    'castLevel': workflow.castData.castLevel,
                    'saveDC': chris.getSpellDC(workflow.item),
                    'macroName': 'sleetStorm',
                    'templateUuid': template.uuid,
                    'turn': 'start',
                    'ignoreMove': false
                },
                'spell': {
                    'fogCloud': true
                }
            },
            'limits': {
                'sight': {
                    'basicSight': {
                        'enabled': true,
                        'range': 0
                    },
                    'devilsSight': {
                        'enabled': true,
                        'range': 0
                    },
                    'lightPerception': {
                        'enabled': true,
                        'range': 0
                    },
                    'seeAll': {
                        'enabled': true,
                        'range': 0
                    }
                }
            },
            'walledtemplates': {
                'wallRestriction': 'move',
                'wallsBlock': 'recurse',
            }
        }
    });
}
async function sleetStorm_trigger(token, trigger, reason) {
    let template = await fromUuid(trigger.templateUuid);
    if (!template) return;
    if (chris.inCombat()) {
        let turn = game.combat.round + '-' + game.combat.turn;
        let lastTurn = template.flags['chris-premades']?.spell?.sleetStorm?.[token.id]?.turn;
        if (turn === lastTurn) return;
        await template.setFlag('chris-premades', 'spell.sleetStorm.' + token.id + '.turn', turn);
    }
    let originUuid = template.flags.dnd5e?.origin;
    if (!originUuid) return;
    let originItem = await fromUuid(originUuid);
    if (!originItem) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Sleet Storm - Prone', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Sleet Storm - Prone');
    featureData.system.save.dc = trigger.saveDC;
    delete featureData._id;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': originItem.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.uuid]);
    await MidiQOL.completeItemUse(feature, config, options);
    if (reason === 'turnStart' && chris.findEffect(token.actor, 'Concentrating')) await MidiQOL.doConcentrationCheck(token.actor, trigger.saveDC);
}
let sleetStorm = {
    'item': sleetStorm_item,
    'trigger': sleetStorm_trigger
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/rogue/sneakAttack.js



async function sneakAttack_animation(target, token, attackType) {
    //Animations by: eskiemoh
    let hitSeq = new Sequence()
        .effect()
        .from(target)
        .atLocation(target)
        .fadeIn(100)
        .fadeOut(100)
        .loopProperty('sprite', 'position.x', {'from': -0.05, 'to': 0.05, 'duration': 75, 'pingPong': true, 'gridUnits': true})
        .scaleToObject(target.document.texture.scaleX)
        .duration(500)
        .opacity(0.15)
        .tint('#fd0706')

        .effect()
        .file('jb2a.particles.outward.red.01.04')
        .atLocation(target)
        .fadeIn(100)
        .fadeOut(400)
        .scaleIn(0, 500, {'ease': 'easeOutCubic'}) 
        .scaleToObject(1.65 * target.document.texture.scaleX)
        .duration(800)
        .opacity(1)
        .randomRotation(true)
        .filter('ColorMatrix', {'saturate': 1 })
        .belowTokens(true);
    switch (attackType) {
        case 'slashing':
            new Sequence()
                .effect()
                .file('animated-spell-effects-cartoon.water.105')
                .atLocation(token)
                .scale(0.2 * token.document.width)
                .rotateTowards(target)
                .spriteRotation(80)
                .spriteOffset({'x':-0.15 * token.document.width, 'y': -0.1 * token.document.width}, {'gridUnits': true})
                .filter('ColorMatrix', { saturate: 0.75 })
                .rotateIn(-45, 250, {'ease': 'easeOutExpo'})
                .zIndex(1)

                .effect()
                .file('jb2a.melee_generic.slashing.one_handed')
                .atLocation(token)
                .scale(0.5 * token.document.width)
                .rotateTowards(target)
                .mirrorY()
                .spriteOffset({'x':- 1.7 * token.document.width}, {'gridUnits': true})
                .filter('ColorMatrix', {'saturate': -1, 'brightness': -1 })
                .rotateIn(-90, 250, {'ease': 'easeOutBack'})
                .zIndex(0)

                .thenDo(function(){
                    hitSeq.play();
                })
                .play();
            return;
        case 'bludgeoning':
            new Sequence()
                .effect()
                .file('animated-spell-effects-cartoon.water.115')
                .atLocation(target)
                .scale(0.17 * token.document.width)
                .rotateTowards(token)
                .spriteRotation(0)
                .spriteOffset({'x': -0.45 * token.document.width, 'y': 0}, {'gridUnits': true})
                .filter('ColorMatrix', {'saturate': 0.75 })
                .scaleIn(0, 250, {'ease': 'easeOutExpo'})
                .zIndex(1)

                .effect()
                .file('jb2a.melee_generic.bludgeoning.two_handed')
                .atLocation(target)
                .scale(0.4 * token.document.width)
                .rotateTowards(token)
                .spriteRotation(180)
                .spriteOffset({'x': -1 * token.document.width, 'y':0}, {'gridUnits': true})
                .filter('ColorMatrix', {'saturate': -1, 'brightness': -1 })
                .scaleIn(0, 250, {'ease': 'easeOutExpo'})
                .zIndex(0)

                .thenDo(function(){
                    hitSeq.play();
                })
                .play();
            return;
        case 'ranged':
            new Sequence()
                .effect()
                .file('animated-spell-effects-cartoon.water.109')
                .atLocation(target)
                .scale(0.2 * token.document.width)
                .rotateTowards(token)
                .spriteRotation(0)
                .spriteOffset({'x': -0.3 * token.document.width, 'y': 0}, {'gridUnits': true})
                .filter('ColorMatrix', {'saturate': 0.75 })
                .scaleIn(0, 250, {'ease': 'easeOutExpo'})
                .zIndex(1)

                .effect()
                .file('animated-spell-effects-cartoon.water.115')
                .atLocation(target)
                .scale({'x':0.1 * token.document.width, 'y': 0.2 * token.document.width})
                .rotateTowards(token)
                .spriteRotation(0)
                .spriteOffset({'x': -0.4 * token.document.width, 'y': 0}, {'gridUnits': true})
                .filter('ColorMatrix', {'saturate': -1, 'brightness': -1 })
                .scaleIn(0, 250, {'ease': 'easeOutExpo'})
                .zIndex(0)

                .thenDo(function(){
                    hitSeq.play();
                })
                .play();
            return;
        default:
            new Sequence()
                .effect()
                .file('animated-spell-effects-cartoon.water.107')
                .atLocation(token)
                .scale(0.25 * token.document.width)
                .rotateTowards(target)
                .spriteRotation(18)
                .spriteOffset({'x': -0.6 * token.document.width, 'y': -0.25 * token.document.width}, {'gridUnits': true})
                .filter('ColorMatrix', {'saturate': 0.75 })
                .rotateIn(-25, 250, {'ease': 'easeOutExpo'})
                .zIndex(1)

                .effect()
                .file('jb2a.melee_generic.piercing.one_handed')
                .atLocation(token)
                .scale(0.5 * token.document.width)
                .rotateTowards(target)
                .spriteRotation(15)
                .mirrorY()
                .spriteOffset({'x': -1.9 * token.document.width, 'y':-0.3 * token.document.width}, {'gridUnits': true})
                .filter('ColorMatrix', {'saturate': -1, 'brightness': -1 })
                .rotateIn(-25, 250, {'ease': 'easeOutExpo'})
                .zIndex(0)

                .thenDo(function(){
                    hitSeq.play();
                })
                .play();
            return;
    }
}
async function sneakAttack_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (!(workflow.item.system.actionType === 'rwak' || workflow.item.system.properties?.fin)) return;
    let originFeature = chris.getItem(workflow.actor, 'Sneak Attack');
    if (!originFeature) return;
    if (!chris.perTurnCheck(originFeature, 'feature', 'sneakAttack')) return;
    let doSneak = false;
    let displayRakish = false;
    if (workflow.advantage) doSneak = true;
    let targetToken = workflow.targets.first();
    if (!doSneak && !workflow.disadvantage) {
        let nearbyTokens = await chris.findNearby(targetToken, 5, 'enemy').filter(t => t.id != workflow.token.id);
        if (nearbyTokens.length > 0) doSneak = true;
    }
    let rakishAudacity = chris.getItem(workflow.actor, 'Rakish Audacity');
    if (rakishAudacity && !workflow.disadvantage && !doSneak && (chris.getDistance(workflow.token, targetToken) <= 5)) {
        let rNearbyTokens = await chris.findNearby(workflow.token, 5, 'all', true).filter(t => t.id != targetToken.id);
        if (rNearbyTokens.length === 0) {
            doSneak = true;
            displayRakish = true;
        }
    }
    let insightfulFighting = chris.findEffect(workflow.actor, 'Insightful Fighting');
    let iTarget = false;
    if (insightfulFighting) {
        let effectTarget = insightfulFighting.changes[0].value;
        if (effectTarget === targetToken.document.uuid) {
            doSneak = true;
            iTarget = true;
        }
    }
    if (!doSneak) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'sneakAttack', 215);
    if (!queueSetup) return;
    let autoSneak = chris.getConfiguration(originFeature, 'auto') ?? false;
    if (!autoSneak) {
        let selection = await chris.dialog(originFeature.name, constants_constants.yesNo, 'Use ' + originFeature.name + '?');
        if (!selection) {
            queue_queue.remove(workflow.item.uuid);
            return;
        }
    }
    await chris.setTurnCheck(originFeature, 'feature', 'sneakAttack');
    let bonusDamageFormula = workflow.actor.flags['chris-premades']?.feature?.sneakAttack?.customFormula;
    if (!bonusDamageFormula) {
        if (workflow.actor.type === 'character') {
            let scale = workflow.actor.system.scale?.rogue?.['sneak-attack'];
            if (scale) {
                let number = scale.number;
                bonusDamageFormula = number + 'd' + scale.faces + '[' + workflow.defaultDamageType + ']';
            } else {
                ui.notifications.warn('Actor does not appear to have a Sneak Attack scale!');
                queue_queue.remove(workflow.item.uuid);
                return;
            }
        } else if (workflow.actor.type === 'npc') {
            let number = Math.ceil(workflow.actor.system.details.cr / 2);
            bonusDamageFormula = number + 'd6[' + workflow.defaultDamageType + ']';
        }
    } else {
        bonusDamageFormula += '[' + workflow.defaultDamageType + ']';
    }
    let eyeFeature = chris.getItem(workflow.actor, 'Eye for Weakness');
    if (iTarget && eyeFeature) bonusDamageFormula += ' + 3d6[' + workflow.defaultDamageType + ']';
    if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
    let damageFormula = workflow.damageRoll._formula + ' + ' + bonusDamageFormula;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    await originFeature.use();
    if (displayRakish) await rakishAudacity.use();
    if (iTarget) {
        let iFeature = chris.getItem(workflow.actor, 'Insightful Fighting');
        if (iFeature) await iFeature.displayCard();
        if (eyeFeature) await eyeFeature.use();
    }
    queue_queue.remove(workflow.item.uuid);
    let playAnimation = chris.getConfiguration(originFeature, 'animation') ?? true;
    if (!chris.aseCheck() || chris.jb2aCheck() != 'patreon') playAnimation = false;
    if (!playAnimation) return;
    let animationType;
    if (chris.getDistance(workflow.token, targetToken) > 5) animationType = 'ranged';
    if (!animationType) animationType = workflow.defaultDamageType;
    await sneakAttack_animation(targetToken, workflow.token, animationType);
}
async function sneakAttack_combatEnd(origin) {
    await origin.setFlag('chris-premades', 'feature.sneakAttack.turn', '');
    await chris.setTurnCheck(origin, 'feature', 'sneakAttack', true);
}
let sneakAttack = {
    'attack': sneakAttack_attack,
    'combatEnd': sneakAttack_combatEnd,
    'animation': sneakAttack_animation
}

;// CONCATENATED MODULE: ./scripts/macros/classFeatures/wizard/bladesinging/songOfDefense.js

async function songOfDefense({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = workflow.actor.effects.find(i => i.flags['chris-premades']?.feature?.bladesong);
    if (!effect) {
        ui.notifications.info('You must be Bladesinging to use this feature!');
        return;
    }
    let validLevels = [];
    for (let i = 1; i <= 9; i++) {
        let key2 = 'spell' + i;
        let key = 'system.spells.' + key2 + '.value';
        if ((workflow.actor.system.spells[key2].value > 0) && workflow.actor.system.spells[key2].max > 0) validLevels.push({'level': i, 'key': key});
    }
    let pact = workflow.actor.system.spells.pact;
    if (pact.max > 0 && pact.value > 0) validLevels.push({'level': 'p', 'key': 'system.spells.pact.value'});
    if (!validLevels.length) {
        ui.notifications.info('You have no spell slots to expend!');
        return;
    }
    let options = validLevels.map(i => [(i.level != 'p' ? chris.nth(i.level) + ' Level' : 'Pact Slot'), i.key]);
    let selection = options.length > 1 ? await chris.dialog(workflow.item.name, options, 'Expend what spell slot?') : options[0][1];
    if (!selection) return;
    let value = getProperty(workflow.actor, selection);
    if (isNaN(value)) return;
    let slotLevel = selection.split('.')[2][0] === 'p' ? workflow.actor.system.spells.pact.level : selection.split('.')[2].slice(-1);
    let damageReduction = slotLevel * 5;
    await workflow.actor.update({[selection]: value - 1});
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 1,
        },
        'changes': [
            {
                'key': 'flags.midi-qol.DR.all',
                'mode': 0,
                'value': damageReduction,
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'specialDuration': [
                    '1Reaction'
                ]
            },
        },
    }
    await chris.createEffect(actor, effectData);
}

;// CONCATENATED MODULE: ./scripts/macros/feats/soothePain.js



async function soothePain(targetToken, {workflow, ditem}) {
    if (ditem.newHP >= ditem.oldHP) return;
    let queueSetup = await queue_queue.setup(workflow.uuid, 'soothePain', 350);
    if (!queueSetup) return;
    let reactionTargets = chris.findNearby(targetToken, 30, 'ally', false, true).filter(t =>
        !chris.findEffect(t.actor, 'Reaction') &&
        chris.getItem(t.actor, 'Righteous Heritor: Soothe Pain')?.system?.uses?.value > 0 &&
        chris.getDistance(t, targetToken) <= 30
    );
    if (!reactionTargets.length) {
        queue_queue.remove(workflow.uuid);
        return;
    }
    for (let reactor of reactionTargets) {
        let feature = chris.getItem(reactor.actor, 'Righteous Heritor: Soothe Pain');
        if (!feature) continue;
        let firstOwner = chris.firstOwner(reactor);
        await chris.thirdPartyReactionMessage(firstOwner);
        let message = 'Protect ' + targetToken.actor.name + ' with ' + feature.name + '?';
        if (firstOwner.isGM) message = '[' + reactor.actor.name + '] ' + message;
        let selection = await chris.remoteDialog(feature.name, constants_constants.yesNo, firstOwner.id, message);
        if (!selection) continue;
        let updates = {
            'embedded': {
                'Item': {
                    [feature.name]: {
                        'system.uses.value': feature.system.uses.value - 1
                    }
                }
            }
        };
        let options2 = {
            'permanent': true,
            'name': feature.name,
            'description': feature.name
        };
        await warpgate.mutate(reactor.document, updates, {}, options2);
        let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.document.uuid]);
        await warpgate.wait(100);
        let featureWorkflow = await MidiQOL.completeItemUse(feature, config, options);
        chris.removeDamageDetailDamage(ditem, targetToken, featureWorkflow.damageTotal);
        break;
    }
    await chris.clearThirdPartyReactionMessage();
    queue_queue.remove(workflow.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/soulMonger/soulThirst.js

async function passive({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size === 0 || !workflow.damageList) return;
    let maxHP = null;
    let killedTarget = false;
    for (let i of workflow.damageList) {
        if (i.newHP === 0) {
            killedTarget = true;
            let targetToken = await fromUuid(i.tokenUuid);
            let targetMaxHP = targetToken.actor.system.attributes.hp.max;
            if (targetMaxHP > maxHP) maxHP = targetMaxHP;
        }
    }
    if (!killedTarget) return;
    let effect = chris.findEffect(workflow.actor, 'Soul Thirst - Passive');
    if (!effect) return;
    let originItem = await fromUuid(effect.origin);
    if (!originItem) return;
    await originItem.use();
    await chris.applyDamage([workflow.token], Math.floor(maxHP / 2), 'temphp');
}
async function soulThirst_onHit(workflow, targetToken) {
    if (workflow.hitTargets.size === 0) return;
    if (targetToken.actor.system.attributes.hp.temp > 0) return;
    let effect = chris.findEffect(targetToken.actor, 'Soul Thirst');
    if (effect) await chris.removeEffect(effect);
}
let soulThirst = {
    'passive': passive,
    'onHit': soulThirst_onHit
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/soulMonger/waveOfWeariness.js

async function waveOfWeariness({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size === 0) return;
    workflow.failedSaves.forEach(async function(value, key, set) {
        await chris.increaseExhaustion(value.actor);
    });
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/soulMonger/weightOfAges.js

async function weightOfAges(token, origin) {
    let targetToken = game.canvas.tokens.get(game.combat.current.tokenId);
    if (!targetToken) return;
    if (targetToken.id === token.id) return;
    let distance = chris.getDistance(token, targetToken);
    if (distance > 5) return;
    let targetRace = chris.raceOrType(targetToken.actor);
    if (targetRace.toLowerCase() === 'elf') return;
    if (targetToken.actor.type === 'npc') {
        if (targetRace != 'beast' || targetRace != 'humanoid') return;
    }
    let effect = chris.findEffect(targetToken.actor, origin.name);
    if (effect) await chris.removeEffect(effect);
    let effectData = {
        'label': origin.name,
        'icon': origin.img,
        'origin': origin.uuid,
        'duration': {
            'rounds': 1
        },
        'changes': [
            {
                'key': 'system.attributes.movement.all',
                'mode': 0,
                'value': '-20',
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    'turnStartSource',
                    'combatEnd'
                ],
                'stackable': 'multi',
                'macroRepeat': 'none'
            }
        }
    }
    await chris.createEffect(targetToken.actor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/soulMonger/soulMonger.js



let soulMonger = {
    'waveOfWeariness': waveOfWeariness,
    'soulThirst': soulThirst,
    'weightOfAges': weightOfAges
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/artificer/infusions/spellRefuelingRing.js

async function spellRefuelingRing({speaker, actor, token, character, item, args, scope, workflow}) {
    let pact = workflow.actor.system.spells.pact.value;
    let pactMax = workflow.actor.system.spells.pact.max;
    let pactLevel = workflow.actor.system.spells.pact.level;
    let spell1 = workflow.actor.system.spells.spell1.value;
    let spell1Max = workflow.actor.system.spells.spell1.max;
    let spell2 = workflow.actor.system.spells.spell2.value;
    let spell2Max = workflow.actor.system.spells.spell2.max;
    let spell3 = workflow.actor.system.spells.spell3.value;
    let spell3Max = workflow.actor.system.spells.spell3.max;
    let options = [];
    if (pactLevel <= 3 && pactMax > pact) options.push(['Pact', 'pact']);
    if (spell1Max > spell1) options.push(['First Level', 'spell1']);
    if (spell2Max > spell2) options.push(['2nd Level', 'spell2']);
    if (spell3Max > spell3) options.push(['3rd Level', 'spell3']);
    if (!options.length) {
        ui.notifications.info('No spell slots to recover!');
        return;
    }
    let selection;
    if (options.length === 1) selection = options[0][1];
    if (!selection) selection = await chris.dialog(workflow.item.name, options, 'What spell slot do you want to recover?');
    if (!selection) return;
    let key = 'system.spells.' + selection + '.value';
    let value = getProperty(workflow.actor.system.spells, selection + '.value');
    await workflow.actor.update({[key]: value + 1});
}
;// CONCATENATED MODULE: ./scripts/macros/spells/spikeGrowth.js


async function spikeGrowthEnterLeave(data, template) {
    if (canvas.scene.grid.units != 'ft') return;
    if (data.hook.animate === false) return;
    let cellDistance;
    if (canvas.scene.grid.type != 0) {
        let through = data.hook.templatemacro.through.find(tmp => tmp.templateId === template.id);
        if (!through) return;
        cellDistance = through.cells.length;
    } else {
        let token = canvas.tokens.get(data.tokenId);
        let currentTokenCenter = {
            x: data.coords.current.x + (token.w / 2),
            y: data.coords.current.y + (token.w / 2)
        };
        let previousTokenCenter = {
            x: data.coords.previous.x + (token.w / 2),
            y: data.coords.previous.y + (token.w / 2)
        };
        let intersectionPoint = quadraticIntersection(previousTokenCenter, currentTokenCenter, template.object.center, template.object.shape.radius, epsilon=0);
        if (intersectionPoint.length === 0) return;
        let ray = new Ray(intersectionPoint[0], currentTokenCenter);
        cellDistance = (Math.ceil(ray.distance / canvas.scene.grid.size));
    }
    let scale = Math.ceil(canvas.scene.grid.distance / 5);
    let distance = cellDistance * scale;
    if (distance <= 0) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Spike Growth - Thorns', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Spike Growth - Thorns');
    let originUuid = template.flags.dnd5e?.origin;
    if (!originUuid) return;
    let originItem = await fromUuid(originUuid);
    if (!originItem) return;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': originItem.actor});
    let token = canvas.tokens.get(data.tokenId);
    if (!token) return;
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.document.uuid]);
    for (let i = 0; i < distance; i++) {
        if (i > 0) await (warpgate.wait(100));
        await MidiQOL.completeItemUse(feature, config, options);
    }
}
async function spikeGrowthStaying(data, template) {
    if (canvas.scene.grid.units != 'ft') return;
    if (data.hook.animate === false) return;
    let cellDistance;
    if (canvas.scene.grid.type != 0) {
        let through = data.hook.templatemacro.through.find(tmp => tmp.templateId === template.id);
        if (!through) return;
        cellDistance = through.cells.length - 1;
    } else {
        let token = canvas.tokens.get(data.tokenId);
        let currentTokenCenter = {
            x: data.coords.current.x + (token.w / 2),
            y: data.coords.current.y + (token.w / 2)
        };
        let previousTokenCenter = {
            x: data.coords.previous.x + (token.w / 2),
            y: data.coords.previous.y + (token.w / 2)
        };
        let intersectionPoint = quadraticIntersection(previousTokenCenter, currentTokenCenter, template.object.center, template.object.shape.radius, epsilon=0);
        if (intersectionPoint.length === 0) return;
        let ray = new Ray(intersectionPoint[0], currentTokenCenter);
        cellDistance = (Math.ceil(ray.distance / canvas.scene.grid.size));
    }
    let scale = Math.ceil(canvas.scene.grid.distance / 5);
    let distance = cellDistance * scale;
    if (distance <= 0) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Spike Growth - Thorns', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Spike Growth - Thorns');
    let originUuid = template.flags.dnd5e?.origin;
    if (!originUuid) return;
    let originItem = await fromUuid(originUuid);
    if (!originItem) return;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': originItem.actor});
    let token = canvas.tokens.get(data.tokenId);
    if (!token) return;
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.document.uuid]);
    for (let i = 0; i < distance; i++) {
        if (i > 0) await (warpgate.wait(100));
        await MidiQOL.completeItemUse(feature, config, options);
    }
}
let spikeGrowth = {
    'enterLeave': spikeGrowthEnterLeave,
    'staying': spikeGrowthStaying
}
;// CONCATENATED MODULE: ./scripts/macros/spells/spiritGuardians.js



async function spiritGuardians_moved(token, castLevel, spellDC, damage, damageType, sourceTokenID) {
    let doDamage = false;
    if (!chris.inCombat()) {
        doDamage = true;
    } else {
        let combatant = game.combat.combatants.get(game.combat.current.combatantId);
        let lastTriggerTurn = combatant.flags?.['chris-premades']?.spell?.spiritGuardians?.[sourceTokenID]?.lastTriggerTurn;
        let currentTurn = game.combat.current.round + '-' + game.combat.current.turn;
        if (!lastTriggerTurn || lastTriggerTurn != currentTurn) {
            doDamage = true;
            await combatant.setFlag('chris-premades', 'spell.spiritGuardians.' + sourceTokenID + '.lastTriggerTurn', currentTurn);
        }
    }
    if (!doDamage) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Spirit Guardians - Damage', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Spirit Guardians - Damage');
    featureData.system.damage.parts = [
        [
            damage + '[' + damageType + ']',
            damageType
        ]
    ];
    featureData.system.save.dc = spellDC;
    featureData.flags['chris-premades'] = {
        'spell': {
            'castData': {
                'baseLevel': 3,
                'castLevel': castLevel,
                'school': 'con'
            }
        }
    }
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.uuid]);
    let sourceToken = canvas.tokens.get(sourceTokenID);
    if (!sourceToken) return;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': sourceToken.actor});
    await MidiQOL.completeItemUse(feature, config, options);
}
async function spiritGuardians_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let castLevel = workflow.castData.castLevel;
    let spellDC = chris.getSpellDC(workflow.item);
    let sourceTokenID = workflow.token.id;
    let range = 15;
    let alignment = workflow.actor.system.details.alignment.toLowerCase();
    let damageType;
    if (alignment.includes('good') || alignment.includes('neutral')) {
        damageType = 'radiant';
    } else if (alignment.includes('evil')) {
        damageType = 'necrotic'
    } else {
        damageType = await chris.dialog('What is your alignment?', [['Good or Neutral (Radiant)', 'radiant'], ['Evil (Necrotic)', 'necrotic']]);
        if (!damageType) damageType = 'radiant';        
    }
    let damage = castLevel + 'd8';
    let effect = chris.findEffect(workflow.actor, 'Spirit Guardians');
    if (!effect) return;
    await tokenMove.add('spiritGuardians', castLevel, spellDC, damage, damageType, sourceTokenID, range, true, true, 'start', effect.uuid, true);
    let color = chris.getConfiguration(workflow.item, 'color') ?? 'blueyellow';
    let variation = '.' + (chris.getConfiguration(workflow.item, 'variation') ?? 'ring');
    if (color === 'random') {
        let colors = [
            'blueyellow',
            'blue',
            'dark_black',
            'dark_blue',
            'dark_purple',
            'dark_red',
            'dark_whiteblue',
            'green',
            'orange',
            'greenorange',
            'pinkpurple'
        ];
        color = colors[Math.floor(Math.random() * colors.length)];
    }
    if (chris.jb2aCheck() === 'free') {
        color = 'blueyellow';
        variation = '.ring'
    }
    new Sequence().effect().file('jb2a.spirit_guardians.' + color + variation).size(workflow.token.document.width + 6, {'gridUnits': true}).attachTo(workflow.token).persist().name('SpiritGuardians-' + workflow.token.id).fadeIn(300).fadeOut(300).play();
}
async function spiritGuardians_effectEnd(token) {
    await tokenMove.remove('spiritGuardians', token.id);
    Sequencer.EffectManager.endEffects({ 'name': 'SpiritGuardians-' + token.id, 'object': token});
}
let spiritGuardians = {
    'item': spiritGuardians_item,
    'effectEnd': spiritGuardians_effectEnd,
    'moved': spiritGuardians_moved
}
;// CONCATENATED MODULE: ./scripts/macros/spells/spiritShroud.js


async function spiritShroudItem({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Spirit Shroud');
    if (!effect) return;
    let options = [
        ['Radiant', 'radiant'],
        ['Necrotic', 'necrotic'],
        ['Cold', 'cold']
    ];
    let selection = await chris.dialog('What damage type?', options);
    if (!selection) selection = 'necrotic';
    await effect.setFlag('chris-premades', 'spell.spiritShroud', selection);
}
async function spiritShroudAttack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let validAttacks = ['mwak', 'rwak', 'msak', 'rsak'];
    if (!validAttacks.includes(workflow.item.system.actionType)) return;
    let distance = MidiQOL.getDistance(workflow.token, workflow.targets.first(), {wallsBlock: false});
    if (distance > 10) return;
    let effect = chris.findEffect(workflow.actor, 'Spirit Shroud');
    if (!effect) return;
    let castLevel = effect.flags['midi-qol'].castData.castLevel;
    let damageType = effect.flags['chris-premades']?.spell?.spiritShroud;
    if (!damageType) damageType = 'necrotic';
    let diceNum;
    switch (castLevel) {
        case 3:
        case 4:
            diceNum = 1;
            break;
        case 5:
        case 6:
            diceNum = 2;
            break;
        case 7:
        case 8:
            diceNum = 3;
            break;
        case 9:
            diceNum = 4;
            break;
    }
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'spiritShroud', 250);
    if (!queueSetup) return;
    let oldFormula = workflow.damageRoll._formula;
    let bonusDamageFormula = diceNum + 'd8[' + damageType + ']';
    if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
    let damageFormula = oldFormula + ' + ' + bonusDamageFormula;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function spiritShroudSlow(token, origin) {
    let targetToken = game.canvas.tokens.get(game.combat.current.tokenId);
    if (!targetToken) return;
    if (targetToken.document.disposition === token.document.disposition) return;
    let distance = chris.getDistance(token, targetToken);
    if (distance > 10) return;
    let effect = chris.findEffect(targetToken.actor, 'Spirit Shroud - Slow');
    if (effect) await chris.removeEffect(effect);
    let effectData = {
        'label': 'Spirit Shroud - Slow',
        'icon': origin.img,
        'origin': origin.actor.uuid,  //Not item Uuid to prevent AA from killing the animation on the source actor.
        'duration': {
            'rounds': 1
        },
        'changes': [
            {
                'key': 'system.attributes.movement.all',
                'mode': 0,
                'value': '-10',
                'priority': 20
            }
        ],
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    'turnStartSource',
                    'combatEnd'
                ],
                'stackable': 'multi',
                'macroRepeat': 'none'
            }
        }
    }
    await chris.createEffect(targetToken.actor, effectData);
}
let spiritShroud = {
    'item': spiritShroudItem,
    'attack': spiritShroudAttack,
    'slow': spiritShroudSlow
}
;// CONCATENATED MODULE: ./scripts/macros/spells/spiritualWeapon.js

async function spiritualWeapon_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let sourceActor = game.actors.getName('CPR - Spiritual Weapon');
    if (!sourceActor) return;
    async function effectMacro() {
        let originActor = origin.actor;
        await warpgate.dismiss(token.id);
        let castEffect = chrisPremades.helpers.findEffect(originActor, origin.name);
        if (castEffect) await chrisPremades.helpers.removeEffect(castEffect);
    }
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': 'Dismiss Summon'
                }
            }
        }
    };
    let name = chris.getConfiguration(workflow.item, 'name') ?? 'Spiritual Weapon';
    if (name === '') name = 'Spiritual Weapon';
    let updates = {
        'actor': {
            'name': name,
            'prototypeToken': {
                'name': name
            }
        },
        'token': {
            'name': name
        },
        'embedded': {
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    async function selectTokenImg () {
        let selection;
        let selection2;
        let selection3;
        let selectedImg = '';
        if (!chris.jb2aCheck()) {
            return;
        }
        if (chris.jb2aCheck() === 'patreon') {
            selection = await chris.dialog('What Style?', [['Flaming', 'flaming'], ['Dark', 'dark']]);
            if (!selection) return;
            if (selection === 'flaming') {
                selection2 = await chris.dialog('What Weapon?', [['Mace', 'mace'], ['Maul', 'maul'], ['Sword', 'sword']]);
                if (!selection2) return;
                selection3 = await chris.dialog('What Color?', [
                    ['Blue', 'blue'], 
                    ['Green', 'green'], 
                    ['Yellow', 'yellow'], 
                    ['Orange', 'orange'], 
                    ['Red', 'red'], 
                    ['Purple', 'purple']
                ]);
                if (!selection3) return;
            }
            if (selection === 'dark') {
                selection2 = await chris.dialog('What Weapon?', [['Scythe', 'scythe'], ['Sword', 'sword']]);
                if (!selection2) return;
                selection3 = await chris.dialog('What Color?', [
                    ['Green', 'green'], 
                    ['Blue', 'blue'], 
                    ['Purple', 'purple'], 
                    ['Red', 'red'], 
                    ['White', 'white']
                ]);
                if (!selection3) return;
            }
            selectedImg = 'jb2a.spiritual_weapon.' + selection2 + '.' + selection + '.' + selection3;
        } else {
            selection = await chris.dialog('What Weapon?', [['Mace', 'mace'], ['Maul', 'maul']]);
            if (!selection) return;
            selection2 = await chris.dialog('What Color?', [['Blue', 'spectral.blue'], ['Yellow', 'flaming.yellow']]);
            if (!selection2) return;
            selectedImg = 'jb2a.spiritual_weapon.' + selection + '.' + selection2;;
        }
        selectedImg = await Sequencer.Database.getEntry(selectedImg).file;
        return selectedImg;
    }
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar');
    if (avatarImg) updates.actor.img = avatarImg;
    let tokenImg = chris.getConfiguration(workflow.item, 'token');
    if (!tokenImg) tokenImg = await selectTokenImg();
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    let options = {
        'controllingActor': workflow.token.actor
    };
    let tokenDocument = await sourceActor.getTokenDocument();
    let spawnedTokens = await warpgate.spawn(tokenDocument, updates, {}, options);
    if (!spawnedTokens) return;
    let spawnedToken = game.canvas.scene.tokens.get(spawnedTokens[0]);
    if (!spawnedToken) return;
    let targetEffect = chris.findEffect(spawnedToken.actor, workflow.item.name);
    if (!targetEffect) return;
    let casterEffectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'changes': [
            {
                'key': 'flags.chris-premades.feature.spiritualWeapon.tokenUuid',
                'mode': 5,
                'value': spawnedToken.uuid,
                'priority': 20
            }
        ],
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': 'let effect = await fromUuid("' + targetEffect.uuid + '"); if (effect) await chrisPremades.helpers.removeEffect(effect); await warpgate.revert(token.document, "Spiritual Weapon");'
                }
            },
            'chris-premades': {
                'vae': {
                    'button': 'Spiritual Weapon - Attack'
                }
            }
        }
    };
    let attackFeatureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Spiritual Weapon - Attack', false);
    if (!attackFeatureData) return;
    attackFeatureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Spiritual Weapon - Attack');
    attackFeatureData.system.ability = workflow.item.system.ability;
    let spellLevel = workflow.castData?.castLevel;
    if (!spellLevel) return;
    let scaling = Math.floor(spellLevel / 2);
    attackFeatureData.system.damage.parts[0] = scaling + 'd8[force] + @mod';
    let updates2 = {
        'embedded': {
            'Item': {
                [attackFeatureData.name]: attackFeatureData
            },
            'ActiveEffect': {
                [casterEffectData.name]: casterEffectData
            }
        }
    };
    let options2 = {
        'permanent': false,
        'name': 'Spiritual Weapon',
        'description': 'Spiritual Weapon'
    };
    await warpgate.mutate(workflow.token.document, updates2, {}, options2);
}
async function spiritualWeapon_attackEarly({speaker, actor, token, character, item, args, scope, workflow}) {
    await workflow.item.setFlag('chris-premades', 'feature.spiritualWeapon.position', {'x': workflow.token.document.x, 'y': workflow.token.document.y});
    await workflow.actor.setFlag('chris-premades', 'mechanic.noFlanking', true);
    let weaponTokenUuid = workflow.actor.flags['chris-premades']?.feature?.spiritualWeapon?.tokenUuid;
    if (!weaponTokenUuid) return;
    let weaponToken = await fromUuid(weaponTokenUuid);
    if (!weaponToken) return;
    let position = canvas.grid.getSnappedPosition(weaponToken.x, weaponToken.y);
    workflow.token.document.x = position.x;
    workflow.token.document.y = position.y;
    workflow.flankingAdvantage = false; //Does not currently work.
}
async function spiritualWeapon_attackLate({speaker, actor, token, character, item, args, scope, workflow}) { 
    await workflow.actor.unsetFlag('chris-premades', 'mechanic.noFlanking');
    let position = workflow.item.flags['chris-premades']?.feature?.spiritualWeapon?.position;
    if (!position) return;
    workflow.token.document.x = position.x;
    workflow.token.document.y = position.y;
}
let spiritualWeapon = {
    'item': spiritualWeapon_item,
    'attackEarly': spiritualWeapon_attackEarly,
    'attackLate': spiritualWeapon_attackLate
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/sprite/shortbow.js

async function shortbow({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1 || workflow.failedSaves.size != 1) return;
    let targetActor = workflow.targets.first().actor;
    if (!chris.findEffect(targetActor, 'Poisoned')) return;
    let saveResult = workflow.saveResults[0].total;
    if (saveResult <= 5) await chris.addCondition(targetActor, 'Unconscious', false, workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/sprite/sprite.js

let sprite = {
    'showbow': shortbow
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/druid/circleOfStars/starryForm.js

async function starryForm({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Starry Form - Passive');
    if (!effect) return;
    let starry = await fromUuid(effect.origin);
    if (!starry) return;
    let selection = await chris.dialog('Starry Form: Which Constellation?', [['Archer', 'Archer'], ['Dragon', 'Dragon'], ['Chalice', 'Chalice']]);
    let tier = workflow.actor.classes.druid.system.levels > 13 ? 3 : workflow.actor.classes.druid.system.levels > 9 ? 2 : 1;
    let featureData;
    switch (selection) {
        case 'Archer':
            featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Starry Form: Luminous Arrow', false);
            featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Starry Form: Luminous Arrow');
            break;
        case 'Dragon':
            featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Starry Form: Wise Dragon', false);
            featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Starry Form: Wise Dragon');
            break;
        case 'Chalice':
            featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Starry Form: Healing Chalice', false);
            featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Starry Form: Healing Chalice');
            break;
    }
    async function effectMacro() {
        await warpgate.revert(token.document, 'Starry Form');
    }
    async function turnStart() {
        let change = await chrisPremades.helpers.dialog('Twinkling Constellations: Change Constellation?', [['Yes', true], ['No', false]]);
        if (!change) return;
        let otherEffect = chrisPremades.helpers.findEffect(actor, 'Twinkling Constellations');
        if (!otherEffect) return;
        let otherEffectItem = await fromUuid(otherEffect.origin);
        if (!otherEffectItem) return;
        await otherEffectItem.use();
    }
    let changes = [
        {
            'key': 'ATL.light.bright',
            'value': '10',
            'mode': 5,
            'priority': 20
        },
        {
            'key': 'ATL.light.dim',
            'value': '20',
            'mode': 5,
            'priority': 20
        },
        {
            'key': 'ATL.light.color',
            'value': '#ffffff',
            'mode': 5,
            'priority': 20
        },
        {
            'key': 'ATL.light.alpha',
            'value': '0.25',
            'mode': 5,
            'priority': 20
        },
        {
            'key': 'ATL.light.animation',
            'value': '{\'type\': \'starlight\', \'speed\': 1,\'intensity\': 3}',
            'mode': 5,
            'priority': 20
        }
    ];
    if (tier === 3) {
        changes.push({
            'key': 'system.traits.dr.value',
            'value': 'slashing',
            'mode': 2,
            'priority': 20
        });
        changes.push({
            'key': 'system.traits.dr.value',
            'value': 'piercing',
            'mode': 2,
            'priority': 20
        });
        changes.push({
            'key': 'system.traits.dr.value',
            'value': 'bludgeoning',
            'mode': 2,
            'priority': 20
        });
    }
    if (selection === 'Dragon') {
        changes.push({
            'key': 'flags.midi-qol.min.ability.check.wis',
            'value': '10',
            'mode': 5,
            'priority': 20
        });
        changes.push({
            'key': 'flags.midi-qol.min.ability.check.int',
            'value': '10',
            'mode': 5,
            'priority': 20
        });
        changes.push({
            'key': 'flags.midi-qol.min.ability.save.con',
            'value': '10',
            'mode': 5,
            'priority': 20
        });
        if (tier > 1){
            changes.push({
                'key': 'system.attributes.movement.fly',
                'value': '20',
                'mode': 4,
                'priority': 20
            });
        }
    }
    let duration = 600;
    let existing = workflow.actor.effects.find(eff => eff.flags['chris-premades']?.feature?.starryForm === true);
    if (existing) {
        duration = existing.duration.remaining;
    }
    let effectData = {
        'changes': changes,
        'origin': starry.uuid,
        'disabled': false,
        'duration': {
            'seconds': duration
        },
        'icon': starry.img,
        'name': starry.name + ': ' + selection,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'dae': {
                'transfer': true
            },
            'chris-premades': {
                'feature': {
                    'starryForm': true
                }
            }
        }
    }
    if (tier > 1){
        effectData.flags['effectmacro'].onTurnStart = {
            'script': chris.functionToString(turnStart)
        };
    }
    if (selection != 'Dragon') {
        effectData.flags['chris-premades'].vae = {
            'button': featureData.name
        };
    }
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Starry Form',
        'description': 'Starry Form'
    };
    if (existing) await warpgate.revert(workflow.token.document, 'Starry Form');
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
;// CONCATENATED MODULE: ./scripts/macros/feats/stasisStrike.js




async function stasisStrike_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || !workflow.token || !workflow.damageRoll) return;
    if (constants_constants.nonDamageTypes.includes(workflow.defaultDamageType)) return;
    let targetToken = workflow.targets.first();
    if (chris.getDistance(workflow.token, targetToken) > 60) return;
    let feature = chris.getItem(workflow.actor, 'Agent of Order: Stasis Strike');
    if (!feature) return;
    if (feature.uuid === workflow.item.uuid) return;
    if (!feature.system.uses.value) return;
    if (!chris.perTurnCheck(feature, 'feat', 'stasisStrike')) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'stasisStrike', 250);
    if (!queueSetup) return;
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Use ' + feature.name + '?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await chris.setTurnCheck(feature, 'feat', 'stasisStrike');
    await feature.update({'system.uses.value': feature.system.uses.value - 1});
    let featureData = feature.toObject();
    delete featureData._id;
    featureData.system.damage.parts = [];
    let sFeature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    await warpgate.wait(100);
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.document.uuid]);
    await MidiQOL.completeItemUse(sFeature, config, options);
    let oldFormula = workflow.damageRoll._formula;
    let bonusDamageFormula = feature.system.damage.parts[0][0] + '[' + translate.damageType('force') + ']';
    if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
    let damageFormula = oldFormula + ' + ' + bonusDamageFormula;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function stasisStrike_damageMany({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size < 2 || !workflow.token || !workflow.damageRoll) return;
    if (constants_constants.nonDamageTypes.includes(workflow.defaultDamageType)) return;
    let feature = chris.getItem(workflow.actor, 'Agent of Order: Stasis Strike');
    if (!feature) return;
    if (!feature.system.uses.value) return;
    if (!chris.perTurnCheck(feature, 'feat', 'stasisStrike')) return;
    let targetTokens = Array.from(workflow.targets).filter(t => chris.getDistance(workflow.token, t) <= 60);
    if (!targetTokens.length) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'stasisStrike', 250);
    if (!queueSetup) return;
    let selection = await chris.selectTarget('Use ' + feature.name + '?', constants_constants.yesNoButton, targetTokens, true, 'one');
    if (!selection.buttons) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let targetTokenUuid = selection.inputs.find(uuid => uuid);
    if (!targetTokenUuid) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await feature.update({'system.uses.value': feature.system.uses.value - 1});
    await chris.setTurnCheck(feature, 'feat', 'stasisStrike');
    let targetToken = await fromUuid(targetTokenUuid);
    let featureData = feature.toObject();
    delete featureData._id;
    featureData.system.damage.parts[0][1] = 'midi-none';
    let sFeature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    await warpgate.wait(100);
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.uuid]);
    let sWorkflow = await MidiQOL.completeItemUse(sFeature, config, options);
    chris.addDamageDetailDamage(targetToken, sWorkflow.damageTotal, 'force', workflow);
    queue_queue.remove(workflow.item.uuid);
}
async function stasisStrike_end(origin) {
    await chris.setTurnCheck(origin, 'feat', 'stasisStrike', true);
}
let stasisStrike = {
    'damage': stasisStrike_damage,
    'damageMany': stasisStrike_damageMany,
    'end': stasisStrike_end
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/artificer/battleSmith/steelDefender.js


async function steelDefender_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let sourceActor = game.actors.getName('CPR - Steel Defender');
    if (!sourceActor) return;
    let deflectAttackData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Deflect Attack', false);
    if (!deflectAttackData) return;
    deflectAttackData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Deflect Attack');
    let forceEmpoweredRendData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Force-Empowered Rend', false);
    if (!forceEmpoweredRendData) return;
    forceEmpoweredRendData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Force-Empowered Rend');
    let mendingData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Mending (Steel Defender)', false);
    if (!mendingData) return;
    mendingData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Mending (Steel Defender)');
    mendingData.name = 'Mending';
    let repairData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Repair', false);
    if (!repairData) return;
    repairData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Repair');
    let vigilantData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Vigilant', false);
    if (!vigilantData) return;
    vigilantData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Vigilant');
    let dodgeData = await chris.getItemFromCompendium('chris-premades.CPR Actions', 'Dodge', false);
    if (!dodgeData) return;
    dodgeData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Dodge');
    let artificerLevel = workflow.actor.classes?.artificer?.system?.levels;
    if (!artificerLevel) return;
    let repairUsesValue = workflow.actor.flags['chris-premades']?.feature?.steelDefenderRepair;
    if (!repairUsesValue && artificerLevel > 2) actor.setFlag('chris-premades', 'feature.steelDefenderRepair', 3);
    repairData.system.uses.value = repairUsesValue;
    let arcaneJoltData = await chris.getItemFromCompendium('chris-premades.CPR Class Features', 'Arcane Jolt', false);
    if (!arcaneJoltData) return;
    let arcaneJoltItem = workflow.actor.items.getName('Arcane Jolt');
    if (arcaneJoltItem) arcaneJoltData.system.uses = arcaneJoltItem.system.uses;
    let hpValue = (2 + chris.getSpellMod(workflow.item)) + (artificerLevel * 5);
    let name = chris.getConfiguration(workflow.item, 'name') ?? 'Steel Defender';
    if (name === '') name = 'Steel Defender';
    let meleeAttackBonus = await new Roll(workflow.actor.system.bonuses.msak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let rangedAttackBonus = await new Roll(workflow.actor.system.bonuses.rsak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'details': {
                    'cr': tashaSummon.getCR(workflow.actor.system.attributes.prof)
                },
                'attributes': {
                    'hp': {
                        'formula': hpValue,
                        'max': hpValue,
                        'value': hpValue
                    }
                },
                'traits': {
                    'languages': workflow.actor.system?.traits?.languages
                }
            },
            'prototypeToken': {
                'name': name,
                'disposition': workflow.token.document.disposition
            },
            'flags': {
                'chris-premades': {
                    'summon': {
                        'attackBonus': {
                            'melee': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.str.mod + meleeAttackBonus.total,
                            'ranged': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.str.mod + rangedAttackBonus.total
                        }
                    }
                }
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition
        },
        'embedded': {
            'Item': {
                [deflectAttackData.name]: deflectAttackData,
                [forceEmpoweredRendData.name]: forceEmpoweredRendData,
                [mendingData.name]: mendingData,
                [repairData.name]: repairData,
                [vigilantData.name]: vigilantData,
                [dodgeData.name]: dodgeData
            }
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar');
    if (avatarImg) updates.actor.img = avatarImg;
    let tokenImg = chris.getConfiguration(workflow.item, 'token');
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    if (artificerLevel > 8) {
        if (artificerLevel > 14) {
            updates.actor.system.attributes.ac = {'flat': 17};
            updates.embedded.Item['Deflect Attack'].system.damage.parts[0][0] = '1d4[force] + ' + chris.getSpellMod(workflow.item)
        }
        updates.embedded.Item['Arcane Jolt'] = arcaneJoltData;
        sourceActor.setFlag('chris-premades', 'feature.arcaneJoltScale', workflow.actor.system?.scale?.['battle-smith']?.['arcane-jolt'].formula);;
    }
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? 'default';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    let spawnedToken = await tashaSummon.spawn(sourceActor, updates, 86400, workflow.item, 120, workflow.token, animation);
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Steel Defender - Command', false);
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Steel Defender - Command');
    if (!featureData) return;
    let updates2 = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Steel Defender',
        'description': featureData.name
    };
    await warpgate.mutate(workflow.token.document, updates2, {}, options);
    let effect = chris.findEffect(workflow.actor, 'Steel Defender');
    if (!effect) return;
    let currentScript = effect.flags.effectmacro?.onDelete?.script;
    if (!currentScript) return;
    let effectUpdates = {
        'flags': {
            'effectmacro': {
                'onDelete': { 
                    'script': currentScript + ' await warpgate.revert(token.document, "Steel Defender");'
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    if (artificerLevel > 8) setProperty(effectUpdates, 'flags.chris-premades.feature.steelDefender.spawnedTokenUuid', spawnedToken.uuid);
    await chris.updateEffect(effect, effectUpdates);

}
async function steelDefender_longRest(actor, data) {
    if (!data.longRest) return;
    if (actor.classes?.arificer?.system?.levels < 3) return;
    let item = actor.items.getName('Battle Smith');
    if (!item) return;
    if (item.type != 'subclass') return;
    actor.setFlag('chris-premades', 'feature.steelDefenderRepair', 3);
}
async function steelDefender_repair({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Summoned Creature');
    if (!effect) return;
    let origin = await fromUuid(effect.origin);
    if (!origin) return;
    origin.actor.setFlag('chris-premades', 'feature.steelDefenderRepair', workflow.item.system?.uses?.value);
}
let steelDefender = {
    'item': steelDefender_item,
    'longRest': steelDefender_longRest,
    'repair': steelDefender_repair,
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/stenchKow/stenchKow.js

let stenchKow = {
    'stench': stench
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/monk/stillnessOfMind.js

async function stillnessOfMind({speaker, actor, token, character, item, args, scope, workflow}) {
    let charmedEffect = chris.findEffect(workflow.actor, 'Charmed');
    let frightenedEffect = chris.findEffect(workflow.actor, 'Frightened');
    if (!charmedEffect && !frightenedEffect) return;
    if (charmedEffect && frightenedEffect) {
        let selection = await chris.dialog('What condition would you like to remove?', [['Charmed', 1], ['Frightened', 2]]);
        if (!selection) return;
        if (selection === 1) await chris.removeCondition(workflow.actor, 'Charmed');
        if (selection === 2) await chris.removeCondition(workflow.actor, 'Frightened');
        return;
    }
    if (charmedEffect) await chris.removeCondition(workflow.actor, 'Charmed');
    if (frightenedEffect) await chris.removeCondition(workflow.actor, 'Frightened');
}
;// CONCATENATED MODULE: ./scripts/macros/feats/strikeOfTheGiants/stoneStrike.js




async function stoneStrike_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (workflow.item.system.actionType != 'mwak') return;
    let originFeature = chris.getItem(workflow.actor, 'Strike of the Giants: Stone Strike');
    if (!originFeature) return;
    if (!originFeature.system.uses.value) return;
    let turnCheck = chris.perTurnCheck(originFeature, 'feat', 'stoneStrike', false, workflow.token.id);
    if (!turnCheck) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'stoneStrike', 150);
    if (!queueSetup) return;
    let selection = await chris.dialog(originFeature.name, [['Yes', true], ['No', false]], 'Use ' + originFeature.name + '?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await originFeature.update({'system.uses.value': originFeature.system.uses.value - 1});
    if (chris.inCombat()) await originFeature.setFlag('chris-premades', 'feat.stoneStrike.turn', game.combat.round + '-' + game.combat.turn);
    let damageFormula = workflow.damageRoll._formula;
    let bonusDamage = '1d6[' + translate.damageType('force') + ']';
    if (workflow.isCritical) bonusDamage = chris.getCriticalFormula(bonusDamage);
    let damageRoll = await new Roll(damageFormula + ' + ' + bonusDamage).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    let saveDC = Math.max(workflow.actor.system.abilities.con.dc, workflow.actor.system.abilities.str.dc);
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Feat Features', 'Strike of the Giants: Stone Strike', false);
    if (!featureData) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Strike of the Giants: Stone Strike');
    featureData.system.save.dc = saveDC;
    delete featureData._id;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    feature.prepareData();
    feature.prepareFinalAttributes();
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.hitTargets.first().document.uuid]);
    await warpgate.wait(100);
    let targetWorkflow = await MidiQOL.completeItemUse(feature, config, options);
    if (targetWorkflow.failedSaves.size === 0) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let selection2 = 10;
    let targetToken = targetWorkflow.failedSaves.first();
    let knockBackFactor;
    let ray;
    let newCenter;
    let hitsWall = true;
    while (hitsWall) {
        knockBackFactor = selection2 / canvas.dimensions.distance;
        ray = new Ray(workflow.token.center, targetToken.center);
        newCenter = ray.project(1 + ((canvas.dimensions.size * knockBackFactor) / ray.distance));
        hitsWall = targetToken.checkCollision(newCenter, {origin: ray.A, type: "move", mode: "any"});
        if (hitsWall) {
            selection2 -= 5;
            if (selectio2n === 0) {
                ui.notifications.info('Target is unable to be moved!');
                queue_queue.remove(workflow.item.uuid);
                return;
            }
        }
    }
    newCenter = canvas.grid.getSnappedPosition(newCenter.x - targetToken.w / 2, newCenter.y - targetToken.h / 2, 1);
    let targetUpdate = {
        'token': {
            'x': newCenter.x,
            'y': newCenter.y
        }
    };
    let options2 = {
        'permanent': true,
        'name': workflow.item.name,
        'description': workflow.item.name
    };
    await warpgate.mutate(targetToken.document, targetUpdate, {}, options2);
    queue_queue.remove(workflow.item.uuid);
}
async function stoneStrike_end(origin) {
    await origin.setFlag('chris-premades', 'feat.stoneStrike.turn', '');
}
let stoneStrike = {
    'damage': stoneStrike_damage,
    'end': stoneStrike_end
}
;// CONCATENATED MODULE: ./scripts/macros/spells/stormSphere.js



async function stormSphere_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.templateUuid) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Storm Sphere Bolt', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Storm Sphere Bolt');
    async function effectMacro () {
        await warpgate.revert(token.document, 'Storm Sphere Handler');
    }
    async function effectMacro2() {
        await chrisPremades.macros.stormSphere.turnStart(actor, effect);
    }
    let effectData = {
        'name': 'Storm Sphere Handler',
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                },
                'onEachTurn': {
                    'script':chris.functionToString(effectMacro2)
                }
            },
            'chris-premades': {
                'spell': {
                    'stormSphere': {
                        'templateUuid': workflow.templateUuid,
                        'castLevel': workflow.castData.castLevel,
                        'spellSaveDC': chris.getSpellDC(workflow.item)
                    }
                },
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': effectData.name,
        'description': featureData.name
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
async function boltItem({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    let effect = chris.findEffect(workflow.actor, 'Storm Sphere Handler');
    if (!effect) return;
    let castLevel = effect.flags['chris-premades']?.spell?.stormSphere?.castLevel;
    if (!castLevel) castLevel = 4;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Storm Sphere Bolt Attack', false);
    if (!featureData) return;
    featureData.system.damage.parts = [
        [
            castLevel + 'd6[lightning]',
            'lightning'
        ]
    ];
    featureData.flags['chris-premades'] = {
        'spell': {
            'castData': {
                'castLevel': castLevel,
                'school': 'evo'
            }
        }
    };
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    feature.prepareData();
    feature.prepareFinalAttributes();
    let options = {
        'showFullCard': false,
        'createWorkflow': true,
        'targetUuids': [targetToken.document.uuid],
        'configureDialog': false,
        'versatile': false,
        'consumeResource': false,
        'consumeSlot': false,
        'workflowOptions': {
            'autoRollDamage': 'always',
            'autoFastDamage': true
        }
    };
    let templateUuid = effect.flags['chris-premades']?.spell?.stormSphere?.templateUuid;
    if (!templateUuid) return;
    let template = await fromUuid(templateUuid);
    if (!template) return;
    let chatMessage = game.messages.get(workflow.itemCardId);
    if (chatMessage) await chatMessage.delete();
    let flag = workflow.actor.flags['midi-qol']?.ignoreNearbyFoes;
    if (!flag) workflow.actor.flags['midi-qol'].ignoreNearbyFoes = 1;
    let position = canvas.grid.getSnappedPosition(template.object.center.x, template.object.center.y);
    let savedX = workflow.token.document.x;
    let savedY = workflow.token.document.y;
    workflow.token.document.x = position.x;
    workflow.token.document.y = position.y;
    await MidiQOL.completeItemUse(feature, {}, options);
    workflow.token.document.x = savedX;
    workflow.token.document.y = savedY;
    if (!flag) workflow.actor.flags['midi-qol'].ignoreNearbyFoes = 0;
    new Sequence().effect().atLocation(template.object).stretchTo(targetToken).file('jb2a.chain_lightning.primary.blue').play();
}
async function boltAttackItem({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let effect = chris.findEffect(workflow.actor, 'Storm Sphere Handler');
    if (!effect) return;
    let templateUuid = effect.flags['chris-premades']?.spell?.stormSphere?.templateUuid;
    if (!templateUuid) return;
    let template = await fromUuid(templateUuid);
    if (!template) return;
    let targetToken = workflow.targets.first();
    if (!chris.tokenInTemplate(targetToken.document, template)) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'stormSphere', 50);
    if (!queueSetup) return;
    workflow.advantage = true;
    workflow.attackAdvAttribution.add('Advantage: Storm Sphere');
    queue_queue.remove(workflow.item.uuid);
}
async function stormSphere_turnStart(actor, effect) {
    let previousTurnId = game.combat.previous.tokenId;
    if (!previousTurnId) return;
    let templateUuid = effect.flags['chris-premades']?.spell?.stormSphere?.templateUuid;
    if (!templateUuid) return;
    let template = await fromUuid(templateUuid);
    if (!template) return;
    let targetToken = game.canvas.tokens.get(previousTurnId);
    if (!chris.tokenInTemplate(targetToken, template)) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Storm Sphere Turn', false);
    if (!featureData) return;
    let stormSphere = effect.flags['chris-premades']?.spell?.stormSphere;
    if (!stormSphere) return;
    featureData.system.save.dc = stormSphere.spellSaveDC;
    featureData.system.damage.parts = [
        [
            (stormSphere.castLevel - 2) + 'd6[bludgeoning]',
            'bludgeoning'
        ]
    ];
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.document.uuid]);
    await MidiQOL.completeItemUse(feature, config, options);
}
let stormSphere = {
    'item': stormSphere_item,
    'turnStart': stormSphere_turnStart,
    'boltItem': boltItem,
    'boltAttackItem': boltAttackItem
}
;// CONCATENATED MODULE: ./scripts/macros/feats/strikeOfTheGiants/stormStrike.js




async function stormStrike_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (workflow.item.system.actionType != 'mwak') return;
    let originFeature = chris.getItem(workflow.actor, 'Strike of the Giants: Storm Strike');
    if (!originFeature) return;
    if (!originFeature.system.uses.value) return;
    let turnCheck = chris.perTurnCheck(originFeature, 'feat', 'stormStrike', false, workflow.token.id);
    if (!turnCheck) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'stormStrike', 150);
    if (!queueSetup) return;
    let selection = await chris.dialog(originFeature.name, [['Yes', true], ['No', false]], 'Use ' + originFeature.name + '?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await originFeature.update({'system.uses.value': originFeature.system.uses.value - 1});
    if (chris.inCombat()) await originFeature.setFlag('chris-premades', 'feat.stormStrike.turn', game.combat.round + '-' + game.combat.turn);
    let damageFormula = workflow.damageRoll._formula;
    let bonusDamage = '1d6[' + translate.damageType('lightning') + ']';
    if (workflow.isCritical) bonusDamage = chris.getCriticalFormula(bonusDamage);
    let damageRoll = await new Roll(damageFormula + ' + ' + bonusDamage).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    let saveDC = Math.max(workflow.actor.system.abilities.con.dc, workflow.actor.system.abilities.str.dc);
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Feat Features', 'Strike of the Giants: Storm Strike', false);
    if (!featureData) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Strike of the Giants: Storm Strike');
    featureData.system.save.dc = saveDC;
    delete featureData._id;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    feature.prepareData();
    feature.prepareFinalAttributes();
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.hitTargets.first().document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature, config, options);
    queue_queue.remove(workflow.item.uuid);
}
async function stormStrike_end(origin) {
    await origin.setFlag('chris-premades', 'feat.stormStrike.turn', '');
}
let stormStrike = {
    'damage': stormStrike_damage,
    'end': stormStrike_end
}
;// CONCATENATED MODULE: ./scripts/macros/items/stormgirdle.js


async function stormAvatar({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || workflow.item.type != 'weapon') return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'stormAvatar', 340);
    if (!queueSetup) return;
    let damageFormula = workflow.damageRoll._formula.toLowerCase().replace('slashing', 'lightning').replace('piercing', 'lightning').replace('bludgeoning', 'thunder');
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function stormgirdle_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let level = workflow.actor.flags['chris-premades']?.item?.stormgirdle?.level;
    if (level === undefined) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Item Features', 'Storm Avatar Lightning', false);
    if (!featureData) return;
    let diceNumber = 3 + level;
    featureData.system.damage.parts = [
        [
            diceNumber + 'd6[lightning]',
            'lightning'
        ]
    ];
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Storm Avatar Lightning');
    async function effectMacro () {
        await warpgate.revert(token.document, 'Storm Avatar');
    }
    let changes = [
        {
            'key': 'system.traits.di.value',
            'mode': 0,
            'value': 'lightning',
            'priority': 20
        },
        {
            'key': 'system.traits.di.value',
            'mode': 0,
            'value': 'thunder',
            'priority': 20
        },
        {
            'key': 'flags.midi-qol.onUseMacroName',
            'mode': 0,
            'value': 'function.chrisPremades.macros.stormgirdle.stormAvatar,postDamageRoll',
            'priority': 20
        }
    ];
    if (level > 0) {
        changes.push({
            'key': 'system.attributes.movement.fly',
            'mode': 2,
            'value': 30,
            'priority': 20
        },
        {
            'key': 'system.attributes.movement.hover',
            'mode': 0,
            'value': 1,
            'priority': 20
        });
    }
    let effectData = {
        'name': 'Storm Avatar',
        'icon': 'icons/magic/lightning/fist-unarmed-strike-blue.webp',
        'changes': changes,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'autoanimations': {
                'label': 'Storm Avatar',
                'activeEffectType': 'ontoken',
                'menu': 'aefx',
                'macro': {
                    'enable': false,
                    'playWhen': '0'
                },
                'primary': {
                    'video': {
                        'dbSection': 'static',
                        'menuType': 'marker',
                        'animation': 'energystrand',
                        'variant': '01',
                        'color': 'blue',
                        'enableCustom': false,
                        'customPath': ''
                    },
                    'options': {
                        'addTokenWidth': false,
                        'anchor': '0.5',
                        'delay': 0,
                        'elevation': 1000,
                        'fadeIn': 250,
                        'fadeOut': 500,
                        'isMasked': false,
                        'isRadius': false,
                        'isWait': false,
                        'opacity': 1,
                        'persistent': true,
                        'playbackRate': 1,
                        'playOn': 'source',
                        'repeat': 1,
                        'repeatDelay': 250,
                        'size': 1,
                        'unbindAlpha': false,
                        'unbindVisibility': false,
                        'zIndex': 1
                    },
                    'sound': {
                        'enable': false,
                        'delay': 0,
                        'repeat': 1,
                        'repeatDelay': 250,
                        'startTime': 0,
                        'volume': 0.75
                    }
                },
                'secondary': {
                    'enable': false,
                    'video': {
                        'dbSection': 'static',
                        'menuType': 'spell',
                        'animation': 'curewounds',
                        'variant': '01',
                        'color': 'blue',
                        'enableCustom': false,
                        'customPath': ''
                    },
                    'sound': {
                        'enable': false,
                        'delay': 0,
                        'repeat': 1,
                        'repeatDelay': 250,
                        'startTime': 0,
                        'volume': 0.75
                    },
                    'options': {
                        'addTokenWidth': false,
                        'anchor': '0.5',
                        'delay': 0,
                        'elevation': 1000,
                        'fadeIn': 250,
                        'fadeOut': 500,
                        'isMasked': false,
                        'isRadius': true,
                        'isWait': false,
                        'opacity': 1,
                        'repeat': 1,
                        'repeatDelay': 250,
                        'size': 1.5,
                        'zIndex': 1
                    }
                },
                'soundOnly': {
                    'sound': {
                        'enable': false,
                        'delay': 0,
                        'repeat': 1,
                        'repeatDelay': 250,
                        'startTime': 0,
                        'volume': 0.75
                    }
                },
                'source': {
                    'enable': false,
                    'video': {
                        'dbSection': 'static',
                        'menuType': 'spell',
                        'animation': 'curewounds',
                        'variant': '01',
                        'color': 'blue',
                        'enableCustom': false,
                        'customPath': ''
                    },
                    'sound': {
                        'enable': false,
                        'delay': 0,
                        'repeat': 1,
                        'repeatDelay': 250,
                        'startTime': 0,
                        'volume': 0.75
                    },
                    'options': {
                        'addTokenWidth': false,
                        'anchor': '0.5',
                        'delay': 0,
                        'elevation': 1000,
                        'fadeIn': 250,
                        'fadeOut': 500,
                        'isMasked': false,
                        'isRadius': false,
                        'isWait': true,
                        'opacity': 1,
                        'repeat': 1,
                        'repeatDelay': 250,
                        'size': 1,
                        'zIndex': 1
                    }
                },
                'isEnabled': true,
                'isCustomized': true,
                'version': 5
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Storm Avatar',
        'description': featureData.name
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
async function stormgirdle_equip(actor, origin) {
    let spellData = await chris.getItemFromCompendium(game.settings.get('chris-premades', 'Spell Compendium'), 'Control Weather', false);
    if (!spellData) return;
    let charges = origin.flags['chris-premades']?.item?.stormgirdle?.charges;
    if (charges === undefined) charges = 1;
    spellData.system.uses.per = 'day';
    spellData.system.uses.max = 1;
    spellData.system.uses.value = charges;
    spellData.system.preparation.mode = 'atwill';
    spellData.system.preparation.prepared = true;
    await chris.addTempItem(actor, spellData, origin.id, 'Stormgirdle', false, 0);
}
async function stormgirdle_unequip(actor, origin) {
    let charges = 1;
    let tempItem = chris.getTempItem(actor, origin.id, 0);
    if (tempItem) charges = tempItem.system.uses.value;
    await origin.setFlag('chris-premades', 'item.stormgirdle.charges', charges);
    await chris.removeTempItems(actor, origin.id);
}
async function stormgirdle_deleted(actor, effect) {
    if (effect.disabled) return;
    let originArray = effect.origin.split('Item.');
    if (originArray.length != 2) return;
    let originID = originArray[1];
    await chris.removeTempItems(actor, originID);
}
let stormgirdle = {
    'item': stormgirdle_item,
    'stormAvatar': stormAvatar,
    'equip': stormgirdle_equip,
    'unequip': stormgirdle_unequip,
    'deleted': stormgirdle_deleted
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/sorcerer/shadowMagic/strengthOfTheGrave.js



async function strengthOfTheGrave(token, {item, workflow, ditem}) {
    if (ditem.newHP != 0 || ditem.oldHP === 0) return;
    let tokenActor = token.actor;
    let effect = chris.findEffect(tokenActor, 'Strength of the Grave');
    if (!effect) return;
    if (workflow.isCritical || chris.checkTrait(tokenActor, 'di', 'healing') || chris.totalDamageType(tokenActor, ditem.damageDetail[0], 'radiant') > 0 || chris.totalDamageType(tokenActor, ditem.damageDetail[0], 'none')) return;
    let originItem = await fromUuid(effect.origin);
    if (!originItem) return;
    if (originItem.system.uses.value === 0) return;
    let selection = await chris.dialog('Use Strength of the Grave?', [['Yes', true], ['No', false]]);
    if (!selection || selection === false) return;
    let queueSetup = await queue_queue.setup(workflow.uuid, 'strengthOfTheGrave', 389);
    if (!queueSetup) return;
    let featureData = duplicate(originItem.toObject());
    let damageDealt = ditem.appliedDamage;
    featureData.system.save.dc = damageDealt + featureData.system.save.dc;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': tokenActor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.document.uuid]);
    let featureWorkflow = await MidiQOL.completeItemUse(feature, config, options);
    await originItem.update({
        'system.uses.value': originItem.system.uses.value -1
    });
    if (featureWorkflow.failedSaves.size === 1) {
        queue_queue.remove(workflow.uuid);
        return;
    }
    ditem.newHP = 1;
    ditem.hpDamage = Math.abs(ditem.newHP - ditem.oldHP);
    queue_queue.remove(workflow.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/monk/stunningStrike.js



async function stunningStrike({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    if (workflow.item.system.actionType != 'mwak') return;
    let feature = chris.getItem(workflow.actor, 'Stunning Strike');
    if (!feature) return;
    let onHit = chris.getConfiguration(feature, 'onhit');
    if (!onHit) return;
    let ki = chris.getItem(workflow.actor, 'Ki Points');
    if (!ki) return;
    if (!ki.system.uses.value) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'stunningStrike', 450);
    if (!queueSetup) return;
    let selection = await chris.dialog(feature.name, constants_constants.yesNo, 'Use ' + feature.name + '?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    await warpgate.wait(100);
    let options = {
        'targetUuids': [workflow.targets.first().document.uuid]
    };
    await MidiQOL.completeItemUse(feature, {}, options);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/succubus/drainingKiss.js

async function drainingKiss({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetActor = workflow.targets.first().actor;
    let damage = -workflow.damageList[0].appliedDamage;
    if (damage === 0) return;
    let targetMaxHP = targetActor.system.attributes.hp.max;
    let effect = chris.findEffect(targetActor, workflow.item.name);
    if (!effect) {
        let effectData = {
            'label': workflow.item.name,
            'icon': workflow.item.img,
            'duration': {
                'seconds': 604800
            },
            'origin': workflow.item.uuid,
            'changes': [
                {
                    'key': 'system.attributes.hp.tempmax',
                    'mode': 2,
                    'value': Math.max(damage, -targetMaxHP),
                    'priority': 20
                }
            ],
            'flags': {
                'dae': {
                    'specialDuration': [
                        'longRest'
                    ]
                }
            }
        };
        await chris.createEffect(targetActor, effectData);
    } else {
        let oldDamage = parseInt(effect.changes[0].value);
        damage += oldDamage;
        let updates = {
            'changes': [
                {
                    'key': 'system.attributes.hp.tempmax',
                    'mode': 2,
                    'value': Math.max(damage, -targetMaxHP),
                    'priority': 20
                }
            ]
        };
        await chris.updateEffect(effect, updates);
    }
    if (Math.abs(damage) >= targetMaxHP) {
        let unconscious = chris.findEffect(targetActor, 'Unconscious');
        if (!unconscious) return;
        await chris.removeCondition(targetActor, 'Unconscious');
        await chris.addCondition(targetActor, 'Dead', true, null)
    }
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/succubus/succubus.js

let succubus = {
    'drainingKiss': drainingKiss
}
;// CONCATENATED MODULE: ./scripts/macros/spells/summonAberration.js


async function summonAberration({speaker, actor, token, character, item, args, scope, workflow}){
    let selection = await chris.dialog('What type?', [['Beholderkin', 'Beholderkin'], ['Slaad', 'Slaad'], ['Star Spawn', 'Star Spawn']]);
    if (!selection) return;
    let sourceActor = game.actors.getName('CPR - Aberrant Spirit');
    if (!sourceActor) return;
    let multiAttackFeatureData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Multiattack (Aberrant Spirit)', false);
    if (!multiAttackFeatureData) return;
    multiAttackFeatureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Multiattack (Aberrant Spirit)');
    let attacks = Math.floor(workflow.castData.castLevel / 2);
    multiAttackFeatureData.name = 'Multiattack (' + attacks + ' Attacks)';
    let hpFormula = 40 + ((workflow.castData.castLevel - 4) * 10);
    let name = chris.getConfiguration(workflow.item, 'name-' + selection) ?? 'Aberrant Spirit (' + selection + ')';
    if (name === '') name = 'Aberrant Spirit (' + selection + ')';
    let meleeAttackBonus = await new Roll(workflow.actor.system.bonuses.msak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let rangedAttackBonus = await new Roll(workflow.actor.system.bonuses.rsak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'details': {
                    'cr': tashaSummon.getCR(workflow.actor.system.attributes.prof)
                },
                'attributes': {
                    'ac': {
                        'flat': 11 + workflow.castData.castLevel
                    },
                    'hp': {
                        'formula': hpFormula,
                        'max': hpFormula,
                        'value': hpFormula
                    }
                }
            },
            'prototypeToken': {
                'name': name,
                'disposition': workflow.token.document.disposition
            },
            'flags': {
                'chris-premades': {
                    'summon': {
                        'attackBonus': {
                            'melee': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.int.mod + meleeAttackBonus.total,
                            'ranged': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.int.mod + rangedAttackBonus.total
                        }
                    }
                }
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition
        },
        'embedded': {
            'Item': {
                [multiAttackFeatureData.name]: multiAttackFeatureData
            }
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar-' + selection);
    let tokenImg = chris.getConfiguration(workflow.item, 'token-' + selection);
    if (avatarImg) updates.actor.img = avatarImg;
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    switch (selection) {
        case 'Beholderkin':
            let eyeRayData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Eye Ray (Beholderkin Only)', false);
            if (!eyeRayData) return;
            eyeRayData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Eye Ray (Beholderkin Only)');
            eyeRayData.system.damage.parts[0][0] += ' + ' + workflow.castData.castLevel;
            updates.embedded.Item[eyeRayData.name] = eyeRayData;
            updates.actor.system.attributes.movement = {
                'walk': 30,
                'fly': 30,
                'hover': true
            };
            break;
        case 'Slaad':
            let clawsData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Claws (Slaad Only)', false);
            if (!clawsData) return;
            clawsData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Claws (Slaad Only)');
            clawsData.system.damage.parts[0][0] += ' + ' + workflow.castData.castLevel;
            updates.embedded.Item[clawsData.name] = clawsData;
            let regenerationData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Regeneration (Slaad Only)', false);
            if (!regenerationData) return;
            regenerationData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Regeneration (Slaad Only)');
            updates.embedded.Item[regenerationData.name] = regenerationData;
            break;
        case 'Star Spawn':
            let slamData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Psychic Slam (Star Spawn Only)', false);
            if (!slamData) return;
            slamData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Psychic Slam (Star Spawn Only)');
            slamData.system.damage.parts[0][0] += ' + ' + workflow.castData.castLevel;
            updates.embedded.Item[slamData.name] = slamData;
            let auraData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Whispering Aura (Star Spawn Only)', false);
            if (!auraData) return;
            auraData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Whispering Aura (Star Spawn Only)');
            auraData.system.save.dc = chris.getSpellDC(workflow.item);
            updates.embedded.Item[auraData.name] = auraData;
            break;
    }
    let animation = chris.getConfiguration(workflow.item, 'animation-' + selection) ?? 'shadow';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await tashaSummon.spawn(sourceActor, updates, 3600, workflow.item, 90, workflow.token, animation);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/summonBeast.js


async function summonBeast({speaker, actor, token, character, item, args, scope, workflow}){
    let selection = await chris.dialog('What type?', [['Air', 'Air'], ['Land', 'Land'], ['Water', 'Water']]);
    if (!selection) return;
    let sourceActor = game.actors.getName('CPR - Bestial Spirit');
    if (!sourceActor) return;
    let multiAttackFeatureData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Multiattack (Bestial Spirit)', false);
    if (!multiAttackFeatureData) return;
    multiAttackFeatureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Multiattack (Bestial Spirit)');
    let attacks = Math.floor(workflow.castData.castLevel / 2);
    multiAttackFeatureData.name = 'Multiattack (' + attacks + ' Attacks)';
    let maulData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Maul (Bestial Spirit)', false);
    if (!maulData) return;
    maulData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Maul (Bestial Spirit)');
    maulData.system.damage.parts[0][0] += ' + ' + workflow.castData.castLevel;
    let hpFormula;
    let name = chris.getConfiguration(workflow.item, 'name-' + selection) ?? 'Bestial Spirit (' + selection + ')';
    if (name === '') name = 'Bestial Spirit (' + selection + ')';
    let meleeAttackBonus = await new Roll(workflow.actor.system.bonuses.msak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let rangedAttackBonus = await new Roll(workflow.actor.system.bonuses.rsak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'details': {
                    'cr': tashaSummon.getCR(workflow.actor.system.attributes.prof)
                },
                'attributes': {
                    'ac': {
                        'flat': 11 + workflow.castData.castLevel
                    }
                }
            },
            'prototypeToken': {
                'name': name,
                'disposition': workflow.token.document.disposition
            },
            'flags': {
                'chris-premades': {
                    'summon': {
                        'attackBonus': {
                            'melee': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.str.mod + meleeAttackBonus.total,
                            'ranged': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.str.mod + rangedAttackBonus.total
                        }
                    }
                }
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition
        },
        'embedded': {
            'Item': {
                [multiAttackFeatureData.name]: multiAttackFeatureData,
                [maulData.name]: maulData
            }
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar-' + selection);
    let tokenImg = chris.getConfiguration(workflow.item, 'token-' + selection);
    if (avatarImg) updates.actor.img = avatarImg;
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    switch (selection) {
        case 'Air':
            let flybyData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Flyby (Air Only)', false);
            if (!flybyData) return;
            flybyData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Flyby (Air Only)');
            updates.embedded.Item[flybyData.name] = flybyData;
            updates.actor.system.attributes.movement = {
                'walk': 30,
                'fly': 60
            };
            hpFormula = 20 + ((workflow.castData.castLevel - 2) * 5);
            updates.actor.system.attributes.hp = {
                'formula': hpFormula,
                'max': hpFormula,
                'value': hpFormula
            };
            break;
        case 'Land':
            let packTacticsData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Pack Tactics (Land and Water Only)', false);
            if (!packTacticsData) return;
            packTacticsData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Pack Tactics (Land and Water Only)');
            updates.embedded.Item[packTacticsData.name] = packTacticsData;
            updates.actor.system.attributes.movement = {
                'walk': 30,
                'climb': 30
            };
            hpFormula = 30 + ((workflow.castData.castLevel - 2) * 5);
            updates.actor.system.attributes.hp = {
                'formula': hpFormula,
                'max': hpFormula,
                'value': hpFormula
            };
            break;
        case 'Water':
            let packTacticsData2 = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Pack Tactics (Land and Water Only)', false);
            if (!packTacticsData2) return;
            packTacticsData2.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Pack Tactics (Land and Water Only)');
            updates.embedded.Item[packTacticsData2.name] = packTacticsData2;
            updates.actor.system.attributes.movement = {
                'walk': 30,
                'swim': 30
            };
            hpFormula = 30 + ((workflow.castData.castLevel - 2) * 5);
            updates.actor.system.attributes.hp = {
                'formula': hpFormula,
                'max': hpFormula,
                'value': hpFormula
            };
            break;
    }
    let defaultAnimations = {
        'Air': 'air',
        'Land': 'earth',
        'Water': 'water'
    };
    let animation = chris.getConfiguration(workflow.item, 'animation-' + selection) ?? defaultAnimations[selection];
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await tashaSummon.spawn(sourceActor, updates, 3600, workflow.item, 90, workflow.token, animation);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/summonCelestial.js


async function summonCelestial({speaker, actor, token, character, item, args, scope, workflow}){
    let selection = await chris.dialog('What type?', [['Avenger ', 'Avenger'], ['Defender', 'Defender']]);
    if (!selection) return;
    let sourceActor = game.actors.getName('CPR - Celestial Spirit');
    if (!sourceActor) return;
    let multiAttackFeatureData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Multiattack (Celestial Spirit)', false);
    if (!multiAttackFeatureData) return;
    multiAttackFeatureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Multiattack (Celestial Spirit)');
    let attacks = Math.floor(workflow.castData.castLevel / 2);
    multiAttackFeatureData.name = 'Multiattack (' + attacks + ' Attacks)';
    let healingTouchData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Healing Touch (Celestial Spirit)', false);
    if (!healingTouchData) return;
    healingTouchData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Healing Touch (Celestial Spirit)');
    healingTouchData.system.damage.parts[0][0] += ' + ' + workflow.castData.castLevel;
    let hpFormula = 40 + ((workflow.castData.castLevel - 5) * 10);
    let name = chris.getConfiguration(workflow.item, 'name-' + selection) ?? 'Celestial Spirit (' + selection + ')';
    if (name === '') name = 'Celestial Spirit (' + selection + ')';
    let meleeAttackBonus = await new Roll(workflow.actor.system.bonuses.msak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let rangedAttackBonus = await new Roll(workflow.actor.system.bonuses.rsak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'details': {
                    'cr': tashaSummon.getCR(workflow.actor.system.attributes.prof)
                },
                'attributes': {
                    'hp': {
                        'formula': hpFormula,
                        'max': hpFormula,
                        'value': hpFormula
                    }
                }
            },
            'prototypeToken': {
                'name': name,
                'disposition': workflow.token.document.disposition
            },
            'flags': {
                'chris-premades': {
                    'summon': {
                        'attackBonus': {
                            'melee': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.str.mod + meleeAttackBonus.total,
                            'ranged': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.wis.mod + rangedAttackBonus.total
                        }
                    }
                }
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition
        },
        'embedded': {
            'Item': {
                [multiAttackFeatureData.name]: multiAttackFeatureData,
                [healingTouchData.name]: healingTouchData
            }
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar-' + selection);
    let tokenImg = chris.getConfiguration(workflow.item, 'token-' + selection);
    if (avatarImg) updates.actor.img = avatarImg;
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    switch (selection) {
        case 'Avenger':
            let radiantBowData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Radiant Bow (Avenger Only)', false);
            if (!radiantBowData) return;
            radiantBowData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Radiant Bow (Avenger Only)');
            radiantBowData.system.damage.parts[0][0] += ' + ' + workflow.castData.castLevel;
            updates.embedded.Item[radiantBowData.name] = radiantBowData;
            updates.actor.system.attributes.ac = {
                'flat': 11 + workflow.castData.castLevel
            }
            break;
        case 'Defender':
            let radiantMaceData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Radiant Mace (Defender Only)', false);
            if (!radiantMaceData) return;
            radiantMaceData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Radiant Mace (Defender Only)');
            radiantMaceData.system.damage.parts[0][0] += ' + ' + workflow.castData.castLevel;
            updates.embedded.Item[radiantMaceData.name] = radiantMaceData;
            updates.actor.system.attributes.ac = {
                'flat': 11 + workflow.castData.castLevel + 2
            }
            break;
    }
    let animation = chris.getConfiguration(workflow.item, 'animation-' + selection) ?? 'celestial';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await tashaSummon.spawn(sourceActor, updates, 3600, workflow.item, 90, workflow.token, animation);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/summonConstruct.js


async function summonConstruct({speaker, actor, token, character, item, args, scope, workflow}){
    let selection = await chris.dialog('What type?', [['Clay ', 'Clay'], ['Metal', 'Metal'], ['Stone', 'Stone']]);
    if (!selection) return;
    let sourceActor = game.actors.getName('CPR - Construct Spirit');
    if (!sourceActor) return;
    let multiAttackFeatureData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Multiattack (Construct Spirit)', false);
    if (!multiAttackFeatureData) return;
    multiAttackFeatureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Multiattack (Construct Spirit)');
    let attacks = Math.floor(workflow.castData.castLevel / 2);
    multiAttackFeatureData.name = 'Multiattack (' + attacks + ' Attacks)';
    let slamData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Slam (Construct Spirit)', false);
    if (!slamData) return;
    slamData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Slam (Construct Spirit)');
    slamData.system.damage.parts[0][0] += ' + ' + workflow.castData.castLevel;
    let hpFormula = 40 + ((workflow.castData.castLevel - 4) * 15);
    let name = chris.getConfiguration(workflow.item, 'name-' + selection) ?? 'Construct Spirit (' + selection + ')';
    if (name === '') name = 'Construct Spirit (' + selection + ')';
    let meleeAttackBonus = await new Roll(workflow.actor.system.bonuses.msak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let rangedAttackBonus = await new Roll(workflow.actor.system.bonuses.rsak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'details': {
                    'cr': tashaSummon.getCR(workflow.actor.system.attributes.prof)
                },
                'attributes': {
                    'hp': {
                        'formula': hpFormula,
                        'max': hpFormula,
                        'value': hpFormula
                    },
                    'ac': {
                        'flat': 13 + workflow.castData.castLevel
                    }
                }
            },
            'prototypeToken': {
                'name': name,
                'disposition': workflow.token.document.disposition
            },
            'flags': {
                'chris-premades': {
                    'summon': {
                        'attackBonus': {
                            'melee': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.str.mod + meleeAttackBonus.total,
                            'ranged': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.str.mod + rangedAttackBonus.total
                        }
                    }
                }
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition
        },
        'embedded': {
            'Item': {
                [multiAttackFeatureData.name]: multiAttackFeatureData,
                [slamData.name]: slamData
            }
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar-' + selection);
    let tokenImg = chris.getConfiguration(workflow.item, 'token-' + selection);
    if (avatarImg) updates.actor.img = avatarImg;
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    switch (selection) {
        case 'Clay':
            let beserkLashingData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Berserk Lashing (Clay Only)', false);
            if (!beserkLashingData) return;
            beserkLashingData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Berserk Lashing (Clay Only)');
            updates.embedded.Item[beserkLashingData.name] = beserkLashingData;
            break;
        case 'Metal':
            let heatedBodyData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Heated Body (Metal Only)', false);
            if (!heatedBodyData) return;
            heatedBodyData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Heated Body (Metal Only)');
            updates.embedded.Item[heatedBodyData.name] = heatedBodyData;
            break;
        case 'Stone':
            let stoneLethargyData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Stone Lethargy (Stone Only)', false);
            if (!stoneLethargyData) return;
            stoneLethargyData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Stone Lethargy (Stone Only)');
            stoneLethargyData.system.save.dc = chris.getSpellDC(workflow.item);
            updates.embedded.Item[stoneLethargyData.name] = stoneLethargyData;
            break;
    }
    let animation = chris.getConfiguration(workflow.item, 'animation-' + selection) ?? 'earth';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await tashaSummon.spawn(sourceActor, updates, 3600, workflow.item, 90, workflow.token, animation);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/summonDraconicSpirit.js


async function summonDraconicSpirit({speaker, actor, token, character, item, args, scope, workflow}) {
    let selection = await chris.dialog('What dragon type?', [['Chromatic ', 'Chromatic'], ['Metallic', 'Metallic'], ['Gem', 'Gem']]);
    if (!selection) return;
    let sourceActor = game.actors.getName('CPR - Draconic Spirit');
    if (!sourceActor) return;
    let multiAttackFeatureData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Multiattack (Draconic Spirit)', false);
    if (!multiAttackFeatureData) return;
    multiAttackFeatureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Multiattack (Draconic Spirit)');
    let attacks = Math.floor(workflow.castData.castLevel / 2);
    multiAttackFeatureData.name = 'Multiattack (' + attacks + ' Attacks)';
    let rendData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Rend (Draconic Spirit)', false);
    if (!rendData) return;
    rendData.name = 'Rend';
    rendData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Rend (Draconic Spirit)');
    rendData.system.damage.parts[0][0] += ' + ' + workflow.castData.castLevel;
    let breathData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Breath Weapon', false);
    if (!breathData) return;
    breathData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Breath Weapon');
    breathData.system.save.dc = chris.getSpellDC(workflow.item);
    let hpFormula = 50 + ((workflow.castData.castLevel - 5) * 10);
    let name = chris.getConfiguration(workflow.item, 'name-' + selection) ?? 'Draconic Spirit (' + selection + ')';
    if (name === '') name = 'Draconic Spirit (' + selection + ')';
    let meleeAttackBonus = await new Roll(workflow.actor.system.bonuses.msak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let rangedAttackBonus = await new Roll(workflow.actor.system.bonuses.rsak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'details': {
                    'cr': tashaSummon.getCR(workflow.actor.system.attributes.prof)
                },
                'attributes': {
                    'hp': {
                        'formula': hpFormula,
                        'max': hpFormula,
                        'value': hpFormula
                    },
                    'ac': {
                        'flat': 14 + workflow.castData.castLevel
                    }
                }
            },
            'prototypeToken': {
                'name': name,
                'disposition': workflow.token.document.disposition
            },
            'flags': {
                'chris-premades': {
                    'summon': {
                        'attackBonus': {
                            'melee': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.str.mod + meleeAttackBonus.total,
                            'ranged': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.str.mod + rangedAttackBonus.total
                        }
                    },
                    'draconicSpirit': {
                        'type': selection
                    }
                }
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition
        },
        'embedded': {
            'Item': {
                [multiAttackFeatureData.name]: multiAttackFeatureData,
                [rendData.name]: rendData,
                [breathData.name]: breathData
            }
        }
    };
    switch (selection) {
        case 'Chromatic':
        case 'Metallic':
            updates.actor.system.traits = {
                'dr': {
                    'value': [
                        'acid',
                        'cold',
                        'fire',
                        'lightning',
                        'poison'
                    ]
                }
            }
        break;
        case 'Gem': {
            updates.actor.system.traits = {
                'dr': {
                    'value': [
                        'force',
                        'necrotic',
                        'psychic',
                        'radiant',
                        'thunder'
                    ]
                }
            }
        }
    }
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar-' + selection);
    let tokenImg = chris.getConfiguration(workflow.item, 'token-' + selection);
    if (avatarImg) updates.actor.img = avatarImg;
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    let animation = chris.getConfiguration(workflow.item, 'animation-' + selection) ?? 'fire';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await tashaSummon.spawn(sourceActor, updates, 3600, workflow.item, 60, workflow.token, animation);
    let options;
    switch (selection) {
        case 'Chromatic':
        case 'Metallic':
            options = [['Acid', 'acid'], ['Cold', 'cold'], ['Fire', 'fire'], ['Lightning', 'lightning'], ['Poison', 'poison']];
            break;
        case 'Gem':
            options = [['Force', 'force'], ['Necrotic', 'necrotic'], ['Psychic', 'psychic'], ['Radiant', 'radiant'], ['Thunder', 'thunder']];
            break;
    }
    let selection2 = await chris.dialog('Shared Resistances: What damage type?', options);
    if (!selection2) return;
    let effect = chris.findEffect(workflow.actor, workflow.item.name);
    if (!effect) return;
    let effectUpdates = {
        'changes': [
            {
                'key': 'system.traits.dr.value',
                'mode': 0,
                'priority': 20,
                'value': selection2
            }
        ]
    }
    await chris.updateEffect(effect, effectUpdates);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/ranger/drakeWarden/summonDrakeCompanion.js


async function summonDrakeCompanion_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let selection = await chris.dialog('What drake type?', [['Acid', 'acid'], ['Cold', 'cold'], ['Fire', 'fire'], ['Lightning','lightning'], ['Poison','poison']]);
    if (!selection) return;
    let sourceActor = game.actors.getName('CPR - Drake Companion');
    if (!sourceActor) return;
    let rangerLevel = workflow.actor.classes?.ranger?.system?.levels;
    if (!rangerLevel) return;
    let drakeUpgrades = Math.floor((rangerLevel + 1) / 8);
    let biteData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Bite (Drake Companion)', false);
    if (!biteData) return;
    biteData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Bite (Drake Companion)');
    let commandData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Drake Companion: Command', false);
    if (!commandData) return;
    commandData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Drake Companion: Command');
    let dodgeData = await chris.getItemFromCompendium('chris-premades.CPR Actions', 'Dodge', false);
    if (!dodgeData) return;
    dodgeData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Dodge');
    let essenceData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Draconic Essence', false);
    if (!essenceData) return;
    essenceData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Draconic Essence');
    let strikesData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Infused Strikes', false);
    if (!strikesData) return;
    strikesData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Infused Strikes');
    strikesData.system.damage.parts[0][0] += '[' + selection + ']';
    strikesData.system.damage.parts[0][1] = selection;
    let resistanceData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Reflexive Resistance', false);
    if (!resistanceData) return;
    let resistanceMacro = resistanceData.flags['midi-qol'].onUseMacroName;
    resistanceData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Reflexive Resistance');
    let resistanceUsesValue = workflow.actor.flags['chris-premades']?.feature?.reflexiveResistance;
    if (!resistanceUsesValue && drakeUpgrades == 2) {
        resistanceUsesValue = workflow.actor.system.attributes.prof
        workflow.actor.setFlag('chris-premades', 'feature.reflexiveResistance', resistanceUsesValue);
    }
    resistanceData.system.uses.value = resistanceUsesValue;
    resistanceData.system.uses.max = workflow.actor.system.attributes.prof;
    let heighWidth = 1;
    let scale = '0.8';
    switch (drakeUpgrades) {
        case 1: 
            biteData.system.damage.parts[1][0] = '1d6[' + selection + ']';
            biteData.system.damage.parts[1][1] = selection;
            scale = '1';
        break;
        case 2:
            biteData.system.damage.parts[1][0] = '2d6[' + selection + ']';
            biteData.system.damage.parts[1][1] = selection;
            scale = '1';
            heighWidth = 2;
    }
    let hpFormula = 5 + (rangerLevel * 5);
    let name = chris.getConfiguration(workflow.item, 'name-' + selection) ?? 'Drake Companion (' + selection + ')';
    if (name === '') name = 'Drake Companion (' + selection + ')';
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'details': {
                    'cr': tashaSummon.getCR(workflow.actor.system.attributes.prof)
                },
                'attributes': {
                    'hp': {
                        'formula': hpFormula,
                        'max': hpFormula,
                        'value': hpFormula
                    },
                    'ac': {
                        'flat': 14 + workflow.actor.system.attributes.prof
                    }
                },
                'traits': {
                    'di': {
                        'value': selection
                    }
                }
            },
            'prototypeToken': {
                'name': name,
                'disposition': workflow.token.document.disposition
            },
            'flags': {
                'chris-premades': {
                    'drakeCompanion': {
                        'type': selection
                    }
                }
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition,
            'height': heighWidth,
            'width': heighWidth,
            'texture': {
                'scaleX': scale,
                'scaleY': scale
            }
        },
        'embedded': {
            'Item': {
                [biteData.name]: biteData,
                [dodgeData.name]: dodgeData,
                [essenceData.name]: essenceData,
                [strikesData.name]: strikesData
            }
        }
    }
    switch (drakeUpgrades) {
        case 1:
            setProperty(updates, 'actor.system.attributes.movement.fly', '40');
            setProperty(updates, 'actor.system.traits.size', 'med');
        break;
        case 2:
            setProperty(updates, 'actor.system.attributes.movement.fly', '40');
            setProperty(updates, 'actor.system.traits.size', 'lg');
            setProperty(resistanceData, 'flags.midi-qol.onUseMacroName', (resistanceMacro + 'Summon'));
            setProperty(updates, 'embedded.Item.Reflexive Resistance', resistanceData);
    }
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar-' + selection);
    let tokenImg = chris.getConfiguration(workflow.item, 'token-' + selection);
    if (avatarImg) updates.actor.img = avatarImg;
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    let animation = chris.getConfiguration(workflow.item, 'animation-' + selection) ?? 'default';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    let spawnedToken = await tashaSummon.spawn(sourceActor, updates, 86400, workflow.item, 30, workflow.token, animation);
    let effect = chris.findEffect(workflow.actor, workflow.item.name);
    if (!effect) return;
    if (drakeUpgrades > 0 ) {
        let effectUpdates = {
            'changes': [
                {
                    'key': 'system.traits.dr.value',
                    'mode': 0,
                    'priority': 20,
                    'value': selection
                }
            ]
        };
        await chris.updateEffect(effect, effectUpdates);
    }
    let updates2 = {
        'embedded': {
            'Item': {
                [commandData.name]: commandData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Drake Companion',
        'description': commandData.name
    };
    if (drakeUpgrades === 2) {
        setProperty(resistanceData, 'flags.midi-qol.onUseMacroName', (resistanceMacro + 'Actor'));
        setProperty(resistanceData, 'flags.chris-premades.feature.spawnedTokenUuid', spawnedToken.uuid);
        setProperty(updates2, 'embedded.Item.Reflexive Resistance', resistanceData);
    }
    await warpgate.mutate(workflow.token.document, updates2, {}, options);
    let currentScript = effect.flags.effectmacro?.onDelete?.script;
    if (!currentScript) return;
    let effectUpdates = {
        'flags': {
            'effectmacro': {
                'onDelete': { 
                    'script': currentScript + ' await warpgate.revert(token.document, "Drake Companion");'
                }
            },
            'chris-premades': {
                'vae': {
                    'button': resistanceData.name
                }
            }
        }
    };
    await chris.updateEffect(effect, effectUpdates); 
}
async function summonDrakeCompanion_longRest(actor, data) {
    if (!data.longRest) return;
    if (actor.classes?.ranger?.system?.levels < 15) return;
    let item = actor.items.getName('Drakewarden');
    if (!item) return;
    if (item.type != 'subclass') return;
    actor.setFlag('chris-premades', 'feature.reflexiveResistance', actor.system.attributes.prof);
}
async function onSummon({speaker, actor, token, character, item, args, scope, workflow}) {
    let reactionEffect = chris.findEffect(workflow.actor, 'Reaction');
    if (reactionEffect) await chris.removeEffect(reactionEffect);
    let effect = chris.findEffect(workflow.actor, 'Summoned Creature');
    if (!effect) return;
    let origin = await fromUuid(effect.origin);
    if (!origin) return;
    origin.actor.setFlag('chris-premades', 'feature.reflexiveResistance', workflow.item.system?.uses?.value)
    await chris.addCondition(origin.actor, 'Reaction');
    let itemToUpdate = origin.actor.items.getName('Reflexive Resistance');
    if (!itemToUpdate) return;
    await itemToUpdate.update({'system.uses.value': workflow.item.system?.uses?.value});
}
async function onActor({speaker, actor, token, character, item, args, scope, workflow}) {
    workflow.actor.setFlag('chris-premades', 'feature.reflexiveResistance', workflow.item.system?.uses?.value)
    await chris.addCondition(workflow.actor, 'Reaction');
    let spawnedToken = await fromUuid(item.flags['chris-premades']?.feature?.spawnedTokenUuid);
    if (!spawnedToken) return;
    let itemToUpdate = spawnedToken.actor.items.getName('Reflexive Resistance');
    if (!itemToUpdate) return;
    await itemToUpdate.update({'system.uses.value': workflow.item.system?.uses?.value});
}
let summonDrakeCompanion = {
    'item': summonDrakeCompanion_item,
    'longRest': summonDrakeCompanion_longRest,
    'onSummon': onSummon,
    'onActor': onActor,
}
;// CONCATENATED MODULE: ./scripts/macros/spells/summonElemental.js


async function summonElemental({speaker, actor, token, character, item, args, scope, workflow}){
    let selection = await chris.dialog('What type?', [['Air', 'Air'], ['Earth', 'Earth'], ['Fire', 'Fire'], ['Water', 'Water']]);
    if (!selection) return;
    let sourceActor = game.actors.getName('CPR - Elemental Spirit');
    if (!sourceActor) return;
    let multiAttackFeatureData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Multiattack (Elemental Spirit)', false);
    if (!multiAttackFeatureData) return;
    multiAttackFeatureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Multiattack (Elemental Spirit)');
    let attacks = Math.floor(workflow.castData.castLevel / 2);
    multiAttackFeatureData.name = 'Multiattack (' + attacks + ' Attacks)';
    let slamData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Slam (Elemental Spirit)', false);
    if (!slamData) return;
    slamData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Slam (Elemental Spirit)');
    slamData.system.damage.parts[0][0] += ' + ' + workflow.castData.castLevel;
    let hpFormula = 50 + ((workflow.castData.castLevel - 4) * 10);
    let name = chris.getConfiguration(workflow.item, 'name-' + selection) ?? 'Elemental Spirit (' + selection + ')';
    if (name === '') name = 'Elemental Spirit (' + selection + ')';
    let meleeAttackBonus = await new Roll(workflow.actor.system.bonuses.msak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let rangedAttackBonus = await new Roll(workflow.actor.system.bonuses.rsak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'details': {
                    'cr': tashaSummon.getCR(workflow.actor.system.attributes.prof)
                },
                'attributes': {
                    'hp': {
                        'formula': hpFormula,
                        'max': hpFormula,
                        'value': hpFormula
                    },
                    'ac': {
                        'flat': 11 + workflow.castData.castLevel
                    }
                }
            },
            'prototypeToken': {
                'name': name,
                'disposition': workflow.token.document.disposition
            },
            'flags': {
                'chris-premades': {
                    'summon': {
                        'attackBonus': {
                            'melee': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.str.mod + meleeAttackBonus.total,
                            'ranged': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.str.mod + rangedAttackBonus.total
                        }
                    }
                }
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition
        },
        'embedded': {
            'Item': {
                [multiAttackFeatureData.name]: multiAttackFeatureData,
                [slamData.name]: slamData
            }
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar-' + selection);
    let tokenImg = chris.getConfiguration(workflow.item, 'token-' + selection);
    if (avatarImg) updates.actor.img = avatarImg;
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    switch (selection) {
        case 'Air':
            let amorphousFormData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Amorphous Form (Air, Fire, and Water Only)', false);
            if (!amorphousFormData) return;
            amorphousFormData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Amorphous Form (Air, Fire, and Water Only)');
            updates.embedded.Item[amorphousFormData.name] = amorphousFormData;
            updates.actor.system.attributes.movement = {
                'walk': 40,
                'fly': 40,
                'hover': true
            };
            setProperty(updates, 'actor.system.traits.dr.value', ['lightning', 'thunder']);
            break;
        case 'Earth':
            updates.actor.system.attributes.movement = {
                'walk': 40,
                'burrow': 40
            };
            setProperty(updates, 'actor.system.traits.dr.value', ['slashing', 'piercing']);
            break;
        case 'Fire':
            let amorphousFormData2 = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Amorphous Form (Air, Fire, and Water Only)', false);
            if (!amorphousFormData2) return;
            amorphousFormData2.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Amorphous Form (Air, Fire, and Water Only)');
            updates.embedded.Item[amorphousFormData2.name] = amorphousFormData2;
            setProperty(updates, 'actor.system.traits.di.value', ['fire', 'poison']);
            let damageString = updates.embedded.Item[slamData.name].system.damage.parts[0][0];
            updates.embedded.Item[slamData.name].system.damage.parts[0][0] = damageString.replace('bludgeoning', 'fire');
            updates.embedded.Item[slamData.name].system.damage.parts[0][1] = 'fire';
            break;
        case 'Water':
            let amorphousFormData3 = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Amorphous Form (Air, Fire, and Water Only)', false);
            if (!amorphousFormData3) return;
            amorphousFormData3.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Amorphous Form (Air, Fire, and Water Only)');
            updates.embedded.Item[amorphousFormData3.name] = amorphousFormData3;
            updates.actor.system.attributes.movement = {
                'walk': 40,
                'swim': 40
            };
            setProperty(updates, 'actor.system.traits.dr.value', ['acid']);
            break;
    }
    let defaultAnimations = {
        'Air': 'air',
        'Earth': 'earth',
        'Fire': 'fire',
        'Water': 'water'
    };
    let animation = chris.getConfiguration(workflow.item, 'animation-' + selection) ?? defaultAnimations[selection];
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await tashaSummon.spawn(sourceActor, updates, 3600, workflow.item, 90, workflow.token, animation);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/summonFey.js


async function summonFey({speaker, actor, token, character, item, args, scope, workflow}){
    let selection = await chris.dialog('What type?', [['Fuming', 'Fuming'], ['Mirthful', 'Mirthful'], ['Tricksy', 'Tricksy']]);
    if (!selection) return;
    let sourceActor = game.actors.getName('CPR - Fey Spirit');
    if (!sourceActor) return;
    let multiAttackFeatureData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Multiattack (Fey Spirit)', false);
    if (!multiAttackFeatureData) return;
    multiAttackFeatureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Multiattack (Fey Spirit)');
    let attacks = Math.floor(workflow.castData.castLevel / 2);
    multiAttackFeatureData.name = 'Multiattack (' + attacks + ' Attacks)';
    let feyStepData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Fey Step (Fey Spirit)', false);
    if (!feyStepData) return;
    feyStepData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Fey Step (Fey Spirit)');
    feyStepData.name = 'Fey Step';
    let shortSwordData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Shortsword (Fey Spirit)', false);
    if (!shortSwordData) return;
    shortSwordData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Shortsword (Fey Spirit)');
    shortSwordData.system.damage.parts[0][0] += ' + ' + workflow.castData.castLevel;
    shortSwordData.name = 'Shortsword';
    let hpFormula = 30 + ((workflow.castData.castLevel - 3) * 10);
    let name = chris.getConfiguration(workflow.item, 'name-' + selection) ?? 'Fey Spirit (' + selection + ')';
    if (name === '') name = 'Fey Spirit (' + selection + ')';
    let meleeAttackBonus = await new Roll(workflow.actor.system.bonuses.msak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let rangedAttackBonus = await new Roll(workflow.actor.system.bonuses.rsak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'details': {
                    'cr': tashaSummon.getCR(workflow.actor.system.attributes.prof)
                },
                'attributes': {
                    'hp': {
                        'formula': hpFormula,
                        'max': hpFormula,
                        'value': hpFormula
                    },
                    'ac': {
                        'flat': 12 + workflow.castData.castLevel
                    }
                }
            },
            'prototypeToken': {
                'name': name,
                'disposition': workflow.token.document.disposition
            },
            'flags': {
                'chris-premades': {
                    'summon': {
                        'attackBonus': {
                            'melee': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.dex.mod + meleeAttackBonus.total,
                            'ranged': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.dex.mod + rangedAttackBonus.total
                        }
                    }
                }
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition
        },
        'embedded': {
            'Item': {
                [multiAttackFeatureData.name]: multiAttackFeatureData,
                [feyStepData.name]: feyStepData,
                [shortSwordData.name]: shortSwordData
            }
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar-' + selection);
    let tokenImg = chris.getConfiguration(workflow.item, 'token-' + selection);
    if (avatarImg) updates.actor.img = avatarImg;
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    switch (selection) {
        case 'Fuming':
            let fumingData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Fuming', false);
            if (!fumingData) return;
            fumingData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Fuming');
            updates.embedded.Item[fumingData.name] = fumingData;
            updates.embedded.Item[feyStepData.name].flags['midi-qol'] = {
                'effectActivation': false,
                'onUseMacroName': '[postActiveEffects]function.chrisPremades.macros.monster.feySpirit.fuming',
                'onUseMacroParts': {
                    'items': [
                        {
                            'macroName': 'function.chrisPremades.macros.monster.feySpirit.fuming',
                            'option': 'postActiveEffects'
                        }
                    ]
                }
            };
            break;
        case 'Mirthful':
            let mirthfulData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Mirthful', false);
            if (!mirthfulData) return;
            mirthfulData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Mirthful');
            mirthfulData.system.save.dc = chris.getSpellDC(workflow.item);
            updates.embedded.Item[mirthfulData.name] = mirthfulData;
            break;
        case 'Tricksy':
            let tricksyData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Tricksy', false);
            if (!tricksyData) return;
            tricksyData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Tricksy');
            updates.embedded.Item[tricksyData.name] = tricksyData;
            break;
    }
    let animation = chris.getConfiguration(workflow.item, 'animation-' + selection) ?? 'nature';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await tashaSummon.spawn(sourceActor, updates, 3600, workflow.item, 90, workflow.token, animation);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/summonFiend.js


async function summonFiend({speaker, actor, token, character, item, args, scope, workflow}){
    let selection = await chris.dialog('What type?', [['Demon', 'Demon'], ['Devil', 'Devil'], ['Yugoloth', 'Yugoloth']]);
    if (!selection) return;
    let sourceActor = game.actors.getName('CPR - Fiendish Spirit');
    if (!sourceActor) return;
    let multiAttackFeatureData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Multiattack (Fiendish Spirit)', false);
    if (!multiAttackFeatureData) return;
    multiAttackFeatureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Multiattack (Fiendish Spirit)');
    let attacks = Math.floor(workflow.castData.castLevel / 2);
    multiAttackFeatureData.name = 'Multiattack (' + attacks + ' Attacks)';
    let magicReistanceData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Magic Resistance (Fiendish Spirit)', false);
    if (!magicReistanceData) return;
    magicReistanceData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Magic Resistance (Fiendish Spirit)');
    magicReistanceData.name = 'Magic Resistance';
    let hpFormula;
    let name = chris.getConfiguration(workflow.item, 'name-' + selection) ?? 'Fiendish Spirit (' + selection + ')';
    if (name === '') name = 'Fiend Spirit (' + selection + ')';
    let meleeAttackBonus = await new Roll(workflow.actor.system.bonuses.msak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let rangedAttackBonus = await new Roll(workflow.actor.system.bonuses.rsak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'details': {
                    'cr': tashaSummon.getCR(workflow.actor.system.attributes.prof)
                },
                'attributes': {
                    'ac': {
                        'flat': 12 + workflow.castData.castLevel
                    }
                }
            },
            'prototypeToken': {
                'name': name,
                'disposition': workflow.token.document.disposition
            },
            'flags': {
                'chris-premades': {
                    'summon': {
                        'attackBonus': {
                            'melee': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.dex.mod + meleeAttackBonus.total,
                            'ranged': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.dex.mod + rangedAttackBonus.total
                        }
                    }
                }
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition
        },
        'embedded': {
            'Item': {
                [multiAttackFeatureData.name]: multiAttackFeatureData,
                [magicReistanceData.name]: magicReistanceData
            }
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar-' + selection);
    let tokenImg = chris.getConfiguration(workflow.item, 'token-' + selection);
    if (avatarImg) updates.actor.img = avatarImg;
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    switch (selection) {
        case 'Demon':
            hpFormula = 50 + ((workflow.castData.castLevel - 6) * 15);
            updates.actor.system.attributes.hp = {
                'formula': hpFormula,
                'max': hpFormula,
                'value': hpFormula
            };
            updates.actor.system.attributes.movement = {
                'walk': 40,
                'climb': 40
            };
            let deathThroesData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Death Throes (Demon Only)', false);
            if (!deathThroesData) return;
            deathThroesData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Death Throes (Demon Only)');
            deathThroesData.system.save.dc = chris.getSpellDC(workflow.item);
            updates.embedded.Item[deathThroesData.name] = deathThroesData;
            let biteData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Bite (Demon Only)', false);
            if (!biteData) return;
            biteData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Bite (Demon Only)');
            biteData.system.damage.parts[0][0] += ' + ' + workflow.castData.castLevel;
            updates.embedded.Item[biteData.name] = biteData;
            break;
        case 'Devil':
            hpFormula = 40 + ((workflow.castData.castLevel - 6) * 15);
            updates.actor.system.attributes.hp = {
                'formula': hpFormula,
                'max': hpFormula,
                'value': hpFormula
            };
            updates.actor.system.attributes.movement = {
                'walk': 40,
                'fly': 60
            };
            let hurlFlameData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Hurl Flame (Devil Only)', false);
            if (!hurlFlameData) return;
            hurlFlameData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Hurl Flame (Devil Only)');
            hurlFlameData.system.damage.parts[0][0] += ' + ' + workflow.castData.castLevel;
            updates.embedded.Item[hurlFlameData.name] = hurlFlameData;
            let devilsSightData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Devil\'s Sight (Devil Only)', false);
            if (!devilsSightData) return;
            devilsSightData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Devil\'s Sight (Devil Only)');
            updates.embedded.Item[devilsSightData.name] = devilsSightData;
            break;
        case 'Yugoloth':
            hpFormula = 60 + ((workflow.castData.castLevel - 6) * 15);
            updates.actor.system.attributes.hp = {
                'formula': hpFormula,
                'max': hpFormula,
                'value': hpFormula
            };
            let clawsData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Claws (Yugoloth Only)', false);
            if (!clawsData) return;
            clawsData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Claws (Yugoloth Only)');
            clawsData.system.damage.parts[0][0] += ' + ' + workflow.castData.castLevel;
            updates.embedded.Item[clawsData.name] = clawsData;
            break;
    }
    let animation = chris.getConfiguration(workflow.item, 'animation-' + selection) ?? 'fire';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await tashaSummon.spawn(sourceActor, updates, 3600, workflow.item, 90, workflow.token, animation);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/summonLesserDemons.js


async function summonLesserDemons({speaker, actor, token, character, item, args, scope, workflow}){
    let spellLevel = workflow.castData?.castLevel;
    if (!spellLevel) return;
    let summonsMultiplier = spellLevel > 7 ? 3 : spellLevel > 5 ? 2 : 1;
    let roll = await new Roll('1d6').roll({async: true});
    let flavor;
    let cr;
    switch (roll.total) {
        case 1:
        case 2:
            flavor = (summonsMultiplier * 2) + ' demons of challenge rating 1 or lower';
            cr = 1;
            break;
        case 3:
        case 4:
            flavor = (summonsMultiplier * 4) + ' demons of challenge rating 1/2 or lower';
            cr = 0.5;
            break;
        case 5:
        case 6:
            flavor = (summonsMultiplier * 8) + ' demons of challenge rating 1/4 or lower';
            cr = 0.25;
    }
    roll.toMessage({
        rollMode: 'roll',
        speaker: {alias: name},
        flavor: flavor
    });
    let folder = chris.getConfiguration(workflow.item, 'folder') ?? game.settings.get('chris-premades', 'Summons Folder');
    if (!folder && folder === '') folder = 'Chris Premades';
    let actors = game.actors.filter(i => i.folder?.name === folder).filter(i => i.system?.details?.type?.subtype.toLowerCase() === 'demon').filter(i => i.system?.details?.cr <= cr);
    if (actors.length < 1) {
        ui.notifications.warn('No matching actors found in specified folder!');
        return;
    }
    let userId = game.settings.get('chris-premades', 'LastGM');
    if (game.settings.get('chris-premades', 'Player Chooses Conjures')) userId = game.userId;
    if (!userId) return;
    let sourceActors = await chris.remoteDocumentsDialog(userId, 'Select Summons (Max ' + (summonsMultiplier * 2 / cr) + ')', actors);
    if (!sourceActors) return;
    if (sourceActors.length > (summonsMultiplier * 2 / cr)) {
        ui.notifications.info('Too many selected, try again!');
        return;
    }
    let updates = {
        'token': {
            'disposition': -1 
        }
    };
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? 'fire';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await summons.spawn(sourceActors, updates, 3600, workflow.item, false, true, 60, workflow.token, animation);
    let templateData = {
        t: CONST.MEASURED_TEMPLATE_TYPES.CIRCLE,
        distance: 2.5 * workflow.actor.prototypeToken.width,
        x: workflow.token.center.x,
        y: workflow.token.center.y,
        borderColor: '#941010'
    };
    let template = await chris.createTemplate(templateData);
    new Sequence()
        .effect()
            .atLocation(template[0])
            .origin(template[0].uuid)
            .file('jb2a.extras.tmfx.runes.circle.simple.conjuration')
            .scale(0.2 * workflow.actor.prototypeToken.width)
            .tint('#941010')
            .persist(true)
            .belowTokens(true)
            .tieToDocuments(template[0])
        .effect()
            .atLocation(template[0])
            .origin(template[0].uuid)
            .file('jb2a.extras.tmfx.border.circle.simple.01')
            .scale(0.2 * workflow.actor.prototypeToken.width)
            .tint('#941010')
            .persist(true)
            .tieToDocuments(template[0])
        .play();
    let effect = chris.findEffect(workflow.actor, workflow.item.name);
    if (!effect) return;
    let currentScript = effect.flags.effectmacro?.onDelete?.script;
    if (!currentScript) return;
    let newScript = '; let template = await fromUuid(effect.flags[\'chris-premades\']?.spell?.summonLesserDemons); if (!template) return; await template.delete();'
    let effectUpdates = {
        'flags': {
            'effectmacro': {
                'onDelete': { 
                    'script': currentScript + newScript
                }
            },
            'chris-premades': {
                'spell': {
                    'summonLesserDemons': template[0].uuid
                }
            }
        }
    };
    await chris.updateEffect(effect, effectUpdates);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/summonShadowspawn.js


async function summonShadowspawn({speaker, actor, token, character, item, args, scope, workflow}){
    let selection = await chris.dialog('What type?', [['Fury', 'Fury'], ['Despair', 'Despair'], ['Fear', 'Fear']]);
    if (!selection) return;
    let sourceActor = game.actors.getName('CPR - Shadow Spirit');
    if (!sourceActor) return;
    let multiAttackFeatureData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Multiattack (Shadow Spirit)', false);
    if (!multiAttackFeatureData) return;
    multiAttackFeatureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Multiattack (Shadow Spirit)');
    let attacks = Math.floor(workflow.castData.castLevel / 2);
    multiAttackFeatureData.name = 'Multiattack (' + attacks + ' Attacks)';
    let chillingRendData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Chilling Rend', false);
    if (!chillingRendData) return;
    chillingRendData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Chilling Rend');
    chillingRendData.system.damage.parts[0][0] += ' + ' + workflow.castData.castLevel;
    let dreadfulScreamData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Dreadful Scream', false);
    if (!dreadfulScreamData) return;
    dreadfulScreamData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Dreadful Scream');
    dreadfulScreamData.system.save.dc = chris.getSpellDC(workflow.item);
    let hpFormula = 35 + ((workflow.castData.castLevel - 3) * 15);
    let name = chris.getConfiguration(workflow.item, 'name-' + selection) ?? 'Shadow Spirit (' + selection + ')';
    if (name === '') name = 'Shadow Spirit (' + selection + ')';
    let meleeAttackBonus = await new Roll(workflow.actor.system.bonuses.msak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let rangedAttackBonus = await new Roll(workflow.actor.system.bonuses.rsak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'details': {
                    'cr': tashaSummon.getCR(workflow.actor.system.attributes.prof)
                },
                'attributes': {
                    'hp': {
                        'formula': hpFormula,
                        'max': hpFormula,
                        'value': hpFormula
                    },
                    'ac': {
                        'flat': 11 + workflow.castData.castLevel
                    }
                }
            },
            'prototypeToken': {
                'name': name,
                'disposition': workflow.token.document.disposition
            },
            'flags': {
                'chris-premades': {
                    'summon': {
                        'attackBonus': {
                            'melee': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.dex.mod + meleeAttackBonus.total,
                            'ranged': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.dex.mod + rangedAttackBonus.total
                        }
                    }
                }
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition
        },
        'embedded': {
            'Item': {
                [multiAttackFeatureData.name]: multiAttackFeatureData,
                [chillingRendData.name]: chillingRendData,
                [dreadfulScreamData.name]: dreadfulScreamData
            }
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar-' + selection);
    let tokenImg = chris.getConfiguration(workflow.item, 'token-' + selection);
    if (avatarImg) updates.actor.img = avatarImg;
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    switch (selection) {
        case 'Fury':
            let terrorFrenzyData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Terror Frenzy (Fury Only)', false);
            if (!terrorFrenzyData) return;
            terrorFrenzyData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Terror Frenzy (Fury Only)');
            updates.embedded.Item[terrorFrenzyData.name] = terrorFrenzyData;
            break;
        case 'Despair':
            let weightOfSorrowData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Weight of Sorrow (Despair Only)', false);
            if (!weightOfSorrowData) return;
            weightOfSorrowData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Weight of Sorrow (Despair Only)');
            updates.embedded.Item[weightOfSorrowData.name] = weightOfSorrowData;
            break;
        case 'Fear':
            let shadowStealthData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Shadow Stealth (Fear Only)', false);
            if (!shadowStealthData) return;
            shadowStealthData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Shadow Stealth (Fear Only)');
            updates.embedded.Item[shadowStealthData.name] = shadowStealthData;
            break;
    }
    let animation = chris.getConfiguration(workflow.item, 'animation-' + selection) ?? 'shadow';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await tashaSummon.spawn(sourceActor, updates, 3600, workflow.item, 90, workflow.token, animation);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/summonUndead.js


async function summonUndead({speaker, actor, token, character, item, args, scope, workflow}){
    let selection = await chris.dialog('What type?', [['Ghostly', 'Ghostly'], ['Putrid', 'Putrid'], ['Skeletal', 'Skeletal']]);
    if (!selection) return;
    let sourceActor = game.actors.getName('CPR - Undead Spirit');
    if (!sourceActor) return;
    let multiAttackFeatureData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Multiattack (Undead Spirit)', false);
    if (!multiAttackFeatureData) return;
    multiAttackFeatureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Multiattack (Undead Spirit)');
    let attacks = Math.floor(workflow.castData.castLevel / 2);
    multiAttackFeatureData.name = 'Multiattack (' + attacks + ' Attacks)';
    let hpFormula = 0;
    let damageBonus = 0;
    if (workflow.actor.flags['chris-premades']?.feature?.undeadThralls) {
        let wizardLevels = workflow.actor.classes.wizard?.system?.levels;
        if (wizardLevels) hpFormula += wizardLevels;
        damageBonus = workflow.actor.system.attributes.prof;
    }
    let name = chris.getConfiguration(workflow.item, 'name-' + selection) ?? 'Undead Spirit (' + selection + ')';
    if (name === '') name = 'Undead Spirit (' + selection + ')';
    let meleeAttackBonus = await new Roll(workflow.actor.system.bonuses.msak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let rangedAttackBonus = await new Roll(workflow.actor.system.bonuses.rsak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'details': {
                    'cr': tashaSummon.getCR(workflow.actor.system.attributes.prof)
                },
                'attributes': {
                    'ac': {
                        'flat': 11 + workflow.castData.castLevel
                    }
                }
            },
            'prototypeToken': {
                'name': name,
                'disposition': workflow.token.document.disposition
            },
            'flags': {
                'chris-premades': {
                    'summon': {
                        'attackBonus': {
                            'melee': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.dex.mod + meleeAttackBonus.total,
                            'ranged': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.dex.mod + rangedAttackBonus.total
                        }
                    }
                }
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition
        },
        'embedded': {
            'Item': {
                [multiAttackFeatureData.name]: multiAttackFeatureData
            }
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar-' + selection);
    let tokenImg = chris.getConfiguration(workflow.item, 'token-' + selection);
    if (avatarImg) updates.actor.img = avatarImg;
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    switch (selection) {
        case 'Ghostly':
            hpFormula += 30 + ((workflow.castData.castLevel - 3) * 10);
            updates.actor.system.attributes.hp = {
                'formula': hpFormula,
                'max': hpFormula,
                'value': hpFormula
            };
            updates.actor.system.attributes.movement = {
                'walk': 30,
                'fly': 40,
                'hover': true
            };
            let incorporealPassageData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Incorporeal Passage (Ghostly Only)', false);
            if (!incorporealPassageData) return;
            incorporealPassageData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Incorporeal Passage (Ghostly Only)');
            updates.embedded.Item[incorporealPassageData.name] = incorporealPassageData;
            let deathlyTouchData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Deathly Touch (Ghostly Only)', false);
            if (!deathlyTouchData) return;
            deathlyTouchData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Deathly Touch (Ghostly Only)');
            deathlyTouchData.system.damage.parts[0][0] += ' + ' + workflow.castData.castLevel;
            deathlyTouchData.system.save.dc = chris.getSpellDC(workflow.item);
            if (damageBonus) deathlyTouchData.system.damage.parts[0][0] += ' + ' + damageBonus;
            updates.embedded.Item[deathlyTouchData.name] = deathlyTouchData;
            break;
        case 'Putrid':
            hpFormula += 30 + ((workflow.castData.castLevel - 3) * 10);
            updates.actor.system.attributes.hp = {
                'formula': hpFormula,
                'max': hpFormula,
                'value': hpFormula
            };
            let festeringAuraData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Festering Aura (Putrid Only)', false);
            if (!festeringAuraData) return;
            festeringAuraData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Festering Aura (Putrid Only)');
            festeringAuraData.system.save.dc = chris.getSpellDC(workflow.item);
            updates.embedded.Item[festeringAuraData.name] = festeringAuraData;
            let rottingClawData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Rotting Claw (Putrid Only)', false);
            if (!rottingClawData) return;
            rottingClawData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Rotting Claw (Putrid Only)');
            rottingClawData.system.damage.parts[0][0] += ' + ' + workflow.castData.castLevel;
            if (damageBonus) rottingClawData.system.damage.parts[0][0] += ' + ' + damageBonus;
            setProperty(rottingClawData, 'flags.chris-premades.feature.rottingClaw.dc', chris.getSpellDC(workflow.item));
            updates.embedded.Item[rottingClawData.name] = rottingClawData;
            break;
        case 'Skeletal':
            hpFormula += 20 + ((workflow.castData.castLevel - 3) * 10);
            updates.actor.system.attributes.hp = {
                'formula': hpFormula,
                'max': hpFormula,
                'value': hpFormula
            };
            let graveBoltData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Grave Bolt (Skeletal Only)', false);
            if (!graveBoltData) return;
            graveBoltData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Grave Bolt (Skeletal Only)');
            graveBoltData.system.damage.parts[0][0] += ' + ' + workflow.castData.castLevel;
            if (damageBonus) graveBoltData.system.damage.parts[0][0] += ' + ' + damageBonus;
            updates.embedded.Item[graveBoltData.name] = graveBoltData;
            break;
    }
    let animation = chris.getConfiguration(workflow.item, 'animation-' + selection) ?? 'shadow';
    if (chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) animation = 'none';
    await tashaSummon.spawn(sourceActor, updates, 3600, workflow.item, 90, workflow.token, animation);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/druid/circleOfWildfire/summonWildfireSpirit.js




async function summonWildfireSpirit_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let sourceActor = game.actors.getName('CPR - Wildfire Spirit');
    if (!sourceActor) return;
    let druidLevel = workflow.actor.classes?.druid?.system?.levels;
    if (!druidLevel) return;
    let originEffect = chris.findEffect(workflow.actor, 'Wild Shape Passive');
    if (!originEffect) {
        ui.notifications.info('Wild Shape Item Effect Not Found!');
        return;
    }
    let wildShapeItem = await fromUuid(originEffect.origin);
    if (!wildShapeItem) return;
    let wildShapeValue = wildShapeItem.system?.uses?.value;
    if (!wildShapeValue) {
        ui.notifications.info('No Wild Shape Uses Left!');
        return;
    }
    let flameSeedData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Flame Seed', false);
    if (!flameSeedData) return;
    flameSeedData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Flame Seed');
    let fieryTeleportationData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Fiery Teleportation', false);
    if (!fieryTeleportationData) return;
    fieryTeleportationData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Fiery Teleportation');
    fieryTeleportationData.system.save.dc = chris.getSpellDC(workflow.item);
    let commandData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Wildfire Spirit - Command', false);
    if (!commandData) return;
    commandData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Wildfire Spirit - Command');
    let dodgeData = await chris.getItemFromCompendium('chris-premades.CPR Actions', 'Dodge', false);
    if (!dodgeData) return;
    dodgeData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Dodge');
    let hpFormula = 5 + (druidLevel * 5);
    let name = chris.getConfiguration(workflow.item, 'name') ?? 'Wildfire Spirit';
    if (name === '') name = 'Wildfire Spirit';
    let meleeAttackBonus = await new Roll(workflow.actor.system.bonuses.msak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let rangedAttackBonus = await new Roll(workflow.actor.system.bonuses.rsak.attack + ' + 0', workflow.actor.getRollData()).roll({async: true});
    let updates = {
        'actor': {
            'name': name,
            'system': {
                'details': {
                    'cr': tashaSummon.getCR(workflow.actor.system.attributes.prof)
                },
                'attributes': {
                    'hp': {
                        'formula': hpFormula,
                        'max': hpFormula,
                        'value': hpFormula
                    }
                },
                'traits': {
                    'languages': workflow.actor.system?.traits?.languages
                }
            },
            'prototypeToken': {
                'name': name,
                'disposition': workflow.token.document.disposition
            },
            'flags': {
                'chris-premades': {
                    'summon': {
                        'attackBonus': {
                            'melee': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.dex.mod + meleeAttackBonus.total,
                            'ranged': chris.getSpellMod(workflow.item) - sourceActor.system.abilities.dex.mod + rangedAttackBonus.total
                        }
                    }
                }
            }
        },
        'embedded': {
            'Item': {
                [flameSeedData.name]: flameSeedData,
                [fieryTeleportationData.name]: fieryTeleportationData,
                [dodgeData.name]: dodgeData
            }
        },
        'token': {
            'name': name,
            'disposition': workflow.token.document.disposition
        }
    }
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar');
    let tokenImg = chris.getConfiguration(workflow.item, 'token');
    if (avatarImg) updates.actor.img = avatarImg;
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? (chris.jb2aCheck() === 'patreon' && chris.aseCheck()) ? 'fire' : 'none';
    let spawnedToken = await tashaSummon.spawn(sourceActor, updates, 3600, workflow.item, 30, workflow.token, animation);
    let updates2 = {
        'embedded': {
            'Item': {
                [commandData.name]: commandData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Wildfire Spirit',
        'description': commandData.name
    };
    await warpgate.mutate(workflow.token.document, updates2, {}, options);
    let effect = chris.findEffect(workflow.actor, workflow.item.name);
    if (!effect) return;
    let currentScript = effect.flags.effectmacro?.onDelete?.script;
    if (!currentScript) return;
    let effectUpdates = {
        'flags': {
            'effectmacro': {
                'onDelete': { 
                    'script': currentScript + ' await warpgate.revert(token.document, "Wildfire Spirit");'
                }
            },
            'chris-premades': {
                'vae': {
                    'button': commandData.name
                }
            }
        }
    };
    await chris.updateEffect(effect, effectUpdates); 
    await wildShapeItem.update({'system.uses.value': wildShapeValue - 1});
    let damageData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Summon Wildfire Spirit - Damage', false);
    if (!damageData) return;
    damageData.system.save.dc = chris.getSpellDC(workflow.item);
    spawnedToken = spawnedToken.object;
    let nearbyTargets = chris.findNearby(spawnedToken, 10, null).filter(t => t.id != workflow.token.id);
    if (nearbyTargets.length > 0) {
        let targetUuids = nearbyTargets.map(token => token.document.uuid);
        let [config, synthItemOptions] = constants_constants.syntheticItemWorkflowOptions(targetUuids, false);
        let feature = new CONFIG.Item.documentClass(damageData, {'parent': workflow.actor});
        await warpgate.wait(100);
        await MidiQOL.completeItemUse(feature, config, synthItemOptions);
    }
}
async function fieryTeleportation({speaker, actor, token, character, item, args, scope, workflow}) {
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'fieryTeleportation', 450);
    if (!queueSetup) return;
    let nearbyTargets = chris.findNearby(workflow.token, 5, 'ally');
    let selection;
    let selectedTargets = [workflow.token];
    if (nearbyTargets.length > 0) {
        selection = await chris.selectTarget('Teleport Which Creatures?', constants_constants.yesNoButton, nearbyTargets, true, 'multiple');
        if (selection.buttons) {
            for (let i of selection.inputs) {
            if (i) selectedTargets.push((await fromUuid(i)).object);
            }
        }
    }
    await workflow.actor.sheet.minimize();
    let icon = workflow.token.document.texture.src;
    let position = await chris.aimCrosshair(workflow.token, 15, icon, -1, workflow.token.document.width);
    if (position.cancelled) {
        await workflow.actor.sheet.maximize();
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    queue_queue.remove(workflow.item.uuid);
    let difference = {x: workflow.token.x, y: workflow.token.y};
    await new Sequence().effect().file('jb2a.thunderwave.center.blue').atLocation(workflow.token).randomRotation().animation().play();
    async function teleport(targetToken) {
        await new Sequence().effect().file('jb2a.misty_step.01.blue').atLocation(targetToken).randomRotation().scaleToObject(2).wait(750).animation().on(targetToken).opacity(0.0).waitUntilFinished().play();
        let diffX = targetToken.x - difference.x;
        let diffY = targetToken.y - difference.y;
        let newCenter = canvas.grid.getSnappedPosition(position.x - targetToken.w / 2, position.y - targetToken.h / 2, 1);
        let targetUpdate = {
            'token': {
                'x': newCenter.x + diffX,
                'y': newCenter.y + diffY
            }
        };
        let options = {
            'permanent': true,
            'name': workflow.item.name,
            'description': workflow.item.name,
            'updateOpts': {'token': {'animate': false}}
        };
        await warpgate.mutate(targetToken.document, targetUpdate, {}, options);
        await new Sequence().effect().file('jb2a.misty_step.02.blue').atLocation(targetToken).randomRotation().scaleToObject(2).wait(500).animation().on(targetToken).opacity(1.0).play();
    }
    for (let i = 0; selectedTargets.length > i; i++) {
        let targetToken = selectedTargets[i];
        teleport(targetToken);
    }
    await warpgate.wait(2000);
    await workflow.actor.sheet.maximize();
}
let summonWildfireSpirit = {
    item: summonWildfireSpirit_item,
    fieryTeleportation: fieryTeleportation
}
;// CONCATENATED MODULE: ./scripts/macros/generic/summon.js


async function summon_item({speaker, actor, token, character, item, args, scope, workflow}) {
    await summon_spawn(workflow.item, {}, chris.getConfiguration(workflow.item, 'prefill'), workflow.token);
}
async function summon_spawn(item, updates, prefill, casterToken) {
    if (!game.modules.get('quick-insert')?.active) {
        ui.notifications.warn('This macro requires the Quick Insert module to be active!');
        return;
    }
    let selectedActor;
    QuickInsert.open({
        spawnCSS: {
            'left': 600,
            'top': 100
        },
        startText: prefill,
        allowMultiple: false,
        restrictTypes: ['Actor'],
        onSubmit: async (selected) => {
            if (!selected) return;
            if (selected.uuid === item.actor.uuid) {
                ui.notifications.warn('You cannot summon yourself!');
                return;
            }
            selectedActor = await fromUuid(selected.uuid);
            if (selectedActor.compendium) {
                ui.notifications.warn('The actor must not be in a compendium!');
                return;
            }
            let durationSeconds = chris.itemDuration(item).seconds;
            let animation = chris.getConfiguration(item, 'animation');
            if (chris.jb2aCheck() === 'patreon' && chris.aseCheck()) animation = 'none';
            await tashaSummon.spawn(selectedActor, updates, durationSeconds, item, item.system.range.value ?? 120, casterToken, animation);
        }
    });
}
let summon = {
    'item': summon_item,
    'spawn': summon_spawn
}
;// CONCATENATED MODULE: ./scripts/macros/spells/synapticStatic.js

async function synapticStatic({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.targets.size) return;
    chris.updateTargets(Array.from(workflow.targets).filter(i => i.actor.system.abilities.int.value > 2).map(j => j.id));
}
;// CONCATENATED MODULE: ./scripts/macros/spells/tashasOtherworldlyGuise.js


async function tashasOtherworldlyGuise_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let selection = await chris.dialog(workflow.item.name, [['Lower Planes', 'lower'], ['Upper Planes', 'upper']], 'What planes do you draw magic from?');
    if (!selection) return;
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 60
        },
        'changes': [
            {
                'key': 'system.traits.di.value',
                'mode': 0,
                'value': 'fire',
                'priority': 20
            },
            {
                'key': 'system.traits.di.value',
                'mode': 0,
                'value': 'poison',
                'priority': 20
            },
            {
                'key': 'system.traits.ci.value',
                'mode': 0,
                'value': 'poisoned',
                'priority': 20
            },
            {
                'key': 'system.attributes.movement.fly',
                'mode': 4,
                'value': '40',
                'priority': 20
            },
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.tashasOtherworldlyGuise.attack,preambleComplete',
                'priority': 20
            },
            {
                'key': 'system.attributes.ac.bonus',
                'mode': 2,
                'value': '+2',
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'spell': {
                    'tashasOtherworldlyGuise': workflow.item.system.save.scaling
                }
            }
        }
    };
    if (selection === 'upper') {
        effectData.changes[0].value = 'radiant';
        effectData.changes[1].value = 'necrotic';
        effectData.changes[3].value = 'charmed';
    }
    await chris.createEffect(workflow.actor, effectData);
}
async function tashasOtherworldlyGuise_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.item.type != 'weapon') return;
    let effect = workflow.actor.effects.find(i => i.flags['chris-premades']?.spell?.tashasOtherworldlyGuise);
    if (!effect) return;
    let scaling = effect.flags['chris-premades'].spell.tashasOtherworldlyGuise;
    if (scaling === 'spell') scaling = workflow.actor.system.attributes.spellcasting;
    let itemScaling = workflow.item.system.ability;
    if (!itemScaling) itemScaling = 'str';
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'tashasOtherworldlyGuise', 50);
    if (!queueSetup) return;
    let properties = duplicate(workflow.item.system.properties);
    properties.mgc = true;
    let ability = duplicate(workflow.item.system.ability);
    if (workflow.actor.system.abilities[itemScaling].mod < workflow.actor.system.abilities[scaling].mod) ability = scaling;
    workflow.item = workflow.item.clone({'system.properties': properties, 'system.ability': ability}, {'keepId': true});
    workflow.item.prepareData();
    workflow.item.prepareFinalAttributes();
    queue_queue.remove(workflow.item.uuid);
}
let tashasOtherworldlyGuise = {
    'item': tashasOtherworldlyGuise_item,
    'attack': tashasOtherworldlyGuise_attack
}
;// CONCATENATED MODULE: ./scripts/macros/feats/telekinetic.js


async function telekinetic({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size != 1) return;
    let targetToken = workflow.targets.first();
    let distance = chris.getDistance(workflow.token, targetToken);
    let selection = await chris.dialog('Which way?', [['Toward', -5], ['Away', 5]]);
    if (!selection) return;
    let knockBackFactor;
    let ray;
    let newCenter;
    let hitsWall = true;
    while (hitsWall) {
        knockBackFactor = selection / canvas.dimensions.distance;
        ray = new Ray(workflow.token.center, targetToken.center);
        if (ray.distance === 0) {
            ui.notifications.info('Target is unable to be moved!');
            queue_queue.remove(workflow.item.uuid);
            return;
        }
        newCenter = ray.project(1 + ((canvas.dimensions.size * knockBackFactor) / ray.distance));
        hitsWall = targetToken.checkCollision(newCenter, {origin: ray.A, type: 'move', mode: 'any'});
        if (hitsWall) {
            selection -= 5;
            if (selection === 0) {
                ui.notifications.info('Target is unable to be moved!');
                queue_queue.remove(workflow.item.uuid);
                return;
            }
        }
    }
    newCenter = canvas.grid.getSnappedPosition(newCenter.x - targetToken.w / 2, newCenter.y - targetToken.h / 2, 1);
    let targetUpdate = {
        'token': {
            'x': newCenter.x,
            'y': newCenter.y
        }
    };
    let options = {
        'permanent': true,
        'name': workflow.item.name,
        'description': workflow.item.name
    };
    await warpgate.mutate(targetToken.document, targetUpdate, {}, options);
    distance = chris.getDistance(workflow.token, targetToken);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/teleport.js




async function teleport_teleport({speaker, actor, token, character, item, args, scope, workflow}) {
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'teleport', 50);
    if (!queueSetup) return;
    let gmID = game.settings.get('chris-premades', 'LastGM');
    let doAnimation = false;
    let targetTokens = [];
    if (workflow.token) {
        doAnimation = true;
        let targets = chris.findNearby(workflow.token, 10, 'ally', true, false);
        if (targets.length > 0) {
            let selection = await chris.selectTarget('Who else is getting teleported?', constants_constants.okCancel, targets, true, 'multiple');
            if (selection.buttons) {
                targetTokens = selection.inputs.filter(i => i).map(i => fromUuidSync(i));
            }
            if (targetTokens.length > 8) {
                ui.notifications.info('Too many targets selected!');
                queue_queue.remove(workflow.item.uuid);
                return;
            }
        }
        targetTokens.push(workflow.token.document);
    }
    let options = [
        ['Permanent Circle', 'pc'],
        ['Associated Object', 'ao'],
        ['Very Familiar', 'vf'],
        ['Seen Casually', 'sc'],
        ['Viewed Once', 'vo'],
        ['Description', 'd'],
        ['False Destination', 'fd']
    ];
    let selection = await chris.remoteDialog(workflow.item.name, options, gmID, 'What is the Familiarity?');
    if (!selection) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let flavor = 'Mishap';
    let totalDamage = 0;
    while (flavor === 'Mishap') {
        if (totalDamage > 0) await warpgate.wait(100);
        let roll = await new Roll('1d100').roll({async: true});
        let total = roll.total;
        switch (selection) {
            case 'pc':
            case 'ao':
                flavor = 'On Target'
                break;
            case 'vf':
                if (0 <= total && total < 6) {
                    flavor = 'Mishap';
                    totalDamage += 3;
                } else if (6 <= total && total < 14) {
                    flavor = 'Similar Area';
                } else if (14 <= total && total < 25) {
                    flavor = 'Off Target';
                } else if (25 <= total && total <= 100) {
                    flavor = 'On Target';
                }
                break;
            case 'sc':
                if (0 <= total && total < 34) {
                    flavor = 'Mishap';
                    totalDamage += 3;
                } else if (34 <= total && total < 44) {
                    flavor = 'Similar Area';
                } else if (44 <= total && total < 54) {
                    flavor = 'Off Target';
                } else if (54 <= total && total <= 100) {
                    flavor = 'On Target';
                }
                break;
            case 'vo':
            case 'd':
                if (0 <= total && total < 44) {
                    flavor = 'Mishap';
                    totalDamage += 3;
                } else if (44 <= total && total < 54) {
                    flavor = 'Similar Area';
                } else if (54 <= total && total < 74) {
                    flavor = 'Off Target';
                } else if (74 <= total && total <= 100) {
                    flavor = 'On Target';
                }
                break;
            case 'fd':
                if (0 <= total && total < 51) {
                    flavor = 'Mishap';
                    totalDamage += 3;
                } else if (51 <= total && total <= 100) {
                    flavor = 'Similar Area';
                }
                break;
        }
        roll.toMessage({
            'rollMode': 'roll',
            'speaker': {'alias': name},
            'flavor': flavor,
            'whisper': [gmID]
        },
        {
            'rollMode': CONST.DICE_ROLL_MODES.BLIND
        });
    }
    if (totalDamage > 0) {
        let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Teleport - Damage', false);
        if (!featureData) {
            queue_queue.remove(workflow.item.uuid);
            return;
        }
        featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Teleport - Damage');
        featureData.system.damage.parts[0][0] = totalDamage + 'd10[' + translate.damageType('force') + ']';
        let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
        let [config, options] = constants_constants.syntheticItemWorkflowOptions(targetTokens.map(i => i.uuid));
        await warpgate.wait(100);
        await MidiQOL.completeItemUse(feature, config, options);
    }
    if (flavor === 'Off Target') {
        let roll = await new Roll('1d10 * 1d10').roll({async: true});
        roll.toMessage({
            'rollMode': 'roll',
            'speaker': {'alias': name},
            'flavor': 'Off Target - Distance',
            'whisper': [gmID]
        },
        {
            'rollMode': CONST.DICE_ROLL_MODES.BLIND
        });
        let roll2 = await new Roll('1d8').roll({async: true});
        roll2.toMessage({
            'rollMode': 'roll',
            'speaker': {'alias': name},
            'flavor': 'Off Target - Direction',
            'whisper': [gmID]
        },
        {
            'rollMode': CONST.DICE_ROLL_MODES.BLIND
        });
        let inputs = [
            {
                'label': 'Distance',
                'type': 'number'
            },
            {
                'label': 'Units:',
                'type': 'select',
                'options': [
                    {
                        'html': 'Miles',
                        'value': 'miles'
                    },
                    {
                        'html': 'Feet',
                        'value': 'feet'
                    }
                ]
            }
        ];
        let location = await chris.remoteMenu('How far away is the destination?', constants_constants.okCancel, inputs, true, gmID);
        if (!location.buttons) {
            queue_queue.remove(workflow.item.uuid);
            return;
        }
        let distance = Math.floor((roll.total / 100) * location.inputs[0]);
        let directions = ['north', 'northeast', 'east', 'southeast', 'south', 'southwest', 'west', 'northwest'];
        ChatMessage.create({
            'speaker': {'alias': name},
            'content': 'Destination is ' + distance + ' ' + location.inputs[1] + ' ' + directions[roll2.total - 1] + ' of the intended location.',
            'whisper': [gmID],
            'blind': true
        });
    }
    if (!doAnimation || chris.jb2aCheck() != 'patreon' || !chris.aseCheck()) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    if (workflow.actor) await workflow.actor.sheet.minimize();
    let selected = workflow.token;
    let teleOut = new Sequence()
        .effect()
        .file('jb2a.particles.outward.blue.01.05')
        .atLocation(selected)
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 2})
        .scaleToObject(1.7)
        .fadeIn(3000, {'ease': 'easeInExpo'})
        .duration(5500)

        .effect()
        .file('jb2a.particles.outward.blue.01.05')
        .atLocation(selected)
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 2})
        .scaleToObject(4)
        .belowTokens()
        .fadeIn(3000, {'ease': 'easeInExpo'})
        .duration(5500)

        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.intro.blue')
        .atLocation(selected)
        .belowTokens()
        .scaleToObject(3)
        .filter('ColorMatrix', {'saturate': -0.25, 'brightness': 1})
        .opacity(0.8)
        .waitUntilFinished(-500)

        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.blue')
        .atLocation(selected)
        .filter('ColorMatrix', {'saturate': -0.5, 'brightness': 1.5})
        .opacity(0.65)
        .belowTokens()
        .scaleToObject(3)
        .duration(2500)

        .effect()
        .file('jb2a.extras.tmfx.outpulse.circle.02.fast')
        .atLocation(selected)
        .opacity(0.5)
        .scaleToObject(3)
        .duration(2500)

        .animation()
        .on(selected)
        .delay(2000)
        .opacity(0)

        .thenDo(function() {
            targetTokens.filter(i => i.uuid != selected.document.uuid).forEach(target => {  
                new Sequence()
                    .animation()
                    .on(target)
                    .delay(2000)
                    .opacity(0)

                    .effect()
                    .from(target)
                    .atLocation(target)
                    .scaleToObject(1.1)
                    .fadeIn(2000, {'ease': 'easeInExpo'})
                    .filter('ColorMatrix', {'saturate': -1, 'brightness': 10})
                    .filter('Blur', { 'blurX': 5, 'blurY': 10})
                    .scaleOut(0, 100, {'ease': 'easeOutCubic'})
                    .duration(2500)
                    .attachTo(target, {'bindAlpha': false})
                    .waitUntilFinished(-200)

                    .play();
                })
            }
        )

        .effect()
        .from(selected)
        .atLocation(selected)
        .scaleToObject(1.1)
        .fadeIn(2000, {'ease': 'easeInExpo'})
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 10})
        .filter('Blur', {'blurX': 5, 'blurY': 10})
        .scaleOut(0, 100, {'ease': 'easeOutCubic'})
        .animateProperty('sprite', 'scale.x', {'from': 0.5, 'to': 0, 'duration': 500, 'delay': 2500, 'ease': 'easeOutElastic'})
        .animateProperty('spriteContainer', 'position.y', {'from': 0, 'to': -1000, 'duration': 500, 'delay': 2500, 'ease': 'easeOutCubic'})
        .fadeOut(100)
        .duration(2500+500)
        .attachTo(selected, {'bindAlpha': false})
        .waitUntilFinished(-700)

        .effect()
        .file('modules/animated-spell-effects-cartoon/spell-effects/cartoon/energy/energy_pulse_yellow_CIRCLE.webm')
        .atLocation(selected)
        .opacity(1)
        .scaleToObject(4)
        .filter('ColorMatrix', {'saturate': -1, 'hue': 160, 'brightness': 2})

        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.blue')
        .atLocation(selected)
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 0})
        .opacity(0.3)
        .fadeOut(10000, {'ease': 'easeOutQuint'})
        .belowTokens()
        .scaleToObject(3)
        .duration(20000)

        .effect()
        .file('jb2a.particles.outward.blue.01.03')
        .atLocation(selected)
        .fadeIn(250, {'ease': 'easeOutQuint'})
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .opacity(1)
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 2})
        .scaleToObject(5)
        .duration(10000);

        await teleOut.play();
    let selection2 = await chris.remoteDialog(workflow.item.name, constants_constants.yesNo, gmID, 'Select destination?');
    if (!selection2) {
        let options = {
            'permanent': true,
            'name': workflow.item.name,
            'description': workflow.item.name
        };
        let updates = {
            'token': {
                'hidden': true,
                'alpha': 1
            }
        };
        for (let token of targetTokens) await warpgate.mutate(token, updates, {}, options);
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let interval = selected.document.width % 2 === 0 ? 1 : -1;
    let position = await chris.remoteAimCrosshair(selected, false, workflow.item.img, interval, selected.document.width + 2, gmID);
    if (position.cancelled) {
        await workflow.actor.sheet.maximize();
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let originX = selected.center.x;
    let originY = selected.center.y; 
    let teleIn = new Sequence()
        .animation()
        .on(selected)
        .teleportTo(position)
        .snapToGrid()
        .offset({'x': -1, 'y': -1 })
        .waitUntilFinished(1000)
        
        .thenDo(function() {
            targetTokens.filter(i => i.uuid != selected.document.uuid).forEach(target => {
                let targetX = position.x + target.object.center.x - originX;
                let targetY = position.y + target.object.center.y - originY;
                new Sequence()
                    .animation()
                    .on(target)
                    .teleportTo({'x': targetX, 'y': targetY})
                    .snapToGrid()
                    .offset({'x': -1, 'y': -1 })
                    .waitUntilFinished(1000)
                    .play();
                })
            }
        )

        .effect()
        .from(selected)
        .atLocation(selected)
        .scaleToObject(1.1)
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 10})
        .filter('Blur', {'blurX': 5, 'blurY': 10 })
        .animateProperty('spriteContainer', 'position.y', {'from': -1000, 'to': 0, 'duration': 500, 'ease': 'easeOutCubic'})
        .animateProperty('sprite', 'scale.x', {'from': 0.5, 'to': 0, 'duration': 500, 'ease': 'easeOutElastic'})
        .fadeOut(100)
        .scaleOut(0, 100, {'ease': 'easeOutCubic'})
        .duration(500)
        .attachTo(selected, {'bindAlpha': false})
        .waitUntilFinished(-300)
        
        .effect()
        .file('modules/animated-spell-effects-cartoon/spell-effects/cartoon/energy/energy_pulse_yellow_CIRCLE.webm')
        .atLocation(selected)
        .opacity(1)
        .scaleToObject(4)
        .filter('ColorMatrix', {'saturate':-1, 'hue': 160,'brightness': 2})
        
        .effect()
        .file('jb2a.particles.outward.blue.01.03')
        .atLocation(selected)
        .fadeIn(250, {'ease': 'easeOutQuint'})
        .scaleIn(0, 200, {'ease': 'easeOutCubic'})
        .fadeOut(5000, {'ease': 'easeOutQuint'})
        .opacity(1)
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 2})
        .scaleToObject(5)
        .duration(10000)
        
        .effect()
        .from(selected)
        .atLocation(selected)
        .scaleToObject(1.1)
        .fadeOut(1000, {'ease': 'easeInExpo'})
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 10})
        .filter('Blur', {'blurX': 5, 'blurY': 10 })
        .scaleIn(0, 500, {'ease': 'easeOutCubic'})
        .duration(1200)
        .attachTo(selected, {'bindAlpha': false})
        
        .animation()
        .on(selected)
        .opacity(1.0)
        .show()
        
        .thenDo(function() {
            targetTokens.forEach(target => {  
                new Sequence()
                    .effect()
                    .from(target)
                    .atLocation(target)
                    .scaleToObject(1.1)
                    .fadeOut(1000, {'ease': 'easeInExpo'})
                    .filter('ColorMatrix', {'saturate': -1, 'brightness': 10})
                    .filter('Blur', {'blurX': 5, 'blurY': 10 })
                    .scaleIn(0, 500, {'ease': 'easeOutCubic'})
                    .duration(1200)
                    .attachTo(target, {'bindAlpha': false})
                    
                    .animation()
                    .on(target)
                    .opacity(1.0)
                    .show()
                    .play();
                })
            }
        )
        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.blue')
        .atLocation(selected)
        .filter('ColorMatrix', {'saturate': -0.5, 'brightness': 1.5})
        .opacity(0.65)
        .belowTokens()
        .scaleToObject(3)
        .fadeOut(4000)
        .duration(5000)
        .waitUntilFinished(-4000)
        
        .effect()
        .file('jb2a.magic_signs.circle.02.conjuration.loop.blue')
        .atLocation(selected)
        .filter('ColorMatrix', {'saturate': -1, 'brightness': 0})
        .opacity(0.3)
        .fadeOut(10000, {'ease': 'easeOutQuint'})
        .belowTokens()
        .scaleToObject(3)
        .duration(20000);

        await teleIn.play();
        await workflow.actor.sheet.maximize();
        queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/warlock/fathomless/tentacleOfTheDeeps.js

async function tentacleOfTheDeeps_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let sourceActor = game.actors.getName('CPR - Spectral Tentacle');
    if (!sourceActor) return;
    async function effectMacro() {
        await chrisPremades.macros.tentacleOfTheDeeps.remove(token, origin);
    }
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': 'Dismiss Summon'
                }
            }
        }
    };
    let name = 'Spectral Tentacle';
    let updates = {
        'actor': {
            'name': name,
            'prototypeToken': {
                'name': name
            }
        },
        'token': {
            'name': name
        },
        'embedded': {
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let avatarImg = chris.getConfiguration(workflow.item, 'avatar');
    if (avatarImg) updates.actor.img = avatarImg;
    let tokenImg = chris.getConfiguration(workflow.item, 'token');
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    let options = {
        'controllingActor': workflow.token.actor
    };
    let tokenDocument = await sourceActor.getTokenDocument();
    let spawnedTokens = await warpgate.spawn(tokenDocument, updates, {}, options);
    if (!spawnedTokens) return;
    let spawnedToken = game.canvas.scene.tokens.get(spawnedTokens[0]);
    if (!spawnedToken) return;
    let targetEffect = chris.findEffect(spawnedToken.actor, workflow.item.name);
    if (!targetEffect) return;
    let casterEffectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'changes': [
            {
                'key': 'flags.chris-premades.feature.tentacleOfTheDeeps.tokenUuid',
                'mode': 5,
                'value': spawnedToken.uuid,
                'priority': 20
            }
        ],
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': 'let effect = await fromUuid("' + targetEffect.uuid + '"); if (effect) await chrisPremades.helpers.removeEffect(effect); await warpgate.revert(token.document, "Tentacle of the Deeps");'
                }
            },
            'chris-premades': {
                'vae': {
                    'button': 'Tentacle of the Deeps - Attack'
                }
            }
        }
    };
    let attackFeatureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Tentacle of the Deeps - Attack', false);
    if (!attackFeatureData) return;
    attackFeatureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Tentacle of the Deeps - Attack');
    attackFeatureData.system.ability = workflow.item.system.ability;
    let updates2 = {
        'embedded': {
            'Item': {
                [attackFeatureData.name]: attackFeatureData
            },
            'ActiveEffect': {
                [casterEffectData.name]: casterEffectData
            }
        }
    };
    let options2 = {
        'permanent': false,
        'name': 'Tentacle of the Deeps',
        'description': 'Tentacle of the Deeps'
    };
    await warpgate.mutate(workflow.token.document, updates2, {}, options2);
}
async function tentacleOfTheDeeps_attackEarly({speaker, actor, token, character, item, args, scope, workflow}) {
    await workflow.item.setFlag('chris-premades', 'feature.tentacleOfTheDeeps.position', {'x': workflow.token.document.x, 'y': workflow.token.document.y});
    await workflow.actor.setFlag('chris-premades', 'mechanic.noFlanking', true);
    let tentacleTokenUuid = workflow.actor.flags['chris-premades']?.feature?.tentacleOfTheDeeps?.tokenUuid;
    if (!tentacleTokenUuid) return;
    let tentacleToken = await fromUuid(tentacleTokenUuid);
    if (!tentacleToken) return;
    let position = canvas.grid.getSnappedPosition(tentacleToken.x, tentacleToken.y);
    workflow.token.document.x = position.x;
    workflow.token.document.y = position.y;
    workflow.flankingAdvantage = false; //Does not currently work.
}
async function tentacleOfTheDeeps_attackLate({speaker, actor, token, character, item, args, scope, workflow}) { 
    await workflow.actor.unsetFlag('chris-premades', 'mechanic.noFlanking');
    let position = workflow.item.flags['chris-premades']?.feature?.tentacleOfTheDeeps?.position;
    if (!position) return;
    workflow.token.document.x = position.x;
    workflow.token.document.y = position.y;
}
async function tentacleOfTheDeeps_remove(token, origin) {
    let originActor = origin.actor;
    await warpgate.dismiss(token.id);
    let castEffect = chrisPremades.helpers.findEffect(originActor, origin.name);
    if (castEffect) await chrisPremades.helpers.removeEffect(castEffect);
}
let tentacleOfTheDeeps = {
    'item': tentacleOfTheDeeps_item,
    'attackEarly': tentacleOfTheDeeps_attackEarly,
    'attackLate': tentacleOfTheDeeps_attackLate,
    'remove': tentacleOfTheDeeps_remove
}
;// CONCATENATED MODULE: ./scripts/macros/spells/thornWhip.js

async function thornWhip({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let targetToken = workflow.targets.first();
    if ((chris.getSize(targetToken.actor)) > (chris.sizeStringValue('large'))) {
        ui.notifications.info('Target is unable to be moved!');
        return;
    }
    let distance = chris.getDistance(workflow.token, targetToken);
    let selection = await chris.dialog('How far do you pull the target?', [['0 ft.', false], ['5 ft.', -5], ['10 ft.', -10]]);
    if (!selection) return;
    if (distance <= 5) {
        return;
    } else if (distance > 5 && distance <= 10) {
        selection = -5;
    }
    let knockBackFactor;
    let ray;
    let newCenter;
    let hitsWall = true;
    while (hitsWall) {
        knockBackFactor = selection / canvas.dimensions.distance;
        ray = new Ray(workflow.token.center, targetToken.center);
        if (ray.distance === 0) {
            ui.notifications.info('Target is unable to be moved!');
            return;
        }
        newCenter = ray.project(1 + ((canvas.dimensions.size * knockBackFactor) / ray.distance));
        hitsWall = targetToken.checkCollision(newCenter, {origin: ray.A, type: "move", mode: "any"});
        if (hitsWall) {
            selection -= 5;
            if (selection === 0) {
                ui.notifications.info('Target is unable to be moved!');
                return;
            }
        }
    }
    newCenter = canvas.grid.getSnappedPosition(newCenter.x - targetToken.w / 2, newCenter.y - targetToken.h / 2, 1);
    let targetUpdate = {
        'token': {
            'x': newCenter.x,
            'y': newCenter.y
        }
    };
    let options = {
        'permanent': true,
        'name': workflow.item.name,
        'description': workflow.item.name
    };
    await warpgate.mutate(targetToken.document, targetUpdate, {}, options);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/thunderStep.js


async function thunderStep({speaker, actor, token, character, item, args, scope, workflow}) {
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'thunderStep', 450);
    if (!queueSetup) return;
    let casterSize = chris.getSize(workflow.actor);
    let nearbyTargets = chris.findNearby(workflow.token, 5, 'ally').filter(t => chris.getSize(t.actor) <= casterSize);
    let selection;
    let selectedTargets = [workflow.token];
    if (nearbyTargets.length > 0) {
        let buttons = [
            {
                'label': 'Yes',
                'value': true
            }, {
                'label': 'No',
                'value': false
            }
        ];
        selection = await chris.selectTarget('Teleport a Creature?', buttons, nearbyTargets, true, 'one');
        if (selection.buttons) {
            let selectedTarget = selection.inputs.find(id => id != false);
            if (selectedTarget) {
                chris.updateTargets(Array.from(workflow.targets).filter(t => t.document.uuid != selectedTarget).map(t => t.id));
                selectedTargets.push((await fromUuid(selectedTarget)).object);
            }
        }
    }
    await workflow.actor.sheet.minimize();
    let icon = workflow.token.document.texture.src;
    let position = await chris.aimCrosshair(workflow.token, 90, icon, -1, workflow.token.document.width);
    queue_queue.remove(workflow.item.uuid);
    if (position.cancelled) {
        await workflow.actor.sheet.maximize();
        return;
    }
    let difference = {x: workflow.token.x, y: workflow.token.y};
    await new Sequence().effect().file('jb2a.thunderwave.center.blue').atLocation(workflow.token).randomRotation().animation().play();
    async function teleport(targetToken) {
        await new Sequence().effect().file('jb2a.misty_step.01.blue').atLocation(targetToken).randomRotation().scaleToObject(2).wait(750).animation().on(targetToken).opacity(0.0).waitUntilFinished().play();
        let diffX = targetToken.x - difference.x;
        let diffY = targetToken.y - difference.y;
        let newCenter = canvas.grid.getSnappedPosition(position.x - targetToken.w / 2, position.y - targetToken.h / 2, 1);
        let targetUpdate = {
            'token': {
                'x': newCenter.x + diffX,
                'y': newCenter.y + diffY
            }
        };
        let options = {
            'permanent': true,
            'name': workflow.item.name,
            'description': workflow.item.name,
            'updateOpts': {'token': {'animate': false}}
        };
        await warpgate.mutate(targetToken.document, targetUpdate, {}, options);
        await new Sequence().effect().file('jb2a.misty_step.02.blue').atLocation(targetToken).randomRotation().scaleToObject(2).wait(500).animation().on(targetToken).opacity(1.0).play();
    }
    for (let i = 0; selectedTargets.length > i; i++) {
        let targetToken = selectedTargets[i];
        teleport(targetToken);
    }
    await warpgate.wait(2000);
    await workflow.actor.sheet.maximize();
}
;// CONCATENATED MODULE: ./scripts/macros/spells/thunderwave.js


async function thunderWave({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.failedSaves.size) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'thunderWave', 50);
    if (!queueSetup) return;
    for (let i of Array.from(workflow.failedSaves)) {
        chris.pushToken(workflow.token, i, 10);
    }
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/cleric/tempestDomain/thunderboltStrike.js



async function thunderboltStrike({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.hitTargets.size || !workflow.damageRoll) return;
    let feature = chris.getItem(workflow.actor, 'Thunderbolt Strike');
    if (!feature) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'thunderboltStrike', 475);
    if (!queueSetup) return;
    let damageTypes = chris.getRollDamageTypes(workflow.damageRoll);
    if (!damageTypes.has('lightning')) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let targets = Array.from(workflow.hitTargets).filter(i => chris.getSize(i.actor) <= 3);
    if (!targets.length) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let selection = await chris.selectTarget(feature.name + ': Push targets?', constants_constants.yesNoButton, targets, true, 'multiple');
    if (!selection.buttons) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let pushTargets = selection.inputs.filter(i => i).map(i => fromUuidSync(i).object);
    if (!pushTargets.length) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    for (let i of pushTargets) chrisPremades.helpers.pushToken(workflow.token, i, 10);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/thunderousSmite.js



async function thunderousSmite_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1 || !workflow.item) return;
    if (workflow.item.system.actionType != 'mwak') return;
    let effect = workflow.actor.effects.find(i => i.flags['chris-premades']?.spell?.thunderousSmite);
    if (!effect) return;
    let targetToken = workflow.targets.first();
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'thunderousSmite', 250);
    if (!queueSetup) return;
    let oldFormula = workflow.damageRoll._formula;
    let bonusDamageFormula = '2d6[thunder]';
    if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
    let damageFormula = oldFormula + ' + ' + bonusDamageFormula;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Thunderous Smite - Push');
    if (!featureData) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Thunderous Smite - Push');
    delete featureData._id;
    featureData.system.save.dc = effect.flags['chris-premades'].spell.thunderousSmite.dc;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.document.uuid]);
    await warpgate.wait(100);
    let featureWorkflow = await MidiQOL.completeItemUse(feature, config, options);
    if (featureWorkflow.failedSaves.size) {
        await chris.pushToken(workflow.token, targetToken, 10);
        if (!chris.checkTrait(targetToken.actor, 'ci', 'prone')) await chris.addCondition(targetToken.actor, 'Prone');
    }
    await chris.removeEffect(effect);
    let conEffect = chris.findEffect(workflow.actor, 'Concentrating');
    if (conEffect) await chris.removeEffect(conEffect);
    queue_queue.remove(workflow.item.uuid);
}
async function thunderousSmite_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let effectData = {
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 60
        },
        'name': workflow.item.name,
        'changes': [
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'mode': 0,
                'value': 'function.chrisPremades.macros.thunderousSmite.damage,postDamageRoll',
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'spell': {
                    'thunderousSmite': {
                        'dc': chris.getSpellDC(workflow.item)
                    }
                }
            }
        }
    };
    await chris.createEffect(workflow.actor, effectData);
}
let thunderousSmite = {
    'damage': thunderousSmite_damage,
    'item': thunderousSmite_item
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/tixieTockworth/forceField.js


async function forceField_item({speaker, actor, token, character, item, args, scope, workflow}) {
    await chris.removeCondition(workflow.actor, 'Grappled');
    await chris.removeCondition(workflow.actor, 'Restrained');
    await chris.removeCondition(workflow.actor, 'Stunned');
}
async function forceField_turnStart(token, origin) {
    if (token.actor.system.attributes.hp.value === 0) return;
    let featureData = duplicate(origin.toObject());
    delete featureData._id;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': token.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.document.uuid]);
    await MidiQOL.completeItemUse(feature, config, options);
}
async function forceField_onHit(workflow, targetToken) {
    if (!workflow.damageRoll || targetToken.actor.system.attributes.hp.temp > 0) return;
    let effect = chris.findEffect(targetToken.actor, 'Force Field');
    if (!effect) return;
    await chris.removeEffect(effect);
}
let forceField = {
    'item': forceField_item,
    'turnStart': forceField_turnStart,
    'onHit': forceField_onHit
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/tixieTockworth/tixieTockworth.js

let tixieTockworth = {
    'forceField': forceField
}
;// CONCATENATED MODULE: ./scripts/macros/spells/tollTheDead.js

async function tollTheDead({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'tollTheDead', 50);
    if (!queueSetup) return;
    if (targetActor.system.attributes.hp.value === targetActor.system.attributes.hp.max) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let damageFormula = workflow.damageRoll._formula.replace('d8', 'd12');
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/raceFeatures/elf/trance.js


async function trance({speaker, actor, token, character, item, args, scope, workflow}) {
    let tools = {
        'alchemist': 'Alchemist\'s Supplies',
        'brewer': 'Brewer\'s Supplies',
        'calligrapher': 'Calligrapher\'s Supplies',
        'carpenter': 'Carpenter\'s Tools',
        'cartographer': 'Cartographer\'s Tools',
        'cobbler': 'Cobbler\'s Tools',
        'cook': 'Cook\'s Utensils',
        'glassblower': 'Glassblower\'s Tools',
        'jeweler': 'Jeweler\'s Tools',
        'leatherworker': 'Leatherworker\'s Tools',
        'mason': 'Mason\'s Tools',
        'painter': 'Painter\'s Supplies',
        'potter': 'Potter\'s Tools',
        'smith': 'Smith\'s Tools',
        'tinker': 'Tinker\'s Tools',
        'weaver': 'Weaver\'s Tools',
        'woodcarver': 'Woodcarver\'s Tools',
        'disg': 'Disguise Kit',
        'forg': 'Forgery Kit',
        'herb': 'Herbalism Kit',
        'navg': 'Navigator\'s Tools',
        'pois': 'Poisoner\'s Kit',
        'thief': 'Thieves\' Tools'
    }
    function dialogRender(html) {
        let ths = html[0].getElementsByTagName('th');
        for (let t of ths) {
            t.style.width = 'auto';
            t.style.textAlign = 'left';
        }
        let tds = html[0].getElementsByTagName('td');
        for (let t of tds) {
            t.style.width = '50px';
            t.style.textAlign = 'center';
            t.style.paddingRight = '5px';
        }
    }
    let selection = await warpgate.menu({
        'inputs': [
            {
                'label': 'Skill:',
                'type': 'select',
                'options': Object.entries(CONFIG.DND5E.skills).map(([i, j]) => ({'value': i, 'html': j.label}))
            },
            {
                'label': 'Weapon or Tool:',
                'type': 'select',
                'options': Object.keys(CONFIG.DND5E.weaponIds).map(i => ({'value': i, 'html': i.charAt(0).toUpperCase() + i.slice(1)})).concat(Object.keys(tools).map(i => ({'value': i, 'html': tools[i]})))
            }
        ],
        'buttons': constants_constants.okCancel
    }, {
        'title': workflow.item.name,
        'render': dialogRender
    });
    if (!selection.buttons) return;
    async function effectMacro () {
        await warpgate.revert(token.document, 'Trance');
    }
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 604800
        },
        'changes': [
            {
                'key': 'system.skills.' + selection.inputs[0] +'.value',
                'mode': 4,
                'value': '1',
                'priority': 20
            }
        ],
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'dae': {
                'specialDuration': [
                    'longRest'
                ]
            }
        }
    };
    let updates = {}
    if (Object.keys(CONFIG.DND5E.weaponIds).includes(selection.inputs[1])) {
        effectData.changes.push({
            'key': 'system.traits.weaponProf.value',
            'mode': 2,
            'value': selection.inputs[1],
            'priority': 20
        });
    } else {
        let ability = await chris.dialog('What ability for the tool?', Object.values(CONFIG.DND5E.abilities).map(i => [i.label, i.abbreviation]));
        if (!ability) return;
        setProperty(updates, 'actor.system.tools.' + selection.inputs[1], {
            'ability': ability,
            'value': 1
        });
    }
    setProperty(updates, 'embedded.ActiveEffect.' + workflow.item.name, effectData);
    let effect = chris.findEffect(workflow.actor, workflow.item.name);
    if (effect) await chris.removeEffect(effect);
    let options = {
        'permanent': false,
        'name': 'Trance',
        'description': 'Trance'
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/fighter/gunslinger/trickShots.js



async function runFeature(workflow, featureName) {
    if (workflow.hitTargets.size != 1 || workflow.item.system.baseItem != 'firearmCR') return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', featureName, false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', featureName);
    let originItem = chris.getItem(workflow.actor, featureName);
    if (!originItem) return;
    featureData._id = originItem.id;
    featureData.system.save.dc = chris.getSpellDC(originItem);
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
    await warpgate.wait(100);
    return await MidiQOL.completeItemUse(feature, config, options);
}
async function wingingShot({speaker, actor, token, character, item, args, scope, workflow}) {
    await runFeature(workflow, 'Winging Shot');
}
async function forcefulShot({speaker, actor, token, character, item, args, scope, workflow}) {
    let featureWorkflow = await runFeature(workflow, 'Forceful Shot');
    if (featureWorkflow.failedSaves.size != 1) return;
    await chris.pushToken(workflow.token, workflow.targets.first(), 15);
}
async function disarmingShot({speaker, actor, token, character, item, args, scope, workflow}) {
    await runFeature(workflow, 'Disarming Shot');
}
async function dazingShot({speaker, actor, token, character, item, args, scope, workflow}) {
    await runFeature(workflow, 'Dazing Shot');
}
async function piercingShot({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.token) return;
    let weapons = workflow.actor.items.filter(i => i.system.baseItem === 'firearmCR' && i.system.uses.value && i.system.equipped && !chris.getConfiguration(i, 'status'));
    if (!weapons.length) {
        ui.notifications.info('You have no equipped firearms with ammo!');
        return;
    }
    let weapon;
    if (weapons.length === 1) {
        weapon = weapons[0];
    } else {
        [weapon] = await chris.selectDocument(workflow.item.name, weapons);
    }
    if (!weapon) return;
    let range = weapon.system.range.value;
    let templateData = {
        'user': game.user,
        't': 'ray',
        'distance': range,
        'width': 5,
        'fillColor': game.user.color,
        'flags': {
            'dnd5e': {
                'origin': workflow.item.uuid
            },
            'midi-qol': {
                'originUuid': workflow.item.uuid
            }
        }
    };
    await workflow.actor.sheet.minimize();
    let {template, tokens} = await chris.placeTemplate(templateData, true);
    if (!template) return;
    tokens = tokens.filter(i => i.uuid != workflow.token.document.uuid);
    if (!tokens.length) return;
    let targetRanges = tokens.map(i => ({'uuid': i.uuid, 'distance': chris.getDistance(workflow.token, i)}));
    let closestTargetRange = Math.min(...targetRanges.map(i => i.distance));
    let closestTarget = targetRanges.find(i => i.distance === closestTargetRange);
    let weaponData = weapon.toObject();
    let misfireScore = (chris.getConfiguration(weapon, 'misfire') ?? 1) + 1;
    setProperty(weaponData, 'flags.chris-premades.configuration.misfire', misfireScore);
    delete weaponData._id;
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([closestTarget.uuid]);
    let newWeapon = new CONFIG.Item.documentClass(weaponData, {'parent': workflow.actor});
    await weapon.update({'system.uses.value': weapon.system.uses.value - 1});
    await warpgate.wait(100);
    let weaponWorkflow = await MidiQOL.completeItemUse(newWeapon, config, options);
    if (weaponWorkflow.attackRoll.terms[0].total <= misfireScore) {
        await template.delete();
        await workflow.actor.sheet.maximize();
        let updates = {
            'flags.chris-premades.configuration.status': 1,
            'name': weapon.name += ' (Damaged)'
        }
        await weapon.update(updates);
        return;
    }
    let otherTargets = tokens.filter(i => closestTarget.uuid != i.uuid);
    if (!otherTargets.length) {
        await template.delete();
        await workflow.actor.sheet.maximize();
        return;
    }
    let effectData = {
        'name': 'Piercing Shot - Disadvantage',
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 1
        },
        'changes': [
            {
                'key': 'flags.midi-qol.disadvantage.attack.all',
                'mode': 0,
                'value': '1',
                'priority': 20
            }
        ]
    };
    let effect = await chris.createEffect(workflow.actor, effectData);
    setProperty(weaponData, 'flags.chris-premades.configuration.misfire', -100);
    newWeapon = new CONFIG.Item.documentClass(weaponData, {'parent': workflow.actor});
    for (let i of otherTargets) {
        await warpgate.wait(100);
        options.targetUuids = [i.uuid];
        await MidiQOL.completeItemUse(newWeapon, config, options);
    }
    await template.delete();
    await chris.removeEffect(effect);
    await workflow.actor.sheet.maximize();
}
async function violentShotFeature({speaker, actor, token, character, item, args, scope, workflow}) {
    workflow.options.configureDialog = false;
    workflow.options.consumeResource = false;
    workflow.options.consumeQuantity = false;
    workflow.options.consumeUsage = false;
    let feature = chris.getItem(workflow.actor, 'Adept Marksman');
    if (!feature) return;
    if (!feature.system.uses.value) return;
    let options = [];
    for (let i = 1; i < feature.system.uses.value + 1; i++) options.push([i + ' Grit', i]);
    let selection = await chris.dialog(workflow.item.name, options, 'How many grit?');
    if (!selection) return;
    await feature.update({'system.uses.value': feature.system.uses.value - selection});
    let effectData = {
        'label': 'Violent Shot',
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 1
        },
        'changes': [
            {
                'key': 'flags.midi-qol.onUseMacroName',
                'value': 'function.chrisPremades.macros.trickShots.violentShot,preItemRoll',
                'mode': 0,
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'feature': {
                    'violentShot': selection
                }
            },
            'dae': {
                'specialDuration': [
                    '1Attack'
                ]
            }
        }
    };
    await chris.createEffect(workflow.actor, effectData);
}
async function violentShot({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.item) return;
    let baseItem = workflow.item.system.baseItem;
    if (baseItem != 'firearmCR') return;
    let effect = chris.findEffect(workflow.actor, 'Violent Shot');
    if (!effect) return;
    let misfireBonus = effect.flags?.['chris-premades']?.feature?.violentShot;
    if (!misfireBonus) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'violentShot', 45);
    if (!queueSetup) return;
    let misfireScore = (chris.getConfiguration(workflow.item, 'misfire') ?? 1) + (misfireBonus * 2);
    let damageParts = workflow.item.system.damage.parts;
    if (!damageParts) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let roll = await new Roll(damageParts[0][0]).roll({async: true});
    let faces = roll.terms[0].faces;
    if (!faces) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    damageParts.push([[misfireBonus + 'd' + faces + '[' + damageParts[0][1] + ']'], damageParts[0][1]]);
    workflow.item = workflow.item.clone({'system.damage.parts': damageParts, 'flags.chris-premades.configuration.misfire': misfireScore}, {'keepId': true});
    queue_queue.remove(workflow.item.uuid);
}
let trickShots = {
    'dazingShot': dazingShot,
    'disarmingShot':disarmingShot,
    'forcefulShot': forcefulShot,
    'piercingShot': piercingShot,
    'violentShot': violentShot,
    'violentShotFeature': violentShotFeature,
    'wingingShot': wingingShot
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/troglodyte/troglodyte.js

let troglodyte = {
    'stench': stench
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/troll/regeneration.js


async function regeneration_onHit(workflow, targetToken) {
    if (!workflow.damageRoll || !workflow.hitTargets.has(targetToken)) return;
    let effect = chris.findEffect(targetToken.actor, 'Regeneration');
    if (!effect) return;
    let effect2 = chris.findEffect(targetToken.actor, 'Regeneration Blocked');
    if (effect2) return;
    let originItem = await fromUuid(effect.origin);
    if (!originItem) return;
    let stopHeal = false;
    let reducedHeal = false;
    let hp = targetToken.actor.system.attributes.hp.value;
    let oldHP = workflow.damageList.find(i => i.tokenUuid === targetToken.document.uuid).oldHP;
    for (let i of Object.keys(CONFIG.DND5E.damageTypes).filter(i => i != 'midi-none')) {
        if (chris.getConfiguration(originItem, i) && chris.getRollDamageTypes(workflow.damageRoll).has(i) && !chris.checkTrait(targetToken.actor, 'di', i)) {
            let threshold = chris.getConfiguration(originItem, 'threshold') ?? false;
            if (threshold) {
                if (oldHP != 0) {
                    reducedHeal = true;
                    continue;
                } else {
                    if (chris.totalDamageType(targetToken.actor, workflow.damageDetail, i) >= threshold) {
                        reducedHeal = false;
                        stopHeal = true;
                        break;
                    }
                    reducedHeal = true;
                    continue;
                }
            }
            stopHeal = true;
            reducedHeal = false;
            break;
        }
    }
    if (workflow.isCritical && chris.getConfiguration(originItem, 'critical')) stopHeal = true;
    if (!stopHeal) {
        let effect = chris.findEffect(targetToken.actor, 'Reduced Regeneration');
        if (reducedHeal && !effect) {
            let effectData = {
                'label': 'Reduced Regeneration',
                'icon': originItem.img,
                'duration': {
                    'seconds': 12
                },
                'origin': originItem.uuid
            };
            await chris.createEffect(targetToken.actor, effectData);
        }
        if (chris.getConfiguration(originItem, 'zeroHP')) return;
        if (hp === 0 && chris.inCombat()) {
            let updates = {
                'defeated': false
            };
            await chris.updateCombatant(chris.getCombatant(targetToken), updates);
            let effectData = {
                'icon': 'icons/svg/skull.svg',
                'label': 'Dead?',
                'origin': originItem.uuid,
                'duration': {
                    'seconds': 86400
                },
                'flags': {
                    'core': {
                        'overlay': true
                    }
                }
            };
            await warpgate.wait(200);
            await chris.createEffect(targetToken.actor, effectData);
            if (!chris.findEffect(targetToken.actor, 'Prone')) await chris.addCondition(targetToken.actor, 'Prone', false, originItem.uuid);
        }
        return;
    } else {
        let effect2 = chris.findEffect(targetToken.actor, 'Reduced Regeneration');
        if (effect2) await chris.removeEffect(effect2);
        let hp = targetToken.actor.system.attributes.hp.value;
        if (hp === 0 && chris.inCombat()) {
            let effect = chris.findEffect(targetToken.actor, 'Dead?');
            if (effect) {
                await chris.removeEffect(effect);
                await chris.addCondition(targetToken.actor, 'Dead', true, null);
            }
        }
    }
    let effectData = {
        'label': 'Regeneration Blocked',
        'icon': originItem.img,
        'duration': {
            'seconds': 12
        },
        'origin': originItem.uuid
    };
    await chris.createEffect(targetToken.actor, effectData);
}
async function regeneration_turnStart(token, origin) {
    let hp = token.actor.system.attributes.hp.value;
    if (chris.checkTrait(token.actor, 'di', 'healing')) return;
    let effect2 = chris.findEffect(token.actor, 'Regeneration Blocked');
    if (effect2) {
        if (hp != 0) await chris.removeEffect(effect2);
        return;
    }
    if (chris.getConfiguration(origin, 'zeroHP') && hp === 0) return;
    let effect4 = chris.findEffect(token.actor, 'Reduced Regeneration');
    let featureData = duplicate(origin.toObject());
    delete featureData._id;
    if (effect4) {
        featureData.system.damage.parts[0][0] = '(' + featureData.system.damage.parts[0][0] + ') / 2';
        await chris.removeEffect(effect4);
    }
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': token.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.document.uuid]);
    setProperty(options, 'workflowOptions.allowIncapacitated', true);
    if (hp === 0) {
        let effect3 = chris.findEffect(token.actor, 'Dead?');
        if (effect3) {
            await chris.removeEffect(effect3);
        }
    }
    await MidiQOL.completeItemUse(feature, config, options);
}

let regeneration_regeneration = {
    'onHit': regeneration_onHit,
    'turnStart': regeneration_turnStart
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/troll/troll.js

let troll = {
    'regeneration': regeneration_regeneration
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/cleric/turnUndead.js

async function turnUndead_targets({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size === 0) return;
    let effectData = {
        'label': 'Turn Advantage',
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'duration': {
            'turns': 1
        },
        'changes': [
            {
                'key': 'flags.midi-qol.advantage.ability.save.wis',
                'value': '1',
                'mode': 5,
                'priority': 120
            }
        ],
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    'isSave'
                ],
                'stackable': 'multi',
                'macroRepeat': 'none'
            }
        }
    };
    let effectData2 = {
        'label': 'Turn Immunity',
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'duration': {
            'turns': 1
        },
        'changes': [
            {
                'key': 'flags.midi-qol.min.ability.save.wis',
                'value': '100',
                'mode': 5,
                'priority': 120
            }
        ],
        'flags': {
            'dae': {
                'transfer': false,
                'specialDuration': [
                    'isSave'
                ],
                'stackable': 'multi',
                'macroRepeat': 'none'
            }
        }
    };
    let validTargets = [];
    for (let i of Array.from(workflow.targets)) {
        if (chris.raceOrType(i.actor) != 'undead') continue;
        if (i.actor.system.attributes.hp.value === 0) continue;
        if (i.actor.flags['chris-premades']?.feature?.turnResistance) await chris.createEffect(i.actor, effectData);
        if (i.actor.flags['chris-premades']?.feature?.turnImmunity) await chris.createEffect(i.actor, effectData2);
        validTargets.push(i.id);
    }
    chris.updateTargets(validTargets);
}
async function turnUndead_saves({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size === 0) return;
    let classIdentifier = chris.getConfiguration(workflow.item, 'identifier') ?? 'cleric';
    let clericLevels = workflow.actor.classes[classIdentifier]?.system?.levels;
    if (!clericLevels) return;
    let destroyLevel;
    if (clericLevels >= 17) {
        destroyLevel = 4;
    } else if (clericLevels >= 14) {
        destroyLevel = 3;
    } else if (clericLevels >= 11) {
        destroyLevel = 2;
    } else if (clericLevels >= 8) {
        destroyLevel = 1;
    } else if (clericLevels >= 5) {
        destroyLevel = 0.5;
    }
    if (!destroyLevel) return;
    let destroyTokens = [];
    for (let i of Array.from(workflow.failedSaves)) {
        let CR = i.actor.system.details?.cr;
        if (!CR) continue;
        if (CR > destroyLevel) continue;
        destroyTokens.push(i);
        new Sequence().effect().atLocation(i).file('jb2a.divine_smite.target.blueyellow').play();
    }
    if (destroyTokens.length === 0) return;
    await chris.applyDamage(destroyTokens, '10000', 'none');
}
let turnUndead = {
    'targets': turnUndead_targets,
    'saves': turnUndead_saves
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/cleric/twilightDomain/twilightSanctuary.js



async function twilightSanctuary_turnStart(token, origin) {
    let targetTokenId = game.combat.previous.tokenId;
    if (!targetTokenId) return;
    let targetToken = canvas.scene.tokens.get(targetTokenId);
    if (!targetToken) return;
    if (targetToken.disposition != token.document.disposition) return;
    let distance = await chris.getDistance(token, targetToken);
    if (distance > 30) return;
    let charmedEffect = chris.findEffect(targetToken.actor, 'Charmed');
    let frightenedEffect = chris.findEffect(targetToken.actor, 'Frightened');
    let classLevels = origin.actor.classes.cleric?.system?.levels ?? 0;
    let formula = '1d6[temphp] + ' + classLevels;
    let generatedMenu = [['Gain 1d6 + ' + classLevels + ' temporary HP', 'hp']];
    if (charmedEffect) generatedMenu.push(['Remove the charmed condition', 'Charmed']);
    if (frightenedEffect) generatedMenu.push(['Remove the frightened condition', 'Frightened']);
    generatedMenu.push(['None', false]);
    let ownerId = chris.firstOwner(targetToken).id;
    let selection = await chris.remoteDialog(origin.name, generatedMenu, ownerId, 'What would you like to do?');
    if (!selection) return;
    switch (selection) {
        case 'hp':
            let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Twilight Sanctuary - Temporary HP', false);
            if (!featureData) return;
            delete featureData._id;
            featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Twilight Sanctuary - Temporary HP');
            featureData.system.damage.parts[0][0] = formula;
            let feature = new CONFIG.Item.documentClass(featureData, {'parent': token.actor});
            let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.uuid]);
            let queueSetup = await queue_queue.setup(origin.uuid, 'twilightSanctuary', 50);
            if (!queueSetup) return;
            await warpgate.wait(100);
            await MidiQOL.completeItemUse(feature, config, options);
            queue_queue.remove(origin.uuid);
            break;
        case 'Charmed':
        case 'Frightened':
            await chris.removeCondition(targetToken.actor, selection);
            break;
    }
}
let twilightSanctuary = {
    'turnStart': twilightSanctuary_turnStart
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/cleric/twilightDomain/twilightShroud.js



async function twilightShroud_attack(workflow) {
    if (workflow.targets.size != 1 || !workflow.item || !constants_constants.attacks.includes(workflow.item?.system?.actionType)) return;
    let targetToken = workflow.targets.first();
    let coverBonus = MidiQOL.computeCoverBonus(workflow.token, targetToken, workflow.item);
    if (coverBonus >= 2) return;
    let nearbyShrouds = chris.findNearby(targetToken, 30, 'ally', false, true).filter(i => chris.findEffect(i.actor, 'Channel Divinity: Twilight Sanctuary') && chris.getItem(i.actor, 'Twilight Shroud'));
    if (!nearbyShrouds.length) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'twilightShroud', 150);
    if (!queueSetup) return;
    let updatedRoll = await chris.addToRoll(workflow.attackRoll, -2);
    let feature = chris.getItem(nearbyShrouds[0].actor, 'Twilight Shroud');
    workflow.attackAdvAttribution.add('Half-Cover: ' + feature.name);
    workflow.setAttackRoll(updatedRoll);
    queue_queue.remove(workflow.item.uuid);
}
let saveTargets = [];
async function saveEarly(workflow) {
    if (workflow.item?.system?.save?.ability != 'dex' || !workflow.targets.size) return;
    let effectData = {
        'icon': 'icons/magic/time/arrows-circling-green.webp',
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 1
        },
        'name': 'Dex Cover Bonus',
        'changes': [
            {
                'key': 'system.abilities.dex.bonuses.save',
                'mode': 2,
                'value': '+2',
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'effect': {
                    'noAnimation': true
                }
            }
        }
    };
    for (let i of workflow.targets) {
        let nearbyShrouds = chris.findNearby(i, 30, 'ally', false, true).filter(i => chris.findEffect(i.actor, 'Channel Divinity: Twilight Sanctuary') && chris.getItem(i.actor, 'Twilight Shroud'));
        if (!nearbyShrouds.length) continue;
        await chris.createEffect(i.actor, effectData);
        saveTargets.push(i.actor);
    }
}
async function saveLate(workflow) {
    if (workflow.item?.system?.save?.ability != 'dex' || !workflow.targets.size) return;
    for (let i of saveTargets) {
        let effect = chris.findEffect(i, 'Dex Cover Bonus');
        if (effect) await chris.removeEffect(effect);
    }
    saveTargets = [];
}
let twilightShroud = {
    'attack': twilightShroud_attack,
    'saveEarly': saveEarly,
    'saveLate': saveLate
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/undeadSpirit/festeringAura.js

async function festeringAura(token, origin) {
    let targetToken = game.canvas.tokens.get(game.combat.current.tokenId);
    if (!targetToken) return;
    if (targetToken.id === token.id) return;
    let distance = chris.getDistance(token, targetToken);
    if (distance > 5) return;
    let effect = chris.findEffect(token.actor, 'Summoned Creature');
    if (!effect) return;
    let originItem = await fromUuid(effect.origin);
    if (originItem.actor.id === targetToken.actor.id) return;
    let [config, options] = constants.syntheticItemWorkflowOptions([targetToken.document.uuid]);
    await MidiQOL.completeItemUse(origin, config, options);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/undeadSpirit/rottingClaw.js


async function rottingClaw({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let targetToken = workflow.targets.first();
    let effect = chris.findEffect(targetToken.actor, 'Poisoned');
    if (!effect) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Summon Features', 'Rotting Claw (Putrid Only) - Paralyze', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Rotting Claw (Putrid Only) - Paralyze');
    let spellDC = workflow.item.flags['chris-premades']?.feature?.rottingClaw?.dc;
    if (!spellDC) return;
    featureData.system.save.dc = spellDC;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.document.uuid]);
    await MidiQOL.completeItemUse(feature, config, options);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/undeadSpirit/undeadSpirit.js


let undeadSpirit = {
    'festeringAura': festeringAura,
    'rottingClaw': rottingClaw
}
;// CONCATENATED MODULE: ./scripts/macros/raceFeatures/dhampir/vampiricBite.js

async function vampiricBite({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let selection = await chris.dialog('Fanged Bite', [['Restore HP', 'hp'], ['Skill Bonus', 'skill']]);
    if (!selection) selection = 'hp';
    let damage = chris.totalDamageType(workflow.targets.first().actor, workflow.damageDetail, 'piercing');
    if (!damage) return;
    switch (selection) {
        case 'hp':
            chris.applyDamage(workflow.token, damage, 'healing');
            break;
        case 'skill':
            let effectData = {
                'label': 'Vampiric Bite',
                'icon': workflow.item.img,
                'duration': {
                    'seconds': 86400
                },
                'changes': [
                    {
                        'key': 'system.bonuses.abilities.check',
                        'mode': 2,
                        'value': damage,
                        'priority': 20
                    },
                    {
                        'key': 'system.bonuses.All-Attacks',
                        'mode': 2,
                        'value': damage,
                        'priority': 20
                    }
                ],
                'flags': {
                    'dae': {
                        'specialDuration': [
                            '1Attack',
                            'isSkill'
                        ]
                    }
                }
            };
            await chris.createEffect(workflow.actor, effectData);
            break;
    }
}
;// CONCATENATED MODULE: ./scripts/macros/spells/vampiricTouch.js



async function vampiricTouchItem({speaker, actor, token, character, item, args, scope, workflow}) {
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Vampiric Touch Attack', false);
    if (!featureData) return;
    let spellLevel = workflow.castData.castLevel;
    featureData.system.damage.parts = [
        [
            spellLevel + 'd6[necrotic]',
            'necrotic'
        ]
    ];
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Vampiric Touch Attack');
    featureData.flags['chris-premades'] = {
        'spell': {
            'vampiricTouchAttack': true,
            'castData': workflow.castData
        }
    }
    featureData.flags['chris-premades'].spell.castData.school = workflow.item.system.school;
    async function effectMacro () {
        await warpgate.revert(token.document, 'Vampiric Touch');
    }
    let effectData = {
        'label': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 60
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                }
            }
        }
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [workflow.item.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': workflow.item.name,
        'description': featureData.name
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
    let feature = workflow.actor.items.find(item => item.flags['chris-premades']?.spell?.vampiricTouchAttack);
    if (!feature) return;
    if (workflow.targets.size === 0) return;
    let [config, options2] = constants_constants.syntheticItemWorkflowOptions([workflow.targets.first().document.uuid]);
    await MidiQOL.completeItemUse(feature, config, options2);
}
async function vampiricTouchAttack({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.hitTargets.size != 1) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'vampiricTouchAttack', 450);
    if (!queueSetup) return;
    let damage = chris.totalDamageType(workflow.targets.first().actor, workflow.damageDetail, 'necrotic');
    if (!damage) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    damage = Math.floor(damage / 2);
    await chris.applyDamage([workflow.token], damage, 'healing');
    queue_queue.remove(workflow.item.uuid);
}
let vampiricTouch = {
    'item': vampiricTouchItem,
    'attack': vampiricTouchAttack
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/fighter/gunslinger/viciousIntent.js

async function viciousIntent({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.item?.system?.baseItem != 'firearmCR') return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'viciousIntent', 50);
    if (!queueSetup) return;
    let critical = duplicate(workflow.item.system.critical);
    if ((critical.threshold ?? 20) <= 19) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    critical.threshold = 19;
    workflow.item = workflow.item.clone({'system.critical': critical}, {'keepId': true});
    workflow.item.prepareData();
    workflow.item.prepareFinalAttributes();
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/feats/vigorOfTheHillGiant.js

async function vigorOfTheHillGiant({speaker, actor, token, character, item, args, scope, workflow}) {
    await chris.removeCondition(workflow.actor, 'Prone');
}
;// CONCATENATED MODULE: ./scripts/macros/spells/vortexWarp.js

async function vortexWarp({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.failedSaves.size != 1) return;
    let targetToken = workflow.targets.first();
    let maxRange = 90 + (30 * (workflow.castData.castLevel - 2));
    let icon = targetToken.document.texture.src;
    let interval = targetToken.document.width % 2 === 0 ? 1 : -1;
    await workflow.actor.sheet.minimize();
    let position = await chris.aimCrosshair(workflow.token, maxRange, icon, interval, targetToken.document.width);
    if (position.cancelled) {
        await workflow.actor.sheet.maximize();
        return;
    }
    let animation = chris.getConfiguration(workflow.item, 'animation') ?? 'default';
    if (animation === 'simple' || chris.jb2aCheck() === 'free') {
        await new Sequence()
            .effect()
            .file('jb2a.misty_step.01.blue')
            .atLocation(targetToken)
            .randomRotation()
            .scaleToObject(2)
            .wait(750)
            .animation()
            .on(targetToken)
            .opacity(0.0)
            .waitUntilFinished()
            .play();
        let newCenter = canvas.grid.getSnappedPosition(position.x - targetToken.w / 2, position.y - targetToken.h / 2, 1);
        let targetUpdate = {
            'token': {
                'x': newCenter.x,
                'y': newCenter.y
            }
        };
        let options = {
            'permanent': true,
            'name': workflow.item.name,
            'description': workflow.item.name,
            'updateOpts': {'token': {'animate': false}}
        };
        await warpgate.mutate(targetToken.document, targetUpdate, {}, options);
        await new Sequence()
            .effect()
            .file('jb2a.misty_step.02.blue')
            .atLocation(targetToken)
            .randomRotation()
            .scaleToObject(2)
            .wait(1500)
            .animation()
            .on(targetToken)
            .opacity(1.0)
            .play();
        await warpgate.wait(1000);
    } else {
        //Animations by: eskiemoh
        new Sequence()
            .effect()
            .from(targetToken)
            .duration(1500)
            .scaleOut(0, 500, {'ease': 'easeInOutElastic'})
            .rotateOut(180, 300, {'ease': 'easeOutCubic'})
            .animateProperty('sprite', 'position.y', {'from': 0 , 'to': -0.25, 'gridUnits': true, 'duration': 100, 'delay': 1000})
            .animateProperty('sprite', 'position.y', {'from': -0.25 , 'to': 0, 'gridUnits': true, 'duration': 100, 'delay': 1100})
            
            .animation()
            .delay(100)
            .on(targetToken)
            .opacity(0)
            
            .effect()
            .file('jb2a.particles.outward.white.01.02')
            .scaleIn(0, 500, {ease: 'easeOutQuint'})
            .delay(1000)
            .fadeOut(1000)
            .atLocation(targetToken)
            .duration(1000)
            .size(1.35, {'gridUnits': true})
            .animateProperty('spriteContainer', 'position.y', {'from':0 , 'to': -0.5, 'gridUnits': true, 'duration': 1000})
            .zIndex(1)
            
            .effect()
            .file('jb2a.portals.horizontal.vortex.purple')
            .atLocation(targetToken)
            .scaleToObject(0.5)
            .rotateIn(-360, 500, {'ease': 'easeOutCubic'})
            .rotateOut(360, 500, {'ease': 'easeOutCubic'})
            .scaleIn(0, 600, {'ease': 'easeInOutCirc'})
            .scaleOut(0, 600, {'ease': 'easeOutCubic'})
            .opacity(1)
            .duration(1500)
            .belowTokens()
            .zIndex(0)
            
            .effect()
            .file('jb2a.extras.tmfx.outflow.circle.04')
            .atLocation(targetToken)
            .scaleToObject(2.5)
            .rotateIn(-360, 500, {'ease': 'easeOutCubic'})
            .rotateOut(360, 500, {'ease': 'easeOutCubic'})
            .scaleIn(0, 600, {'ease': 'easeInOutCirc'})
            .scaleOut(0, 600, {'ease': 'easeOutCubic'})
            .fadeOut(1000)
            .opacity(0.2)
            .belowTokens()
            .zIndex(0)
            
            .effect()
            .file('jb2a.template_circle.vortex.intro.purple')
            .atLocation(targetToken)
            .scaleToObject(1.9)
            .rotateIn(-360, 500, {'ease': 'easeOutCubic'})
            .rotateOut(360, 500, {'ease': 'easeOutCubic'})
            .scaleIn(0, 600, {'ease': 'easeInOutCirc'})
            .scaleOut(0, 600, {'ease': 'easeOutCubic'})
            .opacity(1)
            .belowTokens()
            .zIndex(1)
            .waitUntilFinished()
            
            .animation()
            .on(targetToken)
            .teleportTo(position)
            .snapToGrid()
            .offset({'x': -1, 'y': -1 })
            .waitUntilFinished(200)
            
            .effect()
            .file('jb2a.portals.horizontal.vortex.purple')
            .atLocation(targetToken)
            .scaleToObject(0.5)
            .rotateIn(-360, 500, {'ease': 'easeOutCubic'})
            .rotateOut(360, 500, {'ease': 'easeOutCubic'})
            .scaleIn(0, 600, {'ease': 'easeInOutCirc'})
            .scaleOut(0, 600, {'ease': 'easeOutCubic'})
            .opacity(1)
            .duration(1500)
            .belowTokens()
            .zIndex(0)
            
            .effect()
            .file('jb2a.template_circle.vortex.outro.purple')
            .atLocation(targetToken)
            .scaleToObject(1.9)
            .rotateIn(-360, 500, {'ease': 'easeOutCubic'})
            .rotateOut(360, 500, {'ease': 'easeOutCubic'})
            .scaleIn(0, 500, {'ease': 'easeInOutCirc'})
            .scaleOut(0, 500, {'ease': 'easeOutCubic'})
            .opacity(1)
            .belowTokens()
            .zIndex(1)
            
            .effect()
            .file('jb2a.extras.tmfx.outflow.circle.04')
            .atLocation(targetToken)
            .scaleToObject(2.5)
            .rotateIn(-360, 500, {'ease': 'easeOutCubic'})
            .rotateOut(360, 500, {'ease': 'easeOutCubic'})
            .scaleIn(0, 500, {'ease': 'easeInOutCirc'})
            .scaleOut(0, 500, {'ease': 'easeOutCubic'})
            .opacity(0.2)
            .fadeOut(1000)
            .belowTokens()
            .zIndex(0)
            
            .effect()
            .file('jb2a.particles.outward.white.01.02')
            .delay(250)
            .scaleIn(0, 500, {'ease': 'easeOutQuint'})
            .fadeOut(1000)
            .atLocation(targetToken)
            .duration(1000)
            .size(1.35, {'gridUnits': true})
            .animateProperty('spriteContainer', 'position.y', {'from':0 , 'to': -0.5, 'gridUnits': true, 'duration': 1000})
            .zIndex(1)
            
            .effect()
            .from(targetToken)
            .delay(250)
            .atLocation(targetToken)
            .duration(1500)
            .scaleIn({'x': 0.2, 'y': 0 }, 1000, {'ease': 'easeOutElastic'})
            .rotateIn(360, 500, {ease: 'easeOutCubic'})
            .animateProperty('spriteContainer', 'position.y', {'from':0 , 'to': -0.5, 'gridUnits': true, 'duration': 200})
            .animateProperty('spriteContainer', 'position.y', {'from':-0.5 , 'to': 0, 'gridUnits': true, 'duration': 200, 'delay': 200})
            .waitUntilFinished(-200)
            
            .animation()
            .on(targetToken)
            .opacity(1)
            
            .play();
        await warpgate.wait(4000);
    }
    await workflow.actor.sheet.maximize();
}
;// CONCATENATED MODULE: ./scripts/macros/items/wandOfTheWarMage.js


async function wandOfTheWarMage({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!workflow.targets.size) return;
    let validTypes = ['rsak', 'msak'];
    if (!validTypes.includes(workflow.item.system.actionType)) return;
    if (game.settings.get('midi-qol', 'ConfigSettings').optionalRules.coverCalculation === 'none') return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'wandOfTheWarMage', 150);
    if (!queueSetup) return;
    let coverBonus = MidiQOL.computeCoverBonus(workflow.token, workflow.targets.first(), workflow.item);
    if (coverBonus != 2) {
        queue_queue.remove(workflow.item.uuid);
        return;
    }
    let updatedRoll = await chris.addToRoll(workflow.attackRoll, 2);
    workflow.setAttackRoll(updatedRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/wardingBond.js


async function wardingBond_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size != 1) return;
    let effect = chris.findEffect(workflow.targets.first().actor, 'Warding Bond - Target');
    if (effect) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Dismiss Warding Bond', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Dismiss Warding Bond');
    let targetToken = workflow.targets.first();
    featureData.name = 'Dismiss Warding Bond: ' + targetToken.actor.name;
    setProperty(featureData, 'flags.chris-premades.spell.wardingBond.targetUuid', targetToken.document.uuid);
    let effectData = {
        'name': 'Warding Bond: ' + targetToken.actor.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 3600
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': 'await warpgate.revert(token.document, "Warding Bond: ' + targetToken.uuid + '");'
                }
            },
            'chris-premades': {
                'vae': {
                    'button': featureData.name
                },
                'spell': {
                    'wardingBond': {
                        'targetUuid': targetToken.document.uuid
                    }
                }
            }
        },
        'transfer': true
    };
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            },
            'ActiveEffect': {
                [effectData.name]: effectData
            }
        }
    };
    let options = {
        'permanent': false,
        'name': 'Warding Bond: ' + targetToken.uuid,
        'description': featureData.name
    };
    await warpgate.mutate(workflow.token.document, updates, {}, options);
    let effectData2 = {
        'name': 'Warding Bond - Target',
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 3600
        },
        'changes': [
            {
                'key': 'system.attributes.ac.bonus',
                'mode': 2,
                'value': '+1',
                'priority': 20
            },
            {
                'key': 'system.bonuses.abilities.save',
                'mode': 2,
                'value': '+1',
                'priority': 20
            },
            {
                'key': 'system.traits.dr.all',
                'mode': 0,
                'value': '1',
                'priority': 20
            },
            {
                'key': 'flags.chris-premades.spell.wardingBond.sourceUuid',
                'mode': 5,
                'value': workflow.token.document.uuid,
                'priority': 20
            },
            {
                'key': 'flags.chris-premades.feature.onHit.wardingBond',
                'mode': 5,
                'value': true,
                'priority': 20
            }
        ],
        'transfer': true
    };
    await chris.createEffect(workflow.targets.first().actor, effectData2);
}
async function wardingBond_dismiss({speaker, actor, token, character, item, args, scope, workflow}) {
    let targetTokenUuid = workflow.item.flags['chris-premades']?.spell?.wardingBond?.targetUuid;
    if (!targetTokenUuid) return;
    let targetToken = await fromUuid(targetTokenUuid);
    if (!targetToken) return;
    let targetEffect = chris.findEffect(targetToken.actor, 'Warding Bond - Target');
    if (targetEffect) await chris.removeEffect(targetEffect);
    let sourceEffect = chris.findEffect(workflow.actor, 'Warding Bond: ' + targetToken.actor.name);
    if (!sourceEffect) return;
    await chris.removeEffect(sourceEffect);
}
async function wardingBond_onHit(workflow, targetToken) {
    if (workflow.hitTargets.size === 0 || !workflow.damageList) return;
    let effect = chris.findEffect(targetToken.actor, 'Warding Bond - Target');
    if (!effect) return;
    let bondTokenUuid = targetToken.actor.flags['chris-premades']?.spell?.wardingBond?.sourceUuid;
    if (!bondTokenUuid) return;
    let damageInfo = workflow.damageList.find(list => list.actorId === targetToken.actor.id);
    if (!damageInfo) return;
    if (damageInfo.appliedDamage === 0) return;
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Spell Features', 'Warding Bond - Damage', false);
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Warding Bond - Damage');
    featureData.system.damage.parts = [
        [
            damageInfo.appliedDamage + '[none]',
            'none'
        ]
    ];
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': targetToken.actor});
    let sourceToken = await fromUuid(bondTokenUuid);
    if (!sourceToken) return;
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([sourceToken.uuid]);
    let damageWorkflow = await MidiQOL.completeItemUse(feature, config, options);
    if (damageWorkflow.targets.first().actor.system.attributes.hp.value != 0) return;
    await chris.removeEffect(effect);
    let sourceEffect = sourceToken.actor.effects.find(eff => eff.flags['chris-premades']?.spell?.wardingBond?.targetUuid === targetToken.document.uuid);
    if (!sourceEffect) return;
    await chris.removeEffect(sourceEffect);
}
async function moveTarget(token, changes) {
    if (!chris.isLastGM()) return;
    if (token.parent.id != canvas.scene.id) return;
    if (!changes.x && !changes.y && !changes.elevation) return;
    let effect = chris.findEffect(token.actor, 'Warding Bond - Target');
    if (!effect) return;
    let bondTokenUuid = token.actor.flags['chris-premades']?.spell?.wardingBond?.sourceUuid;
    if (!bondTokenUuid) return;
    let sourceToken = await fromUuid(bondTokenUuid);
    if (!sourceToken) return;
    await token.object?._animation;
    let distance = chris.getDistance(token, sourceToken);
    if (distance <= 60) return;
    let selection = await chris.dialog('Warding Bond: Distance over 60 feet, remove effect?', constants_constants.yesNo);
    if (!selection) return;
    await chris.removeEffect(effect);
    let sourceEffect = sourceToken.actor.effects.find(eff => eff.flags['chris-premades']?.spell?.wardingBond?.targetUuid === token.uuid);
    if (!sourceEffect) return;
    await chris.removeEffect(sourceEffect);
}
async function moveSource(token, changes) {
    if (game.settings.get('chris-premades', 'LastGM') != game.user.id) return;
    if (!changes.x && !changes.y && !changes.elevation) return;
    let effects = token.actor.effects.filter(eff => eff.flags['chris-premades']?.spell?.wardingBond?.targetUuid);
    if (effects.length === 0) return;
    for (let i of effects) {
        let targetToken = await fromUuid(i.flags['chris-premades']?.spell?.wardingBond?.targetUuid);
        if (!targetToken) continue;
        let distance = chris.getDistance(token, targetToken);
        if (distance <= 60) continue;
        let selection = await chris.dialog('Warding Bond: Distance over 60 feet, remove effect?', constants_constants.yesNo);
        if (!selection) continue;
        await chris.removeEffect(i);
        let targetEffect = chris.findEffect(targetToken.actor, 'Warding Bond - Target');
        if (!targetEffect) continue;
        await chris.removeEffect(targetEffect);
    }
}
let wardingBond = {
    'item': wardingBond_item,
    'onHit': wardingBond_onHit,
    'moveTarget': moveTarget,
    'moveSource': moveSource,
    'dismiss': wardingBond_dismiss
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/druid/wildshape.js


async function wildshape_item({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!game.modules.get('quick-insert')?.active) {
        ui.notifications.warn('This feature requires the Quick Insert module to be active!');
        return;
    }
    let mutationStack = warpgate.mutationStack(workflow.token.document);
    let mutateItem = mutationStack.getName('Wild Shape');
    if (mutateItem) {
        ui.notifications.warn('Revert forms before using this feature again!');
        return;
    }
    let filter = 'wildshape';
    if (workflow.actor.flags['chris-premades']?.feature?.wildshape?.moon) filter = 'wildshape-moon';
    let customFilter = workflow.actor.flags['chris-premades']?.feature?.wildshape?.custom;
    if (customFilter) filter = customFilter;
    let selectedActor;
    if (!QuickInsert.hasIndex) await QuickInsert.forceIndex();
    QuickInsert.open({
        'allowMultiple': false,
        'restrictTypes': ['Actor'],
        'filter': filter,
        'onSubmit': async (selected) => {
            if (!selected) return;
            if (selected.uuid === workflow.item.actor.uuid) {
                ui.notifications.warn('You cannot Wild Shape into yourself!');
                return;
            }
            selectedActor = await fromUuid(selected.uuid);
            if (selectedActor.compendium) {
                ui.notifications.warn('The actor must not be in a compendium!');
                return;
            }
            if (!selectedActor) return;
            let equipedItems = workflow.actor.items.filter(i => i.system.equipped);
            let selection;
            if (equipedItems.length > 0) {
                let options = [
                    'Merge / Drop',
                    'Wear'
                ];
                function dialogRender(html) {
                    let ths = html[0].getElementsByTagName('th');
                    for (let t of ths) {
                        t.style.width = 'auto';
                        t.style.textAlign = 'left';
                    }
                    let tds = html[0].getElementsByTagName('td');
                    for (let t of tds) {
                        t.style.width = '50px';
                        t.style.textAlign = 'center';
                        t.style.paddingRight = '5px';
                    }
                }
                let config = {
                    'title': 'What happens to your equipment?',
                    'render': dialogRender
                };
                let generatedInputs = [];
                for (let i of equipedItems) {
                    generatedInputs.push({
                        'label': i.name,
                        'type': 'select',
                        'options': options,
                        'value': i.uuid
                    });
                }
                selection = await warpgate.menu(
                    {
                        'inputs': generatedInputs,
                        'buttons': constants_constants.okCancel
                    },
                    config
                );
                if (!selection) return;
            }
            let wildshapeActor = selectedActor.toObject();
            delete wildshapeActor.token;
            delete wildshapeActor.items;
            delete wildshapeActor.effects;
            delete wildshapeActor.type;
            delete wildshapeActor.flags;
            delete wildshapeActor.folder;
            delete wildshapeActor.name;
            delete wildshapeActor.sort;
            delete wildshapeActor._id;
            delete wildshapeActor._stats;
            delete wildshapeActor.ownership;
            let texture = wildshapeActor.prototypeToken.texture;
            let wildshapeToken = {
                'name': selectedActor.name + ' (' + workflow.actor.name + ')',
                'texture': texture,
                'width': wildshapeActor.prototypeToken.width,
                'height': wildshapeActor.prototypeToken.height
            }
            wildshapeActor.prototypeToken = wildshapeToken;
            wildshapeActor.system.abilities.cha = workflow.actor.system.abilities.cha;
            wildshapeActor.system.abilities.int = workflow.actor.system.abilities.int;
            wildshapeActor.system.abilities.wis = workflow.actor.system.abilities.wis;
            wildshapeActor.system.attributes.prof = workflow.actor.system.attributes.prof;
            delete wildshapeActor.system.attributes.attunement;
            delete wildshapeActor.system.attributes.death;
            delete wildshapeActor.system.attributes.encumbrance;
            delete wildshapeActor.system.attributes.exhuastion;
            delete wildshapeActor.system.attributes.hd;
            delete wildshapeActor.system.attributes.init;
            delete wildshapeActor.system.attributes.inspiration;
            delete wildshapeActor.system.attributes.spellcasting;
            delete wildshapeActor.system.attributes.spelldc;
            delete wildshapeActor.system.bonuses;
            delete wildshapeActor.system.currency;
            delete wildshapeActor.system.details;
            delete wildshapeActor.system.resources;
            delete wildshapeActor.system.scale;
            let sourceSkills = workflow.actor.system.skills;
            let targetSkills = selectedActor.system.skills;
            let skills = {};
            for (let i of Object.keys(sourceSkills)) {
                if (targetSkills[i].proficient > sourceSkills[i].proficient) skills[i] = {'value': targetSkills[i].proficient};
            }
            wildshapeActor.system.skills = skills;
            delete wildshapeActor.system.tools;
            wildshapeActor.system.traits = {
                'size': selectedActor.system.traits.size
            };
            delete wildshapeActor.system.spells;
            let mutateOptions = {
                'name': 'Wild Shape',
            }
            async function effectMacro() {
                await warpgate.revert(token.document, 'Wild Shape');
            }
            let druidLevels = workflow.actor.classes.druid?.system?.levels;
            if (!druidLevels) return;
            let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Wild Shape - Revert', false);
            if (!featureData) return;
            featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Wild Shape - Revert');
            let effectData = {
                'name': 'Wild Shape',
                'icon': workflow.item.img,
                'duration': {
                    'seconds': Math.min(druidLevels / 2) * 3600
                },
                'changes': [
                    {
                        'key': 'flags.midi-qol.fail.spell.vocal',
                        'value': '1',
                        'mode': 0,
                        'priority': 20
                    },
                    {
                        'key': 'flags.midi-qol.fail.spell.somatic',
                        'value': '1',
                        'mode': 0,
                        'priority': 20
                    },
                    {
                        'key': 'flags.midi-qol.fail.spell.material',
                        'value': '1',
                        'mode': 0,
                        'priority': 20
                    }
                ],
                'origin': workflow.item.uuid,
                'flags': {
                    'effectmacro': {
                        'onDelete': {
                            'script': chris.functionToString(effectMacro)
                        }
                    },
                    'chris-premades': {
                        'vae': {
                            'button': featureData.name
                        }
                    }
                },
                'transfer': true
            };
            if (druidLevels === 20) delete effectData.changes;
            let invalidTypes = [
                'weapon',
                'equipment',
                'consumable',
                'tool',
                'container',
                'loot',
                'backpack'
            ];
            let items = workflow.actor.items.filter(i => invalidTypes.includes(i.type) && !i.system.equipped);
            let itemUpdates = {};
            for (let i of items) {
                itemUpdates[i.name] = warpgate.CONST.DELETE
            }
            if (selection) {
                for (let i = 0; selection.inputs.length > i; i++) {
                    if (selection.inputs[i] === 'Merge / Drop') {
                        itemUpdates[equipedItems[i].name] = warpgate.CONST.DELETE;
                    }
                }
            }
            let primalStrike = workflow.actor.flags['chris-premades']?.feature?.primalStrike;
            let insigniaOfClaws = workflow.actor.flags['chris-premades']?.item?.insigniaOfClaws;
            let targetItems = selectedActor.items.contents;
            for (let i of targetItems) {
                itemUpdates[i.name] = i.toObject();
                if (primalStrike && itemUpdates[i.name].type === 'weapon') setProperty(itemUpdates[i.name], 'system.properties.mgc', true);
                if (insigniaOfClaws && itemUpdates[i.name].type === 'weapon') {
                    try {
                        itemUpdates[i.name].system.damage.parts[0][0] += ' + 1';
                    } catch (error) {}
                    itemUpdates[i.name].system.attackBonus = 1;
                }
                itemUpdates[i.name].flags['tidy5e-sheet'] = {'favorite': true};
                if (invalidTypes.includes(itemUpdates[i.name].type)) continue;
                itemUpdates[i.name].flags['custom-character-sheet-sections'] = {'sectionName': 'Wild Shape'}
            }
            itemUpdates[featureData.name] = featureData;
            let updates = {
                'token': wildshapeToken,
                'actor': wildshapeActor,
                'embedded': {
                    'Item': itemUpdates,
                    'ActiveEffect': {
                        [effectData.name]: effectData
                    }
                }
            }
            await warpgate.mutate(workflow.token.document, updates, {}, mutateOptions);
        }
    });
}
async function wildshape_hook() {
    //handle rollover damage
}
async function revert({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.token.actor, 'Wild Shape');
    if (!effect) return;
    await chris.removeEffect(effect);
}
let wildShape = {
    'item': wildshape_item,
    'hook': wildshape_hook,
    'revert': revert
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/barbarian/wildMagic/wildSurge.js



let choices = [
    'Shadowy Tendrils',
    'Teleport',
    'Intangible Spirit',
    'Magic Infusion',
    'Retribution',
    'Protective Lights',
    'Flowers and Vines',
    'Bolt of Light'
];
async function wildSurge_item({speaker, actor, token, character, item, args, scope, workflow}) {
    let effect = chris.findEffect(workflow.actor, 'Wild Surge');
    if (effect) {
        await chris.removeEffect(effect);
        await warpgate.wait(100);
    }
    let rollFormula = '1d8';
    let controlledSurge = chris.getItem(workflow.actor, 'Controlled Surge');
    if (controlledSurge) rollFormula = '2d8';
    let roll = await new Roll(rollFormula).roll({async: true});
    roll.toMessage({
        rollMode: 'roll',
        speaker: {'alias': name},
        flavor: workflow.item.name
    });
    let selection;
    if (controlledSurge) {
        let roll1 = roll.terms[0].values[0] - 1;
        let roll2 = roll.terms[0].values[1] - 1;
        if (roll1 === roll2) {
            selection = await chris.dialog(workflow.item.name, choices.map(i => [i, i]), 'Which effect?');
        } else {
            selection = await chris.dialog(workflow.item.name, [[choices[roll1], choices[roll1]], [choices[roll2], choices[roll2]]], 'Which effect?');
        }
    } else {
        selection = choices[roll.total - 1];
    }
    let effectData;
    let featureData;
    let feature;
    let options = {
        'permanent': false,
        'name': 'Wild Surge',
        'description': 'Wild Surge'
    };
    async function effectMacro() {
        await warpgate.revert(token.document, 'Wild Surge');
    }
    async function doMutate(featureName) {
        let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Wild Surge - ' + featureName);
        if (!featureData) return;
        featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Wild Surge - ' + featureName);
        delete featureData._id;
        let effectData = {
            'name': 'Wild Surge',
            'icon': workflow.item.img,
            'origin': workflow.item.uuid,
            'duration': {
                'seconds': 60
            },
            'flags': {
                'effectmacro': {
                    'onDelete': {
                        'script': chris.functionToString(effectMacro)
                    }
                },
                'chris-premades': {
                    'vae': {
                        'button': featureData.name
                    }
                }
            }
        };
        let updates = {
            'embedded': {
                'Item': {
                    [featureData.name]: featureData
                },
                'ActiveEffect': {
                    [effectData.name]: effectData
                }
            }
        };
        await warpgate.mutate(workflow.token.document, updates, {}, options);
    }
    switch(selection) {
        case 'Shadowy Tendrils':
            featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Wild Surge - Shadowy Tendrils');
            if (!featureData) return;
            featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Wild Surge - Shadowy Tendrils');
            delete featureData._id;
            feature = new CONFIG.Item.documentClass(featureData, {'parent': workflow.actor});
            await warpgate.wait(100);
            await feature.use();
            let tRoll = await new Roll('1d12[temphp]').roll({async: true});
            tRoll.toMessage({
                rollMode: 'roll',
                speaker: {'alias': name},
                flavor: featureData.name
            });
            await chris.applyDamage([workflow.token], tRoll.total, 'temphp');
            return;
        case 'Teleport':
            await doMutate('Teleport');
            feature = workflow.actor.items.getName('Wild Surge - Teleport');
            if (feature) await feature.use();
            return;
        case 'Intangible Spirit':
            await doMutate('Intangible Spirit');
            feature = workflow.actor.items.getName('Wild Surge - Intangible Spirit');
            if (feature) await feature.use();
            return;
        case 'Magic Infusion':
            let weapons = workflow.actor.items.filter(i => i.type === 'weapon');
            if (!weapons.length) return;
            let weapon;
            if (weapons.length === 1) {
                weapon = weapons[0];
            } else {
                [weapon] = await chris.selectDocument('What weapon?', weapons);
                if (!weapon) return;
            }
            let damage = duplicate(weapon.toObject()).system.damage;
            for (let i = 0; i < damage.parts.length; i++) {
                damage.parts[i] = [
                    damage.parts[i][0].replaceAll(damage.parts[i][1], 'force'),
                    damage.parts[i][1] = 'force'
                ];
            }
            let versatile = weapon.system.damage.versatile.toLowerCase();
            if (versatile != '') {
                let flavors = new Set();
                let versatileRoll = await new Roll(weapon.system.damage.versatile, workflow.actor.getRollData()).evaluate({'async': true});
                for (let i of versatileRoll.terms) {
                    if (i.flavor != '') flavors.add(i.flavor);
                }
                for (let i of Array.from(flavors)) {
                    versatile = versatile.replaceAll(i, 'force');
                }
                damage.versatile = versatile;
            }
            effectData = {
                'name': 'Wild Surge',
                'icon': workflow.item.img,
                'origin': workflow.item.uuid,
                'duration': {
                    'seconds': 60
                },
                'flags': {
                    'effectmacro': {
                        'onDelete': {
                            'script': chris.functionToString(effectMacro)
                        }
                    },
                    'chris-premades': {
                        'vae': {
                            'button': weapon.name
                        }
                    }
                }
            };
            let updates = {
                'embedded': {
                    'Item': {
                        [weapon.name]: {
                            'system': {
                                'damage': damage,
                                'properties': {
                                    'thr': true,
                                    'lgt': true
                                },
                                'range': {
                                    'long': 60,
                                    'value': 20
                                }
                            }
                        }
                    },
                    'ActiveEffect': {
                        [effectData.name]: effectData
                    }
                }
            };
            await warpgate.mutate(workflow.token.document, updates, {}, options);
            return;
        case 'Retribution':
            await doMutate('Retribution');
            return;
        case 'Protective Lights':
            effectData = {
                'icon': workflow.item.img,
                'origin': workflow.item.uuid,
                'duration': {
                    'seconds': 60
                },
                'name': 'Wild Surge',
                'changes': [
                    {
                        'key': 'flags.chris-premades.aura.protectiveLights.name',
                        'mode': 5,
                        'value': 'protectiveLights',
                        'priority': 20
                    },
                    {
                        'key': 'flags.chris-premades.aura.protectiveLights.castLevel',
                        'mode': 5,
                        'value': 1,
                        'priority': 20
                    },
                    {
                        'key': 'flags.chris-premades.aura.protectiveLights.range',
                        'mode': 5,
                        'value': '10',
                        'priority': 20
                    },
                    {
                        'key': 'flags.chris-premades.aura.protectiveLights.disposition',
                        'mode': 5,
                        'value': 'ally',
                        'priority': 20
                    },
                    {
                        'key': 'flags.chris-premades.aura.protectiveLights.effectName',
                        'mode': 5,
                        'value': 'Wild Surge - Protective Lights',
                        'priority': 20
                    },
                    {
                        'key': 'flags.chris-premades.aura.protectiveLights.macroName',
                        'mode': 5,
                        'value': 'protectiveLights',
                        'priority': 20
                    }
                ],
                flags: {
                    'effectmacro': {
                        'onDelete': {
                            'script': 'await chrisPremades.macros.wildSurge.protectiveLights.end(token);'
                        }
                    }
                }
            };
            let flagAuras = {
                'protectiveLights': {
                    'name': 'protectiveLights',
                    'castLevel': 1,
                    'range': 10,
                    'disposition': 'ally',
                    'effectName': 'Wild Surge - Protective Lights',
                    'macroName': 'protectiveLights'
                }
            }
            await chris.createEffect(workflow.actor, effectData);
            effectAuras.add(flagAuras, workflow.token.document.uuid, true);
            return;
        case 'Flowers and Vines':
            let templateData = {
                't': 'circle',
                'x': workflow.token.center.x,
                'y': workflow.token.center.y,
                'distance': 15,
                'direction': 0,
                'angle': 0,
                'user': game.user,
                'fillColor': game.user.color
            }
            let template = await chris.createTemplate(templateData);
            await warpgate.wait(200);
            await tokenAttacher.attachElementsToToken([template], workflow.token, false);
            effectData = {
                'icon': workflow.item.img,
                'origin': workflow.item.uuid,
                'duration': {
                    'seconds': 60
                },
                'name': 'Wild Surge',
                'flags': {
                    'effectmacro': {
                        'onDelete': {
                            'script': 'let template = await fromUuid("' + template.uuid + '"); if (template) await template.delete();'
                        }
                    }
                }
            };
            await chris.createEffect(workflow.actor, effectData);
            return;
        case 'Bolt of Light':
            await doMutate('Bolt of Light');
            feature = workflow.actor.items.getName('Wild Surge - Bolt of Light');
            if (feature) {
                let targets;
                let nearbyTargets = chris.findNearby(workflow.token, 30, 'enemy', true);
                if (!nearbyTargets.length) return;
                if (nearbyTargets.length === 1) {
                    targets = [nearbyTargets[0].uuid];
                } else {
                    let selection = await await chris.selectTarget(feature.name, constants_constants.okCancel, nearbyTargets, true, 'one', false, false, 'Select a target:');
                    if (!selection.buttons) return;
                    targets = selection.inputs.filter(i => i);
                }
                let [config, options] = constants_constants.syntheticItemWorkflowOptions(targets);
                await MidiQOL.completeItemUse(feature, config, options);
            }
            return;
    }
}
async function protectiveLightsEnd(token) {
    effectAuras.remove('protectiveLights', token.document.uuid);
}
async function protectiveLightsAura(token, selectedAura) {
    let originToken = await fromUuid(selectedAura.tokenUuid);
    if (!originToken) return;
    let originActor = originToken.actor;
    let auraEffect = chris.findEffect(originActor, 'Wild Surge');
    if (!auraEffect) return;
    let originItem = await fromUuid(auraEffect.origin);
    if (!originItem) return;
    let effectData = {
        'name': 'Wild Surge - Protective Lights',
        'icon': originItem.img,
        'origin': originItem.uuid,
        'duration': {
            'seconds': 604800
        },
        'changes': [
            {
                'key': 'system.attributes.ac.bonus',
                'mode': 2,
                'value': '+1',
                'priority': 20
            }
        ],
        'flags': {
            'chris-premades': {
                'aura': true,
                'effect': {
                    'noAnimation': true
                }
            }
        }
    };
    let effect = chris.findEffect(token.actor, effectData.name);
    if (effect?.origin === effectData.origin) return;
    if (effect) await chris.removeEffect(effect);
    await chris.createEffect(token.actor, effectData);
}
async function intangibleSpirit({speaker, actor, token, character, item, args, scope, workflow}) {
    let sourceActor = game.actors.getName('CPR - Intangible Spirit');
    if (!sourceActor) return;
    let tokenDocument = await sourceActor.getTokenDocument();
    let options = {
        'controllingActor': workflow.actor,
        'crosshairs': {
            'interval': tokenDocument.width % 2 === 0 ? 1 : -1
        }
    };
    let featureData = await chris.getItemFromCompendium('chris-premades.CPR Class Feature Items', 'Wild Surge - Intangible Spirit Explode');
    if (!featureData) return;
    featureData.system.description.value = chris.getItemDescription('CPR - Descriptions', 'Wild Surge - Intangible Spirit Explode');
    featureData.system.save.dc = chris.getSpellDC(workflow.item);
    let updates = {
        'embedded': {
            'Item': {
                [featureData.name]: featureData
            }
        }
    };
    let type = await chris.dialog(workflow.item.name, [['Flumph', 'flumph'], ['Pixie', 'pixie']], 'What form does the intangible spirit take?') ?? 'flumph';
    let originItem = chris.getItem(workflow.actor, 'Wild Surge');
    if (!originItem) return;
    let avatarImg = chris.getConfiguration(originItem, type + '-avatar');
    let tokenImg = chris.getConfiguration(originItem, type + '-token');
    if (avatarImg) setProperty(updates, 'actor.img', avatarImg);
    if (tokenImg) {
        setProperty(updates, 'actor.prototypeToken.texture.src', tokenImg);
        setProperty(updates, 'token.texture.src', tokenImg);
    }
    let spawnedTokens = await warpgate.spawn(tokenDocument, updates, {}, options);
    if (!spawnedTokens) return;
    let spawnedToken = game.canvas.scene.tokens.get(spawnedTokens[0]);
    if (!spawnedToken) return;
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 6
        },
        'flags': {
            'effectmacro': {
                'onTurnEnd': {
                    'script': 'let token = await fromUuid("' + spawnedToken.uuid + '"); if (!token) return; let feature = token.actor.items.getName("Wild Surge - Intangible Spirit Explode"); if (feature) await feature.use(); await warpgate.dismiss("' + spawnedToken.id + '"); await effect.delete();'
                }
            }
        }
    };
    await chris.createEffect(workflow.actor, effectData);
}
async function retribution(workflow, token) {
    if (!constants_constants.attacks.includes(workflow.item.system.actionType)) return;
    if (workflow.hitTargets.size != 1) return;
    let feature = token.actor.items.getName('Wild Surge - Retribution');
    if (!feature) return;
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([workflow.token.document.uuid]);
    await warpgate.wait(100);
    await MidiQOL.completeItemUse(feature, config, options);
}
let wildSurge = {
    'item': wildSurge_item,
    'intangibleSpirit': intangibleSpirit,
    'retribution': retribution,
    'protectiveLights': {
        'end': protectiveLightsEnd,
        'aura': protectiveLightsAura
    }
}
;// CONCATENATED MODULE: ./scripts/macros/raceFeatures/shifter/wildhunt.js


async function wildhunt(workflow) {
    if (workflow.targets.size === 0 || workflow.disadvanage) return;
    let targetToken = workflow.targets.first();
    let targetActor = targetToken.actor;
    let effect = chris.findEffect(targetActor, 'Wildhunt');
    if (!effect) return;
    let distance = chris.getDistance(workflow.token, targetToken);
    if (distance > 30) return;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'wildhunt', 50);
    if (!queueSetup) return;
    workflow.advantage = false;
    workflow.rollOptions.advantage = false;
    workflow.flankingAdvantage = false;
    workflow.attackAdvAttribution.add('Wildhunt');
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/spells/witherAndBloom.js

async function witherAndBloom({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size === 0) return;
    let healTargets = [];
    for (let target of workflow.damageList) {
        let targetToken = await fromUuid(target.tokenUuid);
        if (workflow.token.document.disposition != targetToken.disposition) continue;
        target.damageDetail = [
            {
                'damage': 0,
                'type': 'necrotic'
            }
        ];
        target.totalDamage = 0;
        target.newHP = target.oldHP;
        target.hpDamage = 0;
        target.appliedDamage = 0;
        healTargets.push(targetToken.object);
    }
    if (healTargets.length === 0) return;
    let buttons = [
        {
            'label': 'Yes',
            'value': true
        }, {
            'label': 'No',
            'value': false
        }
    ];
    let selection = await chris.selectTarget('Heal a target?', buttons, healTargets, true, 'one');
    if (!selection.buttons) return;
    let targetTokenUuid = selection.inputs.find(id => id != false);
    if (!targetTokenUuid) return;
    async function effectMacro () {
        if (actor.type != 'character') {
            effect.delete();
            return;
        }
        let classDice = [];
        let classes = actor.classes;
        for (let [key, value] of Object.entries(classes)) {
            let hitDiceAvailable = value.system.levels - value.system.hitDiceUsed;
            if (hitDiceAvailable != 0) classDice.push({
                'class': key,
                'hitDice': value.system.hitDice,
                'available': hitDiceAvailable,
                'max': value.system.levels
            });
        }
        if (classDice.length === 0) {
            effect.delete();
            return;
        }
        let inputs = [];
        let outputs = [];
        for (let i of classDice) {
            inputs.push(i.class + ' (' + i.hitDice + ') [' + i.available + '/' + i.max + ']:');
            outputs.push(
                {
                    'class': i.class,
                    'dice': i.hitDice
                }
            );
        }
        let buttons = [
            {
                'label': 'Yes',
                'value': true
            }, {
                'label': 'No',
                'value': false
            }
        ];
        let maxHitDice = effect.flags['chris-premades'].spell.witherAndBloom.castLevel;
        let selection = await chrisPremades.helpers.numberDialog('Heal using hit dice? Max: ' + maxHitDice, buttons, inputs);
        if (!selection.buttons) {
            effect.delete();
            return;
        }
        let selectedTotal = 0;
        let healingFormula = '';
        for (let i = 0; selection.inputs.length > i; i++) {
            if (isNaN(selection.inputs[i])) continue;
            selectedTotal += selection.inputs[i];
            healingFormula = healingFormula + selection.inputs[i] + outputs[i].dice + '[healing] + ';
        }
        if (selectedTotal > maxHitDice) {
            ui.notifications.info('Too many hit dice selected!');
            effect.delete();
            return;
        }
        let conMod = actor.system.abilities.con.mod;
        let spellcastingMod = chrisPremades.helpers.getSpellMod(origin);
        healingFormula = healingFormula + '(' + selectedTotal + ' * ' + conMod + ') + ' + spellcastingMod;
        let healingRoll = await new Roll(healingFormula).roll({async: true});
        let itemCardId = effect.flags['chris-premades'].spell.witherAndBloom.itemCardId;
        await chrisPremades.helpers.applyWorkflowDamage(token, healingRoll, 'healing', [token], origin.name, itemCardId);
        for (let i = 0; selection.inputs.length > i; i++) {
            if (isNaN(selection.inputs[i])) continue;
            await actor.classes[outputs[i].class].update({
                'system.hitDiceUsed': actor.classes[outputs[i].class].system.hitDiceUsed + selection.inputs[i]
            });
        }
        effect.delete();
    }
    let effectData = {
        'label': workflow.item.name,
        'icon': workflow.item.img,
        'duration': {
            'seconds': 6
        },
        'origin': workflow.item.uuid,
        'flags': {
            'effectmacro': {
                'onCreate': {
                    'script': chris.functionToString(effectMacro)
                }
            },
            'chris-premades': {
                'spell': {
                    'witherAndBloom': {
                        'castLevel': workflow.castData.castLevel - 1,
                        'itemCardId': workflow.itemCardId
                    }
                }
            }
        }
    };
    let targetToken = await fromUuid(targetTokenUuid);
    await chris.createEffect(targetToken.actor, effectData);
}
;// CONCATENATED MODULE: ./scripts/macros/items/wrapsOffDyamak.js



let strikeUsed = false;
async function wrapsOffDyamak_rest(actor ,data) {
    let item = chris.getItem(actor, 'Wraps of Dyamak');
    if (!item) return;
    if (!item.system.equipped || item.system.attunement === 1) return;
    let feature = chris.getItem(actor, 'Ki Points');
    if (!feature) return;
    let tokens = actor.getActiveTokens();
    if (!tokens) return;
    await chris.applyDamage([tokens[0]], feature.system.uses.max, 'temphp');
    await item.displayCard();
}
async function wrapsOffDyamak_attack({speaker, actor, token, character, item, args, scope, workflow}) {
    console.log(workflow);
    let unarmedStrike = chris.getItem(workflow.actor, 'Unarmed Strike (Monk)');
    if (!unarmedStrike) return;
    if (workflow.item.uuid != unarmedStrike.uuid) return;
    let wrapsOffDyamakItem = chris.getItem(workflow.actor, 'Wraps of Dyamak');
    if (!wrapsOffDyamakItem) return;
    let tier = chris.getConfiguration(wrapsOffDyamakItem, 'tier') ?? 1;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'wrapsOffDyamak', 150);
    if (!queueSetup) return;
    let attackRoll = await chris.addToRoll(workflow.attackRoll, tier);
    await workflow.setAttackRoll(attackRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function wrapsOffDyamak_damage({speaker, actor, token, character, item, args, scope, workflow}) {
    let unarmedStrike = chris.getItem(workflow.actor, 'Unarmed Strike (Monk)');
    if (!unarmedStrike) return;
    if (workflow.item.uuid != unarmedStrike.uuid) return;
    let wrapsOffDyamakItem = chris.getItem(workflow.actor, 'Wraps of Dyamak');
    if (!wrapsOffDyamakItem) return;
    let tier = chris.getConfiguration(wrapsOffDyamakItem, 'tier') ?? 1;
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'wrapsOffDyamak', 150);
    if (!queueSetup) return;
    let damageFormula = workflow.damageRoll._formula + ' + ' + tier + '[' + workflow.damageRoll.terms[0].flavor + ']';
    if (tier === 3 && workflow.hitTargets.size) {
        if (wrapsOffDyamakItem.system.uses.value) {
            let selection = await chris.dialog(wrapsOffDyamakItem.name, constants_constants.yesNo, 'Make a ravenous strike?');
            if (selection) {
                let bonusDamageFormula = '6d6[necrotic]';
                if (workflow.isCritical) bonusDamageFormula = chris.getCriticalFormula(bonusDamageFormula);
                damageFormula += ' + ' + bonusDamageFormula;
                wrapsOffDyamakItem.update({'system.uses.value': 0});
                wrapsOffDyamakItem.displayCard();
                strikeUsed = true;
            }
        }
    }
    if (workflow.isCritical) {
        if (tier >= 2) {
            let crimsonMistFeature = chris.getItem(workflow.actor, 'Crimson Mist');
            if (crimsonMistFeature && crimsonMistFeature.system.uses.value != 1) crimsonMistFeature.update({'system.uses.value': 1}); 
        }
        if (tier === 3 && wrapsOffDyamakItem.system.uses.value != 1) wrapsOffDyamakItem.update({'system.uses.value': 1});
    }
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
async function wrapsOffDyamak_heal({speaker, actor, token, character, item, args, scope, workflow}) {
    if (!strikeUsed) return;
    let healing = chris.totalDamageType(workflow.targets.first().actor, workflow.damageDetail, 'necrotic');
    await chris.applyDamage([workflow.token], healing, 'healing');
    strikeUsed = false;
}
let wrapsOffDyamak = {
    'rest': wrapsOffDyamak_rest,
    'attack': wrapsOffDyamak_attack,
    'damage': wrapsOffDyamak_damage,
    'heal': wrapsOffDyamak_heal
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/cleric/tempestDomain/wrathOfTheStorm.js


async function wrathOfTheStorm({speaker, actor, token, character, item, args, scope, workflow}) {
    let queueSetup = await queue_queue.setup(workflow.item.uuid, 'wrathOfTheStorm', 50);
    if (!queueSetup) return;
    let selection = await chris.dialog('What damage type?', [['Lightning', '[lightning]'], ['Thunder', '[thunder]']]);
    if (!selection) selection = 'lightning';
    let damageFormula = workflow.damageRoll._formula + selection;
    let damageRoll = await new Roll(damageFormula).roll({async: true});
    await workflow.setDamageRoll(damageRoll);
    queue_queue.remove(workflow.item.uuid);
}
;// CONCATENATED MODULE: ./scripts/macros/classFeatures/barbarian/zealot/zealousPresence.js

async function zealousPresence({speaker, actor, token, character, item, args, scope, workflow}) {
    if (workflow.targets.size <= 10) return;
    let buttons = [
        {
            'label': 'OK',
            'value': true
        }, {
            'label': 'Cancel',
            'value': false
        }
    ];
    let selection = await chris.selectTarget('Who should get targeted? Max: 10', buttons, Array.from(workflow.targets), false, 'multiple');
    if (!selection.buttons) return;
    let newTargets = [];
    for (let i of selection.inputs) {
        let count = 0;
        if (i) {
            count++;
            if (count > 10) {
                ui.notifications.info('Too many targets selected!');
                break;
            }
            newTargets.push(i);
        }
    }
    chris.updateTargets(newTargets);
}
;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/zombie/undeadFortitude.js



async function undeadFortitude(targetToken, {workflow, ditem}) {
    if (ditem.newHP != 0 || ditem.oldHP === 0) return;
    let targetActor = targetToken.actor;
    let effect = chris.findEffect(targetActor, 'Undead Fortitude');
    if (!effect) return;
    if (workflow.isCritical || chris.checkTrait(targetActor, 'di', 'healing') || chris.totalDamageType(targetActor, ditem.damageDetail[0], 'radiant') > 0 || chris.totalDamageType(targetActor, ditem.damageDetail[0], 'none')) return;
    let originItem = await fromUuid(effect.origin);
    if (!originItem) return;
    let queueSetup = await queue_queue.setup(workflow.uuid, 'undeadFortitude', 389);
    if (!queueSetup) return;
    let featureData = duplicate(originItem.toObject());
    let damageDealt = ditem.appliedDamage;
    featureData.system.save.dc = damageDealt + featureData.system.save.dc;
    delete featureData._id;
    let feature = new CONFIG.Item.documentClass(featureData, {'parent': targetActor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([targetToken.document.uuid]);
    let featureWorkflow = await MidiQOL.completeItemUse(feature, config, options);
    if (featureWorkflow.failedSaves.size === 1) {
        queue_queue.remove(workflow.uuid);
        return;
    }
    ditem.newHP = 1;
    ditem.hpDamage = Math.abs(ditem.newHP - ditem.oldHP);
    queue_queue.remove(workflow.uuid);
}

;// CONCATENATED MODULE: ./scripts/macros/monsterFeatures/zombie/zombie.js

let zombie = {
    'undeadFortitude': undeadFortitude
}
;// CONCATENATED MODULE: ./scripts/macros/spells/zoneOfTruth.js


async function bestZone(token) {
    let templates = chris.tokenTemplates(token.document);
    let bestDC = null;
    let bestOriginUuid;
    for (let i of templates) {
        let testTemplate = canvas.scene.collections.templates.get(i);
        if (!testTemplate) continue;
        let testOriginUuid = testTemplate.flags['midi-qol']?.originUuid;
        if (!testOriginUuid) continue;
        let testOriginItem = await fromUuid(testOriginUuid);
        if (testOriginItem.name != 'Zone of Truth') continue;
        let testDC = chris.getSpellDC(testOriginItem);
        if (testDC > bestDC) {
            bestDC = testDC;
            bestOriginUuid = testOriginUuid;
        }
    }
    return bestOriginUuid;
}
async function inZone(token, template) {
    let originUuid = template.flags['midi-qol']?.originUuid;
    if (!originUuid) return;
    if (chris.inCombat()) {
        let turnEntered = template.flags['chris-premades']?.spell?.zoneOfTruth?.tokens?.[token.id];
        let currentTurn = game.combat.round + '-' + game.combat.turn;
        if (currentTurn === turnEntered) return;
        await template.setFlag('chris-premades', 'spell.zoneOfTruth.tokens.' + token.id, currentTurn);
    }
    let bestOriginUuid = await bestZone(token);
    if (bestOriginUuid != originUuid) return;
    let originItem = await fromUuid(originUuid);
    if (!originItem) return;
    let effectData = {
        'label': originItem.name,
        'icon': originItem.img,
        'duration': {
            'seconds': 600
        },
        'origin': originItem.uuid,
    };
    let effect = chris.findEffect(token.actor, 'Zone of Truth');
    if (effect) {
        if (effect.origin === originUuid) return;
        await chris.removeEffect(effect);
        await chris.createEffect(token.actor, effectData);
        return;
    }
    let spellObject = duplicate(originItem.toObject());
    delete(spellObject.flags.templatemacro);
    spellObject.system.range = {
        'value': null,
        'long': null,
        'units': ''
    };
    spellObject.system.target = {
        'value': 1,
        'width': null,
        'units': '',
        'type': 'creature'
    }
    spellObject.system.actionType = 'save';
    spellObject.system.save = {
        'ability': 'cha',
        'dc': chris.getSpellDC(originItem),
        'scaling': 'flat'
    }
    spellObject.system.preparation.mode = 'atwill';
    let spell = new CONFIG.Item.documentClass(spellObject, {'parent': originItem.actor});
    let [config, options] = constants_constants.syntheticItemWorkflowOptions([token.document.uuid]);
    let spellWorkflow = await MidiQOL.completeItemUse(spell, config, options);
    if (spellWorkflow.failedSaves.size != 1) return;
    await chris.createEffect(token.actor, effectData);
}
async function leaveZone(token, template) {
    if (chris.inCombat()) {
        await template.setFlag('chris-premades', 'spell.zoneOfTruth.tokens.' + token.id, '');
    }
    let effect = chris.findEffect(token.actor, 'Zone of Truth');
    if (!effect) return;
    let originUuid = template.flags['midi-qol']?.originUuid;
    if (!originUuid) return;
    if (effect.origin != originUuid) return;
    let bestOriginUuid = await bestZone(token);
    if (!bestOriginUuid) await chris.removeEffect(effect);
}
let zoneOfTruth = {
    'inZone': inZone,
    'leaveZone': leaveZone
}
;// CONCATENATED MODULE: ./scripts/macros.js













































































































































































































































































































































































async function onHitMacro(workflow) {
    if (!workflow.targets.size) return;
    workflow.targets.forEach(async token => {
        let flags = token.actor.flags['chris-premades']?.feature?.onHit;
        if (!flags) return;
        if (token.id === workflow.token.id) return;
        for (let [key, value] of Object.entries(flags)) {
            if (!value) continue;
            if (typeof macros_onHit[key] != 'function') continue;
            await macros_onHit[key](workflow, token);
        }
    });
}
let monster = {
    'aberrantSpirit': aberrantSpirit,
    'autoGnome': autoGnome,
    'bodak': bodak,
    'bugbear': bugbear,
    'bulette': bulette,
    'catoblepas': catoblepas,
    'celestialSpirit': celestialSpirit,
    'chasme': chasme,
    'clayGolem': clayGolem,
    'clockworkDefender': clockworkDefender,
    'constructSpirit': constructSpirit,
    'corpseFlower': corpseFlower,
    'deepGnome': deepGnome,
    'draconicSpirit': draconicSpirit,
    'dreamEater': dreamEater,
    'drow': drow,
    'duergar': duergar,
    'duergarMindMaster': duergarMindMaster,
    'dybbuk': dybbuk,
    'elderBrain': elderBrain,
    'elderOblex': elderOblex,
    'feySpirit': feySpirit,
    'fiendishSpirit': fiendishSpirit,
    'fireElemental': fireElemental,
    'fireSnake': fireSnake,
    'fragmentOfKrokulmar': fragmentOfKrokulmar,
    'gallowsSpeaker': gallowsSpeaker,
    'generic': generic,
    'ghast': ghast,
    'gibberingMouther': gibberingMouther,
    'grell': grell,
    'hezrou': hezrou,
    'hobgoblin': hobgoblin,
    'homunculus': homunculus,
    'intellectDevourer': intellectDevourer,
    'kobold': kobold,
    'leucrotta': leucrotta,
    'mudMephit': mudMephit,
    'nightwalker': nightwalker,
    'rugOfSmothering': rugOfSmothering,
    'salamander': salamander,
    'shadow': shadow_shadow,
    'shadowDemon': shadowDemon,
    'shadowSpirit': shadowSpirit,
    'shadowghast': shadowghast,
    'shamblingMound': shamblingMound,
    'soulMonger': soulMonger,
    'sprite': sprite,
    'stenchKow': stenchKow,
    'succubus': succubus,
    'tixieTockworth': tixieTockworth,
    'troglodyte': troglodyte,
    'troll': troll,
    'undeadSpirit': undeadSpirit,
    'zombie': zombie
}
let macros_onHit = {
    'blackrazor': blackrazor.onHit,
    'distractingStrike': maneuvers.distractingStrikeOnHit,
    'fireForm': fireElemental.fireForm,
    'fireShield': fireShield.onHit,
    'forceField': monster.tixieTockworth.forceField.onHit,
    'heatedBody': fireSnake.heatedBody,
    'malfunction': autoGnome.malfunction,
    'regeneration': monster.troll.regeneration.onHit,
    'shadowOfMoil': shadowOfMoil.onHit,
    'soulThirst': soulMonger.soulThirst.onHit,
    'wardingBond': wardingBond.onHit,
    'armorOfAgathys': armorOfAgathys.onHit,
    'wildSurgeRetribution': wildSurge.retribution,
    'rage': rage.attacked
}
let macros_skills = {
    'bootsOfElvenkind': bootsOfElvenkind,
    'eyesOfMinuteSeeing': eyesOfMinuteSeeing,
    'eyesOfTheEagle': eyesOfTheEagle,
    'grappleEscape': grapple_grapple.escape,
    'grappleInitiate': grapple_grapple.initiate,
    'labyrinthineRecall': labyrinthineRecall,
    'stoneCamouflage': deepGnome.stoneCamouflage
}
let macros_saves = {
    'dangerSense': dangerSense,
    'holyNimbus': holyNimbus.save
}
async function onMove(macroName, token, castLevel, spellDC, damage, damageType, tokenID, reason) {
    switch (macroName) {
        case 'spiritGuardians':
            await spiritGuardians.moved(token, castLevel, spellDC, damage, damageType, tokenID, reason);
            break;
        case 'guardianOfFaith':
            await guardianOfFaith.moved(token, castLevel, spellDC, damage, damageType, tokenID, reason);
            break;
        case 'investitureOfFlame':
            await investitureOfFlame.moved(token, castLevel, spellDC, damage, damageType, tokenID, reason);
            break;
    }
}
async function onMoveEffect(macroName, token, selectedAura) {
    switch (macroName) {
        case 'auraOfPurity': 
            await auraOfPurity.move(token, selectedAura);
            break;
        case 'auraOfProtection':
            await auraOfProtection(token, selectedAura);
            break;
        case 'auraOfCourage':
            await auraOfCourage(token, selectedAura);
            break;
        case 'lanternOfRevealing':
            await lanternOfRevealing.aura(token, selectedAura);
            break;
        case 'auraOfDevotion':
            await auraOfDevotion(token, selectedAura);
            break;
        case 'auraOfLife':
            await auraOfLife.aura(token, selectedAura);
            break;
        case 'auraOfWarding':
            await auraOfWarding(token, selectedAura);
            break;
        case 'protectiveLights':
            await wildSurge.protectiveLights.aura(token, selectedAura);
            break;
        case 'auraOfHate':
            await auraOfHate.aura(token, selectedAura);
            break;
        case 'dreadLord':
            await dreadLord.aura(token, selectedAura);
            break;
    }
}
async function onMoveSpecial(name, sourceToken, targetToken) {
    switch(name) {
        case 'auraOfHate':
            return await auraOfHate.special(sourceToken, targetToken);
        default:
            return false;
    }
}
async function templateTrigger(macroName, token, trigger, reason) {
    switch (macroName) {
        case 'dawn':
            await dawn.trigger(token, trigger, reason);
            break;
        case 'moonbeam':
            await moonbeam.trigger(token, trigger, reason);
            break;
        case 'cloudkill':
            await cloudkill.trigger(token, trigger, reason);
            break;
        case 'sickeningRadiance':
            await sickeningRadiance.trigger(token, trigger, reason);
            break;
        case 'grease':
            await grease.trigger(token, trigger, reason);
            break;
        case 'insectPlague':
            await insectPlague.trigger(token, trigger, reason);
            break;
        case 'hungerOfHadar':
            await hungerOfHadar.trigger(token, trigger, reason);
            break;
        case 'sleetStorm': {
            await sleetStorm.trigger(token, trigger, reason);
            break;
        }
    }
}
let macros = {
    'aasimarRadiantSoul': aasimarRadiantSoul,
    'acidArrow': acidArrow,
    'actions': actions,
    'ancestralProtectors': ancestralProtectors,
    'animateDead': animateDead,
    'animatingPerformance': animatingPerformance,
    'antagonize': antagonize,
    'arcaneJolt': arcaneJolt,
    'arcaneWard': arcaneWard,
    'armorModel': armorModel,
    'armorOfAgathys': armorOfAgathys,
    'armorOfMagicalStrength': armorOfMagicalStrength,
    'auraOfAlacrity': auraOfAlacrity,
    'auraOfCourage': auraOfCourage,
    'auraOfDevotion': auraOfDevotion,
    'auraOfHate': auraOfHate,
    'auraOfLife': auraOfLife,
    'auraOfProtection': auraOfProtection,
    'auraOfPurity': auraOfPurity,
    'auraOfVitality': auraOfVitality,
    'awakenedSpellbook': awakenedSpellbook,
    'balmOfPeace': balmOfPeace,
    'bardicInspiration': bardicInspiration,
    'beaconOfHope': beaconOfHope,
    'beguilingTwist': beguilingTwist,
    'bestialSoul': bestialSoul,
    'bestowCurse': bestowCurse,
    'bg3': bg3,
    'bigbysHand': bigbysHand,
    'binding': binding,
    'blackrazor': blackrazor,
    'bladeFlourish': bladeFlourish,
    'bladesong': bladesong,
    'blessedStrikes': blessedStrikes,
    'blessingOfTheForge': blessingOfTheForge,
    'blessingOfTheRavenQueen': blessingOfTheRavenQueen,
    'blight': blight,
    'blink': blink,
    'bloodSpear': bloodSpear,
    'bolsteringMagic': bolsteringMagic,
    'boomingBlade': boomingBlade,
    'borrowedKnowledge': borrowedKnowledge,
    'brandOfCastigation': brandOfCastigation,
    'breathOfTheDragon': breathOfTheDragon,
    'breathWeapon': breathWeapon,
    'burningHands': burningHands,
    'callLightning': callLightning,
    'callTheHunt': callTheHunt,
    'cartomancer': cartomancer,
    'chainLightning': chainLightning,
    'charmAnimalsAndPlants': charmAnimalsAndPlants,
    'charmPerson': charmPerson,
    'chillTouch': chillTouch,
    'chromaticOrb': chromaticOrb,
    'circleOfMortality': circleOfMortality,
    'cleave': cleave_cleave,
    'cloudStrike': cloudStrike,
    'cloudkill': cloudkill,
    'compelledDuel': compelledDuel,
    'conditionResistanceEarly': conditionResistanceEarly,
    'conditionResistanceLate': conditionResistanceLate,
    'conditionVulnerabilityEarly': conditionVulnerabilityEarly,
    'conditionVulnerabilityLate': conditionVulnerabilityLate,
    'conjureAnimals': conjureAnimals,
    'conjureCelestial': conjureCelestial,
    'conjureElemental': conjureElemental,
    'conjureFey': conjureFey,
    'conjureMinorElementals': conjureMinorElementals,
    'conjureWoodlandBeings': conjureWoodlandBeings,
    'controlUndead': controlUndead,
    'createPactWeapon': createPactWeapon,
    'crimsonRite': crimsonRite,
    'crusher': crusher,
    'crushingThrow': crushingThrow,
    'crystalBlade': crystalBlade,
    'dancingSword': dancingSword,
    'danseMacabre': danseMacabre,
    'darkOnesBlessing': darkOnesBlessing,
    'darkness': darkness,
    'dawn': dawn,
    'deathWard': deathWard,
    'destructiveWave': destructiveWave,
    'destructiveWrath': destructiveWrath,
    'detectThoughts': detectThoughts,
    'disintegrate': disintegrate,
    'divineFury': divineFury,
    'divineSmite': divineSmite,
    'divineStrike': divineStrike,
    'draconicStrike': draconicStrike,
    'dragonVessel': dragonVessel,
    'dragonsBreath': dragonsBreath,
    'dragonsWrath': dragonsWrath,
    'dreadAmbusher': dreadAmbusher,
    'dreadLord': dreadLord,
    'dreadfulAspect': dreadfulAspect,
    'dualWielder': dualWielder,
    'durableMagic': durableMagic,
    'eladrinSeason': eladrinSeason,
    'eldritchBlast': eldritchBlast,
    'eldritchSmite': eldritchSmite,
    'elementalAdept': elementalAdept,
    'elementalCleaver': elementalCleaver,
    'elementalWeapon': elementalWeapon,
    'elixirOfHealth': elixirOfHealth,
    'emboldeningBond': emboldeningBond,
    'enhancedBond': enhancedBond,
    'enhancedWeapon': enhancedWeapon,
    'enlargeReduce': enlargeReduce,
    'experimentalElixir': experimentalElixir,
    'expertDivination': expertDivination,
    'explodingHeals': explodingHeals,
    'faerieFire': faerieFire,
    'fallenPuppet': fallenPuppet,
    'farStep': farStep,
    'favoredFoe': favoredFoe,
    'feyPresence': feyPresence,
    'findFamiliar': findFamiliar,
    'findGreaterSteed': findGreaterSteed,
    'findSteed': findSteed,
    'fireShield': fireShield,
    'fireStorm': fireStorm,
    'fireStrike': fireStrike,
    'firearm': firearm,
    'flameBlade': flameBlade,
    'fly': fly,
    'focusedAim': focusedAim,
    'fogCloud': fogCloud,
    'formOfDread': formOfDread,
    'formOfTheBeast': formOfTheBeast,
    'frostFingers': frostFingers,
    'frostStrike': frostStrike,
    'gatheredSwarm': gatheredSwarm,
    'giftOfTheChromaticDragon': giftOfTheChromaticDragon,
    'graspOfAvarice': graspOfAvarice,
    'graspOfHadar': graspOfHadar,
    'graveTouched': graveTouched,
    'grease': grease,
    'greenFlameBlade': greenFlameBlade,
    'grimHarvest': grimHarvest,
    'grovelthrash': grovelthrash,
    'grungPoison': grungPoison,
    'guardianOfFaith': guardianOfFaith,
    'guardianOfNature': guardianOfNature,
    'hailOfThorns': hailOfThorns,
    'harnessDivinePower': harnessDivinePower,
    'healingLight': healingLight,
    'healingSpirit': healingSpirit,
    'heartOfTheStorm': heartOfTheStorm,
    'heatMetal': heatMetal,
    'hex': hex,
    'hexWarrior': hexWarrior,
    'hexbladesCurse': hexbladesCurse,
    'hiddenStep': hiddenStep,
    'hillStrike': hillStrike,
    'holyNimbus': holyNimbus,
    'holyWeapon': holyWeapon,
    'homunculusServant': homunculusServant,
    'hungerOfHadar': hungerOfHadar,
    'hungryJaws': hungryJaws,
    'huntersMark': huntersMark,
    'hybridTransformation': hybridTransformation,
    'iceStorm': iceStorm,
    'infectiousFury': infectiousFury,
    'insectPlague': insectPlague,
    'insightfulFighting': insightfulFighting,
    'inspiringSmite': inspiringSmite,
    'investitureOfFlame': investitureOfFlame,
    'investitureOfIce': investitureOfIce,
    'investitureOfStone': investitureOfStone,
    'investmentOfTheChainMaster': investmentOfTheChainMaster,
    'javelinOfLightning': javelinOfLightning,
    'lanternOfRevealing': lanternOfRevealing,
    'legionOfOne': legionOfOne,
    'lifeTransference': lifeTransference,
    'lightningArrow': lightningArrow,
    'lightningLure': lightningLure,
    'longLimbed': longLimbed,
    'maddeningHex': maddeningHex,
    'maelstromAura': maelstromAura,
    'magicMissile': magicMissile,
    'maneuvers': maneuvers,
    'manifestEcho': manifestEcho,
    'manifestMind': manifestMind,
    'manualRolls': manualRolls,
    'massCureWounds': massCureWounds,
    'mastersAmulet': mastersAmulet,
    'metaMagic': metaMagic,
    'metallicBreathWeapon': metallicBreathWeapon,
    'mightyImpel': mightyImpel,
    'mirrorImage': mirrorImage,
    'monster': monster,
    'moonbeam': moonbeam,
    'moteOfPotential': moteOfPotential,
    'muddledMind': muddledMind,
    'mutagencraft': mutagencraft,
    'necroticShroud': necroticShroud,
    'noConfiguration': noConfiguration,
    'oilOfSharpness': oilOfSharpness,
    'oldBreathWeapon': oldBreathWeapon,
    'onHit': macros_onHit,
    'onMove': onMove,
    'onMoveEffect': onMoveEffect,
    'onMoveSpecial': onMoveSpecial,
    'orcishFury': orcishFury,
    'overchannel': overchannel,
    'piercer': piercer,
    'planarWanderer': planarWanderer,
    'potionOfDiminution': potionOfDiminution,
    'potionOfFireBreath': potionOfFireBreath,
    'potionOfGiantSize': potionOfGiantSize,
    'potionOfGrowth': potionOfGrowth,
    'potionOfMaximumPower': potionOfMaximumPower,
    'potionOfPoison': potionOfPoison,
    'potionOfVitality': potionOfVitality,
    'preserveLife': preserveLife,
    'primalCompanion': primalCompanion,
    'protectionFromEvilAndGood': protectionFromEvilAndGood,
    'radiantConsumption': radiantConsumption,
    'radiantSoul': radiantSoul,
    'radiantWeapon': radiantWeapon,
    'rage': rage,
    'rayOfEnfeeblement': rayOfEnfeeblement,
    'reaper': reaper,
    'relentless': relentless,
    'relentlessEndurance': relentlessEndurance,
    'removeTemplate': removeTemplate,
    'repeatingShot': repeatingShot,
    'repellingBlast': repellingBlast,
    'repulsionShield': repulsionShield,
    'resistantArmor': resistantArmor,
    'returningWeapon': returningWeapon,
    'rimesBindingIce': rimesBindingIce,
    'ringOfSpellStoring': ringOfSpellStoring,
    'riteOfTheDawn': riteOfTheDawn,
    'sacredWeapon': sacredWeapon,
    'sanctuary': sanctuary,
    'savageAttacker': savageAttacker,
    'saveConditionImmune': saveConditionImmune,
    'scorchingRay': scorchingRay,
    'searingSmite': searingSmite,
    'shadowBlade': shadowBlade,
    'shadowOfMoil': shadowOfMoil,
    'shockingGrasp': shockingGrasp,
    'sickeningRadiance': sickeningRadiance,
    'skillEmpowerment': skillEmpowerment,
    'slasher': slasher,
    'sleetStorm': sleetStorm,
    'sneakAttack': sneakAttack,
    'songOfDefense': songOfDefense,
    'soothePain': soothePain,
    'spellRefuelingRing': spellRefuelingRing,
    'spikeGrowth': spikeGrowth,
    'spiritGuardians': spiritGuardians,
    'spiritShroud': spiritShroud,
    'spiritualWeapon': spiritualWeapon,
    'starryForm': starryForm,
    'stasisStrike': stasisStrike,
    'steelDefender': steelDefender,
    'stillnessOfMind': stillnessOfMind,
    'stoneStrike': stoneStrike,
    'stormSphere': stormSphere,
    'stormStrike': stormStrike,
    'stormgirdle': stormgirdle,
    'strengthOfTheGrave': strengthOfTheGrave,
    'stunningStrike': stunningStrike,
    'summon': summon,
    'summonAberration': summonAberration,
    'summonBeast': summonBeast,
    'summonCelestial': summonCelestial,
    'summonConstruct': summonConstruct,
    'summonDraconicSpirit': summonDraconicSpirit,
    'summonDrakeCompanion': summonDrakeCompanion,
    'summonElemental': summonElemental,
    'summonFey': summonFey,
    'summonFiend': summonFiend,
    'summonLesserDemons': summonLesserDemons,
    'summonShadowspawn': summonShadowspawn,
    'summonUndead': summonUndead,
    'summonWildfireSpirit': summonWildfireSpirit,
    'synapticStatic': synapticStatic,
    'tashasOtherworldlyGuise': tashasOtherworldlyGuise,
    'telekentic': telekinetic,
    'teleport': teleport_teleport,
    'templateTrigger': templateTrigger,
    'tentacleOfTheDeeps': tentacleOfTheDeeps,
    'thornWhip': thornWhip,
    'thunderStep': thunderStep,
    'thunderWave': thunderWave,
    'thunderboltStrike': thunderboltStrike,
    'thunderousSmite': thunderousSmite,
    'tollTheDead': tollTheDead,
    'trance': trance,
    'trickShots': trickShots,
    'turnUndead': turnUndead,
    'twilightSanctuary': twilightSanctuary,
    'twilightShroud': twilightShroud,
    'vampiricBite': vampiricBite,
    'vampiricTouch': vampiricTouch,
    'viciousIntent': viciousIntent,
    'vigorOfTheHillGiant': vigorOfTheHillGiant,
    'vortexWarp': vortexWarp,
    'wandOfTheWarMage': wandOfTheWarMage,
    'wardingBond': wardingBond,
    'wildShape': wildShape,
    'wildSurge': wildSurge,
    'wildhunt': wildhunt,
    'witherAndBloom': witherAndBloom,
    'wrapsOffDyamak': wrapsOffDyamak,
    'wrathOfTheStorm': wrathOfTheStorm,
    'zealousPresence': zealousPresence,
    'zoneOfTruth': zoneOfTruth
}
;// CONCATENATED MODULE: ./scripts/utility/effectAuras.js




let auras = {};
let effectAuras = {
    'add': effectAuras_add,
    'remove': effectAuras_remove,
    'status': effectAuras_status,
    'purge': effectAuras_purge,
    'registerAll': canvasReady,
    'refresh': refreshEffects
}
function effectAuras_status() {
    return auras;
}
async function effectAuras_purge() {
    auras = {};
    await socket.executeForEveryone('syncEffectAuras', auras);
    return;
}
function effectAuras_add(flagAuras, tokenUuid, doRefresh) {
    if (game.settings.get('chris-premades', 'LastGM') != game.user.id) {
        socket.executeForAllGMs('remoteAddEffectAura', flagAuras, tokenUuid, doRefresh);
        return;
    }
    for (let aura of Object.values(flagAuras)) {
        let name = aura.name;
        let castLevel = aura.castLevel || 0;
        let spellDC = aura.spellDC || null;
        let range = aura.range;
        let disposition = aura.disposition || 'all';
        let conscious = aura.conscious || false;
        let effectName = aura.effectName;
        let worldMacro = aura.worldMacro;
        let globalFunction = aura.globalFunction;
        let macroName = aura.macroName;
        let special = aura.special;
        let self = aura.self;
        if (!tokenUuid || !name || !range || !effectName || (!macroName && !worldMacro && !globalFunction)) {
            ui.notifications.warn('Invalid aura data found!');
            console.log(aura);
            continue;
        }
        if (!auras[name]) auras[name] = [];
        auras[name].push({
            'tokenUuid': tokenUuid,
            'name': name,
            'castLevel': castLevel,
            'spellDC': spellDC,
            'range': range,
            'disposition': disposition,
            'conscious': conscious,
            'worldMacro': worldMacro,
            'globalFunction': globalFunction,
            'macroName': macroName,
            'effectName': effectName,
            'special': special,
            'self': self
        });
    }
    if (doRefresh) refreshEffects();
}
function remoteAdd(flagAuras, tokenUuid, doRefresh) {
    if (game.settings.get('chris-premades', 'LastGM') != game.user.id) return;
    effectAuras_add(flagAuras, tokenUuid, doRefresh);
}
async function effectAuras_remove(name, tokenUuid, noRefresh) {
    if (game.settings.get('chris-premades', 'LastGM') != game.user.id) {
        socket.executeForAllGMs('remoteRemoveEffectAura', name, tokenUuid);
        return;
    }
    if (!auras[name]) return;
    if (!noRefresh) await refreshEffects(tokenUuid, name);
    auras[name] = auras[name].filter(aura => aura.tokenUuid != tokenUuid);
    if (auras[name].length === 0) delete(auras[name]);
}
async function remoteRemove(name, tokenUuid) {
    if (game.settings.get('chris-premades', 'LastGM') != game.user.id) return;
    await effectAuras_remove(name, tokenUuid);
}
function preActorUpdate(actor, updates, options) {
    if (game.settings.get('chris-premades', 'LastGM') != game.user.id) return;
    if (!actor.flags['chris-premades']?.aura) return;
    if (!updates.system?.attributes?.hp) return;
    let oldHP = actor.system.attributes.hp.value;
    let newHP = updates.system.attributes.hp.value;
    if (oldHP > 0 && newHP === 0) foundry.utils.setProperty(options, 'chris-premades.refreshAuras', true);
    if (newHP > 0 && oldHP === 0) foundry.utils.setProperty(options, 'chris-premades.refreshAuras', true);
}
function actorUpdate(actor, updates, options) {
    if (options['chris-premades']?.refreshAuras) refreshEffects();
}
async function canvasReady() {
    auras = {};
    let sceneTokens = game.canvas.scene.tokens?.contents;
    if (sceneTokens) {
        for (let token of sceneTokens) {
            if (!token.actor) continue;
            let effects = token.actor.effects.filter(e => e.flags?.['chris-premades']?.aura === true);
            if (effects.length > 0) for (let effect of effects) await chris.removeEffect(effect);
            let flagAuras = token.actor?.flags?.['chris-premades']?.aura;
            if (!flagAuras) continue;
            effectAuras_add(flagAuras, token.uuid, false);
        }
    }
    refreshEffects();
}
async function effectAuras_tokenMoved(token, ignoredUuid, ignoredAura) {
    if (token.parent.id != canvas.scene.id) return;
    await token.object?._animation;
    let distaceMap = {};
    for (let auraName of Object.values(auras)) {
        let validSources = [];
        for (let aura of auraName) {
            if (aura.tokenUuid === ignoredUuid && (ignoredAura === aura.name || ignoredAura === 'all')) continue;
            let sourceToken = await fromUuid(aura.tokenUuid);
            if (!sourceToken) continue;
            let distance = distaceMap[sourceToken.id];
            if (!distance) {
                distance = chris.getDistance(token, sourceToken);
                distaceMap[sourceToken.id] = distance;
            }
            let testDistance = aura.range;
            if (testDistance === 'paladin') {
                let paladinLevels = sourceToken.actor.classes?.paladin?.system?.levels;
                if (paladinLevels >= 18) {
                    testDistance = 30;
                } else {
                    testDistance = 10;
                }
            }
            if (distance > testDistance) continue;
            if (aura.self != undefined && !aura.self && aura.tokenUuid === token.uuid) continue;
            if (aura.conscious) {
                let sourceHP = sourceToken.actor.system.attributes.hp.value;
                if (sourceHP === 0) continue;
                if (chris.findEffect(sourceToken.actor, translate.conditions('unconscious'))) continue;
            }
            switch (aura.disposition) {
                case 'ally':
                    if (token.disposition != sourceToken.disposition) continue;
                    break;
                case 'enemy':
                    if (token.disposition === sourceToken.disposition) continue;
                    break;
            }
            switch (aura.castLevel) {
                case 'cha':
                case 'con':
                case 'dex':
                case 'int':
                case 'str':
                case 'wis':
                    aura.castLevel = sourceToken.actor.system.abilities[aura.castLevel].mod;
                    break;
                case 'castLevel':
                    let auraEffect = chris.findEffect(sourceToken.actor, aura.effectName + ' - Aura');
                    if (!auraEffect) continue;
                    aura.castLevel = chris.getEffectCastLevel(auraEffect);
                    if (!aura.castLevel) continue;
                    break;
            }
            if (aura.special) {
                let check = await macros.onMoveSpecial(aura.special, sourceToken, token);
                if (!check) continue;
            }
            validSources.push(aura);
        }
        let maxLevel = Math.max(...validSources.map(aura => aura.castLevel));
        let selectedAura = validSources.find(aura => aura.castLevel === maxLevel);
        if (selectedAura) {
            console.log('Chris | Adding aura effect ' + selectedAura.effectName + ' to: ' + token.actor.name);
            let macroCommand;
            if (selectedAura.macroName) {
                macros.onMoveEffect(selectedAura.macroName, token, selectedAura);
            } else if (selectedAura.globalFunction) {
                macroCommand = `await ${selectedAura.globalFunction.trim()}.bind(this)({token})`;
            } else if (selectedAura.worldMacro) {
                let macro = game.macros?.getName(selectedAura.worldMacro.replaceAll('"', ''));
                macroCommand = macro?.command ?? `console.warn('Chris | No world macro ${selectedAura.worldMacro.replaceAll('"', '')} found!')`;
            }
            if (macroCommand) {
                let body = `return (async () => {${macroCommand}})()`;
                let fn = Function('{token}={}', body);
                try {
                    fn.call(selectedAura, {token});
                } catch (error) {
                    ui.notifications?.error('There was an error running your macro. See the console (F12) for details');
                    error('Error evaluating macro ', error);
                }
            }
        } else {
            let effect = chris.findEffect(token.actor, auraName[0].effectName);
            if (effect) {
                console.log('Chris | Removing aura effect ' + auraName[0].effectName + ' from: ' + token.actor.name);
                chris.removeEffect(effect);
            }
        }
        await warpgate.wait(100);
    }
}
async function refreshEffects(ignoredUuid, ignoredAura) {
    for (let token of game.canvas.scene.tokens.contents) {
        if (!token.actor) continue;
        effectAuras_tokenMoved(token, ignoredUuid, ignoredAura);
    }
}
function updateToken(token, changes) {
    if (game.settings.get('chris-premades', 'LastGM') != game.user.id) return;
    if (!token.actor) return;
    if (!changes.x && !changes.y && !changes.elevation) return;
    if (token.actor.flags['chris-premades']?.aura) {
        refreshEffects();
    } else {
        effectAuras_tokenMoved(token);
    }
}
async function createToken(token, options, id) {
    if (game.settings.get('chris-premades', 'LastGM') != game.user.id) return;
    let effects = token.actor?.effects?.filter(e => e.flags?.['chris-premades']?.aura === true);
    if (effects.length > 0) for (let effect of effects) await chris.removeEffect(effect);
    let aura = token.actor.flags['chris-premades']?.aura;
    if (aura) {
        effectAuras_add(aura, token.uuid, true);
    } else {
        effectAuras_tokenMoved(token);
    }
}
function deleteToken(token, options, id) {
    if (game.settings.get('chris-premades', 'LastGM') != game.user.id) return;
    let flagAuras = token.actor?.flags['chris-premades']?.aura;
    if (flagAuras) {
        refreshEffects(token.uuid, 'all');
        for (let aura of Object.values(flagAuras)) {
            effectAuras_remove(aura.name, token.uuid, true);
        }
    }
    // delete effects on actor?
}
async function createRemoveEffect(effect, updates, userId) {
    if (!effect.parent || effect.name != translate.conditions('unconscious')) return;
    if (!effect.parent.flags['chris-premades']?.aura) return;
    refreshEffects();
}
let effectAuraHooks = {
    'preActorUpdate': preActorUpdate,
    'actorUpdate': actorUpdate,
    'canvasReady': canvasReady,
    'updateToken': updateToken,
    'createToken': createToken,
    'deleteToken': deleteToken,
    'createRemoveEffect': createRemoveEffect
}
let effectSockets = {
    'remoteAdd': remoteAdd,
    'remoteRemove': remoteRemove
}
;// CONCATENATED MODULE: ./scripts/utility/effect.js


function itemDC(effect, updates, options, user) {
    if (!updates.changes || !effect.parent || !effect.origin) return;
    if (updates.changes.length === 0) return;
    if (effect.parent.constructor.name != 'Actor5e') return;
    let origin = fromUuidSync(effect.origin);
    if (!origin) return;
    if (origin.constructor.name != 'Item5e') return;
    let changed = false;
    for (let i of updates.changes) {
        if (typeof i.value !== 'string') continue;
        if (i.value.includes('$chris.itemDC')) {
            let itemDC = chris.getSpellDC(origin);
            i.value = i.value.replace('$chris.itemDC', itemDC);
            changed = true;
        }
        if (i.value.includes('$chris.itemMod')) {
            let itemMod = chris.getSpellMod(origin);
            i.value = i.value.replace('$chris.itemMod', itemMod);
            changed = true;
        }
    }
    if (!changed) return;
    effect.updateSource({'changes': updates.changes});
}
async function fixOrigin(token, options, user) {
    if ((game.user.id !== user) || token.actorLink) return;
    let updates = await token.actor.effects.reduce(async (updates, effect) => {
        if (!effect.origin) return updates;
        let origin = await fromUuid(effect.origin);
        if (!origin) return updates;
        if (!origin instanceof Item) return updates;
        let item = token.actor.items.get(origin.id);
        if (item) updates.push({'_id': effect.id, 'origin': item.uuid});
        return updates;
    }, []);
    if (Object.keys(updates).length === 0) return;
    await token.actor.updateEmbeddedDocuments('ActiveEffect', updates);
}
function noEffectAnimationCreate(effect, updates,  options, userId) {
    if (effect.flags['chris-premades']?.effect?.noAnimation) options.animate = false
}
function noEffectAnimationDelete(effect,  options, userId) {
    if (effect.flags['chris-premades']?.effect?.noAnimation) options.animate = false
}
function effectTitleBar(config, buttons) {
    if (config.object.parent instanceof Item) {
        buttons.unshift({
            'class': 'chris-premades',
            'icon': 'fa-solid fa-kit-medical',
            'onclick': () => effectConfig(config.object)
        });
    }
}
async function effectConfig(effect) {
    let disableAnimation = effect.flags['chris-premades']?.effect?.noAnimation;
    let vaeButton = effect.flags['chris-premades']?.vae?.button ?? '';
    let inputs = [
        {
            'label': 'Disable Text Animation:',
            'type': 'checkbox',
            'options': disableAnimation ?? false
        },
        {
            'label': 'VAE Button',
            'type': 'text',
            'options': vaeButton
        }
    ]
    let selection = await chris.menu('CPR Effect Options', constants_constants.okCancel, inputs, true);
    if (!selection.buttons) return;
    let refreshedEffect = await fromUuid(effect.uuid);
    if (!refreshedEffect) return;
    let updates = {
        'effects': [
            {
                '_id': refreshedEffect.id,
                'flags': {
                    'chris-premades': {
                        'effect': {
                            'noAnimation': selection.inputs[0]
                        },
                        'vae': {
                            'button': selection.inputs[1] === '' ? null : selection.inputs[1]
                        }
                    }
                }
            }
        ]
    }
    await effect.parent.update(updates);
}
;// CONCATENATED MODULE: ./scripts/macros/generic/syntheticAttack.js
async function flanking(workflow) {
    if (!workflow.actor) return;
    if (!workflow.actor.flags['chris-premades']?.mechanic?.noFlanking) return;
    workflow.flankingAdvantage = false;
}
;// CONCATENATED MODULE: ./scripts/info.js


async function info({speaker, actor, token, character, item, args, scope, workflow}) {
    let info = item?.flags?.['chris-premades']?.info;
    if (!info) return;
    let message = '';
    let gmMessage = '<hr>';
    let cancel = false;
    let updateItem = false;
    if (info.version) {
        let currentVersion = CONFIG.chrisPremades.automations[info.name].version;
        let itemVersion = info.version;
        if (isNewerVersion(currentVersion, itemVersion)) {
            message += '<hr>@UUID[' + item.uuid + ']{' + item.name + '} automation is out of date!<br>Item Version: ' + itemVersion + '<br>Updated Version: ' + currentVersion;
            gmMessage += '<button class="chris-item-button">Update Item</button>'
            cancel = true;
            updateItem = true;
        }
    }
    let missingSettings = [];
    if (info.settings) {
        for (let i of info.settings) {
            if (!game.settings.get('chris-premades', i)) missingSettings.push(i);
        }
        if (missingSettings.length > 0) {
            if (message != '') message += '<hr>';
            message += 'This automation requires the following settings to be enabled:';
            gmMessage += '<button class="chris-settings-button">Enable Required Settings</button>'
            for (let i of missingSettings) {
                let settingName = game.settings.settings.get('chris-premades.' + i).name;
                message += '<br>' + settingName;
            }
            cancel = true;
        }
    }
    if (info.mutation) {
        if (info.mutation.self) {
            if (!token) {
                if (message != '') message += '<hr>';
                message += 'This automation requires your token to be on the scene.';
                cancel = true;
            } else {
                let mutationStack = warpgate.mutationStack(token.document);
                if (mutationStack.getName(info.mutation.self)) {
                    await warpgate.revert(token.document, info.mutation.self);
                    console.warn('A duplicate CPR Warpgate mutation was detected and removed!');
                }
            }
        }
    }
    let missingActors = [];
    if (info.actors) {
        for (let i of info.actors) {
            if (!game.actors.getName(i)) missingActors.push(i);
        }
        if (missingActors.length > 0) {
            if (message != '') message += '<hr>';
            message += 'This automation requires the following sidebar actors:';
            gmMessage += '<button class="chris-actors-button">Import Missing Actors</button>'
            for (let i of missingActors) {
                message += '<br>' + i;
            }
            cancel = true;
        }
    }
    if (cancel) {
        await ChatMessage.create({
            'speaker': {'alias': 'Chris\'s Premades'},
            'content': message
        });
        let messageData = {
            'speaker': {'alias': 'Chris\'s Premades'},
            'blind': true,
            'content': gmMessage
        };
        if (missingSettings.length) setProperty(messageData, 'flags.chris-premades.message.button.settings', missingSettings);
        if (missingActors.length) setProperty(messageData, 'flags.chris-premades.message.button.actors', missingActors);
        if (updateItem) setProperty(messageData, 'flags.chris-premades.message.button.item', item.uuid);
        await ChatMessage.create(messageData);
        return false;
    }
}
async function buttonSettings(settings, element, message) {
    await Promise.all(settings.map(async setting => {
        await game.settings.set('chris-premades', setting, true);
    }));
    ui.notifications.info('Settings updated!');
}
async function buttonActors(actors, element, message) {
    let folder = game.folders.find(i => i.name === 'Chris Premades' && i.type === 'Actor');
    if (!folder) {
        folder = await Folder.create({
            'name': 'Chris Premades',
            'type': 'Actor',
            'color': '#348f2d'
        });
    }
    await Promise.all(actors.map(async actor => {
        let actorData = await chris.getItemFromCompendium('chris-premades.CPR Summons', actor);
        if (!actorData) return;
        actorData.folder = folder.id;
        await Actor.create(actorData);
    }));
    ui.notifications.info('Actors imported!');
}
async function buttonItem(itemUuid, element, message) {
    let item = await fromUuid(itemUuid);
    if (!item) return;
    await updateItem(item);
}
async function setCompendiumItemInfo(key) {
    let gamePack = game.packs.get(key);
    await gamePack.getDocuments();
    for (let i of gamePack.contents) {
        let name = i.flags['chris-premades']?.info?.name ?? i.name;
        if (CONFIG.chrisPremades.automations[name]) await i.setFlag('chris-premades', 'info', CONFIG.chrisPremades.automations[name]);
    }
}
async function stripUnusedFlags(key) {
    let gamePack = game.packs.get(key);
    await gamePack.getDocuments();
    for (let i of gamePack.contents) {
        await i.update({
            'flags.-=ddbimporter': null,
            'flags.-=itemacro': null
        });
    }
}
async function setItemName(uuid, name) {
    let item = await fromUuid(uuid);
    if (!item) return;
    await item.update({
        'flags.-=ddbimporter': null,
        'flags.-=itemacro': null
    });
}
async function removeFolderFlag(uuid) {
    let item = await fromUuid(uuid);
    if (!item) return;
    await item.update({
        'flags.-=cf': null
    });
}
async function updateAllCompendiums() {
    let packs = game.packs.filter(i => i.metadata.label.includes('CPR') && i.metadata.packageType === 'world');
    await Promise.all(packs.map(async i => {
        await stripUnusedFlags(i.metadata.id);
        await setCompendiumItemInfo(i.metadata.id);
    }));
    return 'Done!';
}
;// CONCATENATED MODULE: ./scripts/utility/npcRandomizer.js

let allRaces = {
    'aarakocra': 
    {
        'name': 'Aarakocra',
        'weight': 5,
        'enabled': true,
        'monster': 'Aarakocra'
    },
    'fallen-aasimar': 
    {
        'name': 'Fallen Aasimar',
        'weight': 5,
        'enabled': true,
        'features': [
            {
                'name': 'Healing Hands',
                'description': 'Healing Hands'
            },
            {
                'name': 'Light Bearer',
                'spellcasting': true
            },
            {
                'name': 'Celestial Revelation (Necrotic Shroud)',
                'description': 'Celestial Revelation',
                'level': 3
            },
            {
                'name': 'Celestial Resistance',
                'description': 'Celestial Resistance (Aasimar)'
            }
        ],
        'dr': [
            'necrotic',
            'radiant'
        ],
        'languages': [
            'celestial'
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'spells': [
            {
                'name': 'Light',
                'ability': 'cha'
            }
        ],
        'abilities': {
            'cha': 2,
            'str': 1
        }
    },
    'protector-aasimar': 
    {
        'name': 'Protector Aasimar',
        'weight': 5,
        'enabled': true,
        'features': [
            {
                'name': 'Healing Hands',
                'description': 'Healing Hands'
            },
            {
                'name': 'Light Bearer',
                'spellcasting': true
            },
            {
                'name': 'Celestial Revelation (Radiant Soul)',
                'description': 'Celestial Revelation',
                'level': 3
            },
            {
                'name': 'Celestial Resistance',
                'description': 'Celestial Resistance (Aasimar)'
            }
        ],
        'dr': [
            'necrotic',
            'radiant'
        ],
        'dr': [
            'necrotic',
            'radiant'
        ],
        'languages': [
            'celestial'
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'spells': [
            {
                'name': 'Light',
                'ability': 'cha'
            }
        ],
        'abilities': {
            'cha': 2,
            'wis': 1
        }
    },
    'scourge-aasimar': 
    {
        'name': 'Scourge Aasimar',
        'weight': 5,
        'enabled': true,
        'features': [
            {
                'name': 'Healing Hands',
                'description': 'Healing Hands'
            },
            {
                'name': 'Light Bearer',
                'spellcasting': true
            },
            {
                'name': 'Celestial Revelation (Radiant Consumption)',
                'description': 'Celestial Revelation',
                'level': 3
            },
            {
                'name': 'Celestial Resistance',
                'description': 'Celestial Resistance (Aasimar)'
            }
        ],
        'dr': [
            'necrotic',
            'radiant'
        ],
        'dr': [
            'necrotic',
            'radiant'
        ],
        'languages': [
            'celestial'
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'spells': [
            {
                'name': 'Light',
                'ability': 'cha'
            }
        ],
        'abilities': {
            'cha': 2,
            'con': 1
        }
    },
    'air-genasi': 
    {
        'name': 'Air Genasi',
        'weight': 25,
        'enabled': true,
        'features': [
            {
                'name': 'Unending Breath'
            },
            {
                'name': 'Mingle with the Wind',
                'spellcasting': true
            },
            {
                'name': 'Lightning Resistance'
            }
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'movement': {
            'walk': 35
        },
        'dr': [
            'lightning'
        ],
        'spells': [
            {
                'name': 'Shocking Grasp'
            },
            {
                'name': 'Feather Fall',
                'level': 3,
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                }
            },
            {
                'name': 'Levitate',
                'level': 5,
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                }
            },
            {
                'name': 'Feather Fall',
                'level': 3
            },
            {
                'name': 'Levitate',
                'level': 5
            }
        ],
        'languages': [
            'primordial',
            'auran'
        ],
        'abilities': {
            'con': 2,
            'dex': 1
        }
    },
    'astral-elf': 
    {
        'name': 'Astral Elf',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Starlight Step',
                'description': 'Starlight Step',
                'uses': {
                    'max': '@prof'
                }
            },
            {
                'name': 'Fey Ancestry',
                'description': 'Fey Ancestry (Astral Elf)'
            },
            {
                'name': 'Astral Trance',
                'description': 'Astral Trance'
            },
            {
                'name': 'Astral Fire',
                'spellcasting': true
            },
            {
                'name': 'Keen Senses'
            }
        ],
        'spells': [
            {
                'name': 'Dancing Lights'
            },
            {
                'name': 'Light'
            },
            {
                'name': 'Sacred Flame'
            }
        ],
        'languages': [
            'elvish'
        ]
    },
    'autognome': 
    {
        'name': 'Autognome',
        'weight': 5,
        'enabled': false,
        'monster': 'Autognome'
    },
    'bugbear': 
    {
        'name': 'Bugbear',
        'weight': 25,
        'enabled': true,
        'monster': 'Bugbear'
    },
    'centaur': 
    {
        'name': 'Centaur',
        'weight': 25,
        'enabled': true,
        'monster': 'Centaur'
    },
    'changeling': 
    {
        'name': 'Changeling',
        'weight': 5,
        'enabled': true,
        'monster': 'Changeling'
    },
    'deep-gnome': 
    {
        'name': 'Deep Gnome',
        'weight': 25,
        'enabled': true,
        'monster': 'Deep Gnome (Svirfneblin)'
    },
    'dhampir': 
    {
        'name': 'Dhampir',
        'weight': 5,
        'enabled': false,
        'movement': {
            'walk': 35
        },
        'senses': {
            'darkvision': 60
        },
        'features': [
            {
                'name': 'Deathless Nature'
            },
            {
                'name': 'Spider Climb',
                'description': 'Spider Climb'
            },
            {
                'name': 'Vampiric Bite',
                'description': 'Vampiric Bite',
                'uses': {
                    'max': '@prof'
                }
            }
        ],
        'abilities': {
            'dex': 2,
            'int': 1
        }
    },
    'black-chromatic-dragonborn':
    {
        'name': 'Black Chromatic Dragonborn',
        'weight': 10,
        'enabled': false,
        'features': [
            {
                'name': 'Chromatic Ancestry',
                'description': 'Chromatic Ancestry'
            },
            {
                'name': 'Draconic Resistance',
                'description': 'Draconic Resistance (Chromatic Dragonborn)'
            },
            {
                'name': 'Acid Breath Weapon',
                'description': 'Breath Weapon (Chromatic Dragonborn)',
                'uses': {
                    'max': '@prof'
                }
            },
            {
                'name': 'Chromatic Warding (Acid)',
                'description': 'Chromatic Warding'
            }
        ],
        'dr': [
            'acid'
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'blue-chromatic-dragonborn':
    {
        'name': 'Blue Chromatic Dragonborn',
        'weight': 10,
        'enabled': false,
        'features': [
            {
                'name': 'Chromatic Ancestry',
                'description': 'Chromatic Ancestry'
            },
            {
                'name': 'Draconic Resistance',
                'description': 'Draconic Resistance (Chromatic Dragonborn)'
            },
            {
                'name': 'Lightning Breath Weapon',
                'description': 'Breath Weapon (Chromatic Dragonborn)',
                'uses': {
                    'max': '@prof'
                }
            },
            {
                'name': 'Chromatic Warding (Lightning)',
                'description': 'Chromatic Warding'
            }
        ],
        'dr': [
            'lightning'
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'green-chromatic-dragonborn':
    {
        'name': 'Green Chromatic Dragonborn',
        'weight': 10,
        'enabled': false,
        'features': [
            {
                'name': 'Chromatic Ancestry',
                'description': 'Chromatic Ancestry'
            },
            {
                'name': 'Draconic Resistance',
                'description': 'Draconic Resistance (Chromatic Dragonborn)'
            },
            {
                'name': 'Poision Breath Weapon',
                'description': 'Breath Weapon (Chromatic Dragonborn)',
                'uses': {
                    'max': '@prof'
                }
            },
            {
                'name': 'Chromatic Warding (Poision)',
                'description': 'Chromatic Warding'
            }
        ],
        'dr': [
            'poision'
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'red-chromatic-dragonborn':
    {
        'name': 'Red Chromatic Dragonborn',
        'weight': 10,
        'enabled': false,
        'features': [
            {
                'name': 'Chromatic Ancestry',
                'description': 'Chromatic Ancestry'
            },
            {
                'name': 'Draconic Resistance',
                'description': 'Draconic Resistance (Chromatic Dragonborn)'
            },
            {
                'name': 'Fire Breath Weapon',
                'description': 'Breath Weapon (Chromatic Dragonborn)',
                'uses': {
                    'max': '@prof'
                }
            },
            {
                'name': 'Chromatic Warding (Fire)',
                'description': 'Chromatic Warding'
            }
        ],
        'dr': [
            'fire'
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'white-chromatic-dragonborn':
    {
        'name': 'White Chromatic Dragonborn',
        'weight': 10,
        'enabled': false,
        'features': [
            {
                'name': 'Chromatic Ancestry',
                'description': 'Chromatic Ancestry'
            },
            {
                'name': 'Draconic Resistance',
                'description': 'Draconic Resistance (Chromatic Dragonborn)'
            },
            {
                'name': 'Cold Breath Weapon',
                'description': 'Breath Weapon (Chromatic Dragonborn)',
                'uses': {
                    'max': '@prof'
                }
            },
            {
                'name': 'Chromatic Warding (Cold)',
                'description': 'Chromatic Warding'
            }
        ],
        'dr': [
            'Cold'
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'black-draconblood-dragonborn':
    {
        'name': 'Black Draconblood Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Black)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Forceful Presence',
                'description': 'Forceful Presence'
            },
            {
                'name': 'Draconic Ancestry'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'blue-draconblood-dragonborn':
    {
        'name': 'Blue Draconblood Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Blue)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Forceful Presence',
                'description': 'Forceful Presence'
            },
            {
                'name': 'Draconic Ancestry'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'brass-draconblood-dragonborn':
    {
        'name': 'Brass Draconblood Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Brass)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Forceful Presence',
                'description': 'Forceful Presence'
            },
            {
                'name': 'Draconic Ancestry'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'bronze-draconblood-dragonborn':
    {
        'name': 'Bronze Draconblood Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Bronze)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Forceful Presence',
                'description': 'Forceful Presence'
            },
            {
                'name': 'Draconic Ancestry'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'copper-draconblood-dragonborn':
    {
        'name': 'Copper Draconblood Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Copper)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Forceful Presence',
                'description': 'Forceful Presence'
            },
            {
                'name': 'Draconic Ancestry'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'gold-draconblood-dragonborn':
    {
        'name': 'Gold Draconblood Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Gold)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Forceful Presence',
                'description': 'Forceful Presence'
            },
            {
                'name': 'Draconic Ancestry'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'green-draconblood-dragonborn':
    {
        'name': 'Green Draconblood Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Green)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Forceful Presence',
                'description': 'Forceful Presence'
            },
            {
                'name': 'Draconic Ancestry'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'red-draconblood-dragonborn':
    {
        'name': 'Red Draconblood Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Red)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Forceful Presence',
                'description': 'Forceful Presence'
            },
            {
                'name': 'Draconic Ancestry'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'silver-draconblood-dragonborn':
    {
        'name': 'Silver Draconblood Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Silver)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Forceful Presence',
                'description': 'Forceful Presence'
            },
            {
                'name': 'Draconic Ancestry'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'white-draconblood-dragonborn':
    {
        'name': 'White Draconblood Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (White)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Forceful Presence',
                'description': 'Forceful Presence'
            },
            {
                'name': 'Draconic Ancestry'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'amethyst-gem-dragonborn':
    {
        'name': 'Amethyst Gem Dragonborn',
        'weight': 2,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Force)',
                'description': 'Breath Weapon (Gem Dragonborn)',
                'uses': {
                    'max': '@prof'
                }
            },
            {
                'name': 'Draconic Resistance (Gem Dragonborn)'
            },
            {
                'name': 'Psionic Mind'
            },
            {
                'name': 'Gem Flight',
                'description': 'Gem Flight',
                'level': 5
            }
        ],
        'dr': [
            'force'
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'crystal-gem-dragonborn':
    {
        'name': 'Crystal Gem Dragonborn',
        'weight': 2,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Radiant)',
                'description': 'Breath Weapon (Gem Dragonborn)',
                'uses': {
                    'max': '@prof'
                }
            },
            {
                'name': 'Draconic Resistance (Gem Dragonborn)'
            },
            {
                'name': 'Psionic Mind'
            },
            {
                'name': 'Gem Flight',
                'description': 'Gem Flight',
                'level': 5
            }
        ],
        'dr': [
            'radiant'
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'emerald-gem-dragonborn':
    {
        'name': 'Emerald Gem Dragonborn',
        'weight': 2,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Psychic)',
                'description': 'Breath Weapon (Gem Dragonborn)',
                'uses': {
                    'max': '@prof'
                }
            },
            {
                'name': 'Draconic Resistance (Gem Dragonborn)'
            },
            {
                'name': 'Psionic Mind'
            },
            {
                'name': 'Gem Flight',
                'description': 'Gem Flight',
                'level': 5
            }
        ],
        'dr': [
            'psychic'
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'sapphire-gem-dragonborn':
    {
        'name': 'Sapphire Gem Dragonborn',
        'weight': 2,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Thunder)',
                'description': 'Breath Weapon (Gem Dragonborn)',
                'uses': {
                    'max': '@prof'
                }
            },
            {
                'name': 'Draconic Resistance (Gem Dragonborn)'
            },
            {
                'name': 'Psionic Mind'
            },
            {
                'name': 'Gem Flight',
                'description': 'Gem Flight',
                'level': 5
            }
        ],
        'dr': [
            'thunder'
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'topaz-gem-dragonborn':
    {
        'name': 'Topaz Gem Dragonborn',
        'weight': 2,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Necrotic)',
                'description': 'Breath Weapon (Gem Dragonborn)',
                'uses': {
                    'max': '@prof'
                }
            },
            {
                'name': 'Draconic Resistance (Gem Dragonborn)'
            },
            {
                'name': 'Psionic Mind'
            },
            {
                'name': 'Gem Flight',
                'description': 'Gem Flight',
                'level': 5
            }
        ],
        'dr': [
            'necrotic'
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'brass-metallic-dragonborn':
    {
        'name': 'Brass Metallic Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Metallic Ancestry'
            },
            {
                'name': 'Breath Weapon (Fire)',
                'description': 'Breath Weapon (Metallic Dragonborn)',
                'uses': {
                    'max': '@prof'
                }
            },
            {
                'name': 'Draconic Resistance (Metallic Dragonborn)'
            },
            {
                'name': 'Metallic Breath Weapon',
                'description': 'Metallic Breath Weapon',
                'level': 5
            }
        ],
        'dr': [
            'fire'
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'bronze-metallic-dragonborn':
    {
        'name': 'Bronze Metallic Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Metallic Ancestry'
            },
            {
                'name': 'Breath Weapon (Lightning)',
                'description': 'Breath Weapon (Metallic Dragonborn)',
                'uses': {
                    'max': '@prof'
                }
            },
            {
                'name': 'Draconic Resistance (Metallic Dragonborn)'
            },
            {
                'name': 'Metallic Breath Weapon',
                'description': 'Metallic Breath Weapon',
                'level': 5
            }
        ],
        'dr': [
            'lightning'
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'copper-metallic-dragonborn':
    {
        'name': 'Copper Metallic Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Metallic Ancestry'
            },
            {
                'name': 'Breath Weapon (Acid)',
                'description': 'Breath Weapon (Metallic Dragonborn)',
                'uses': {
                    'max': '@prof'
                }
            },
            {
                'name': 'Draconic Resistance (Metallic Dragonborn)'
            },
            {
                'name': 'Metallic Breath Weapon',
                'description': 'Metallic Breath Weapon',
                'level': 5
            }
        ],
        'dr': [
            'acid'
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'gold-metallic-dragonborn':
    {
        'name': 'Gold Metallic Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Metallic Ancestry'
            },
            {
                'name': 'Breath Weapon (Fire)',
                'description': 'Breath Weapon (Metallic Dragonborn)',
                'uses': {
                    'max': '@prof'
                }
            },
            {
                'name': 'Draconic Resistance (Metallic Dragonborn)'
            },
            {
                'name': 'Metallic Breath Weapon',
                'description': 'Metallic Breath Weapon',
                'level': 5
            }
        ],
        'dr': [
            'fire'
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'silver-metallic-dragonborn':
    {
        'name': 'Silver Metallic Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Metallic Ancestry'
            },
            {
                'name': 'Breath Weapon (Cold)',
                'description': 'Breath Weapon (Metallic Dragonborn)',
                'uses': {
                    'max': '@prof'
                }
            },
            {
                'name': 'Draconic Resistance (Metallic Dragonborn)'
            },
            {
                'name': 'Metallic Breath Weapon',
                'description': 'Metallic Breath Weapon',
                'level': 5
            }
        ],
        'dr': [
            'cold'
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'black-ravenite-dragonborn':
    {
        'name': 'Black Ravenite Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Black)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Vengeful Assault'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'blue-ravenite-dragonborn':
    {
        'name': 'Blue Ravenite Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Blue)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Vengeful Assault'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'brass-ravenite-dragonborn':
    {
        'name': 'Brass Ravenite Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Brass)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Vengeful Assault'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'bronze-ravenite-dragonborn':
    {
        'name': 'Bronze Ravenite Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Bronze)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Vengeful Assault'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'copper-ravenite-dragonborn':
    {
        'name': 'Copper Ravenite Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Copper)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Vengeful Assault'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'gold-ravenite-dragonborn':
    {
        'name': 'Gold Ravenite Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Gold)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Vengeful Assault'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'green-ravenite-dragonborn':
    {
        'name': 'Green Ravenite Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Green)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Vengeful Assault'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'red-ravenite-dragonborn':
    {
        'name': 'Red Ravenite Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Red)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Vengeful Assault'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'silver-ravenite-dragonborn':
    {
        'name': 'Silver Ravenite Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (Silver)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Vengeful Assault'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'white-ravenite-dragonborn':
    {
        'name': 'White Ravenite Dragonborn',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Breath Weapon (White)',
                'description': 'Breath Weapon (Dragonborn)'
            },
            {
                'name': 'Vengeful Assault'
            }
        ],
        'languages': [
            'draconic'
        ],
        'abilities': {
            'str': 2,
            'cha': 1
        }
    },
    'duergar':
    {
        'name': 'Duergar',
        'weight': 50,
        'enabled': true
    },
    'hill-dwarf':
    {
        'name': 'Hill Dwarf',
        'weight': 50,
        'enabled': true,
        'features': [
            {
                'name': 'Dwarven Resilience',
                'description': 'Dwarven Resilience'
            },
            {
                'name': 'Dwarven Combat Training'
            },
            {
                'name': 'Stonecunning',
                'description': 'Stonecunning'
            },
            {
                'name': 'Dwarven Toughness'
            },
            {
                'name': 'Tool Proficiency'
            }
        ],
        'languages': [
            'dwarvish'
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'special': function(actor, updates) {
            let bonusHP = Math.ceil(chris.levelOrCR(actor));
            let currentHP = updates.actor?.system?.attributes?.hp?.value ?? actor.system.attributes.hp.max;
            setProperty(updates, 'actor.system.attributes.hp.max', currentHP + bonusHP);
            setProperty(updates, 'actor.system.attributes.hp.value', currentHP + bonusHP);
            let weaponProf = updates.actor?.system?.traits?.weaponProf?.value ?? actor.system.traits?.weaponProf?.value ? Array.from(actor.system.traits.weaponProf.value) : [];
            if (!weaponProf.includes('battleaxe')) weaponProf.push('battleaxe');
            if (!weaponProf.includes('handaxe')) weaponProf.push('handaxe');
            if (!weaponProf.includes('lighthammer')) weaponProf.push('lighthammer');
            if (!weaponProf.includes('warhammer')) weaponProf.push('warhammer');
            setProperty(updates, 'actor.system.traits.weaponProf.value', weaponProf);
        },
        'abilities': {
            'con': 2,
            'wis': 1
        },
        'extraTools': {
            'proficient': {
                'name': 'choose',
                'options': [
                    'smith',
                    'brewer',
                    'mason'
                ],
                'count': 1
            }
        }
    },
    'mountain-dwarf':
    {
        'name': 'Mountain Dwarf',
        'weight': 50,
        'enabled': false,
        'features': [
            {
                'name': 'Dwarven Resilience',
                'description': 'Dwarven Resilience'
            },
            {
                'name': 'Dwarven Combat Training'
            },
            {
                'name': 'Stonecunning',
                'description': 'Stonecunning'
            },
            {
                'name': 'Dwarven Armor Training'
            },
            {
                'name': 'Tool Proficiency'
            }
        ],
        'languages': [
            'dwarvish'
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'special': function(actor, updates) {
            let weaponProf = updates.actor?.system?.traits?.weaponProf?.value ?? actor.system.traits?.weaponProf?.value ? Array.from(actor.system.traits.weaponProf.value) : [];
            if (!weaponProf.includes('battleaxe')) weaponProf.push('battleaxe');
            if (!weaponProf.includes('handaxe')) weaponProf.push('handaxe');
            if (!weaponProf.includes('lighthammer')) weaponProf.push('lighthammer');
            if (!weaponProf.includes('warhammer')) weaponProf.push('warhammer');
            setProperty(updates, 'actor.system.traits.weaponProf.value', weaponProf);
            let armorProf = updates.actor?.system?.traits?.armorProf?.value ?? actor.system.traits?.armorProf?.value ? Array.from(actor.system.traits.armorProf.value) : [];
            if (!armorProf.includes('lgt')) armorProf.push('lgt');
            if (!armorProf.includes('med')) armorProf.push('med');
            setProperty(updates, 'actor.system.traits.armorProf.value', armorProf);
        },
        'abilities': {
            'con': 2,
            'str': 2
        },
        'extraTools': {
            'proficient': {
                'name': 'choose',
                'options': [
                    'smith',
                    'brewer',
                    'mason'
                ],
                'count': 1
            }
        }
    },
    'mark-of-warding-dwarf':
    {
        'name': 'Mark of Warding Dwarf',
        'weight': 25,
        'enabled': false,
        'features': [
            {
                'name': 'Dwarven Resilience',
                'description': 'Dwarven Resilience'
            },
            {
                'name': 'Dwarven Combat Training'
            },
            {
                'name': 'Stonecunning',
                'description': 'Stonecunning'
            },
            {
                'name': 'Warder\'s Intuition',
                'description': 'Warder\'s Intuition'
            },
            {
                'name': 'Wards and Seals',
                'description': 'Wards and Seals',
                'spellcasting': true
            },
            {
                'name': 'Spells of the Mark',
                'description': 'Spells of the Mark (Mark of Warding Dwarf)',
                'spellcasting': true
            },
            {
                'name': 'Tool Proficiency'
            }
        ],
        'spells': [
            {
                'name': 'Alarm',
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'ability': 'int'
            },
            {
                'name': 'Mage Armor',
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'ability': 'int'
            },
            {
                'name': 'Arcane Lock',
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'level': 3,
                'ability': 'int'
            },
            {
                'name': 'Alarm',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 1
            },
            {
                'name': 'Armor of Agathys',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 1
            },
            {
                'name': 'Arcane Lock',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 3
            },
            {
                'name': 'Knock',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 3
            },
            {
                'name': 'Glyph of Warding',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 5
            },
            {
                'name': 'Magic Circle',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 5
            },
            {
                'name': 'Leomund\'s Secret Chest',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 7
            },
            {
                'name': 'Mordenkainen\'s Faithful Hound',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 7
            },
            {
                'name': 'Antilife Shell',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 9
            }
        ],
        'languages': [
            'dwarvish'
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'abilities': {
            'con': 2,
            'int': 1
        },
        'extraTools': {
            'proficient': {
                'name': 'choose',
                'options': [
                    'smith',
                    'brewer',
                    'mason'
                ],
                'count': 1
            }
        }
    },
    'earth-genasi':
    {
        'name': 'Earth Genasi',
        'weight': 25,
        'enabled': true,
        'features': [
            {
                'name': 'Earth Walk',
                'description': 'Earth Walk'
            },
            {
                'name': 'Merge with Stone',
                'description': 'Merge with Stone',
                'spellcasting': true
            }
        ],
        'spells': [
            {
                'name': 'Blade Ward',
                'activation': {
                    'condition': '',
                    'cost': 1,
                    'type': 'bonus'
                },
                'uses': {
                    'max': '@prof',
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                }
            },
            {
                'name': 'Blade Ward',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                }
            },
            {
                'name': 'Pass without Trace',
                'uses': {
                    'max': 1,
                    'per': 'day',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'level': 5
            },
            {
                'name': 'Pass without Trace',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 5
            }
        ],
        'languages': [
            'primordial',
            'terran'
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'abilities': {
            'con': 2,
            'str': 1
        }
    },
    'autumn-eladrin':
    {
        'name': 'Autumn Eladrin',
        'weight': 10,
        'enabled': true,
        'monster': 'Autumn Eladrin',
        'special': function (actor, updates) {
            let level = chris.levelOrCR(actor);
            let bonusDamageDice = Math.max(Math.ceil(level / 2), 1);
            setProperty(updates, 'embedded.Item.Longsword.system.damage.parts', [['1d8[slashing] + @mod', 'slashing'], [bonusDamageDice + 'd8[psychic]', 'psychic']]);
            setProperty(updates, 'embedded.Item.Longbow.system.damage.parts', [['1d8[slashing] + @mod', 'slashing'], [bonusDamageDice + 'd8[psychic]', 'psychic']]);
            setProperty(updates, 'embedded.Item.Longsword.system.damage.versatile', '1d10[slashing] + @mod ' + bonusDamageDice + 'd8[psychic]', 'psychic');
            let averageDamage = bonusDamageDice * 4;
            let descriptionLongsword = getProperty(updates, 'embedded.Item.Longsword.system.description.value')?.replace('22 (5d8)', averageDamage + ' (' + bonusDamageDice + 'd8)');
            let descriptionLongbow = getProperty(updates, 'embedded.Item.Longbow.system.description.value')?.replace('22 (5d8)', averageDamage + ' (' + bonusDamageDice + 'd8)');
            setProperty(updates, 'embedded.Item.Longsword.system.description.value', descriptionLongsword);
            setProperty(updates, 'embedded.Item.Longbow.system.description.value', descriptionLongbow);
        }
    },
    'winter-eladrin':
    {
        'name': 'Winter Eladrin',
        'weight': 10,
        'enabled': true,
        'monster': 'Winter Eladrin',
        'special': function (actor, updates) {
            let level = chris.levelOrCR(actor);
            let bonusDamageDice = Math.max(Math.floor(level /3), 1);
            setProperty(updates, 'embedded.Item.Longsword.system.damage.parts', [['1d8[slashing] + @mod', 'slashing'], [bonusDamageDice + 'd8[cold]', 'cold']]);
            setProperty(updates, 'embedded.Item.Longbow.system.damage.parts', [['1d8[slashing] + @mod', 'slashing'], [bonusDamageDice + 'd8[cold]', 'cold']]);
            setProperty(updates, 'embedded.Item.Longsword.system.damage.versatile', '1d10[slashing] + @mod ' + bonusDamageDice + 'd8[cold]', 'cold');
            let averageDamage = bonusDamageDice * 4;
            let descriptionLongsword = getProperty(updates, 'embedded.Item.Longsword.system.description.value')?.replace('13 (3d8)', averageDamage + ' (' + bonusDamageDice + 'd8)');
            let descriptionLongbow = getProperty(updates, 'embedded.Item.Longbow.system.description.value')?.replace('13 (3d8)', averageDamage + ' (' + bonusDamageDice + 'd8)');
            setProperty(updates, 'embedded.Item.Longsword.system.description.value', descriptionLongsword);
            setProperty(updates, 'embedded.Item.Longbow.system.description.value', descriptionLongbow);
        }
    },
    'spring-eladrin':
    {
        'name': 'Spring Eladrin',
        'weight': 10,
        'enabled': true,
        'monster': 'Spring Eladrin',
        'special': function (actor, updates) {
            let level = chris.levelOrCR(actor);
            let bonusDamageDice = Math.max(Math.ceil(level / 2), 1);
            setProperty(updates, 'embedded.Item.Longsword.system.damage.parts', [['1d8[slashing] + @mod', 'slashing'], [bonusDamageDice + 'd8[psychic]', 'psychic']]);
            setProperty(updates, 'embedded.Item.Longbow.system.damage.parts', [['1d8[slashing] + @mod', 'slashing'], [bonusDamageDice + 'd8[psychic]', 'psychic']]);
            setProperty(updates, 'embedded.Item.Longsword.system.damage.versatile', '1d10[slashing] + @mod ' + bonusDamageDice + 'd8[psychic]', 'psychic');
            let averageDamage = bonusDamageDice * 4;
            let descriptionLongsword = getProperty(updates, 'embedded.Item.Longsword.system.description.value')?.replace('22 (5d8)', averageDamage + ' (' + bonusDamageDice + 'd8)');
            let descriptionLongbow = getProperty(updates, 'embedded.Item.Longbow.system.description.value')?.replace('22 (5d8)', averageDamage + ' (' + bonusDamageDice + 'd8)');
            setProperty(updates, 'embedded.Item.Longsword.system.description.value', descriptionLongsword);
            setProperty(updates, 'embedded.Item.Longbow.system.description.value', descriptionLongbow);
        }
    },
    'summer-eladrin':
    {
        'name': 'Summer Eladrin',
        'weight': 10,
        'enabled': true,
        'monster': 'Summer Eladrin',
        'special': function (actor, updates) {
            let level = chris.levelOrCR(actor);
            let bonusDamageDice = Math.max(Math.floor(level /5), 1);
            setProperty(updates, 'embedded.Item.Longsword.system.damage.parts', [['1d8[slashing] + @mod', 'slashing'], [bonusDamageDice + 'd8[fire]', 'fire']]);
            setProperty(updates, 'embedded.Item.Longbow.system.damage.parts', [['1d8[slashing] + @mod', 'slashing'], [bonusDamageDice + 'd8[fire]', 'fire']]);
            setProperty(updates, 'embedded.Item.Longsword.system.damage.versatile', '1d10[slashing] + @mod ' + bonusDamageDice + 'd8[fire]', 'fire');
            let averageDamage = bonusDamageDice * 4;
            let descriptionLongsword = getProperty(updates, 'embedded.Item.Longsword.system.description.value')?.replace('9 (2d8)', averageDamage + ' (' + bonusDamageDice + 'd8)');
            let descriptionLongbow = getProperty(updates, 'embedded.Item.Longbow.system.description.value')?.replace('9 (2d8)', averageDamage + ' (' + bonusDamageDice + 'd8)');
            setProperty(updates, 'embedded.Item.Longsword.system.description.value', descriptionLongsword);
            setProperty(updates, 'embedded.Item.Longbow.system.description.value', descriptionLongbow);
        }
    },
    'aereni-high-elf':
    {
        'name': 'Aereni High Elf',
        'weight': 25,
        'enabled': false,
        'features': [
            {
                'name': 'Keen Senses'
            },
            {
                'name': 'Fey Ancestry',
                'description': 'Fey Ancestry (Aereni High Elf)'
            },
            {
                'name': 'Trance'
            },
            {
                'name': 'Aereni Elf'
            },
            {
                'name': 'Cantrip (Aereni High Elf)',
                'rename': 'Cantrip',
                'spellcasting': true
            }
        ],
        'spellcasting': {
            'wizard': {
                'cantrip': 1
            }
        },
        'extraSkills': {
            'expertise': {
                'name': 'any',
                'count': 1
            }
        },
        'languages': [
            'elvish'
        ],
        'extraLanguages': [
            {
                'name': 'any',
                'count': 1
            }
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'abilities': {
            'dex': 2,
            'int': 1
        },
        'skills': {
            'prc': 1
        }
    },
    'aereni-wood-elf':
    {
        'name': 'Aereni Wood Elf',
        'weight': 25,
        'enabled': false,
        'features': [
            {
                'name': 'Keen Senses'
            },
            {
                'name': 'Fey Ancestry',
                'description': 'Fey Ancestry (Aereni Wood Elf)'
            },
            {
                'name': 'Trance'
            },
            {
                'name': 'Aereni Elf'
            },
            {
                'name': 'Fleet of Foot'
            },
            {
                'name': 'Mask of the Wild'
            }
        ],
        'languages': [
            'elvish'
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'extraSkills': {
            'expertise': {
                'name': 'any',
                'count': 1
            }
        },
        'movement': {
            'walk': 35
        },
        'skills': {
            'prc': 1
        },
        'abilities': {
            'dex': 2,
            'wis': 1
        },
        'skills': {
            'per': 1
        }
    },
    'drow':
    {
        'name': 'Drow',
        'weight': 25,
        'enabled': true,
        'monster': 'Drow'
    },
    'high-elf':
    {
        'name': 'High Elf',
        'weight': 50,
        'enabled': true,
        'features': [
            {
                'name': 'Keen Senses'
            },
            {
                'name': 'Fey Ancestry',
                'description': 'Fey Ancestry (High Elf)'
            },
            {
                'name': 'Trance'
            },
            {
                'name': 'Elf Weapon Training'
            },
            {
                'name': 'Cantrip (High Elf)',
                'rename': 'Cantrip',
                'spellcasting': true
            }
        ],
        'spellcasting': {
            'wizard': {
                'cantrip': 1
            }
        },
        'languages': [
            'elvish'
        ],
        'extraLanguages': [
            {
                'name': 'any',
                'count': 1
            }
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'abilities': {
            'dex': 2,
            'int': 1
        },
        'special': function(actor, updates) {
            let weaponProf = updates.actor?.system?.traits?.weaponProf?.value ?? actor.system.traits?.weaponProf?.value ? Array.from(actor.system.traits.weaponProf.value) : [];
            if (!weaponProf.includes('longsword')) weaponProf.push('longsword');
            if (!weaponProf.includes('shortsword')) weaponProf.push('shortsword');
            if (!weaponProf.includes('shortbow')) weaponProf.push('shortbow');
            if (!weaponProf.includes('longbow')) weaponProf.push('longbow');
            setProperty(updates, 'actor.system.traits.weaponProf.value', weaponProf);
        },
        'skills': {
            'prc': 1
        }
    },
    'mark-of-shadow-elf':
    {
        'name': 'Mark of Shadow Elf',
        'weight': 25,
        'enabled': false,
        'features': [
            {
                'name': 'Keen Senses'
            },
            {
                'name': 'Fey Ancestry',
                'description': 'Fey Ancestry (Mark of Shadow Elf)'
            },
            {
                'name': 'Trance'
            },
            {
                'name': 'Cunning Intuition'
            },
            {
                'name': 'Shape Shadows',
                'spellcasting': true
            },
            {
                'name': 'Spells of the Mark',
                'description': 'Spells of the Mark (Mark of Shadow Elf)',
                'spellcasting': true
            }
        ],
        'spells': [
            {
                'name': 'Minor Illusion'
            },
            {
                'name': 'Invisibility',
                'level': 3,
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'ability': 'cha'
            },
            {
                'name': 'Disguise Self',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 1
            },
            {
                'name': 'Silent Image',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 1
            },
            {
                'name': 'Darkness',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 3
            },
            {
                'name': 'Pass without Trace',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 3
            },
            {
                'name': 'Clairvoyance',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 5
            },
            {
                'name': 'Major Image',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 5
            },
            {
                'name': 'Greater Invisibility',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 7
            },
            {
                'name': 'Hallucinatory Terrain',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 7
            },
            {
                'name': 'Mislead',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 9
            }
        ],
        'languages': [
            'elvish'
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'abilities': {
            'dex': 2,
            'cha': 1
        },
        'skills': {
            'prc': 1
        }
    },
    'pallid-elf':
    {
        'name': 'Pallid Elf',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Keen Senses'
            },
            {
                'name': 'Fey Ancestry',
                'description': 'Fey Ancestry (Pallid Elf)'
            },
            {
                'name': 'Trance'
            },
            {
                'name': 'Incisive Sense',
                'description': 'Incisive Sense'
            },
            {
                'name': 'Blessing of the Moon Weaver',
                'spellcasting': true
            }
        ],
        'spells': [
            {
                'name': 'Light',
                'ability': 'wis'
            },
            {
                'name': 'Sleep',
                'level': 3,
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'ability': 'wis'
            },
            {
                'name': 'Invisibility',
                'level': 5,
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'target': {
                    'type': 'self',
                    'units': null,
                    'value': null,
                    'width': null
                },
                'range': {
                    'long': null,
                    'units': 'self',
                    'value': null
                },
                'ability': 'wis'
            }
        ],
        'languages': [
            'elvish'
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'abilities': {
            'dex': 2,
            'wis': 1
        },
        'skills': {
            'prc': 1
        }
    },
    'valenar-high-elf':
    {
        'name': 'Valenar High Elf',
        'weight': 25,
        'enabled': false,
        'features': [
            {
                'name': 'Keen Senses'
            },
            {
                'name': 'Fey Ancestry',
                'description': 'Fey Ancestry (Valenar High Elf)'
            },
            {
                'name': 'Trance'
            },
            {
                'name': 'Valenar Elf'
            },
            {
                'name': 'Cantrip (High Elf)',
                'rename': 'Cantrip',
                'spellcasting': true
            }
        ],
        'spellcasting': {
            'wizard': {
                'cantrip': 1
            }
        },
        'languages': [
            'elvish'
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'abilities': {
            'dex': 2,
            'int': 1
        },
        'special': function(actor, updates) {
            let weaponProf = updates.actor?.system?.traits?.weaponProf?.value ?? actor.system.traits?.weaponProf?.value ? Array.from(actor.system.traits.weaponProf.value) : [];
            if (!weaponProf.includes('scimitar')) weaponProf.push('scimitar');
            if (!weaponProf.includes('longbow')) weaponProf.push('longbow');
            if (!weaponProf.includes('shortbow')) weaponProf.push('shortbow');
            setProperty(updates, 'actor.system.traits.weaponProf.value', weaponProf);
        },
        'skills': {
            'prc': 1
        }
    },
    'valenar-wood-elf':
    {
        'name': 'Valenar Wood Elf',
        'weight': 25,
        'enabled': false,
        'features': [
            {
                'name': 'Keen Senses'
            },
            {
                'name': 'Fey Ancestry',
                'description': 'Fey Ancestry (Valenar Wood Elf)'
            },
            {
                'name': 'Trance'
            },
            {
                'name': 'Valenar Elf'
            },
            {
                'name': 'Fleet of Foot'
            },
            {
                'name': 'Mask of the Wild'
            }
        ],
        'languages': [
            'elvish'
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'extraSkills': {
            'expertise': {
                'name': 'any',
                'count': 1
            }
        },
        'movement': {
            'walk': 35
        },
        'skills': {
            'prc': 1
        },
        'abilities': {
            'dex': 2,
            'wis': 1
        },
        'skills': {
            'per': 1
        },
        'special': function(actor, updates) {
            let weaponProf = updates.actor?.system?.traits?.weaponProf?.value ?? actor.system.traits?.weaponProf?.value ? Array.from(actor.system.traits.weaponProf.value) : [];
            if (!weaponProf.includes('scimitar')) weaponProf.push('scimitar');
            if (!weaponProf.includes('longbow')) weaponProf.push('longbow');
            if (!weaponProf.includes('shortbow')) weaponProf.push('shortbow');
            setProperty(updates, 'actor.system.traits.weaponProf.value', weaponProf);
        }
    },
    'wood-elf':
    {
        'name': 'Wood Elf',
        'weight': 50,
        'enabled': true,
        'features': [
            {
                'name': 'Keen Senses'
            },
            {
                'name': 'Fey Ancestry',
                'description': 'Fey Ancestry (Wood Elf)'
            },
            {
                'name': 'Trance'
            },
            {
                'name': 'Elf Weapon Training'
            },
            {
                'name': 'Fleet of Foot'
            },
            {
                'name': 'Mask of the Wild'
            }
        ],
        'languages': [
            'elvish'
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'extraSkills': {
            'expertise': {
                'name': 'any',
                'count': 1
            }
        },
        'movement': {
            'walk': 35
        },
        'skills': {
            'prc': 1
        },
        'abilities': {
            'dex': 2,
            'wis': 1
        },
        'skills': {
            'per': 1
        },
        'special': function(actor, updates) {
            let weaponProf = updates.actor?.system?.traits?.weaponProf?.value ?? actor.system.traits?.weaponProf?.value ? Array.from(actor.system.traits.weaponProf.value) : [];
            if (!weaponProf.includes('longsword')) weaponProf.push('longsword');
            if (!weaponProf.includes('shortsword')) weaponProf.push('shortsword');
            if (!weaponProf.includes('shortbow')) weaponProf.push('shortbow');
            if (!weaponProf.includes('longbow')) weaponProf.push('longbow');
            setProperty(updates, 'actor.system.traits.weaponProf.value', weaponProf);
        }
    },
    'fairy':
    {
        'name': 'Fairy',
        'weight': 5,
        'enabled': true,
        'features': [
            {
                'name': 'Fairy Magic',
                'spellcasting': true
            },
            {
                'name': 'Flight (Fairy)'
            }
        ],
        'spells': [
            {
                'name': 'Faerie Fire',
                'level': 3,
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                }
            },
            {
                'name': 'Faerie Fire',
                'level': 3,
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                }
            },
            {
                'name': 'Enlarge/Reduce',
                'level': 5,
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                }
            },
            {
                'name': 'Enlarge/Reduce',
                'level': 5,
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                }
            }
        ],
        'size': 'small',
        'movement': {
            'fly': 30
        }
    },
    'firbolg':
    {
        'name': 'Firbolg',
        'weight': 25,
        'enabled': true,
        'features': [
            {
                'name': 'Firbolg Magic',
                'spellcasting': true
            },
            {
                'name': 'Hidden Step',
                'description': 'Hidden Step',
                'uses': {
                    'max': '@prof'
                }
            },
            {
                'name': 'Powerful Build'
            },
            {
                'name': 'Speech of Beast and Leaf'
            }
        ],
        'spells': [
            {
                'name': 'Detect Magic',
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                }
            },
            {
                'name': 'Disguise Self',
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                }
            },
            {
                'name': 'Detect Magic',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                }
            },
            {
                'name': 'Disguise Self',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                }
            }
        ],
        'languages': [
            'elvish',
            'giant'
        ],
        'abilities': {
            'wis': 2,
            'str': 1
        }
    },
    'fire-genasi':
    {
        'name': 'Fire Genasi',
        'weight': 25,
        'enabled': true,
        'features': [
            {
                'name': 'Fire Resistance'
            },
            {
                'name': 'Reach to the Blaze',
                'spellcasting': true
            }
        ],
        'spells': [
            {
                'name': 'Produce Flame'
            },
            {
                'name': 'Burning Hands',
                'level': 3,
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                }
            },
            {
                'name': 'Flame Blade',
                'level': 5,
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                }
            },
            {
                'name': 'Burning Hands',
                'level': 3,
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                }
            },
            {
                'name': 'Flame Blade',
                'level': 5,
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                }
            }
        ],
        'dr': [
            'fire'
        ],
        'languages': [
            'primordial',
            'ignan'
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'abilities': {
            'con': 2,
            'int': 1
        }
    },
    'giff':
    {
        'name': 'Giff',
        'weight': 5,
        'enabled': false,
        'monster': 'Giff'
    },
    'githyanki':
    {
        'name': 'Githyanki',
        'weight': 10,
        'enabled': true,
        'features': [
            {
                'name': 'Astral Knowledge',
                'description': 'Astral Knowledge'
            },
            {
                'name': 'Githyanki Psionics',
                'spellcasting': true
            },
            {
                'name': 'Psychic Resilience'
            }
        ],
        'spells': [
            {
                'name': 'Mage Hand'
            },
            {
                'name': 'Jump',
                'level': 3,
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                }
            },
            {
                'name': 'Misty Step',
                'level': 5,
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                }
            },
            {
                'name': 'Jump',
                'level': 3,
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                }
            },
            {
                'name': 'Misty Step',
                'level': 5,
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                }
            }
        ],
        'dr': [
            'psychic'
        ],
        'languages': [
            'gith'
        ],
        'abilities': {
            'int': 1,
            'str': 2
        }
    },
    'githzerai':
    {
        'name': 'Githzerai',
        'weight': 10,
        'enabled': true,
        'features': [
            {
                'name': 'Mental Discipline (Githzerai)',
                'description': 'Mental Discipline (Githzerai)'
            },
            {
                'name': 'Githyanki Psionics',
                'spellcasting': true
            },
            {
                'name': 'Psychic Resilience'
            }
        ],
        'spells': [
            {
                'name': 'Mage Hand'
            },
            {
                'name': 'Shield',
                'level': 3,
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                }
            },
            {
                'name': 'Detect Thoughts',
                'level': 5,
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                }
            },
            {
                'name': 'Shield',
                'level': 3,
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                }
            },
            {
                'name': 'Detect Thoughts',
                'level': 5,
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                }
            }
        ],
        'dr': [
            'psychic'
        ],
        'languages': [
            'gith'
        ],
        'abilities': {
            'int': 1,
            'wis': 2
        }
    },
    'forest-gnome':
    {
        'name': 'Forest Gnome',
        'weight': 50,
        'enabled': true,
        'features': [
            {
                'name': 'Natural Illusionist',
                'spellcasting': true
            },
            {
                'name': 'Speak with Small Beasts'
            },
            {
                'name': 'Gnome Cunning',
                'description': 'Gnome Cunning'
            }
        ],
        'spells': [
            {
                'name': 'Minor Illusion',
                'ability': 'int'
            }
        ],
        'languages': [
            'gnomish'
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'movement': {
            'walk': 25
        },
        'size': 'small',
        'abilities': {
            'dex': 1,
            'int': 2
        }
    },
    'mark-of-scribing-gnome':
    {
        'name': 'Mark of Scribing Gnome',
        'weight': 25,
        'enabled': false,
        'features': [
            {
                'name': 'Gnome Cunning',
                'description': 'Gnome Cunning'
            },
            {
                'name': 'Gifted Scribe',
                'description': 'Gifted Scribe'
            },
            {
                'name': 'Scribe\'s Insight'
            },
            {
                'name': 'Spells of the Mark',
                'description': 'Spells of the Mark (Mark of Scribing Gnome)',
                'spellcasting': true
            }
        ],
        'spells': [
            {
                'name': 'Message',
                'ability': 'int'
            },
            {
                'name': 'Comprehend Languages',
                'ability': 'int',
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                }
            },
            {
                'name': 'Magic Mouth',
                'level': 3,
                'ability': 'int',
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                }
            },
            {
                'name': 'Comprehend Languages',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 1
            },
            {
                'name': 'Illusory Script',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 1
            },
            {
                'name': 'Animal Messenger',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 3
            },
            {
                'name': 'Silence',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 3
            },
            {
                'name': 'Sending',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 5
            },
            {
                'name': 'Tongues',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 5
            },
            {
                'name': 'Arcane Eye',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 7
            },
            {
                'name': 'Confusion',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 7
            },
            {
                'name': 'Dream',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 9
            }
        ],
        'languages': [
            'gnomish'
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'movement': {
            'walk': 25
        },
        'size': 'small',
        'abilities': {
            'cha': 1,
            'int': 2
        }
    },
    'rock-gnome':
    {
        'name': 'Rock Gnome',
        'weight': 50,
        'enabled': true,
        'features': [
            {
                'name': 'Artificer\'s Lore'
            },
            {
                'name': 'Tinker'
            },
            {
                'name': 'Gnome Cunning',
                'description': 'Gnome Cunning'
            }
        ],
        'languages': [
            'gnomish'
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'movement': {
            'walk': 25
        },
        'size': 'small',
        'abilities': {
            'con': 1,
            'int': 2
        }
    },
    'goblin':
    {
        'name': 'Goblin',
        'weight': 5,
        'enabled': true,
        'monster': 'Goblin'
    },
    'goliath':
    {
        'name': 'Goliath',
        'weight': 10,
        'enabled': true,
        'features': [
            {
                'name': 'Little Giant'
            },
            {
                'name': 'Mountain Born'
            },
            {
                'name': 'Stone\'s Endurance',
                'description': 'Stone\'s Endurance',
                'uses': {
                    'max': '@prof'
                }
            }
        ],
        'languages': [
            'giant'
        ],
        'abilities': {
            'str': 2,
            'con': 1
        },
        'dr': [
            'cold'
        ],
        'specialTraits': {
            'powerfulBuild': true
        },
        'skills': {
            'ath': 1
        }
    },
    'grung':
    {
        'name': 'Grung',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Arboreal Alertness'
            },
            {
                'name': 'Amphibious',
                'description': 'Amphibious (Grung)'
            },
            {
                'name': 'Poison Immunity'
            },
            {
                'name': 'Poisonous Skin',
                'description': 'Poisonous Skin'
            },
            {
                'name': 'Grung Poison',
                'description': 'Grung Poison'
            },
            {
                'name': 'Standing Leap'
            },
            {
                'name': 'Water Dependency'
            }
        ],
        'di': [
            'poison'
        ],
        'ci': [
            'poisoned'
        ],
        'special': async function (actor, updates) {
            let customLanguages = actor.system.traits.languages.custom;
            let addedLanguages = customLanguages === '' ? 'Grung' : ' ;Grung';
            setProperty(updates, 'actor.system.traits.languages.custom', customLanguages + addedLanguages);
        },
        'abilities': {
            'dex': 2,
            'con': 1
        },
        'skills': {
            'prc': 1
        }
    },
    'hadozee':
    {
        'name': 'Hadozee',
        'weight': 5,
        'enabled': false,
        'features': [
            {
                'name': 'Dexterous Feet'
            },
            {
                'name': 'Glide'
            },
            {
                'name': 'Hadozee Dodge',
                'description': 'Hadozee Dodge',
                'uses': {
                    'max': '@prof'
                }
            }
        ]
    },
    'aquatic-half-elf':
    {
        'name': 'Aquatic Half-Elf',
        'weight': 5,
        'enabled': true,
        'features': [
            {
                'name': 'Fey Ancestry',
                'description': 'Fey Ancestry (Aquatic Half-Elf)'
            },
            {
                'name': 'Aquatic Heritage'
            }
        ],
        'languages': [
            'elvish',
            'primordial'
        ],
        'abilities': {
            'cha': 2
        },
        'unassignedAbilities': {
            'one': 2
        },
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'movement': {
            'swim': 30
        }
    },
    'drow-half-elf':
    {
        'name': 'Drow Half-Elf',
        'weight': 10,
        'enabled': true,
        'features': [
            {
                'name': 'Fey Ancestry',
                'description': 'Fey Ancestry (Drow Half-Elf)'
            },
            {
                'name': 'Drow Magic',
                'spellcasting': true
            }
        ],
        'spells': [
            {
                'name': 'Dancing Lights'
            },
            {
                'name': 'Faerie Fire',
                'level': 3,
                'ability': 'cha',
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                }
            },
            {
                'name': 'Darkness',
                'level': 5,
                'ability': 'cha',
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                }
            }
        ],
        'languages': [
            'elvish',
            'undercommon'
        ],
        'abilities': {
            'cha': 2
        },
        'unassignedAbilities': {
            'one': 2
        },
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        }
    },
    'high-half-elf':
    {
        'name': 'High Half-Elf',
        'weight': 50,
        'enabled': true,
        'features': [
            {
                'name': 'Fey Ancestry',
                'description': 'Fey Ancestry (High Half-Elf)'
            },
            {
                'name': 'High Elf Descent',
                'spellcasting': true
            }
        ],
        'spellcasting': {
            'wizard': {
                'cantrip': 1
            }
        },
        'extraLanguages': [
            {
                'name': 'any',
                'count': 1
            }
        ],
        'languages': [
            'elvish'
        ],
        'abilities': {
            'cha': 2
        },
        'unassignedAbilities': {
            'one': 2
        },
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        }
    },
    'mark-of-detection-half-elf':
    {
        'name': 'Mark of Detection Half-Elf',
        'weight': 25,
        'enabled': false,
        'features': [
            {
                'name': 'Fey Ancestry',
                'description': 'Fey Ancestry (Mark of Detection Half-Elf)'
            },
            {
                'name': 'Deductive Intuition',
                'description': 'Deductive Intuition'
            },
            {
                'name': 'Magical Detection',
                'spellcasting': true
            },
            {
                'name': 'Spells of the Mark',
                'description': 'Spells of the Mark (Mark of Detection Half-Elf)',
                'spellcasting': true
            }
        ],
        'spells': [
            {
                'name': 'Detect Magic',
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'ability': 'wis'
            },
            {
                'name': 'Detect Poison and Disease',
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'ability': 'wis'
            },
            {
                'name': 'Detect Poison and Disease',
                'level': 3,
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'ability': 'wis'
            },
            {
                'name': 'Detect Evil and Good',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 1
            },
            {
                'name': 'Detect Poison and Disease',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 1
            },
            {
                'name': 'Detect Thoughts',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 3
            },
            {
                'name': 'Find Traps',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 3
            },
            {
                'name': 'Clairvoyance',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 5
            },
            {
                'name': 'Nondetection',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 5
            },
            {
                'name': 'Arcane Eye',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 7
            },
            {
                'name': 'Divination',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 7
            },
            {
                'name': 'Legend Lore',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 9
            }
        ],
        'extraLanguages': [
            {
                'name': 'any',
                'count': 1
            }
        ],
        'languages': [
            'elvish'
        ],
        'abilities': {
            'wis': 2
        },
        'unassignedAbilities': {
            'one': 1
        },
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        }
    },
    'mark-of-storm-half-elf':
    {
        'name': 'Mark of Storm Half-Elf',
        'weight': 25,
        'enabled': false,
        'features': [
            {
                'name': 'Fey Ancestry',
                'description': 'Fey Ancestry (Mark of Storm Half-Elf)'
            },
            {
                'name': 'Windwright\'s Intuition',
                'description': 'Windwright\'s Intuition'
            },
            {
                'name': 'Storm\'s Boon'
            },
            {
                'name': 'Headwinds',
                'spellcasting': true
            },
            {
                'name': 'Spells of the Mark',
                'description': 'Spells of the Mark (Mark of Storm Half-Elf)',
                'spellcasting': true
            }
        ],
        'spells': [
            {
                'name': 'Gust'
            },
            {
                'name': 'Gust of Wind',
                'level': 3,
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'ability': 'cha'
            },
            {
                'name': 'Feather Fall',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 1
            },
            {
                'name': 'Fog Cloud',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 1
            },
            {
                'name': 'Gust of Wind',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 3
            },
            {
                'name': 'Levitate',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 3
            },
            {
                'name': 'Sleet Storm',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 5
            },
            {
                'name': 'Wind Wall',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 5
            },
            {
                'name': 'Conjure Minor Elementals',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 7
            },
            {
                'name': 'Control Water',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 7
            },
            {
                'name': 'Conjure Elemental',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 9
            }
        ],
        'extraLanguages': [
            {
                'name': 'any',
                'count': 1
            }
        ],
        'languages': [
            'elvish'
        ],
        'abilities': {
            'cha': 2
        },
        'unassignedAbilities': {
            'one': 1
        },
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'dr': [
            'lightning'
        ]
    },
    'wood-half-elf':
    {
        'name': 'Wood Half-Elf',
        'weight': 50,
        'enabled': true,
        'features': [
            {
                'name': 'Fey Ancestry',
                'description': 'Fey Ancestry (Wood Half-Elf)'
            },
            {
                'name': 'Fleet of Foot'
            }
        ],
        'languages': [
            'elvish'
        ],
        'abilities': {
            'cha': 2
        },
        'unassignedAbilities': {
            'one': 2
        },
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'movement': {
            'walk': 35
        }
    },
    'half-orc':
    {
        'name': 'Half-Orc',
        'weight': 10,
        'enabled': true,
        'features': [
            {
                'name': 'Menacing'
            },
            {
                'name': 'Relentless Endurance',
                'description': 'Relentless Endurance'
            },
            {
                'name': 'Savage Attacks',
                'description': 'Savage Attacks'
            }
        ],
        'languages': [
            'orc'
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'skills': {
            'itm': 1
        },
        'abilitie': {
            'str': 2,
            'cont': 1
        }
    },
    'mark-of-finding-half-orc':
    {
        'name': 'Mark of Finding Half-Orc',
        'weight': 25,
        'enabled': false,
        'features': [
            {
                'name': 'Hunter\'s Intuition',
                'description': 'Hunter\'s Intuition'
            },
            {
                'name': 'Finder\'s Magic',
                'spellcasting': true
            },
            {
                'name': 'Spells of the Mark',
                'description': 'Spells of the Mark (Mark of Finding Human)',
                'spellcasting': true
            }
        ],
        'spells': [
            {
                'name': 'Hunter\'s Mark',
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'ability': 'wis'
            },
            {
                'name': 'Locate Object',
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'level': 3,
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'ability': 'wis'
            },
            {
                'name': 'Faerie Fire',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 1
            },
            {
                'name': 'Longstrider',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 1
            },
            {
                'name': 'Locate Animals or Plants',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 3
            },
            {
                'name': 'Locate Object',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 3
            },
            {
                'name': 'Clairvoyance',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 5
            },
            {
                'name': 'Speak with Plants',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 5
            },
            {
                'name': 'Divination',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 7
            },
            {
                'name': 'Locate Creature',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 7
            },
            {
                'name': 'Commune with Nature',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 9
            }
        ],
        'languages': [
            'orc'
        ],
        'senses': {
            'darkvision': 60
        },
        'sight': {
            'range': 60,
            'visionMode': 'darkvision'
        },
        'abilities': {
            'wis': 2,
            'con': 1
        }
    },
    'ghostwise-halfling':
    {
        'name': 'Ghostwise Halfling',
        'weight': 10,
        'enabled': false,
        'features': [
            {
                'name': 'Brave',
                'description': 'Brave'
            },
            {
                'name': 'Lucky',
                'description': 'Lucky'
            },
            {
                'name': 'Halfling Nimbleness'
            },
            {
                'name': 'Silent Speech'
            }
        ],
        'languages': [
            'halfling'
        ],
        'abilities': {
            'dex': 2,
            'wis': 1
        }
    },
    'lightfoot-halfling':
    {
        'name': 'Lightfoot Halfling',
        'weight': 50,
        'enabled': true,
        'features': [
            {
                'name': 'Brave',
                'description': 'Brave'
            },
            {
                'name': 'Lucky',
                'description': 'Lucky'
            },
            {
                'name': 'Halfling Nimbleness'
            },
            {
                'name': 'Naturally Stealthy'
            }
        ],
        'languages': [
            'halfling'
        ],
        'abilities': {
            'dex': 2,
            'cha': 1
        }
    },
    'lotusden-halfling':
    {
        'name': 'Lotusden Halfling',
        'weight': 25,
        'enabled': false,
        'features': [
            {
                'name': 'Brave',
                'description': 'Brave'
            },
            {
                'name': 'Lucky',
                'description': 'Lucky'
            },
            {
                'name': 'Halfling Nimbleness'
            },
            {
                'name': 'Child of the Wood',
                'spellcasting': true
            }
        ],
        'spells': [
            {
                'name': 'Druidcraft'
            },
            {
                'name': 'Entangle',
                'level': 3,
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'ability': 'wis'
            },
            {
                'name': 'Spike Growth',
                'level': 5,
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'ability': 'wis'
            }
        ],
        'languages': [
            'halfling'
        ],
        'abilities': {
            'dex': 2,
            'wis': 1
        }
    },
    'mark-of-healing-halfling':
    {
        'name': 'Mark of Healing Halfling',
        'weight': 25,
        'enabled': false,
        'features': [
            {
                'name': 'Brave',
                'description': 'Brave'
            },
            {
                'name': 'Lucky',
                'description': 'Lucky'
            },
            {
                'name': 'Halfling Nimbleness'
            },
            {
                'name': 'Medical Intuition'
            },
            {
                'name': 'Healing Touch',
                'spellcasting': true
            },
            {
                'name': 'Spells of the Mark',
                'description': 'Spells of the Mark (Mark of Healing Halfling)',
                'spellcasting': true
            }
        ],
        'spells': [
            {
                'name': 'Cure Wounds',
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'ability': 'wis'
            },
            {
                'name': 'Lesser Restoration',
                'level': 3,
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'ability': 'wis'
            },
            {
                'name': 'Cure Wounds',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 1
            },
            {
                'name': 'Healing Word',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 1
            },
            {
                'name': ' Lesser Restoration',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 3
            },
            {
                'name': 'Prayer of Healing',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 3
            },
            {
                'name': 'Aura of Vitality',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 5
            },
            {
                'name': 'Mass Healing Word',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 5
            },
            {
                'name': ' Aura of Purity',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 7
            },
            {
                'name': 'Aura of Life',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 7
            },
            {
                'name': 'Greater Restoration',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 9
            }
        ],
        'languages': [
            'halfling'
        ],
        'abilities': {
            'dex': 2,
            'wis': 1
        }
    },
    'mark-of-hospitality-halfling':
    {
        'name': 'Mark of Hospitality Halfling',
        'weight': 25,
        'enabled': false,
        'features': [
            {
                'name': 'Brave',
                'description': 'Brave'
            },
            {
                'name': 'Lucky',
                'description': 'Lucky'
            },
            {
                'name': 'Halfling Nimbleness'
            },
            {
                'name': 'Ever Hospitable',
                'description': 'Ever Hospitable'
            },
            {
                'name': 'Innkeeper\'s Magic',
                'spellcasting': true
            },
            {
                'name': 'Spells of the Mark',
                'description': 'Spells of the Mark (Mark of Hospitality Halfling)',
                'spellcasting': true
            }
        ],
        'spells': [
            {
                'name': 'Prestidigitation'
            },
            {
                'name': 'Purify Food and Drink',
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'ability': 'cha'
            },
            {
                'name': 'Unseen Servant',
                'uses': {
                    'max': 1,
                    'per': 'lr',
                    'recovery': '',
                    'value': 1
                },
                'preparation': {
                    'mode': 'innate',
                    'prepared': true
                },
                'ability': 'cha'
            },
            {
                'name': 'Goodberry',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 1
            },
            {
                'name': 'Sleep',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 1
            },
            {
                'name': ' Aid',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 3
            },
            {
                'name': 'Calm Emotions',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 3
            },
            {
                'name': 'Create Food and Water',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 5
            },
            {
                'name': 'Leomund\'s Tiny Hut',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 5
            },
            {
                'name': ' Aura of Purity',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 7
            },
            {
                'name': ' Mordenkainen\'s Private Sanctum',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 7
            },
            {
                'name': 'Hallow',
                'preparation': {
                    'mode': 'prepared',
                    'prepared': true
                },
                'level': 9
            }
        ],
        'languages': [
            'halfling'
        ],
        'abilities': {
            'dex': 2,
            'cha': 1
        }
    },
    'stout-halfling':
    {
        'name': 'Stout Halfling',
        'weight': 50,
        'enabled': true,
        'features': [
            {
                'name': 'Brave',
                'description': 'Brave'
            },
            {
                'name': 'Lucky',
                'description': 'Lucky'
            },
            {
                'name': 'Halfling Nimbleness'
            },
            {
                'name': 'Stout Resilience',
                'description': 'Stout Resilience'
            }
        ],
        'languages': [
            'halfling'
        ],
        'abilities': {
            'dex': 2,
            'con': 1
        }
    },
    'harengon':
    {
        'name': 'Harengon',
        'weight': 10,
        'enabled': false
    },
    'hexblood':
    {
        'name': 'Hexblood',
        'weight': 5,
        'enabled': false
    },
    'hobgoblin':
    {
        'name': 'Hobgoblin',
        'weight': 10,
        'enabled': true
    },
    'human':
    {
        'name': 'Human',
        'weight': 100,
        'enabled': true
    },
    'mark-of-finding-human':
    {
        'name': 'Mark of Finding Human',
        'weight': 25,
        'enabled': false
    },
    'mark-of-handling-human':
    {
        'name': 'Mark of Handling Human',
        'weight': 25,
        'enabled': false
    },
    'mark-of-making-human':
    {
        'name': 'Mark of Making Human',
        'weight': 25,
        'enabled': false
    },
    'mark-of-passage-human':
    {
        'name': 'Mark of Passage Human',
        'weight': 25,
        'enabled': false
    },
    'kalashtar':
    {
        'name': 'Kalashtar',
        'weight': 25,
        'enabled': false
    },
    'kender':
    {
        'name': 'Kender',
        'weight': 25,
        'enabled': false
    },
    'kenku':
    {
        'name': 'Kenku',
        'weight': 5,
        'enabled': true
    },
    'kobold':
    {
        'name': 'Kobold',
        'weight': 5,
        'enabled': true
    },
    'leonin':
    {
        'name': 'Leonin',
        'weight': 10,
        'enabled': false
    },
    'lizardfolk':
    {
        'name': 'Lizardfolk',
        'weight': 5,
        'enabled': true
    },
    'locathah':
    {
        'name': 'Locathah',
        'weight': 5,
        'enabled': false
    },
    'loxodon':
    {
        'name': 'Loxodon',
        'weight': 25,
        'enabled': false
    },
    'minotaur':
    {
        'name': 'Minotaur',
        'weight': 5,
        'enabled': true
    },
    'orc':
    {
        'name': 'Orc',
        'weight': 5,
        'enabled': true
    },
    'owlin':
    {
        'name': 'Owlin',
        'weight': 10,
        'enabled': false
    },
    'plasmoid':
    {
        'name': 'Plasmoid',
        'weight': 5,
        'enabled': false
    },
    'reborn':
    {
        'name': 'Reborn',
        'weight': 5,
        'enabled': false
    },
    'satyr':
    {
        'name': 'Satyr',
        'weight': 5,
        'enabled': true
    },
    'sea-elf':
    {
        'name': 'Sea Elf',
        'weight': 10,
        'enabled': true
    },
    'shadar-kai':
    {
        'name': 'Shadar-Kai',
        'weight': 5,
        'enabled': true
    },
    'beasthide-shifter':
    {
        'name': 'Beasthide Shifter',
        'weight': 5,
        'enabled': true
    },
    'longtooth-shifter':
    {
        'name': 'Longtooth Shifter',
        'weight': 5,
        'enabled': true
    },
    'swiftstride-shifter':
    {
        'name': 'Swiftstride Shifter',
        'weight': 5,
        'enabled': true
    },
    'wildhunt-shifter':
    {
        'name': 'Wildhunt Shifter',
        'weight': 5,
        'enabled': true
    },
    'simic-hybrid':
    {
        'name': 'Simic Hybrid',
        'weight': 25,
        'enabled': false
    },
    'tabaxi':
    {
        'name': 'Tabaxi',
        'weight': 10,
        'enabled': true
    },
    'thri-kreen':
    {
        'name': 'Thri-Kreen',
        'weight': 5,
        'enabled': false
    },
    'baalzebul-tiefling':
    {
        'name': 'Baalzebul Tiefling',
        'weight': 1,
        'enabled': true
    },
    'dispater-tiefling':
    {
        'name': 'Dispater Tiefling',
        'weight': 1,
        'enabled': true
    },
    'tierna-tiefling':
    {
        'name': 'Tierna Tiefling',
        'weight': 1,
        'enabled': true
    },
    'glasya-tiefling':
    {
        'name': 'Glasya Tiefling',
        'weight': 1,
        'enabled': true
    },
    'levistus-tiefling':
    {
        'name': 'Levistus Tiefling',
        'weight': 1,
        'enabled': true
    },
    'mammon-tiefling':
    {
        'name': 'Mammon Tiefling',
        'weight': 1,
        'enabled': true
    },
    'mephistopheles-tiefling':
    {
        'name': 'Mephistopheles Tiefling',
        'weight': 1,
        'enabled': true
    },
    'zariel-tiefling':
    {
        'name': 'Zariel Tiefling',
        'weight': 1,
        'enabled': true
    },
    'hellfire-tiefling':
    {
        'name': 'Hellfire Tiefling',
        'weight': 1,
        'enabled': true
    },
    'winged-tiefling':
    {
        'name': 'Winged Tiefling',
        'weight': 1,
        'enabled': true
    },
    'feral-winged-tiefling':
    {
        'name': 'Feral Winged Tiefling',
        'weight': 1,
        'enabled': false
    },
    'feral-hellfire-tiefling':
    {
        'name': 'Feral Hellfire Tiefling',
        'weight': 1,
        'enabled': false
    },
    'tortle':
    {
        'name': 'Tortle',
        'weight': 5,
        'enabled': true
    },
    'triton':
    {
        'name': 'Triton',
        'weight': 5,
        'enabled': true
    },
    'vedalken':
    {
        'name': 'Vedalken',
        'weight': 25,
        'enabled': false
    },
    'verdan':
    {
        'name': 'Verdan',
        'weight': 5,
        'enabled': false
    },
    'water-genasi':
    {
        'name': 'Water Genasi',
        'weight': 25,
        'enabled': false
    },
    'warforged':
    {
        'name': 'Warforged',
        'weight': 25,
        'enabled': false
    },
    'yaun-ti':
    {
        'name': 'Yaun-Ti',
        'weight': 5,
        'enabled': true
    }
};
let chanceTable = [];
let chanceTotal;
function updateChanceTable () {
    chanceTotal = 0;
    for (let [key, value] of Object.entries(game.settings.get('chris-premades', 'Humanoid Randomizer Settings'))) {
        if (!value.enabled) continue;
        chanceTable.push([key, value.weight]);
        chanceTotal += value.weight;
    }
}
function pickRace() {
    if (chanceTable.length === 0) updateChanceTable();
    let threshold = Math.random() * chanceTotal;
    let total = 0;
    for (let i = 0; i < chanceTotal - 1; ++i) {
        total += chanceTable[i][1];
        if (total >= threshold) {
            return chanceTable[i][0];
        }
    }
    return chanceTable[chanceTotal - 1][0];
}
async function npcRandomizer(token, options, user) {
    if ((game.user.id !== user) || token.actorLink) return;
    let item = token.actor.items.getName('CPR - Randomizer');
    if (!item) return;
    let actor = token.actor;
    let updates = {};
    if (chris.getConfiguration(item, 'humanoid')) await humanoid(actor, updates, item) ?? false;
    setProperty(updates, 'embedded.Item.CPR - Randomizer', warpgate.CONST.DELETE);
    console.log(updates);
    let warpgateOptions = {
        'permanent': true,
        'name': 'CPR - Randomzier',
        'description': 'CPR - Randomzier'
    };
    await warpgate.mutate(token, updates, {}, warpgateOptions);
}
async function humanoid(targetActor, updates, item) {
//    let race = pickRace();
    let race = 'stout-halfling';
    console.log(race);
    let sourceActor;
    if (allRaces[race].monster) {
        sourceActor = await chris.getItemFromCompendium(game.settings.get('chris-premades', 'Monster Compendium'), allRaces[race].monster, true);
        if (!sourceActor) return;
    }
    let skills = chris.getConfiguration(item, 'skills') ?? 'upgrade';
    let abilities = chris.getConfiguration(item, 'abilities') ?? 'upgrade';
    if (sourceActor) {
        for (let i of Object.keys(CONFIG.DND5E.abilities)) {
            let sourceAbility = sourceActor.system.abilities[i].value;
            let targetAbility = targetActor.system.abilities[i].value;
            switch (abilities) {
                case 'source':
                    setProperty(updates, 'actor.system.abilities.' + i + '.value', sourceAbility);
                    break;
                case 'upgrade':
                    if (sourceAbility > targetAbility) setProperty(updates, 'actor.system.abilities.' + i + '.value', sourceAbility);
                    break;
                case 'downgrade':
                    if (sourceAbility < targetAbility) setProperty(updates, 'actor.system.abilities.' + i + '.value', sourceAbility);
                    break;
            }
        }
        for (let i of Object.keys(CONFIG.DND5E.skills)) {
            let sourceSkill = sourceActor.system.skills[i].value;
            let targetSkill = targetActor.system.skills[i].value;
            switch (skills) {
                case 'source':
                    setProperty(updates, 'actor.system.skills.' + i + '.value', sourceSkill);
                    break;
                case 'upgrade':
                    if (sourceSkill > targetSkill) setProperty(updates, 'actor.system.skills.' + i + '.value', sourceSkill);
                    break;
                case 'downgrade':
                    if (sourceSkill < targetSkill) setProperty(updates, 'actor.system.skills.' + i + '.value', sourceSkill);
                    break;
            }
        }
        let avatar = chris.getConfiguration(item, 'avatar') ?? 'source';
        if (avatar === 'source') setProperty(updates, 'actor.img', sourceActor.img);
        let token = chris.getConfiguration(item, 'token') ?? 'source';
        if (token === 'source') {
            setProperty(updates, 'actor.prototypeToken.texture.src', sourceActor.prototypeToken.texture.src);
            setProperty(updates, 'token.texture.src', sourceActor.prototypeToken.texture.src);
        }
        setProperty(updates, 'actor.system.details.type.subtype', sourceActor.system.details.type.subtype);
    }
    let features = chris.getConfiguration(item, 'features') ?? 'merge';
    let spells = chris.getConfiguration(item, 'spells') ?? true;
    if (features === 'merge' && sourceActor) {
        for (let item of sourceActor.items) {
            if (updates.embedded?.Item?.[item.name]) continue;
            setProperty(updates, 'embedded.Item.' + item.name, item);
        }
    } else if (features === 'source' && sourceActor) {
        for (let item of targetActor.items) {
            setProperty(updates, 'embedded.Item.' + item.name, warpgate.CONST.DELETE)
        }
        for (let item of sourceActor.items) setProperty(updates, 'embedded.Item.' + item.name, item);
    } else if (features === 'merge' && !sourceActor && allRaces[race].features) {
        for (let i of allRaces[race].features) {
            if (i.spellcasting && !spells) continue;
            if (i.level) {
                if (i.level > chris.levelOrCR(targetActor)) continue;
            }
            let featureData = await chris.getItemFromCompendium('chris-premades.CPR Race Features', i.name, true);
            if (!featureData) featureData = await chris.getItemFromCompendium(game.settings.get('chris-premades', 'Racial Trait Compendium'), i.name, true);
            if (!featureData) continue;
            if (i.description) {
                let descriptionItem = await chris.getItemFromCompendium(game.settings.get('chris-premades', 'Racial Trait Compendium'), i.description, true);
                if (descriptionItem) featureData.system.description.value = descriptionItem.system.description.value;
            }
            if (i.uses) {
                if (i.uses.max === '@prof') setProperty(featureData, 'system.uses.value', targetActor.system.attributes.prof);
            }
            if (!featureData.img) featureData.img = 'icons/sundries/gaming/dice-runed-brown.webp';
            if (i.rename) featureData.name = i.rename;
            setProperty(updates, 'embedded.Item.' + featureData.name, featureData);
        }
        if (allRaces[race].spells) {
            for (let i of allRaces[race].spells) {
                if (i.level) {
                    if (i.level > chris.levelOrCR(targetActor)) continue;
                }
                let spellData = await chris.getItemFromCompendium(game.settings.get('chris-premades', 'Spell Compendium'), i.name, true);
                if (!spellData) continue;
                if (i.uses) {
                    setProperty(spellData, 'system.uses', i.uses);
                    if (spellData.system.uses.max === '@prof') setProperty(spellData, 'system.uses.value', targetActor.system.attributes.prof);
                }
                if (i.preparation) {
                    setProperty(spellData, 'system.preparation', i.preparation);
                    if (i.preparation.mode != 'prepared') spellData.name += ' (' + chris.titleCase(i.preparation.mode) + ')';
                } else {
                    setProperty(spellData, 'system.preparation.prepared', true);
                }
                if (i.ability) setProperty(spellData, 'system.ability', i.ability);
                setProperty(updates, 'embedded.Item.' + spellData.name, spellData);
                if (i.target) setProperty(spellData, 'system.target', i.target);
                if (i.range) setProperty(spellData, 'system.range', i.range);
            }
        }
        if (allRaces[race].skills) {
            switch (skills) {
                case 'upgrade':
                    for (let [key, value] of Object.entries(allRaces[race].skills)) {
                        if (targetActor.system.skills[key].value < value) setProperty(updates, 'actor.system.skills.' + key + '.value', value);
                    }
                    break;
                case 'downgrade':
                    for (let [key, value] of Object.entries(allRaces[race].skills)) {
                        if (targetActor.system.skills[key].value > value) setProperty(updates, 'actor.system.skills.' + key + '.value', value);
                    }
                    break;
            }
        }
        if (allRaces[race].abilities && abilities === 'upgrade') {
            for (let [key, value] of Object.entries(allRaces[race].abilities)) {
                let score = Math.min(20, targetActor.system.abilities[key].value + value);
                setProperty(updates, 'system.abilities.' + key + '.value', score);
            }
        }
    }
    let conditionImmunity = chris.getConfiguration(item, 'conditionimmunity') ?? 'merge';
    let damageImmunity = chris.getConfiguration(item, 'damageimmunity') ?? 'merge';
    let damageResistance = chris.getConfiguration(item, 'damageresistance') ?? 'merge';
    let damageVulnerability = chris.getConfiguration(item, 'damagevulnerability') ?? 'merge';
    let languages = chris.getConfiguration(item, 'languages') ?? 'merge';
    if (sourceActor) {
        if (conditionImmunity === 'source' || conditionImmunity === 'merge') setProperty(updates, 'actor.system.traits.ci.value', sourceActor.system.traits.ci.value);
        if (damageImmunity === 'source' || damageImmunity === 'merge') setProperty(updates, 'actor.system.traits.di.value', sourceActor.system.traits.di.value);
        if (damageResistance === 'source' || damageResistance === 'merge') setProperty(updates, 'actor.system.traits.dr.value', sourceActor.system.traits.dr.value);
        if (damageVulnerability === 'source' || damageVulnerability === 'merge') setProperty(updates, 'actor.system.traits.dv.value', sourceActor.system.traits.dv.value);
        if (languages === 'source' || languages === 'merge') setProperty(updates, 'actor.system.traits.languages.value', sourceActor.system.traits.languages.value);
    } else {
        if (allRaces[race].ci && (conditionImmunity === 'source' || conditionImmunity === 'merge')) setProperty(updates, 'actor.system.traits.ci.value', allRaces[race].ci);
        if (allRaces[race].di && (damageImmunity === 'source' || damageImmunity === 'merge')) setProperty(updates, 'actor.system.traits.di.value', allRaces[race].di);
        if (allRaces[race].dr && (damageResistance === 'source' || damageResistance === 'merge')) setProperty(updates, 'actor.system.traits.dr.value', allRaces[race].dr);
        if (allRaces[race].dv && (damageVulnerability === 'source' || damageVulnerability === 'merge')) setProperty(updates, 'actor.system.traits.dv.value', allRaces[race].dv);
        if (allRaces[race].languages && (languages === 'source' || languages === 'merge')) setProperty(updates, 'actor.system.traits.languages.value', allRaces[race].languages);
    }
    let name = chris.getConfiguration(item, 'name') ?? 'before';
    let sourceName = sourceActor?.name ?? allRaces[race].name;
    switch (name) {
        case 'source':
            setProperty(updates, 'actor.name', sourceName);
            setProperty(updates, 'token.name', sourceName);
            setProperty(updates, 'actor.prototypeToken.name', sourceName);
            break;
        case 'before':
            setProperty(updates, 'actor.name', sourceName + ' ' + targetActor.name);
            setProperty(updates, 'token.name', sourceName + ' ' + targetActor.name);
            setProperty(updates, 'actor.prototypeToken.name', sourceName + ' ' + targetActor.name);
            break;
        case 'after':
            setProperty(updates, 'actor.name', targetActor.name + ' ' + sourceName);
            setProperty(updates, 'token.name', targetActor.name + ' ' + sourceName);
            setProperty(updates, 'actor.prototypeToken.name', targetActor.name + ' ' + sourceName);
            break;
    }
    let ac = chris.getConfiguration(item, 'ac') ?? 'source';
    if (ac === 'source' && sourceActor) {
        setProperty(updates, 'actor.system.attributes.ac', sourceActor.system.attributes.ac);
    } else if (allRaces[race].ac && ac === 'source') {
        setProperty(updates, 'actor.system.attributes.ac.bonus',allRaces[race].ac);
    }
    let movement = chris.getConfiguration(item, 'movement') ?? 'source';
    switch (movement) {
        case 'source':
            if (sourceActor) {
                setProperty(updates, 'actor.system.attributes.movement', sourceActor.system.attributes.movement);
            } else if (allRaces[race].movement) {
                setProperty(updates, 'actor.system.attributes.movement', allRaces[race].movement);
            }
            break;
        case 'upgrade':
            if (sourceActor) {
                if (sourceActor.system.attributes.movement.burrow > targetActor.system.attributes.movement.burrow) setProperty(updates, 'actor.system.attributes.movement.burrow', sourceActor.system.attributes.movement.burrow);
                if (sourceActor.system.attributes.movement.climb > targetActor.system.attributes.movement.climb) setProperty(updates, 'actor.system.attributes.movement.climb', sourceActor.system.attributes.movement.climb);
                if (sourceActor.system.attributes.movement.fly > targetActor.system.attributes.movement.fly) setProperty(updates, 'actor.system.attributes.movement.fly', sourceActor.system.attributes.movement.fly);
                if (sourceActor.system.attributes.movement.swim > targetActor.system.attributes.movement.swim) setProperty(updates, 'actor.system.attributes.movement.swim', sourceActor.system.attributes.movement.swim);
                if (sourceActor.system.attributes.movement.walk > targetActor.system.attributes.movement.walk) setProperty(updates, 'actor.system.attributes.movement.walk', sourceActor.system.attributes.movement.walk);
                if (sourceActor.system.attributes.movement.hover) setProperty(updates, 'actor.system.attributes.movement.hover', true);
            } else if (allRaces[race].movement) {
                if (allRaces[race].movement.burrow > targetActor.system.attributes.movement.burrow) setProperty(updates, 'actor.system.attributes.movement.burrow', allRaces[race].movement.burrow);
                if (allRaces[race].movement.climb > targetActor.system.attributes.movement.climb) setProperty(updates, 'actor.system.attributes.movement.climb', allRaces[race].movement.climb);
                if (allRaces[race].movement.fly > targetActor.system.attributes.movement.fly) setProperty(updates, 'actor.system.attributes.movement.fly', allRaces[race].movement.fly);
                if (allRaces[race].movement.swim > targetActor.system.attributes.movement.swim) setProperty(updates, 'actor.system.attributes.movement.swim', allRaces[race].movement.swim);
                if (allRaces[race].movement.walk > targetActor.system.attributes.movement.walk) setProperty(updates, 'actor.system.attributes.movement.walk', allRaces[race].movement.walk);
                if (allRaces[race].movement.hover) setProperty(updates, 'actor.system.attributes.movement.hover', true);
            }
            break;
        case 'downgrade':
            if (sourceActor) {
                if (sourceActor.system.attributes.movement.burrow < targetActor.system.attributes.movement.burrow) setProperty(updates, 'actor.system.attributes.movement.burrow', sourceActor.system.attributes.movement.burrow);
                if (sourceActor.system.attributes.movement.climb < targetActor.system.attributes.movement.climb) setProperty(updates, 'actor.system.attributes.movement.climb', sourceActor.system.attributes.movement.climb);
                if (sourceActor.system.attributes.movement.fly < targetActor.system.attributes.movement.fly) setProperty(updates, 'actor.system.attributes.movement.fly', sourceActor.system.attributes.movement.fly);
                if (sourceActor.system.attributes.movement.swim < targetActor.system.attributes.movement.swim) setProperty(updates, 'actor.system.attributes.movement.swim', sourceActor.system.attributes.movement.swim);
                if (sourceActor.system.attributes.movement.walk < targetActor.system.attributes.movement.walk) setProperty(updates, 'actor.system.attributes.movement.walk', sourceActor.system.attributes.movement.walk);
                if (sourceActor.system.attributes.movement.hover) setProperty(updates, 'actor.system.attributes.movement.hover', true);
            } else if (allRaces[race].movement) {
                if (allRaces[race].movement.burrow < targetActor.system.attributes.movement.burrow) setProperty(updates, 'actor.system.attributes.movement.burrow', allRaces[race].movement.burrow);
                if (allRaces[race].movement.climb < targetActor.system.attributes.movement.climb) setProperty(updates, 'actor.system.attributes.movement.climb', allRaces[race].movement.climb);
                if (allRaces[race].movement.fly < targetActor.system.attributes.movement.fly) setProperty(updates, 'actor.system.attributes.movement.fly', allRaces[race].movement.fly);
                if (allRaces[race].movement.swim < targetActor.system.attributes.movement.swim) setProperty(updates, 'actor.system.attributes.movement.swim', allRaces[race].movement.swim);
                if (allRaces[race].movement.walk < targetActor.system.attributes.movement.walk) setProperty(updates, 'actor.system.attributes.movement.walk', allRaces[race].movement.walk);
                if (allRaces[race].movement.hover) setProperty(updates, 'actor.system.attributes.movement.hover', true);
            }
            break;
    }
    let senses = chris.getConfiguration(item, 'senses') ?? 'source';
    if (senses === 'source') {
        if (sourceActor) {
            setProperty(updates, 'actor.system.attributes.senses', sourceActor.system.attributes.senses);
            setProperty(updates, 'actor.prototypeToken.sight', sourceActor.prototypeToken.sight);
            setProperty(updates, 'token.sight', sourceActor.prototypeToken.sight);
        } else if (allRaces[race].senses && allRaces[race].sight) {
            setProperty(updates, 'actor.system.attributes.senses', allRaces[race].senses);
            setProperty(updates, 'actor.prototypeToken.sight', allRaces[race].sight);
            setProperty(updates, 'token.sight', allRaces[race].sight);
        }
    }
    if (allRaces[race].size) {
        switch (allRaces[race].size) {
            case 'small':
                setProperty(updates, 'actor.system.traits.size', 'sm');
                setProperty(updates, 'token.texture.scaleX', 0.8);
                setProperty(updates, 'token.texture.scaleY', 0.8);
                setProperty(updates, 'actor.prototypeToken.texture.scaleX', 0.8)
                setProperty(updates, 'actor.prototypeToken.texture.scaleY', 0.8)
                break;
        }
    }
    if (allRaces[race].special) await allRaces[race].special(targetActor, updates);
    if (allRaces[race].specialTraits) setProperty(updates, 'actor.flags.dnd5e', allRaces[race].specialTraits);

}
;// CONCATENATED MODULE: ./scripts/patching.js



function patchSkills(enabled) {
    if (enabled) {
        libWrapper.register('chris-premades', 'CONFIG.Actor.documentClass.prototype.rollSkill', doRollSkill, 'WRAPPER');
    } else {
        libWrapper.unregister('chris-premades', 'CONFIG.Actor.documentClass.prototype.rollSkill');
    }
}
async function doRollSkill(wrapped, ...args) {
    let [skillId, options] = args;
    if (!options) options = {};
    let flags = this.flags['chris-premades']?.skill;
    if (flags) {
        let selections = [];
        for (let [key, value] of Object.entries(flags)) {
            if (!value) continue;
            if (typeof macros_skills[key] != 'function') continue;
            let data = macros_skills[key].bind(this)(skillId, options);
            if (data) selections.push(data);
        }
        if (selections.length) {
            let advantages = selections.filter(i => i.type === 'advantage').map(j => ({'type': 'checkbox', 'label': j.label, 'options': false}));
            let disadvantags = selections.filter(i => i.type === 'disadvantage').map(j => ({'type': 'checkbox', 'label': j.label, 'options': false}));
            let generatedInputs = [];
            if (advantages.length) {
                generatedInputs.push({'label': '<u>Advantage:</u>', 'type': 'info'});
                generatedInputs.push(...advantages);
            }
            if (disadvantags.length) {
                generatedInputs.push({'label': '<u>Disadvantage:</u>', 'type': 'info'});
                generatedInputs.push(...disadvantags);
            }
            let selection = await chris.menu('Skill Roll Options', constants_constants.okCancel, generatedInputs, true);
            if (selection.buttons) {
                let advantage = false;
                let disadvantage = false;
                if (advantages.length) advantage = !!selection.inputs.slice(1, advantages.length + 1).find(i => i);
                if (disadvantags.length) {
                    let start = 1;
                    let end = disadvantags.length + 1;
                    if (advantages.length) {
                        start += advantages.length + 1;
                        end += advantages.length + 1;
                    }
                    disadvantage = !!selection.inputs.slice(start, end).find(i => i);
                }
                if (advantage) options.advantage = true;
                if (disadvantage) options.disadvantage = true;
            }
        }
    }
    let returnData = await wrapped(skillId, options);
    //roll bonus here
    return returnData;
}
function patchSaves(enabled) {
    if (enabled) {
        libWrapper.register('chris-premades', 'CONFIG.Actor.documentClass.prototype.rollAbilitySave', doRollSave, 'WRAPPER');
    } else {
        libWrapper.unregister('chris-premades', 'CONFIG.Actor.documentClass.prototype.rollAbilitySave');
    }
}
async function doRollSave(wrapped, ...args) {
    let [saveId, options] = args;
    let flags = this.flags['chris-premades']?.save;
    if (flags) {
        let selections = [];
        for (let [key, value] of Object.entries(flags)) {
            if (!value) continue;
            if (typeof macros_saves[key] != 'function') continue;
            let data = macros_saves[key].bind(this)(saveId, options);
            if (data) selections.push(data);
        }
        if (selections.length) {
            let advantages = selections.filter(i => i.type === 'advantage').map(j => ({'type': 'checkbox', 'label': j.label, 'options': false}));
            let disadvantags = selections.filter(i => i.type === 'disadvantage').map(j => ({'type': 'checkbox', 'label': j.label, 'options': false}));
            let generatedInputs = [];
            if (advantages.length) {
                generatedInputs.push({'label': '<u>Advantage:</u>', 'type': 'info'});
                generatedInputs.push(...advantages);
            }
            if (disadvantags.length) {
                generatedInputs.push({'label': '<u>Disadvantage:</u>', 'type': 'info'});
                generatedInputs.push(...disadvantags);
            }
            let selection = await chris.menu('Save Roll Options', constants_constants.okCancel, generatedInputs, true);
            if (selection.buttons) {
                let advantage = false;
                let disadvantage = false;
                if (advantages.length) advantage = !!selection.inputs.slice(1, advantages.length + 1).find(i => i);
                if (disadvantags.length) {
                    let start = 1;
                    let end = disadvantags.length + 1;
                    if (advantages.length) {
                        start += advantages.length + 1;
                        end += advantages.length + 1;
                    }
                    disadvantage = !!selection.inputs.slice(start, end).find(i => i);
                }
                if (advantage) options.advantage = true;
                if (disadvantage) options.disadvantage = true;
            }
        }
    }
    let returnData = await wrapped(saveId, options);
    //roll bonus here
    return returnData;
}
function patchActiveEffectSourceName(enabled) {
    if (enabled) {
        libWrapper.register('chris-premades', 'CONFIG.ActiveEffect.documentClass.prototype.sourceName', sourceName, 'WRAPPER');
    } else {
        libWrapper.unregister('chris-premades', 'CONFIG.ActiveEffect.documentClass.prototype.sourceName');
    }
}
function sourceName(wrapped, ...args) {
    let name = wrapped();
    if (name === 'Unknown' && this.origin != '') {
        if (!this.origin.includes('Compendium.')) {
            let origin = fromUuidSync(this.origin);
            if (origin) {
                if (origin.constructor.name === 'MeasuredTemplateDocument') {
                    let orginUuid = origin.flags?.dnd5e?.origin;
                    if (orginUuid) {
                        let originItem = fromUuidSync(orginUuid);
                        if (originItem) {
                            if (originItem.constructor.name === 'Item5e') name = originItem.name + ' Template';
                        }
                    } else name = 'Unknown Template';
                }
            }
        }
    }
    return name;
}

;// CONCATENATED MODULE: ./scripts/macros/mechanics/conditions.js
function removeDumbV10Effects() {
    CONFIG.specialStatusEffects.BLIND = null;
    CONFIG.specialStatusEffects.INVISIBLE = null;
}
;// CONCATENATED MODULE: ./scripts/actor.js
async function update(actors) {
    for (let actor of actors) {
        console.log('Updating: ' + actor.name);
        await game.modules.get('ddb-importer')?.api.effects.addDDBIEffectsToActorDocuments(actor, {'useChrisPremades': true });
    }
}
async function updateSidebarNPCs() {
    if (!game.modules.get('ddb-importer')?.active) {
        ui.notifications.info('This feature requires the D&D Beyond Importer module to be active!');
        return;
    }
    ui.notifications.info('Starting sidebar NPC updater!');
    let actors = game.actors.filter(e => e && e.type !== 'character');
    if (actors.length != 0) await update(actors);
    ui.notifications.info('Sidebar NPC updater complete!');
}
async function updateSceneNPCs() {
    if (!game.modules.get('ddb-importer')?.active) {
        ui.notifications.info('This feature requires the D&D Beyond Importer module to be active!');
        return;
    }
    ui.notifications.info('Starting scene NPC updater!');
    if (canvas.scene) {
        let actors = canvas.scene.tokens.map(i => i.actor).filter(e => e && e.type !== 'character');
        if (actors.length != 0) await update(actors);
    }
    ui.notifications.info('Scene NPC updater complete!');
}
async function updateAllSceneNPCs() {
    if (!game.modules.get('ddb-importer')?.active) {
        ui.notifications.info('This feature requires the D&D Beyond Importer module to be active!');
        return;
    }
    ui.notifications.info('Starting all scenes NPC updater!');
    for (let scene of game.scenes) {
        let actors = scene.tokens.map(i => i.actor).filter(e => e && e.type !== 'character');
        if (actors.length != 0) await update(actors);
    }
    ui.notifications.info('All scenes NPC updater complete!');
}
;// CONCATENATED MODULE: ./scripts/help.js
let names = {
    'ATL': 'Advanced Token Effects',
    'JB2A_DnD5e': 'Jules&Ben\'s Animated Assets (F)',
    'about-time': 'About Time',
    'animated-spell-effects-cartoon': 'Animated Spell Effects: Cartoon',
    'autoanimations': 'Automated Animations',
    'babonus': 'Build A Bonus',
    'compendium-folders': 'Compendium Folders',
    'custom-character-sheet-sections': 'Custom Character Sheet Sections',
    'dae': 'Dynamic Active Effects',
    'ddb-importer': 'D&D Beyond Importer',
    'dfreds-convenient-effects': 'DFreds Convenient Effects',
    'dice-so-nice': 'Dice So Nice!',
    'effectmacro': 'Effect Macro',
    'foundryvtt-simple-calendar': 'Simple Calendar',
    'fxmaster': 'FXMaster',
    'itemacro': 'Item Macro',
    'jb2a_patreon': 'Jules&Ben\'s Animated Assets (P)',
    'lib-wrapper': 'libWrapper',
    'midi-qol': 'Midi-Qol',
    'quick-insert': 'Quick Insert',
    'sequencer': 'Sequencer',
    'smalltime': 'Small Time',
    'socketlib': 'Socketlib',
    'templatemacro': 'Template Macro',
    'tidy5e-sheet': 'Tidy 5e Sheet',
    'times-up': 'Times Up',
    'token-attacher': 'Token Attacher',
    'visual-active-effects': 'Visual Active Effects',
    'warpgate': 'Warpgate'
}
let optionalModules = [
    'ATL',
    'about-time',
    'animated-spell-effects-cartoon',
    'compendium-folders',
    'custom-character-sheet-sections',
    'ddb-importer',
    'dice-so-nice',
    'foundryvtt-simple-calendar',
    'fxmaster',
    'itemacro',
    'JB2A_DnD5e',
    'jb2a_patreon',
    'quick-insert',
    'smalltime',
    'tidy5e-sheet',
    'times-up',
    'visual-active-effects'
];
let incompatibleModules = [
    'advancedspelleffects',
    'attack-roll-check-5e',
    'betterrolls5e',
    'concentrationnotifier',
    'dice-rng-protector',
    'dice-tooltip',
    'effective-transferral',
    'faster-rolling-by-default-5e',
    'gm-paranoia-taragnor',
    'heartbeat',
    'max-crit',
    'mre-dnd5e',
    'multiattack-5e',
    'obsidian',
    'quick-rolls',
    'ready-set-roll-5e',
    'retroactive-advantage-5e',
    'rollgroups',
    'wire'
]
function troubleshoot() {
    let output = '';
    function addLine(text) {
        output += '\n' + text;
        console.log(text);
    }
    function checkModule(name) {
        let module = game.modules.get(name);
        let text;
        if (module) {
            if (names[name]) {
                text = names[name] + ': ' + module.version;
            } else {
                text = module.title + ': ' + module.version;
            }
            if (!module.active) text += ' (Disabled)';
        } else {
            text = names[name] + ': Missing!';
        }
        return text;
    }
    addLine('/////////////// Game Information ///////////////');
    addLine('Foundry: ' + game.version);
    addLine('System: ' + game.system.version);
    addLine('Language: ' + game.settings.get('core', 'language'));
    let cpr = game.modules.get('chris-premades');
    if (cpr.version === '#{VERSION}#') {
        addLine('Chris\'s Premades: Development');
    } else {
        addLine('Chris\'s Premades: ' + game.modules.get('chris-premades').version);
    }
    addLine('');
    addLine('/////////////// Required Modules ///////////////');
    let requiredModules = new Set([]);
    game.modules.get('chris-premades').relationships.requires.forEach(value => {
        requiredModules.add(value.id);
        let module = game.modules.get(value.id);
        if (module) game.modules.get(value.id).relationships.requires.forEach(value => {
            requiredModules.add(value.id);
        });
    });
    Array.from(requiredModules).sort().forEach(value => {
        addLine(checkModule(value));
    });
    addLine('');
    addLine('/////////////// Optional Modules ///////////////');
    optionalModules.forEach(id => {
        addLine(checkModule(id));
    });
    addLine('');
    addLine('/////////////// Incompatible Modules ///////////////');
    incompatibleModules.forEach(id => {
        if (game.modules.get(id)) addLine(checkModule(id));
    });
    addLine('');
    addLine('/////////////// CPR Settings ///////////////');
    let cprSettings = Array.from(game.settings.settings).filter(i => i[0].includes('chris-premades') && i[1].namespace === 'chris-premades');
    cprSettings.forEach(i => {
        addLine(i[1].name + ': ' + game.settings.get('chris-premades', i[1].key));
    });
    if (game.modules.get('itemacro')?.active) {
        addLine('');
        addLine('/////////////// Item Macro Settings ///////////////');
        addLine('Character Sheet Hook: ' + game.settings.get('itemacro', 'charsheet'));
    }
    if (game.modules.get('midi-qol')?.active) {
        addLine('');
        addLine('/////////////// Midi-Qol Settings ///////////////');
        addLine('Roll Automation Support: ' + game.settings.get('midi-qol', 'EnableWorkflow'));
        let midiSettings = game.settings.get('midi-qol', 'ConfigSettings');
        switch(midiSettings.autoCEEffects) {
            case 'none':
                addLine('Apply Convenient Effects: None')
                break;
            case 'itempri':
                addLine('Apply Convenient Effects: Items > CE')
                break;
            case 'cepri':
                addLine('Apply Convenient Effects: CE > Items')
                break;
            case 'both':
                addLine('Apply Convenient Effects: Both')
                break;
        }
        addLine('Roll Seperate Attack Per Target: ' + midiSettings.attackPerTarget);
        addLine('Merge Card: ' + midiSettings.mergeCard);
        addLine('Actor On Use: ' + midiSettings.allowActorUseMacro);
        addLine('Item On Use: ' + midiSettings.allowUseMacro);
    }
    if (game.modules.get('warpgate')?.active) {
        addLine('');
        addLine('/////////////// Warpgate User Permissions ///////////////');
        addLine('Create Tokens: ' + game.permissions.TOKEN_CREATE.includes(1));
        addLine('Configure Tokens: ' + game.permissions.TOKEN_CONFIGURE.includes(1));
        addLine('Browse Files: ' + game.permissions.FILES_BROWSE.includes(1));
    }
    if (game.modules.get('plutonium') || game.modules.get('plutonium-addon-automation')) {
        addLine('');
        addLine('/////////////// Other ///////////////');
        if (!game.modules.get('plutonium')?.active) {
            addLine('Unsupported Importer: false');
        } else {
            addLine('Unsupported Importer: true');
        }
    }
    try {
        let filename = 'CPR-Troubleshoot.txt';
        let blob = new Blob([output], {
            'type': 'text/plain;charset=utf-8'
        });
        saveAs(blob, filename);
    } catch (error) {};
}
async function fixSettings() {
    let changedSettings = [];
    if (game.modules.get('itemacro')?.active) {
        if (game.settings.get('itemacro', 'charsheet')) {
            await game.settings.set('itemacro', 'charsheet', false);
            changedSettings.push('IM-CharSheet');
        }
    }
    if (game.modules.get('midi-qol')?.active) {
        if (!game.settings.get('midi-qol', 'EnableWorkflow')) {
            await game.settings.set('midi-qol', 'EnableWorkflow', true);
            changedSettings.push('MQ-EnableWorkflow');
        }
        let updateMidiSettings = false;
        let midiSettings = duplicate(game.settings.get('midi-qol', 'ConfigSettings'));
        if (midiSettings.autoCEEffects != 'itempri') {
            midiSettings.autoCEEffects = 'itempri';
            changedSettings.push('MQ-autoCEEffects');
            updateMidiSettings = true;
        }
        if (midiSettings.attackPerTarget === true) {
            midiSettings.attackPerTarget = false;
            changedSettings.push('MQ-attackPerTarget');
            updateMidiSettings = true;
        }
        if (midiSettings.mergeCard === false) {
            midiSettings.mergeCard = true;
            changedSettings.push('MQ-mergeCard');
            updateMidiSettings = true;
        }
        if (updateMidiSettings) await game.settings.set('midi-qol', 'ConfigSettings', midiSettings);
    }
    if (changedSettings.length === 0) {
        ChatMessage.create({
            'speaker': {alias: name},
            'whisper': [game.user.id],
            'content': '<hr><b>Updated Settings:</b><br><hr>Nothing!'
        });
        return;
    }
    let list = '';
    if (changedSettings.includes('IM-CharSheet')) {
        list += '- Item Macro: Character Sheet Hook: false<br>';
    }
    if (changedSettings.includes('MQ-EnableWorkflow')) list += '- Midi-Qol: Roll Automation Support: true<br>';
    if (changedSettings.includes('MQ-autoCEEffects')) list += '- Midi-Qol: Apply Convenient Effects: Prefer Item Effect<br>';
    if (changedSettings.includes('MQ-attackPerTarget')) list += '- Midi-Qol: Roll Seperate Attack Per Target: false<br>';
    if (changedSettings.includes('MQ-mergeCard')) list += '- Midi-Qol: Merge Card: true<br>';
    ChatMessage.create({
        'speaker': {alias: name},
        'whisper': [game.user.id],
        'content': '<hr><b>Updated Settings:</b><br><hr>' + list
    });
}
;// CONCATENATED MODULE: ./scripts/tours.js

let registered = false;
let tours_states = {
    1: async () => {
        await ui.sidebar.expand();
        await ui.sidebar.tabs.journal.activate();
    },
    2: async () => {
        let journalEntry = game.journal.getName('CPR - Descriptions');
        if (journalEntry) journalEntry.sheet.render(true);
        await warpgate.wait(250);
    },
    3: async () => {
        let journalEntry = game.journal.getName('CPR - Descriptions');
        if (journalEntry && journalEntry.sheet.rendered) journalEntry.sheet.close();
        await ui.sidebar.expand();
        await ui.sidebar.tabs.compendium.activate();
        await warpgate.wait(250);
        let compendiumFolder = game.folders.find(i => i.name === 'Chris\'s Premades' && i.type === 'Compendium');
        if (compendiumFolder && !compendiumFolder.expanded) document.querySelector('[data-uuid="' + compendiumFolder.uuid + '"]').classList.remove('collapsed');
    },
    4: async () => {
        let pack = game.packs.get('chris-premades.CPR Spells');
        if (!pack) return;
        pack.render(true);
        await warpgate.wait(250);
    },
    5: async () => {
        let pack = game.packs.get('chris-premades.CPR Spells');
        if (!pack) return;
        let index = await pack.getIndex();
        let fireShield = index.getName('Fire Shield');
        if (!fireShield) return;
        let document = await pack.getDocument(fireShield._id);
        document.sheet.render(true);
        await warpgate.wait(250);
    },
    6: async () => {
        let pack = game.packs.get('chris-premades.CPR Spells');
        if (!pack) return;
        let index = await pack.getIndex();
        let fireShield = index.getName('Fire Shield');
        if (!fireShield) return;
        let document = await pack.getDocument(fireShield._id);
        document.sheet.close();
        let compendiumApp = Object.values(ui.windows).find(i => i.metadata?.label === 'CPR Spells');
        if (compendiumApp) compendiumApp.close();
        game.settings.sheet.render(true, {'activeCategory': 'chris-premades'});
        await warpgate.wait(250);
    },
    8: async () => {
        game.settings.sheet.close();
        let pack = game.packs.get('dnd5e.heroes')
        if (!pack) return;
        let index = await pack.getIndex();
        let rogue = index.getName('Riswynn (Dwarf Rogue)')
        if (!rogue) return;
        let document = await pack.getDocument(rogue._id);
        if (!document) return;
        document.sheet.render(true);
        await warpgate.wait(250);
        let feature = document.items.getName('Sneak Attack')
        if (!feature) return;
        feature.sheet.render(true);
        await warpgate.wait(250);
    },
    9: async () => {
        chris.dialog('Item Configuration: Example', [['🔎 Update / Replace Item', false], ['🛠️ Configure', false], ['⚖️ Add Scale', false]]);
        await warpgate.wait(250);
    },
    12: async () => {
        let dialogApp = Object.values(ui.windows).find(i => i.data?.title === 'Item Configuration: Example');
        if (dialogApp) dialogApp.close();
        let pack = game.packs.get('dnd5e.heroes')
        if (!pack) return;
        let index = await pack.getIndex();
        let rogue = index.getName('Riswynn (Dwarf Rogue)')
        if (!rogue) return;
        let document = await pack.getDocument(rogue._id);
        if (!document) return;
        let feature = document.items.getName('Sneak Attack')
        if (!feature) return;
        feature.sheet.close();
        document.sheet.close();
        await ui.sidebar.tabs.chat.activate();
        let journalEntry = game.journal.getName('CPR - Descriptions');
        if (journalEntry) await journalEntry.sheet.render(true);
    }

}
class chrisTour extends Tour {
    async next() {
        if (this.status === Tour.STATUS.COMPLETED) {
            throw new Error('Tour ' + this.id + 'has already been completed');
        }
        if (!this.hasNext) return this.complete();
        let nextIndex = this.stepIndex + 1;
        if (tours_states[nextIndex]) await tours_states[nextIndex]();
        return this.progress(nextIndex);
    }
    get hasPrevious() {
        return false;
    }
    async complete() {
        let nextIndex = this.stepIndex + 1;
        await tours_states[nextIndex]();
        return this.progress(this.steps.length);
    }
}
async function registerTours() {
    let journalEntry = game.journal.getName('CPR - Descriptions');
    if (!journalEntry) return;
    let dragonBreath = journalEntry.pages.getName('Dragon Breath');
    if (!dragonBreath) return;
    let compendiumFolder = game.folders.find(i => i.name === 'Chris\'s Premades' && i.type === 'Compendium');
    if (!compendiumFolder) return;
    let pack = game.packs.get('chris-premades.CPR Spells');
    if (!pack) return;
    let index = await pack.getIndex();
    let fireShield = index.getName('Fire Shield');
    if (!fireShield) return;
    await game.tours.register('chris-premades', 'tour', new chrisTour({
        'title': 'CPR Tour',
        'description': 'CPR Tour',
        'canBeResumed': false,
        'display': false,
        'steps': [
            {
                'id': 'chris-premades.tour.0',
                'title': 'Welcome!',
                'content': 'This tour will guide you through using some of the core features of using Chris\'s Premades.'
            },
            {
                'id': 'chris-premades.tour.1',
                'title': 'The Description Journal',
                'selector': '[data-document-id="' + journalEntry.id + '"]',
                'content': 'This journal is used to store descriptions for temporary spells, items, and features.'
            },
            {
                'id': 'chris-premades.tour.2',
                'title': 'The Description Journal',
                'selector': '[data-page-id="' + dragonBreath.id + '"]',
                'content': 'For example, the spell "Dragon\'s Breath" will make a temporary feature called "Dragon Breath" on the target actor.\nFilling in this journal page will populate the description when it\'s created.'
            },
            {
                'id': 'chris-premades.tour.3',
                'title': 'Content Compendiums',
                'selector': '[data-uuid="' + compendiumFolder.uuid + '"]',
                'content': 'This is where all the content from this module is stored.'
            },
            {
                'id': 'chris-premades.tour.4',
                'title': 'Item Info',
                'selector': '[data-document-id="' + fireShield._id + '"]',
                'content': 'As an example the spell "Fire Shield" is stored in the "CPR Spells" compendium. You can drag the spell from this compendium onto an actor sheet.'
            },
            {
                'id': 'chris-premades.tour.5',
                'title': 'Item Description',
                'selector': '[id*="-Compendium-chris-premades-CPR Spells-Item-' + fireShield._id + '"]',
                'content': 'Some automations require specific settings to be enabled.\nFor example, the "Fire Shield" spell requires the "On Hit Automation" setting to be enabled.'
            },
            {
                'id': 'chris-premades.tour.6',
                'title': 'Settings',
                'selector': '[data-tab="chris-premades"]',
                'content': 'All of the module settings are located here and organized into categories.'
            },
            {
                'id': 'chris-premades.tour.7',
                'title': 'Settings',
                'selector': '[data-key="chris-premades.General"]',
                'content': '"On Hit Automation" is located in this category, along with many other useful settings.'
            },
            {
                'id': 'chris-premades.tour.8',
                'title': 'The Medkit',
                'selector': '[class="header-button control chris-premades-item"]',
                'content': 'As an alternative to copying items out of the compendiums, you can use the medkit button on the title bar.\nThis button is only available on items that are on actors (Not items in your items directory!).\nThe medkit will automatically search the compendiums and locate an automation for you (if one is available).\nThis search is based on the type of the item and it\'s name.'
            },
            {
                'id': 'chris-premades.tour.9',
                'title': 'The Medkit',
                'selector': '[class="dialog-button 🔎 Update / Replace Item"]',
                'content': 'This button will update the item from the compendium.\nThe item description, spell preparation, item uses, and quantity will be preserved.'
            },
            {
                'id': 'chris-premades.tour.10',
                'title': 'The Medkit',
                'selector': '[class="dialog-button 🛠️ Configure"]',
                'content': 'This button will allow you to configure certain options for the automation.\nFor example, "Sneak Attack" can be configured to automatically apply sneak attack on valid attacks instead of prompting you to use it.'
            },
            {
                'id': 'chris-premades.tour.11',
                'title': 'The Medkit',
                'selector': '[class="dialog-button ⚖️ Add Scale"]',
                'content': 'This button (which is only available on certain class items) will allow you to automatically create the needed advancement scale for certain automations.\nFor example, "Sneak Attack" requires a sneak attack die scale set.'
            }
        ]
    }));
}
async function guidedTour() {
    if (!registered) {
        await registerTours();
        registered = true;
    }
    let tour = game.tours.get('chris-premades.tour');
    if (!tour) return;
    tour.start();
}
async function checkTour() {
    if (!game.user.isGM) return;
    let makeMessage = !game.settings.get('chris-premades', 'Tour Message');
    let message = '<hr>View a guided tour of Chris\'s Premades here:<br><button type="button">Start Tour</button>';
    let chatMessage = game.messages.find(i => i.flags?.['chris-premades']?.tour);
    if (!chatMessage && makeMessage) {
        chatMessage = await ChatMessage.create({
            'speaker': {'alias': 'Chris\'s Premades'},
            'content': message,
            'flags': {
                'chris-premades': {
                    'tour': true
                }
            }
        });
        await warpgate.wait(250);
        game.settings.set('chris-premades', 'Tour Message', true);
    }
    if (!chatMessage) return;
    let messageElement = document.querySelector('[data-message-id="' + chatMessage.id + '"]');
    if (!messageElement) return;
    let button = messageElement.querySelector('[type="button"]');
    if (button) button.onclick = guidedTour;

}
let tours = {
    'registerTours': registerTours,
    'guidedTour': guidedTour,
    'chrisTour': chrisTour,
    'checkTour': checkTour
}
;// CONCATENATED MODULE: ./scripts/settingsMenu.js






let settingCategories = {};
function addMenuSetting(key, category) {
    setProperty(settingCategories, key.split(' ').join('-'), category);
}
let labels = {
    'Humanoid-Randomizer-Settings': 'Configure',
    'Additional-Compendiums': 'Configure',
    'Additional-Compendium-Priority': 'Configure',
    'Item-Compendium': 'Select',
    'Spell-Compendium': 'Select',
    'Monster-Compendium': 'Select',
    'Racial-Trait-Compendium': 'Select',
    'Manual-Rolling-Players': 'Configure'
}
class chrisSettingsBase extends FormApplication {
    constructor() {
        super();
        this.category = null;
    }
    static get defaultOptions() {
        return mergeObject(super.defaultOptions, {
            'classes': ['form'],
            'popOut': true,
            'template': 'modules/chris-premades/templates/config.html',
            'id': 'chris-premades-settings',
            'title': 'Chris\'s Premades',
            'width': 800,
            'height': 'auto',
            'closeOnSubmit': true
        });
    }
    getData() {
        let generatedOptions = [];
	    for (let setting of game.settings.settings.values()) {
            if (setting.namespace != 'chris-premades') continue;
            let key = setting.key.split(' ').join('-');
            if (settingCategories[key] != this.category) continue;
            const s = foundry.utils.deepClone(setting);
            if (s.scope === 'world' && !game.user.isGM) continue;
            s.id = `${s.key}`;
            s.name = game.i18n.localize(s.name);
            s.hint = game.i18n.localize(s.hint);
            s.value = game.settings.get(s.namespace, s.key);
            s.type = setting.type instanceof Function ? setting.type.name : 'String';
            s.isCheckbox = setting.type === Boolean;
            s.isSelect = s.choices !== undefined;
            s.isRange = (setting.type === Number) && s.range;
            s.isNumber = setting.type === Number;
            s.filePickerType = s.filePicker === true ? 'any' : s.filePicker;
            s.isButton = (setting.type instanceof Object || setting.type instanceof Array) && setting.type.name != 'String';
            if (s.select) s.isButton = true;
            s.label = labels[key];
            generatedOptions.push(s);
	    }
        return {'settings': generatedOptions.sort(function (a, b) {
            let nameA = a.name.toUpperCase();
            let nameB = b.name.toUpperCase();
            if (nameA > nameB) {
                return 1;
            } else if (nameA < nameB) {
                return -1;
            } else {
                return 0;
            }
        })};
    }
    activateListeners(html) {
        super.activateListeners(html);
    }
    async _updateObject(event, formData) {
        for (let [key, value] of Object.entries(formData)) {
            if (game.settings.get('chris-premades', key) === value) continue;
            await game.settings.set('chris-premades', key, value);
        }
    }
}
class chrisSettingsGeneral extends chrisSettingsBase {
    constructor() {
        super();
        this.category = 'General';
    }
}
class chrisSettingsCompendiums extends chrisSettingsBase {
    constructor() {
        super();
        this.category = 'Compendiums';
    }
}
class chrisSettingsMechanics extends chrisSettingsBase {
    constructor() {
        super();
        this.category = 'Mechanics';
    }
}
class chrisSettingsSpells extends chrisSettingsBase {
    constructor() {
        super();
        this.category = 'Spells';
    }
}
class chrisSettingsFeats extends chrisSettingsBase {
    constructor() {
        super();
        this.category = 'Feats';
    }
}
class chrisSettingsClassFeats extends chrisSettingsBase {
    constructor() {
        super();
        this.category = 'Class Features';
    }
}
class chrisSettingsRaceFeats extends chrisSettingsBase {
    constructor() {
        super();
        this.category = 'Race Features';
    }
}
class chrisSettingsMonsterFeats extends chrisSettingsBase {
    constructor() {
        super();
        this.category = 'Monster Features';
    }
}
class chrisSettingsSummons extends chrisSettingsBase {
    constructor() {
        super();
        this.category = 'Summons';
    }
}
class chrisSettingsHomewbrew extends chrisSettingsBase {
    constructor() {
        super();
        this.category = 'Homebrew';
    }
}
class chrisSettingsModule extends chrisSettingsBase {
    constructor() {
        super();
        this.category = 'Module Integration';
    }
}
class chrisSettingsManualRolling extends chrisSettingsBase {
    constructor() {
        super();
        this.category = 'Manual Rolling';
    }
}
class chrisSettingsRandomizer extends (/* unused pure expression or super */ null && (chrisSettingsBase)) {
    constructor() {
        super();
        this.category = 'Randomizer';
    }
}
class chrisSettingsAnimations extends chrisSettingsBase {
    constructor() {
        super();
        this.category = 'Animations';
    }
}
class chrisSettingsTroubleshoot extends FormApplication {
    constructor() {
        super();
    }
    static get defaultOptions() {
        return mergeObject(super.defaultOptions, {
            'classes': ['form'],
            'popOut': true,
            'template': 'modules/chris-premades/templates/config.html',
            'id': 'chris-troubleshoot-settings',
            'title': 'Help',
            'width': 800,
            'height': 'auto',
            'closeOnSubmit': true
        });
    }
    getData() {
        return {
            'settings': [
                {
                    'name': 'Tour Features',
                    'id': 'tour',
                    'value': {},
                    'isButton': true,
                    'hint': 'Start a guided tour of Chris\'s Premades.',
                    'label': 'Go'
                },
                {
                    'name': 'Run Troubleshooter:',
                    'id': 'trouble',
                    'value': {},
                    'isButton': true,
                    'hint': 'Will export a file used to help troubleshoot issues with this module on my Discord server.',
                    'label': 'Go'
                },
                {
                    'name': 'Apply recommended setting fixes:',
                    'id': 'fix',
                    'value': {},
                    'isButton': true,
                    'hint': 'This will have the module automatically apply recommended setting changes.',
                    'label': 'Go'
                }
            ]
        }
    }
    activateListeners(html) {
        super.activateListeners(html);
    }
    async _updateObject(event, formData) {

    }
}
class chrisSettingsRandomizerHumanoid extends FormApplication {
    constructor() {
        super();
    }
    static get defaultOptions() {
        return mergeObject(super.defaultOptions, {
            'classes': ['form'],
            'popOut': true,
            'template': 'modules/chris-premades/templates/config.html',
            'id': 'chris-humanoid-randomizer-settings',
            'title': 'Chris\'s Humanoid Randomizer Settings',
            'width': 800,
            'height': 'auto',
            'closeOnSubmit': true
        });
    }
    getData() {
        let generatedOptions = [];
        let humanoidSettings = game.settings.get('chris-premades', 'Humanoid Randomizer Settings');
        for (let i of Object.values(allRaces)) {
            let id = i.name.toLowerCase().split(' ').join('-');
            generatedOptions.push(
                {
                    'name': i.name + ' enabled:',
                    'id': id + '.enabled',
                    'value': humanoidSettings?.[id]?.enabled ?? allRaces[id].enabled,
                    'isCheckbox': true,
                    'hint': 'Enable use of the ' + i.name + ' race?'
                },
                {
                    'name': i.name + ' weight:',
                    'id': id + '.weight',
                    'value': humanoidSettings?.[id]?.weight ?? allRaces[id].weight,
                    'isRange': true,
                    'range': {
                        'min': 1,
                        'max': 100,
                        'step': 1
                    },
                    'hint': 'Weighted chance for ' + i.name + ' to be selected.'
                }
            );
        }
        return {'settings': generatedOptions};
    }
    activateListeners(html) {
        super.activateListeners(html);
    }
    async _updateObject(event, formData) {
        let updates = {};
        for (let [key, value] of Object.entries(formData)) {
            setProperty(updates, key, value);
        }
        let setting = mergeObject(allRaces, game.settings.get('chris-premades', 'Humanoid Randomizer Settings'));
        mergeObject(setting, updates);
        game.settings.set('chris-premades', 'Humanoid Randomizer Settings', setting);
    }
}
async function settingButton(id) {
    switch (id) {
        case 'Humanoid Randomizer Settings':
            await new chrisSettingsRandomizerHumanoid().render(true);
            break;
        case 'trouble':
            try {
                troubleshoot();
            } catch {}
            break;
        case 'fix':
            fixSettings();
            break;
        case 'sidebarNPCs':
            await updateSidebarNPCs();
            break;
        case 'sceneNPCs':
            await updateSceneNPCs();
            break;
        case 'allSceneNPCs':
            await updateAllSceneNPCs();
            break;
        case 'Additional Compendiums':
            await additionalCompendiums();
            break;
        case 'Additional Compendium Priority':
            await additionalCompendiumPriority();
            break;
        case 'Item Compendium':
        case 'Spell Compendium':
        case 'Monster Compendium':
        case 'Racial Trait Compendium':
            await selectCompendium(id);
            break;
        case 'tour':
            game.settings.sheet.close();
            let dialogApp = Object.values(ui.windows).find(i => i.id === 'chris-troubleshoot-settings');
            if (dialogApp) dialogApp.close();
            await warpgate.wait(100);
            await tours.guidedTour();
            break;
        case 'Manual Rolling Players':
            await manualRolls.userOptions();
            break;
    }
}
class chrisSettingsNPCUpdate extends FormApplication {
    constructor() {
        super();
    }
    static get defaultOptions() {
        return mergeObject(super.defaultOptions, {
            'classes': ['form'],
            'popOut': true,
            'template': 'modules/chris-premades/templates/config.html',
            'id': 'chris-npc-updater',
            'title': 'Chris\'s NPC Updater',
            'width': 800,
            'height': 'auto',
            'closeOnSubmit': true
        });
    }
    getData() {
        return {
            'settings': [
                {
                    'name': 'Update Sidebar NPCs:',
                    'id': 'sidebarNPCs',
                    'value': {},
                    'isButton': true,
                    'hint': 'This will use the D&D Beyond Importer API to update all sidebar NPCs with automations from this module. Use with care!',
                    'label': 'Go'
                },
                {
                    'name': 'Update Current Scene NPCs:',
                    'id': 'sceneNPCs',
                    'value': {},
                    'isButton': true,
                    'hint': 'This will use the D&D Beyond Importer API to update the NPCs on the current scene with automations from this module. Use with care!',
                    'label': 'Go'
                },
                {
                    'name': 'Update All Scene NPCs',
                    'id': 'allSceneNPCs',
                    'value': {},
                    'isButton': true,
                    'hint': 'This will use the D&D Beyond Importer API to update all NPCs on all scenes with automations from this module. Use with care!',
                    'label': 'Go'
                }
            ]
        }
    }
    activateListeners(html) {
        super.activateListeners(html);
    }
    async _updateObject(event, formData) {

    }
}
;// CONCATENATED MODULE: ./scripts/utility/rest.js






async function rest_rest(actor, data) {
    await armorModel.longRest(actor, data);
    await summonDrakeCompanion.longRest(actor, data);
    await steelDefender.longRest(actor, data);
    await arcaneWard.longRest(actor, data);
    await manifestMind.longRest(actor, data);
    await wrapsOffDyamak.rest(actor, data);
}
;// CONCATENATED MODULE: ./scripts/utility/templateEffect.js


async function templateEffect_updateToken(token, changes, context, userId) {
    if (game.settings.get('chris-premades', 'LastGM') != game.user.id) return;
    if (!changes.x && !changes.y && !changes.elevation) return;
    await token.object?._animation;
    let coords = {'x': token.x, 'y': token.y};
    let previousCoords = foundry.utils.getProperty(context, 'templatemacro.coords.previous');
    let templates = token.parent.templates.reduce((acc, templateDoc) => {
        let cells = chris.findGrids(previousCoords, coords, templateDoc);
        if (!cells.length) return acc;
        acc.push(templateDoc.id);
        return acc;
    }, []);
    if (templates.length === 0) return;
    let allTriggers = {};
    for (let i of templates) {
        let template = canvas.scene.templates.get(i);
        if (!template) continue;
        let flag = template.flags['chris-premades']?.template;
        if (!flag?.name) continue;
        if (flag.ignoreMove) continue;
        if (flag.ignoreStart && chris.inCombat()) {
            let {'x': tokx, 'y': toky} = previousCoords;
            let {'x': tempx, 'y': tempy} = template;
            let startX = token.width >= 1 ? 0.5 : token.width / 2;
            let startY = token.height >= 1 ? 0.5 : token.height / 2;
            let curr = {
                'x': tokx + startX * token.parent.grid.size - tempx,
                'y': toky + startY * token.parent.grid.size - tempy
            };
            let contains = template.object.shape.contains(curr.x, curr.y);
            if (contains) continue;
        }
        if (!allTriggers[flag.name]) allTriggers[flag.name] = [];
        allTriggers[flag.name].push(flag);
    }
    if (allTriggers.length === 0) return;
    runTriggers(allTriggers, token, 'move');
}
function combat(combat, changes, context) {
    if (game.settings.get('chris-premades', 'LastGM') != game.user.id) return;
    let currentTurn = combat.current.turn;
    let previousTurn = context.effectmacro?.previousTR?.T;
    let currentRound = combat.current.round;
    let previousRound = context.effectmacro?.previousTR?.R;
    if (!changes.turn && !changes.round) return;
    if (!combat.started || !combat.isActive) return;
    if (currentRound < previousRound || (currentTurn < previousTurn && currentTurn === previousRound)) return;
    let token = game.combat.scene.tokens.get(combat.current.tokenId);
    if (token) {
        let templates = chris.tokenTemplates(token);
        if (templates.length != 0) {
            let allTriggers = {};
            for (let i of templates) {
                let template = canvas.scene.templates.get(i);
                if (!template) continue;
                let flag = template.flags['chris-premades']?.template;
                if (!flag?.name) continue;
                if (!flag.turn) continue;
                if (!(flag.turn === 'start' || flag.turn === 'both')) continue;
                if (!allTriggers[flag.name]) allTriggers[flag.name] = [];
                allTriggers[flag.name].push(flag);
            }
            if (allTriggers.length === 0) return;
            runTriggers(allTriggers, token, 'turnStart');
        }
    }
    let previousToken = game.combat.scene.tokens.get(combat.previous.tokenId);
    if (previousToken) {
        let templates = chris.tokenTemplates(previousToken);
        if (templates.length != 0) {
            let allTriggers = {};
            for (let i of templates) {
                let template = canvas.scene.templates.get(i);
                if (!template) continue;
                let flag = template.flags['chris-premades']?.template;
                if (!flag?.name) continue;
                if (!flag.turn) continue;
                if (!(flag.turn === 'end' || flag.turn === 'both')) continue;
                if (!allTriggers[flag.name]) allTriggers[flag.name] = [];
                allTriggers[flag.name].push(flag);
            }
            if (allTriggers.length === 0) return;
            runTriggers(allTriggers, previousToken, 'turnEnd'); 
        }
    }
}
async function runTriggers(allTriggers, token, reason) {
    for (let triggerName of Object.values(allTriggers)) {
        let maxLevel = Math.max(...triggerName.map(trigger => trigger.castLevel));
        let maxDC = Math.max(...triggerName.map(trigger => trigger.saveDC));
        let maxDCTrigger = triggerName.find(trigger => trigger.saveDC === maxDC);
        let selectedTrigger;
        if (maxDCTrigger.castLevel === maxLevel) {
            selectedTrigger = triggerName.find(trigger => trigger.castLevel === maxLevel && trigger.saveDC === maxDC);
        } else {
            selectedTrigger = triggerName.find(trigger => trigger.castLevel === maxLevel);
        }
        await executeFunction(selectedTrigger, token, reason);
        await warpgate.wait(100);
    }
}
async function executeFunction(selectedTrigger, token, reason) {
    console.log('Chris | Executing template trigger for ' + selectedTrigger.name + ' to: ' + token.actor.name);
    let macroCommand;
    if (selectedTrigger.macroName) {
        macros.templateTrigger(selectedTrigger.macroName, token, selectedTrigger, reason);
    } else if (selectedTrigger.globalFunction) {
        macroCommand = `await ${selectedTrigger.globalFunction.trim()}.bind(this)({token, reason})`;
    } else if (selectedTrigger.worldMacro) {
        let macro = game.macros?.getName(selectedTrigger.worldMacro.replaceAll('"', ''));
        macroCommand = macro?.command ?? `console.warn('Chris | No world macro ${selectedTrigger.worldMacro.replaceAll('"', '')} found!')`;
    }
    if (macroCommand) {
        let body = `return (async () => {${macroCommand}})()`;
        let fn = Function('{token}={}', body);
        try {
            fn.call(selectedTrigger, {token, reason});
        } catch (error) {
            ui.notifications?.error('There was an error running your macro. See the console (F12) for details');
            error('Error evaluating macro ', error);
        }
    }
}
let templates = {
    'move': templateEffect_updateToken,
    'runTrigger': executeFunction,
    'combat': combat
}
;// CONCATENATED MODULE: ./scripts/integrations/vae.js

function vaeEffectDescription(effect, updates, options, id) {
    if (!effect.parent) return;
    if (effect.parent.constructor.name != 'Actor5e') return;
    if (!effect.origin) return;
    let origin = fromUuidSync(effect.origin);
    if (!origin) return;
    if (origin.constructor.name != 'Item5e') return;
    if (!updates.flags?.['visual-active-effects']?.data?.content) {
        if (game.settings.get('chris-premades', 'No NPC VAE Descriptions')) {
            if (origin.actor?.type === 'npc' && origin.actor.id != effect.parent.id) return;
        }
        setProperty(updates, 'flags.visual-active-effects.data.content', origin.system.description.value);
    } else {
        return;
    }
    effect.updateSource({'flags.visual-active-effects': updates.flags['visual-active-effects']});
}
async function vaeTempItemButton(effect, buttons) {
    let name = effect.flags['chris-premades']?.vae?.button;
    if (!name) return;
    if (name === 'Dismiss Summon') {
        buttons.push({
            'label': name,
            'callback': async function(){
                await chris.removeEffect(effect);
            }
        });
    } else {
        buttons.push({
            'label': 'Use: ' + name,
            'callback': async function(){
                let item = effect.parent.items.getName(name);
                if (item) {
                    await item.use();
                } else {
                    ui.notifications.warn(name + ' item not found!');
                }
            }
        });
    }
}
;// CONCATENATED MODULE: ./scripts/integrations/templateMacro.js
function templateMacroTitleBarButton(app, [elem], options) {
    let headerButton = elem.closest('.window-app').querySelector('a.header-button.templatemacro');
    if (!headerButton) return;
    let object = app.object;
    if (!object) return;
    let flag = object.flags?.templatemacro;
    if (!flag) return;
    if (!Object.keys(flag).length) return;
    headerButton.style.color = 'green';
}
;// CONCATENATED MODULE: ./scripts/macros/actions/token.js

async function addActions(token, options, userId) {
    let option = game.settings.get('chris-premades', 'Add Generic Actions');
    if (option === 'none' || userId != game.user.id || !token.actor) return;
    switch (option) {
        case 'uCharacter':
            if (token.actor.prototypeToken.actorLink) return;
        case 'character':
            if (token.actor.type != 'character') return;
            break;
        case 'uNpc':
            if (token.actor.prototypeToken.actorLink) return;
        case 'npc':
            if (token.actor.type != 'npc') return;
            break;
        case 'lNpc':
            if (!token.actor.prototypeToken.actorLink || token.actor.type != 'npc') return;
            break;
        case 'lCharacter':
            if (!token.actor.prototypeToken.actorLink || token.actor.type != 'character') return;
            break;
        default:
            if (token.actor.type != 'character' && token.actor.type != 'npc') return;
            break;
    }
    let pack = game.packs.get('chris-premades.CPR Actions');
    if (!pack) return;
    await pack.getDocuments();
    let newItemData = [];
    for (let i of pack.contents) {
        if (token.actor.items.getName(i.name)) continue;
        let itemData = i.toObject();
        delete itemData._id;
        itemData.system.description.value = chris.getItemDescription('CPR - Descriptions', itemData.name);
        newItemData.push(itemData);
    }
    if (newItemData.length) await token.actor.createEmbeddedDocuments('Item', newItemData);
}
;// CONCATENATED MODULE: ./scripts/settings.js
























let moduleName = 'chris-premades';
let humanoidSettings = {};
function registerSettings() {
    game.settings.register(moduleName, 'Automation Verification', {
        'name': 'Automation Verification',
        'hint': 'When enabled, the module will verify the automation is up to date and has the correct settings enabled.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': true,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preItemRoll', info);
            } else {
                Hooks.off('midi-qol.preItemRoll', info);
            }
        }
    });
    addMenuSetting('Automation Verification', 'General');
    game.settings.register(moduleName, 'Breaking Version Change', {
        'name': 'Breaking Version Change',
        'hint': 'Internal version number bumped when an update requires new imports.',
        'scope': 'world',
        'config': false,
        'type': Number,
        'default': 9
    });
    game.settings.register(moduleName, 'Tour Message', {
        'name': 'Tour Message',
        'hint': 'Check if the GM has seen the tour message.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false
    });
    game.settings.register(moduleName, 'Show Names', {
        'name': 'Show Names',
        'hint': 'Enabling this will show target names in the target selector dialog (Used for certain features and spells).',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': true
    });
    addMenuSetting('Show Names', 'General');
    game.settings.register(moduleName, 'Priority Queue', {
        'name': 'Priority Queue',
        'hint': 'This setting allows macros from this module to have an on use priority order.  This prevents multiple pop-up dialogs from firing at the same time as well as applying damage modification changes in a certain order.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': true
    });
    addMenuSetting('Priority Queue', 'General');
    game.settings.register(moduleName, 'Item Replacer Access', {
        'name': 'Item Replacer Access',
        'hint': 'If enabled, players can replace their own items.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false
    });
    addMenuSetting('Item Replacer Access', 'General');
    game.settings.register(moduleName, 'Item Configuration Access', {
        'name': 'Item Configuration Access',
        'hint': 'If enabled, players can configure their own items.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false
    });
    addMenuSetting('Item Configuration Access', 'General');
    game.settings.register(moduleName, 'Movement Listener', {
        'name': 'Movement Listener',
        'hint': 'This setting allows certain macros from this module to function on token movement.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value && game.user.isGM) {
                Hooks.on('updateToken', tokenMoved);
                Hooks.on('preUpdateToken', tokenMovedEarly);
            } else if (game.user.isGM) {
                Hooks.off('updateToken', tokenMoved);
                Hooks.off('preUpdateToken', tokenMovedEarly);
            }
        }
    });
    addMenuSetting('Movement Listener', 'General');
    game.settings.register(moduleName, 'Template Listener', {
        'name': 'Template Listener',
        'hint': 'This setting allows certain macros from this module to function when tokens interact with templates.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value && game.user.isGM) {
                Hooks.on('updateToken', templates.move);
                Hooks.on('updateCombat', templates.combat);
            } else if (game.user.isGM) {
                Hooks.off('updateToken', templates.move);
                Hooks.on('updateCombat', templates.combat);
            }
        }
    });
    addMenuSetting('Template Listener', 'General');
    game.settings.register(moduleName, 'Tasha Actors', {
        'name': 'Keep Summon Actors Updated',
        'hint': 'This setting will keep actors from this module updated in the sidebar.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': async value => {
            if (value && game.user.isGM) await tashaSummon.setupFolder();
        }
    });
    addMenuSetting('Tasha Actors', 'Summons');
    game.settings.register(moduleName, 'Tasha Initiative', {
        'name': 'Minions use caster\'s initiative',
        'hint': 'Enabling this will have minions summoned from this module to use the caster\'s initiative instead of rolling their own.  Similar to the summon spells from Tasha\'s Cauldron Of Everything',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false
    });
    addMenuSetting('Tasha Initiative', 'Summons');
    game.settings.register(moduleName, 'Player Chooses Conjures', {
        'name': 'Player choose creatures for conjure spells',
        'hint': 'Enabling this will have players chose the creatures summoned for conjure spells, instead of the Sage Advice ruling that the DM choses the creatures.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false
    });
    addMenuSetting('Player Chooses Conjures', 'Summons');
    game.settings.register(moduleName, 'Effect Auras', {
        'name': 'Effect Auras',
        'hint': 'This setting allows certain macros from this module to apply effect auras.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value && game.user.isGM) {
                Hooks.on('preUpdateActor', effectAuraHooks.preActorUpdate);
                Hooks.on('updateActor', effectAuraHooks.actorUpdate);
                Hooks.on('canvasReady', effectAuraHooks.canvasReady);
                Hooks.on('updateToken', effectAuraHooks.updateToken);
                Hooks.on('createToken', effectAuraHooks.createToken);
                Hooks.on('deleteToken', effectAuraHooks.deleteToken);
                Hooks.on('createActiveEffect', effectAuraHooks.createRemoveEffect);
                Hooks.on('deleteActiveEffect', effectAuraHooks.createRemoveEffect);
            } else if (game.user.isGM) {
                Hooks.off('preUpdateActor', effectAuraHooks.preActorUpdate);
                Hooks.off('updateActor', effectAuraHooks.actorUpdate);
                Hooks.off('canvasReady', effectAuraHooks.canvasReady);
                Hooks.off('updateToken', effectAuraHooks.updateToken);
                Hooks.off('createToken', effectAuraHooks.createToken);
                Hooks.off('deleteToken', effectAuraHooks.deleteToken);
                Hooks.off('createActiveEffect', effectAuraHooks.createRemoveEffect);
                Hooks.off('deleteActiveEffect', effectAuraHooks.createRemoveEffect);
            }
        }
    });
    addMenuSetting('Effect Auras', 'General');
    game.settings.register(moduleName, 'Active Effect Additions', {
        'name': 'Active Effect Additions',
        'hint': 'This setting allows active effects to have additional properties.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': true,
        'onChange': value => {
            if (value) {
                Hooks.on('preCreateActiveEffect', itemDC);
                Hooks.on('preCreateActiveEffect', noEffectAnimationCreate);
                Hooks.on('preDeleteActiveEffect', noEffectAnimationDelete);
                Hooks.on('getActiveEffectConfigHeaderButtons', effectTitleBar);
            } else {
                Hooks.off('preCreateActiveEffect', itemDC);
                Hooks.off('preCreateActiveEffect', noEffectAnimationCreate);
                Hooks.off('preDeleteActiveEffect', noEffectAnimationDelete);
                Hooks.off('getActiveEffectConfigHeaderButtons', effectTitleBar);
            }
            patchActiveEffectSourceName(value);
        }
    });
    addMenuSetting('Active Effect Additions', 'General');
    game.settings.register(moduleName, 'Active Effect Origin Fix', {
        'name': 'Active Effect Origin Fix',
        'hint': 'This setting corrects the origin of effects on unlinked actors.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': true,
        'onChange': value => {
            if (value) {
                Hooks.on('createToken', fixOrigin);
            } else {
                Hooks.off('createToken', fixOrigin);
            }
        }
    });
    addMenuSetting('Active Effect Origin Fix', 'General');
    game.settings.register(moduleName, 'Skill Patching', {
        'name': 'Skill Patching',
        'hint': 'This setting allows certain macros to modify skill checks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            patchSkills(value);
        }
    });
    addMenuSetting('Skill Patching', 'General');
    game.settings.register(moduleName, 'Save Patching', {
        'name': 'Save Patching',
        'hint': 'This setting allows certain macros to modify ability saves.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            patchSaves(value);
        }
    });
    addMenuSetting('Save Patching', 'General');
    game.settings.register(moduleName, 'Automatic VAE Descriptions', {
        'name': 'Automatic VAE Descriptions',
        'hint': 'When enabled, this setting will automatically fill in VAE effect descriptions when possible.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('preCreateActiveEffect', vaeEffectDescription);
            } else {
                Hooks.off('preCreateActiveEffect', vaeEffectDescription);
            }
        }
    });
    addMenuSetting('Automatic VAE Descriptions', 'Module Integration');
    game.settings.register(moduleName, 'No NPC VAE Descriptions', {
        'name': 'No NPC VAE Descriptions',
        'hint': 'If enabled, automatic VAE descriptions will ignore effects created from NPCs.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false
    });
    addMenuSetting('No NPC VAE Descriptions', 'Module Integration');
    game.settings.register(moduleName, 'VAE Temporary Item Buttons', {
        'name': 'VAE Temporary Item Buttons',
        'hint': 'When enabled, this setting will add a button to use temporary items via VAE.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('visual-active-effects.createEffectButtons', vaeTempItemButton);
            } else {
                Hooks.off('visual-active-effects.createEffectButtons', vaeTempItemButton);
            }
        }
    });
    addMenuSetting('VAE Temporary Item Buttons', 'Module Integration');
    game.settings.register(moduleName, 'Show Limits Animations', {
        'name': 'Show Limits Animations',
        'hint': 'When enabled, this setting allows Sequencer effects to be displayed over vision blocking templates.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
    });
    addMenuSetting('Show Limits Animations', 'Module Integration');
    game.settings.register(moduleName, 'Condition Fixes', {
        'name': 'Blinded and Invisibility Changes',
        'hint': 'This setting restores the blinded and invisibility conditions to how they worked in version 9 of Foundry.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) removeDumbV10Effects();
        }
    });
    addMenuSetting('Condition Fixes', 'Mechanics');
    game.settings.register(moduleName, 'LastGM', {
        'name': 'LastGM',
        'hint': 'Last GM to join the game.',
        'scope': 'world',
        'config': false,
        'type': String
    });
    game.settings.register(moduleName, 'Combat Listener', {
        'name': 'Combat Listener',
        'hint': 'This setting allows certain macros from this module to function on combat changes.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value && game.user.isGM) {
                Hooks.on('updateCombat', combatUpdate);
            } else if (game.user.isGM) {
                Hooks.off('updateCombat', combatUpdate);
            }
        }
    });
    addMenuSetting('Combat Listener', 'General');
    game.settings.register(moduleName, 'Rest Listener', {
        'name': 'Short / Long Rest Listener',
        'hint': 'Enabling this allows certain macros to function on short and long rests.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('dnd5e.restCompleted', rest_rest);
            } else {
                Hooks.off('dnd5e.restCompleted', rest_rest);
            }
        }
    });
    addMenuSetting('Rest Listener', 'General');
    game.settings.register(moduleName, 'Movement Triggers', {
        'name': 'Movement Triggers',
        'hint': 'Used to sync the movement queue.',
        'scope': 'world',
        'config': false,
        'type': Object,
        'default': {}
    });
    game.settings.register(moduleName, 'Additional Compendiums', {
        'name': 'Additional Compendiums',
        'hint': 'Select the additional compendiums the medkit will check in.',
        'scope': 'world',
        'config': false,
        'type': Array,
        'default': ['midi-srd.Midi SRD Feats', 'midi-srd.Midi SRD Spells', 'midi-srd.Midi SRD Items', 'midi-qol.midiqol-sample-items']
    });
    addMenuSetting('Additional Compendiums', 'Compendiums');
    game.settings.register(moduleName, 'Additional Compendium Priority', {
        'name': 'Additional Compendium Priority',
        'hint': 'Select the priority of additional compendiums.',
        'scope': 'world',
        'config': false,
        'type': Object,
        'default': {
            'CPR': 0,
            'GPS': 1,
            'MISC': 2,
            'midi-srd.Midi SRD Feats': 3,
            'midi-srd.Midi SRD Spells': 4,
            'midi-srd.Midi SRD Items': 5
        }
    });
    addMenuSetting('Additional Compendium Priority', 'Compendiums');
    game.settings.register(moduleName, 'GPS Support', {
        'name': 'Gambit\'s Premades Support',
        'hint': 'Include Gambit\'s premades in the medkit.',
        'scope': 'world',
        'config': false,
        'type': Number,
        'default': 0,
        'choices': {
            0: 'Disabled',
            1: 'Yes | Exclude Homebrew',
            2: 'Yes | Include Everything'
        }
    });
    addMenuSetting('GPS Support', 'Compendiums');
    game.settings.register(moduleName, 'MISC Support', {
        'name': 'Midi Item Showcase - Community Support',
        'hint': 'Include Midi Item Showcase in the medkit.',
        'scope': 'world',
        'config': false,
        'type': Number,
        'default': 0,
        'choices': {
            0: 'Disabled',
            1: 'Yes | Exclude Homebrew',
            2: 'Yes | Exclude Unearthed Arcana',
            3: 'Yes | Exclude Homebrew and Unearthed Arcana',
            4: 'Yes | Include Everything'
        }
    });
    addMenuSetting('MISC Support', 'Compendiums');
    game.settings.register(moduleName, 'Item Compendium', {
        'name': 'Personal Item Compendium',
        'hint': 'A compendium full of items to pick from (DDB items compendium by default).',
        'scope': 'world',
        'config': false,
        'type': String,
        'default': 'world.ddb-' + game.world.id + '-ddb-items',
        'select': true
    });
    addMenuSetting('Item Compendium', 'Compendiums');
    game.settings.register(moduleName, 'Spell Compendium', {
        'name': 'Personal Spell Compendium',
        'hint': 'A compendium full of spells to pick from (DDB spells compendium by default).',
        'scope': 'world',
        'config': false,
        'type': String,
        'default': 'world.ddb-' + game.world.id + '-ddb-spells',
        'select': true
    });
    addMenuSetting('Spell Compendium', 'Compendiums');
    game.settings.register(moduleName, 'Monster Compendium', {
        'name': 'Personal Monster Compendium',
        'hint': 'A compendium full of monsters to pick from (DDB monster compendium by default).',
        'scope': 'world',
        'config': false,
        'type': String,
        'default': 'world.ddb-' + game.world.id + '-ddb-monsters',
        'select': true
    });
    addMenuSetting('Monster Compendium', 'Compendiums');
    game.settings.register(moduleName, 'Racial Trait Compendium', {
        'name': 'Personal Racial Trait Compendium',
        'hint': 'A compendium full of racial traits to pick from (DDB monster compendium by default).',
        'scope': 'world',
        'config': false,
        'type': String,
        'default': 'world.ddb-' + game.world.id + '-ddb-racial-traits',
        'select': true
    });
    addMenuSetting('Racial Trait Compendium', 'Compendiums');
    game.settings.register(moduleName, 'Condition Resistance', {
        'name': 'Condition Resistance Mechanic',
        'hint': 'Enabling this allows the automation condition resistance via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preItemRoll', macros.conditionResistanceEarly);
                Hooks.on('midi-qol.RollComplete', macros.conditionResistanceLate);
            } else {
                Hooks.off('midi-qol.preItemRoll', macros.conditionResistanceEarly);
                Hooks.off('midi-qol.RollComplete', macros.conditionResistanceLate);
            }
        }
    });
    addMenuSetting('Condition Resistance', 'Mechanics');
    game.settings.register(moduleName, 'Condition Vulnerability', {
        'name': 'Condition Vulnerability Mechanic',
        'hint': 'Enabling this allows the automation condition vulnerability via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preItemRoll', macros.conditionVulnerabilityEarly);
                Hooks.on('midi-qol.RollComplete', macros.conditionVulnerabilityLate);
            } else {
                Hooks.off('midi-qol.preItemRoll', macros.conditionVulnerabilityEarly);
                Hooks.off('midi-qol.RollComplete', macros.conditionVulnerabilityLate);
            }
        }
    });
    addMenuSetting('Condition Vulnerability', 'Mechanics');
    game.settings.register(moduleName, 'On Hit', {
        'name': 'On Hit Automation',
        'hint': 'Enabling this allows the automation for certain "On Hit" features.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.RollComplete', onHitMacro);
            } else {
                Hooks.off('midi-qol.RollComplete', onHitMacro);
            }
        }
    });
    addMenuSetting('On Hit', 'General');
    game.settings.register(moduleName, 'Beacon of Hope', {
        'name': 'Beacon of Hope Automation',
        'hint': 'Enabling this allows the automation of the Beacon of Hope spell via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preTargetDamageApplication', macros.beaconOfHope);
            } else {
                Hooks.off('midi-qol.preTargetDamageApplication', macros.beaconOfHope);
            }
        }
    });
    addMenuSetting('Beacon of Hope', 'Spells');
    game.settings.register(moduleName, 'Darkness', {
        'name': 'Darkness Automation',
        'hint': 'Enabling this allows the automation of the Darkness spell via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preAttackRoll', macros.darkness.hook);
            } else {
                Hooks.off('midi-qol.preAttackRoll', macros.darkness.hook);
            }
        }
    });
    addMenuSetting('Darkness', 'Spells');
    game.settings.register(moduleName, 'Fog Cloud', {
        'name': 'Fog Cloud Automation',
        'hint': 'Enabling this allows the automation of the Fog Cloud spell via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preAttackRoll', macros.fogCloud.hook);
            } else {
                Hooks.off('midi-qol.preAttackRoll', macros.fogCloud.hook);
            }
        }
    });
    addMenuSetting('Fog Cloud', 'Spells');
    game.settings.register(moduleName, 'Death Ward', {
        'name': 'Death Ward Automation',
        'hint': 'Enabling this allows the automation of the Death Ward spell via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preTargetDamageApplication', macros.deathWard);
            } else {
                Hooks.off('midi-qol.preTargetDamageApplication', macros.deathWard);
            }
        }
    });
    addMenuSetting('Death Ward', 'Spells');
    game.settings.register(moduleName, 'Elemental Adept', {
        'name': 'Elemental Adept Automation',
        'hint': 'Enabling this allows the automation of the Elemental Adept feat via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.postPreambleComplete', macros.elementalAdept.early);
                Hooks.on('midi-qol.preDamageRollComplete', macros.elementalAdept.damage);
                Hooks.on('midi-qol.RollComplete', macros.elementalAdept.late);
            } else {
                Hooks.off('midi-qol.postPreambleComplete', macros.elementalAdept.early);
                Hooks.off('midi-qol.preDamageRollComplete', macros.elementalAdept.damage);
                Hooks.off('midi-qol.RollComplete', macros.elementalAdept.late);
            }
        }
    });
    addMenuSetting('Elemental Adept', 'Feats');
    game.settings.register(moduleName, 'Dual Wielder', {
        'name': 'Dual Wielder Automation',
        'hint': 'Enabling this allows the automation of the Dual Wielder feat via the use of Foundry hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('updateItem', macros.dualWielder);
            } else {
                Hooks.off('updateItem', macros.dualWielder);
            }
        }
    });
    addMenuSetting('Dual Wielder', 'Feats');
    game.settings.register(moduleName, 'Mirror Image', {
        'name': 'Mirror Image Automation',
        'hint': 'Enabling this allows the automation of the Mirror Image spell via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.AttackRollComplete', macros.mirrorImage);
            } else {
                Hooks.off('midi-qol.AttackRollComplete', macros.mirrorImage);
            }
        }
    });
    addMenuSetting('Mirror Image', 'Spells');
    game.settings.register(moduleName, 'Protection from Evil and Good', {
        'name': 'Protection from Evil and Good Automation',
        'hint': 'Enabling this allows the automation of the Protection from Evil and Good spell via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preAttackRoll', macros.protectionFromEvilAndGood);
            } else {
                Hooks.off('midi-qol.preAttackRoll', macros.protectionFromEvilAndGood);
            }
        }
    });
    addMenuSetting('Protection from Evil and Good', 'Spells');
    game.settings.register(moduleName, 'Sanctuary', {
        'name': 'Sanctuary Automation',
        'hint': 'Enabling this allows the automation of the Sanctuary spell via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preItemRoll', macros.sanctuary.hook);
            } else {
                Hooks.off('midi-qol.preItemRoll', macros.sanctuary.hook);
            }
        }
    });
    addMenuSetting('Sanctuary', 'Spells');
    game.settings.register(moduleName, 'Ranged Smite', {
        'name': 'Ranged Divine Smite',
        'hint': 'Enabling this will allow the Divine Smite feature to be used on ranged attacks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false
    });
    addMenuSetting('Ranged Smite', 'Homebrew');
    game.settings.register(moduleName, 'Unarmed Strike Smite', {
        'name': 'Unarmed Strike Divine Smite',
        'hint': 'Enabling this will allow the Divine Smite feature to be used on unarmed Strikes.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false
    });
    addMenuSetting('Unarmed Strike Smite', 'Homebrew');
    game.settings.register(moduleName, 'DMG Cleave', {
        'name': 'DMG Cleave Mechanic',
        'hint': 'Enabling this allows the automation of the cleave mechanic from the DMG workshop section via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.RollComplete', macros.cleave.hit);
                Hooks.on('midi-qol.preCheckHits', macros.cleave.attack);
                Hooks.on('midi-qol.preDamageRollComplete', macros.cleave.damage);
            } else {
                Hooks.off('midi-qol.RollComplete', macros.cleave.hit);
                Hooks.off('midi-qol.preCheckHits', macros.cleave.attack);
                Hooks.off('midi-qol.preDamageRollComplete', macros.cleave.damage);
            }
        }
    });
    addMenuSetting('DMG Cleave', 'Mechanics');
    game.settings.register(moduleName, 'DMG Cleave Full Health', {
        'name': 'DMG Cleave Damaged Tokens',
        'hint': 'When enabled the DMG cleave will also prompt on a target even if they didn\'t start with full health.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false
    });
    addMenuSetting('DMG Cleave Full Health', 'Mechanics');
    game.settings.register(moduleName, 'Wildhunt', {
        'name': 'Shifter Wildhunt Automation',
        'hint': 'Enabling this allows the automation of the Shifter Wildhunt feature via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preAttackRoll', macros.wildhunt);
            } else {
                Hooks.off('midi-qol.preAttackRoll', macros.wildhunt);
            }
        }
    });
    addMenuSetting('Wildhunt', 'Race Features');
    game.settings.register(moduleName, 'Undead Fortitude', {
        'name': 'Undead Fortitude Automation',
        'hint': 'Enabling this allows the automation of the Undead Fortitude feature via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preTargetDamageApplication', macros.monster.zombie.undeadFortitude);
            } else {
                Hooks.off('midi-qol.preTargetDamageApplication', macros.monster.zombie.undeadFortitude);
            }
        }
    });
    addMenuSetting('Undead Fortitude', 'Monster Features');
    game.settings.register(moduleName, 'Exploding Heals', {
        'name': 'Exploding Heals',
        'hint': 'Enabling this allows the automation of the homebrew rule to have exploding dice for all healing rolls via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preDamageRollComplete', macros.explodingHeals);
            } else {
                Hooks.off('midi-qol.preDamageRollComplete', macros.explodingHeals);
            }
        }
    });
    addMenuSetting('Exploding Heals', 'Homebrew');
    game.settings.register(moduleName, 'Shield Guardian', {
        'name': 'Shield Guardian Automation',
        'hint': 'Enabling this allows the automation of the Shield Guardian\'s Bound feature via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preTargetDamageApplication', macros.mastersAmulet);
            } else {
                Hooks.off('midi-qol.preTargetDamageApplication', macros.mastersAmulet);
            }
        }
    });
    addMenuSetting('Shield Guardian', 'Monster Features');
    game.settings.register(moduleName, 'Warding Bond', {
        'name': 'Warding Bond Automation',
        'hint': 'Enabling this allows the automation of the Warding Bond spell via the use of hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value && game.user.isGM) {
                Hooks.on('updateToken', macros.wardingBond.moveTarget);
                Hooks.on('updateToken', macros.wardingBond.moveSource);
            } else if (game.user.isGM) {
                Hooks.off('updateToken', macros.wardingBond.moveTarget);
                Hooks.off('updateToken', macros.wardingBond.moveSource);
            }
        }
    });
    addMenuSetting('Warding Bond', 'Spells');
    game.settings.register(moduleName, 'Attack Listener', {
        'name': 'Attack Listener',
        'hint': 'This setting is required for certain macros to help with removing flanking and canceling attacks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preAttackRoll', flanking);
            } else {
                Hooks.off('midi-qol.preAttackRoll', flanking);
            }
        }
    });
    addMenuSetting('Attack Listener', 'General');
    game.settings.register(moduleName, 'Magic Missile Toggle', {
        'name': 'Magic Missile Toggle',
        'hint': 'Enabling this has the Magic Missile spell roll the dice multiple times for damage.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false
    });
    addMenuSetting('Magic Missile Toggle', 'Homebrew');
    game.settings.register(moduleName, 'Strength of the Grave', {
        'name': 'Strength of the Grave Automation',
        'hint': 'Enabling this allows the automation of the Strength of the Grave feature via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preTargetDamageApplication', macros.strengthOfTheGrave);
            } else {
                Hooks.off('midi-qol.preTargetDamageApplication', macros.strengthOfTheGrave);
            }
        }
    });
    addMenuSetting('Strength of the Grave', 'Class Features');
    game.settings.register(moduleName, 'Relentless Endurance', {
        'name': 'Relentless Endurance Automation',
        'hint': 'Enabling this allows the automation of the Relentless Endurance feature via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preTargetDamageApplication', macros.relentlessEndurance);
            } else {
                Hooks.off('midi-qol.preTargetDamageApplication', macros.relentlessEndurance);
            }
        }
    });
    addMenuSetting('Relentless Endurance', 'Race Features');
    game.settings.register(moduleName, 'Shadow of Moil', {
        'name': 'Shadow of Moil Automation',
        'hint': 'Enabling this allows the automation of the Shadow of Moil spell via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preAttackRoll', macros.shadowOfMoil.hook);
            } else {
                Hooks.off('midi-qol.preAttackRoll', macros.shadowOfMoil.hook);
            }
        }
    });
    addMenuSetting('Shadow of Moil', 'Spells');
    game.settings.register(moduleName, 'Emboldening Bond', {
        'name': 'Emboldening Bond',
        'hint': 'Enabling this allows the automation of the Emboldening Bond via the use of Foundry and Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                if (game.user.isGM) Hooks.on('updateToken', macros.emboldeningBond.move);
                Hooks.on('midi-qol.preTargetDamageApplication', macros.emboldeningBond.damage);
            } else {
                if (game.user.isGM) Hooks.off('updateToken', macros.emboldeningBond.move);
                Hooks.off('midi-qol.preTargetDamageApplication', macros.emboldeningBond.damage);
            }
        }
    });
    addMenuSetting('Emboldening Bond', 'Class Features');
    game.settings.register(moduleName, 'Manual Rolls', {
        'name': 'Manual Rolls',
        'hint': 'Enabling this will prompt the GM to input attack, save, and damage totals. This only applies to rolls that involve Midi-Qol.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preCheckHits', macros.manualRolls.attackRoll);
                Hooks.on('midi-qol.postCheckSaves', macros.manualRolls.saveRolls);
                Hooks.on('midi-qol.DamageRollComplete', macros.manualRolls.damageRoll);
            } else {
                Hooks.off('midi-qol.preCheckHits', macros.manualRolls.attackRoll);
                Hooks.off('midi-qol.postCheckSaves', macros.manualRolls.saveRolls);
                Hooks.off('midi-qol.DamageRollComplete', macros.manualRolls.damageRoll);
            }
        }
    });
    addMenuSetting('Manual Rolls', 'Manual Rolling');
    game.settings.register(moduleName, 'Ignore GM', {
        'name': 'Ignore GM Rolls',
        'hint': 'Do not prompt when there are no player owned tokens involved.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': true
    });
    addMenuSetting('Ignore GM', 'Manual Rolling');
    game.settings.register(moduleName, 'Manual Rolling Players', {
        'name': 'Player Settings',
        'hint': 'Set rolling options per-player here.',
        'scope': 'world',
        'config': false,
        'type': Object,
        'default': {}
    });
    addMenuSetting('Manual Rolling Players', 'Manual Rolling');
    game.settings.register(moduleName, 'Use Randomizer', {
        'name': 'Randomizer',
        'hint': 'Change this.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('createToken', npcRandomizer);
            } else {
                Hooks.off('createToken', npcRandomizer);
            }
        }
    });
    addMenuSetting('Use Randomizer', 'Randomizer');
    game.settings.register(moduleName, 'Humanoid Randomizer Settings', {
        'name': 'Humanoid Randomizer Settings',
        'hint': 'Change this.',
        'scope': 'world',
        'config': false,
        'type': Object,
        'default': allRaces,
        'onChange': value => {
            if (value) updateChanceTable();
        }
    });
    addMenuSetting('Humanoid Randomizer Settings', 'Randomizer');
    game.settings.register(moduleName, 'Dice So Nice', {
        'name': 'Dice So Nice Compatability',
        'hint': 'Accounts for damage roll changes for DSN rolls through use of Midi-QoL hooks',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preItemRoll', diceSoNice.early);
                Hooks.on('midi-qol.DamageRollComplete', diceSoNice.late);
            } else {
                Hooks.off('midi-qol.preItemRoll', diceSoNice.early);
                Hooks.off('midi-qol.DamageRollComplete', diceSoNice.late);
            }
        }
    });
    addMenuSetting('Dice So Nice', 'Module Integration');
    game.settings.register(moduleName, 'Arcane Ward', {
        'name': 'Arcane Ward Automation',
        'hint': 'Enabling this allows the automation of the Arcane Ward feature via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preTargetDamageApplication', macros.arcaneWard.damage);
            } else {
                Hooks.off('midi-qol.preTargetDamageApplication', macros.arcaneWard.damage);
            }
        }
    });
    addMenuSetting('Arcane Ward', 'Class Features');
    game.settings.register(moduleName, 'Righteous Heritor', {
        'name': 'Righteous Heritor Automation',
        'hint': 'Enabling this allows the automation of the Righteous Heritor feat via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preTargetDamageApplication', macros.soothePain);
            } else {
                Hooks.off('midi-qol.preTargetDamageApplication', macros.soothePain);
            } 
        }
    });
    addMenuSetting('Righteous Heritor', 'Feats');
    game.settings.register(moduleName, 'Summons Folder', {
        'name': 'Other Summons Folder',
        'hint': 'This is the name of the folder that will be used for other summon spells, including "Conjure" spells and "Find" spells',
        'scope': 'world',
        'config': false,
        'type': String,
        'default': 'Chris Premades'
    });
    addMenuSetting('Summons Folder', 'Summons');
    game.settings.register(moduleName, 'Item Features', {
        'name': 'Item Features',
        'hint': 'When enabled, certain items from this module will be able to add additional features to your character sheet when an item is equipped or attuned.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': true,
        'onChange': value => {
            if (value) {
                Hooks.on('preUpdateItem', itemFeatures);
                Hooks.on('preDeleteItem', itemFeaturesDelete);
            } else {
                Hooks.off('preUpdateItem', itemFeatures);
                Hooks.off('preDeleteItem', itemFeaturesDelete);
            }
        }
    });
    addMenuSetting('Item Features', 'General');
    game.settings.register(moduleName, 'Baldur\'s Gate 3 Weapon Actions', {
        'name': 'Baldur\'s Gate 3 Weapon Actions',
        'hint': 'When enabled Baldur\'s Gate 3 Weapon Actions will be automatically added to actor features.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('preUpdateItem', macros.bg3.addFeatures);
                Hooks.on('preDeleteItem', macros.bg3.removeFeatures);
                Hooks.on('midi-qol.preDamageRollComplete', macros.bg3.piercingStrike.damage);
                Hooks.on('dnd5e.restCompleted', macros.bg3.rest);
                Hooks.on('midi-qol.RollComplete', macros.bg3.healing);
            } else {
                Hooks.off('preUpdateItem', macros.bg3.addFeatures);
                Hooks.off('preDeleteItem', macros.bg3.removeFeatures);
                Hooks.off('midi-qol.postDamageRoll', macros.bg3.piercingStrike.damage);
                Hooks.off('dnd5e.restCompleted', macros.bg3.rest);
                Hooks.off('midi-qol.RollComplete', macros.bg3.healing);
            }
        }
    });
    addMenuSetting('Baldur\'s Gate 3 Weapon Actions', 'Homebrew');
    game.settings.register(moduleName, 'Add Generic Actions', {
        'name': 'Add Generic Actions',
        'hint': 'When enabled special actions will be added to the actor on token drop.',
        'scope': 'world',
        'config': false,
        'type': String,
        'default': 'none',
        'choices': {
            'none': 'None',
            'all': 'All Actors',
            'npc': 'All NPC Actors',
            'character': 'All Character Actors',
            'uNpc': 'Unlinked NPC Actors',
            'uCharacter': 'Unlinked Character Actors',
            'lNpc': 'Linked NPC Actors',
            'lCharacter': 'Linked Character Actors'
        }
    });
    addMenuSetting('Add Generic Actions', 'General');
    game.settings.register(moduleName, 'Cast Animations', {
        'name': ' Cast Animations',
        'hint': 'Enable to automatically play JB2A spell cast animations for all spells.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.postPreambleComplete', cast);
            } else {
                Hooks.off('midi-qol.postPreambleComplete', cast);
            }
        }
    });
    addMenuSetting('Cast Animations', 'Animations');
    game.settings.register(moduleName, 'abj_color', {
        'name': 'Abjuration Color',
        'hint': 'Color to use for abjuration spells.',
        'scope': 'client',
        'config': false,
        'type': String,
        'default': 'blue',
        'choices': {
            'blue': 'Blue',
            'green': 'Green',
            'pink': 'Pink',
            'purple': 'Purple',
            'red': 'Red',
            'yellow': 'Yellow'
        }
    });
    addMenuSetting('abj_color', 'Animations');
    game.settings.register(moduleName, 'con_color', {
        'name': 'Conjuration Color',
        'hint': 'Color to use for conjuration spells.',
        'scope': 'client',
        'config': false,
        'type': String,
        'default': 'yellow',
        'choices': {
            'blue': 'Blue',
            'green': 'Green',
            'pink': 'Pink',
            'purple': 'Purple',
            'red': 'Red',
            'yellow': 'Yellow'
        }
    });
    addMenuSetting('con_color', 'Animations');
    game.settings.register(moduleName, 'div_color', {
        'name': 'Divination Color',
        'hint': 'Color to use for divination spells.',
        'scope': 'client',
        'config': false,
        'type': String,
        'default': 'blue',
        'choices': {
            'blue': 'Blue',
            'green': 'Green',
            'pink': 'Pink',
            'purple': 'Purple',
            'red': 'Red',
            'yellow': 'Yellow'
        }
    });
    addMenuSetting('div_color', 'Animations');
    game.settings.register(moduleName, 'enc_color', {
        'name': 'Enchantment Color',
        'hint': 'Color to use for enchantment spells.',
        'scope': 'client',
        'config': false,
        'type': String,
        'default': 'pink',
        'choices': {
            'blue': 'Blue',
            'green': 'Green',
            'pink': 'Pink',
            'purple': 'Purple',
            'red': 'Red',
            'yellow': 'Yellow'
        }
    });
    addMenuSetting('enc_color', 'Animations');
    game.settings.register(moduleName, 'evo_color', {
        'name': 'Evocation Color',
        'hint': 'Color to use for evocation spells.',
        'scope': 'client',
        'config': false,
        'type': String,
        'default': 'red',
        'choices': {
            'blue': 'Blue',
            'green': 'Green',
            'pink': 'Pink',
            'purple': 'Purple',
            'red': 'Red',
            'yellow': 'Yellow'
        }
    });
    addMenuSetting('evo_color', 'Animations');
    game.settings.register(moduleName, 'ill_color', {
        'name': 'Illusion Color',
        'hint': 'Color to use for illusion spells.',
        'scope': 'client',
        'config': false,
        'type': String,
        'default': 'purple',
        'choices': {
            'blue': 'Blue',
            'green': 'Green',
            'pink': 'Pink',
            'purple': 'Purple',
            'red': 'Red',
            'yellow': 'Yellow'
        }
    });
    addMenuSetting('ill_color', 'Animations');
    game.settings.register(moduleName, 'nec_color', {
        'name': 'Necromancy Color',
        'hint': 'Color to use for necromancy spells.',
        'scope': 'client',
        'config': false,
        'type': String,
        'default': 'green',
        'choices': {
            'blue': 'Blue',
            'green': 'Green',
            'pink': 'Pink',
            'purple': 'Purple',
            'red': 'Red',
            'yellow': 'Yellow'
        }
    });
    addMenuSetting('nec_color', 'Animations');
    game.settings.register(moduleName, 'trs_color', {
        'name': 'Transmutation Color',
        'hint': 'Color to use for transmutation spells.',
        'scope': 'client',
        'config': false,
        'type': String,
        'default': 'yellow',
        'choices': {
            'blue': 'Blue',
            'green': 'Green',
            'pink': 'Pink',
            'purple': 'Purple',
            'red': 'Red',
            'yellow': 'Yellow'
        }
    });
    addMenuSetting('trs_color', 'Animations');
    game.settings.register(moduleName, 'Compelled Duel', {
        'name': 'Compelled Duel Automation',
        'hint': 'Enabling this allows the automation of the spell Compelled Duel via the use of Foundry hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                if (game.user.isGM) Hooks.on('updateToken', macros.compelledDuel.movement);
                Hooks.on('midi-qol.RollComplete', macros.compelledDuel.attacked);
            } else {
                if (game.user.isGM) Hooks.off('updateToken', macros.compelledDuel.movement);
                Hooks.off('midi-qol.RollComplete', macros.compelledDuel.attacked);
            }
        }
    });
    addMenuSetting('Compelled Duel', 'Spells');
    game.settings.register(moduleName, 'Colorize Automated Animations', {
        'name': 'Colorize Automated Animations Title Bar Button',
        'hint': 'Enabling this will make colorize the Automated Animations title bar button.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                automatedAnimations.sortAutoRec();
                Hooks.on('renderItemSheet', automatedAnimations.titleBarButton);
            } else {
                Hooks.off('renderItemSheet', automatedAnimations.titleBarButton);
            }
        }
    });
    addMenuSetting('Colorize Automated Animations', 'Module Integration');
    game.settings.register(moduleName, 'Colorize Build A Bonus', {
        'name': 'Colorize Build A Bonus Title Bar Button',
        'hint': 'Enabling this will make colorize the Build A Bonus title bar button.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('renderItemSheet', buildABonus.titleBarButton);
                Hooks.on('renderDAEActiveEffectConfig', buildABonus.daeTitleBarButton);
                Hooks.on('renderActorSheet5e', buildABonus.actorTitleBarButtons);
            } else {
                Hooks.off('renderItemSheet', buildABonus.titleBarButton);
                Hooks.off('renderDAEActiveEffectConfig', buildABonus.daeTitleBarButton);
                Hooks.off('renderActorSheet5e', buildABonus.actorTitleBarButtons);
            }
        }
    });
    addMenuSetting('Colorize Build A Bonus', 'Module Integration');
    game.settings.register(moduleName, 'Colorize Dynamic Active Effects', {
        'name': 'Colorize Dynamic Active Effects Title Bar Button',
        'hint': 'Enabling this will make colorize the Dynamic Active Effects title bar button.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('renderItemSheet', colorizeDAETitleBarButton);
            } else {
                Hooks.off('renderItemSheet', colorizeDAETitleBarButton);
            }
        }
    });
    addMenuSetting('Colorize Dynamic Active Effects', 'Module Integration');
    game.settings.register(moduleName, 'Colorize Template Macro', {
        'name': 'Colorize Template Macro Title Bar Button',
        'hint': 'Enabling this will make colorize the Template Macro title bar button.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('renderItemSheet', templateMacroTitleBarButton);
            } else {
                Hooks.off('renderItemSheet', templateMacroTitleBarButton);
            }
        }
    });
    addMenuSetting('Colorize Template Macro', 'Module Integration');
    game.settings.register(moduleName, 'D&D5E Animations Sounds', {
        'name': 'D&D5E Animations Sounds',
        'hint': 'Play sounds from the D&D5E Animations module (when available).',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                dndAnimations.sortAutoRec();
                Hooks.on('midi-qol.AttackRollComplete', dndAnimations.attackDone);
                Hooks.on('midi-qol.DamageRollComplete', dndAnimations.damageDone);
                Hooks.on('midi-qol.RollComplete', dndAnimations.rollDone);
            } else {
                Hooks.off('midi-qol.AttackRollComplete', dndAnimations.attackDone);
                Hooks.off('midi-qol.DamageRollComplete', dndAnimations.damageDone);
                Hooks.off('midi-qol.RollComplete', dndAnimations.rollDone);
            }
        }
    });
    addMenuSetting('D&D5E Animations Sounds', 'Module Integration');
    game.settings.register(moduleName, 'Build A Bonus Overlapping Effects', {
        'name': 'Build A Bonus Overlapping Effects',
        'hint': 'When enabled Build A Bonus auras will respect the overlapping spell effect and combining game effects rules.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': true,
        'onChange': value => {
            if (value) {
                Hooks.on('babonus.filterBonuses', buildABonus.overlappingEffects);
            } else {
                Hooks.off('babonus.filterBonuses', buildABonus.overlappingEffects);
            }
        }
    });
    addMenuSetting('Build A Bonus Overlapping Effects', 'Module Integration');
    game.settings.register(moduleName, 'Aura of Life', {
        'name': 'Aura of Life Spell Automation',
        'hint': 'Enabling this allows the automation of the Aura of Life spell via the use of Foundry hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('preCreateActiveEffect', macros.auraOfLife.effect);
                Hooks.on('updateActiveEffect', macros.auraOfLife.effect);
            } else {
                Hooks.off('preCreateActiveEffect', macros.auraOfLife.effect);
                Hooks.off('updateActiveEffect', macros.auraOfLife.effect);
            }
        }
    });
    addMenuSetting('Aura of Life', 'Spells');
    game.settings.register(moduleName, 'Booming Blade', {
        'name': 'Booming Blade Automation',
        'hint': 'Enabling this allows the automation of the Booming Blade spell via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('updateToken', macros.boomingBlade.moved);
            } else {
                Hooks.off('updateToken', macros.boomingBlade.moved);
            }
        }
    });
    addMenuSetting('Booming Blade', 'Spells');
    game.settings.register(moduleName, 'Manifest Echo', {
        'name': 'Manifest Echo Automation',
        'hint': 'Enabling this allows the automation of the Manifest Echo feature via the use of Foundry hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('dnd5e.rollAbilitySave', macros.manifestEcho.save);
            } else {
                Hooks.off('dnd5e.rollAbilitySave', macros.manifestEcho.save);
            }
        }
    });
    addMenuSetting('Manifest Echo', 'Class Features');
    game.settings.register(moduleName, 'Twilight Shroud', {
        'name': 'Twilight Shroud Automation',
        'hint': 'Enabling this allows the automation of the Twilight Shroud feature via the use of Midi-Qol hooks.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {
            if (value) {
                Hooks.on('midi-qol.preCheckHits', macros.twilightShroud.attack);
                Hooks.on('midi-qol.preambleComplete', macros.twilightShroud.saveEarly);
                Hooks.on('midi-qol.RollComplete', macros.twilightShroud.saveLate);
            } else {
                Hooks.off('midi-qol.preCheckHits', macros.twilightShroud.attack);
                Hooks.off('midi-qol.preambleComplete', macros.twilightShroud.saveEarly);
                Hooks.off('midi-qol.RollComplete', macros.twilightShroud.saveLate);
            }
        }
    });
    addMenuSetting('Twilight Shroud', 'Class Features');
//    game.settings.register(moduleName, 'Metric Distance', {
//        'name': 'Use Metric Distance',
//        'hint': 'When enabled macros from this module will use metric for distance calculations.',
//        'scope': 'world',
//        'config': false,
//        'type': Boolean,
//        'default': false
//    });
//    addMenuSetting('Metric Distance', 'General');
    game.settings.register(moduleName, 'Check For Updates', {
        'name': 'Check for Updates',
        'hint': 'Display a message when an update is available.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': true
    });
    addMenuSetting('Check For Updates', 'General');
    game.settings.register(moduleName, 'Critical Role Firearm Support', {
        'name': 'Critical Role Firearm Support',
        'hint': 'Add firearm support to the D&D 5E system.',
        'scope': 'world',
        'config': false,
        'type': Boolean,
        'default': false,
        'onChange': value => {firearm.setup(value)}
    });
    addMenuSetting('Critical Role Firearm Support', 'Mechanics');
    game.settings.registerMenu(moduleName, 'General', {
        'name': 'General',
        'label': 'General',
        'hint': 'General settings for most automations.',
        'icon': 'fas fa-gears',
        'type': chrisSettingsGeneral,
        'restricted': true
    });
    game.settings.registerMenu(moduleName, 'Animations', {
        'name': 'Animations',
        'label': 'Animations',
        'hint': 'Settings for animation automation.',
        'icon': 'fas fa-film',
        'type': chrisSettingsAnimations,
        'restricted': false
    });
    game.settings.registerMenu(moduleName, 'Compendiums', {
        'name': 'Compendium',
        'label': 'Compendium',
        'hint': 'Compendium settings item replacement and macros.',
        'icon': 'fas fa-atlas',
        'type': chrisSettingsCompendiums,
        'restricted': true
    });
    game.settings.registerMenu(moduleName, 'Mechanics', {
        'name': 'Mechanics',
        'label': 'Mechanics',
        'hint': 'Settings related to game mechanics.',
        'icon': 'fas fa-dice',
        'type': chrisSettingsMechanics,
        'restricted': true
    });
    game.settings.registerMenu(moduleName, 'Spells', {
        'name': 'Spells',
        'label': 'Spells',
        'hint': 'Settings for specific spell automations.',
        'icon': 'fas fa-wand-magic',
        'type': chrisSettingsSpells,
        'restricted': true
    });
    game.settings.registerMenu(moduleName, 'Feats', {
        'name': 'Feats',
        'label': 'Feats',
        'hint': 'Settings for specific feat automations.',
        'icon': 'fas fa-crystal-ball',
        'type': chrisSettingsFeats,
        'restricted': true
    });
    game.settings.registerMenu(moduleName, 'Class Features', {
        'name': 'Class Features',
        'label': 'Class Features',
        'hint': 'Settings for specific class features.',
        'icon': 'fas fa-swords',
        'type': chrisSettingsClassFeats,
        'restricted': true
    });
    game.settings.registerMenu(moduleName, 'Race Features', {
        'name': 'Race Features',
        'label': 'Race Features',
        'hint': 'Settings for specific race features.',
        'icon': 'fas fa-solid fa-nesting-dolls',
        'type': chrisSettingsRaceFeats,
        'restricted': true
    });
    game.settings.registerMenu(moduleName, 'Monster Features', {
        'name': 'Monster Features',
        'label': 'Monster Features',
        'hint': 'Settings for specific monster features.',
        'icon': 'fas fa-dragon',
        'type': chrisSettingsMonsterFeats,
        'restricted': true
    });
    game.settings.registerMenu(moduleName, 'Summons', {
        'name': 'Summons',
        'label': 'Summons',
        'hint': 'Settings related to summons.',
        'icon': 'fas fa-hand-holding-magic',
        'type': chrisSettingsSummons,
        'restricted': true
    });
    game.settings.registerMenu(moduleName, 'Homebrew', {
        'name': 'Homebrew',
        'label': 'Homebrew',
        'hint': 'Optional settings for homebrew features.',
        'icon': 'fas fa-cauldron',
        'type': chrisSettingsHomewbrew,
        'restricted': true
    });
    game.settings.registerMenu(moduleName, 'Module Integration', {
        'name': 'Module Integration',
        'label': 'Module Integration',
        'hint': 'Settings for integrations with other modules.',
        'icon': 'fas fa-puzzle-piece',
        'type': chrisSettingsModule,
        'restricted': true
    });
    game.settings.registerMenu(moduleName, 'Manual Rolling', {
        'name': 'Manual Rolling',
        'label': 'Manual Rolling',
        'hint': 'Settings for manual rolling.',
        'icon': 'fas fa-calculator',
        'type': chrisSettingsManualRolling,
        'restricted': true
    });
/*    game.settings.registerMenu(moduleName, 'Randomizer', {
        'name': 'Randomizer',
        'label': 'Randomizer',
        'hint': 'Optional settings for randomizer features.',
        'icon': 'fas fa-dice',
        'type': chrisSettingsRandomizer,
        'restricted': true
    }); */
    game.settings.registerMenu(moduleName, 'NPC Updater', {
        'name': 'NPC Updater',
        'label': 'NPC Updater',
        'hint': 'Used to bulk update NPCs in your world.',
        'icon': 'fas fa-folder-open',
        'type': chrisSettingsNPCUpdate,
        'restricted': true
    });
    game.settings.registerMenu(moduleName, 'Troubleshooter', {
        'name': 'Help',
        'label': 'Help',
        'hint': 'Used to troubleshoot issues with this module.',
        'icon': 'fas fa-screwdriver-wrench',
        'type': chrisSettingsTroubleshoot,
        'restricted': true
    });
}
;// CONCATENATED MODULE: ./scripts/utility/remoteDialog.js

async function remoteDialog(title, options, content) {
    return await chris.dialog(title, options, content);
}
async function remoteDocumentDialog(title, uuids) {
    let documents = [];
    for (let i of uuids) {
        documents.push(await fromUuid(i));
    }
    return await chris.selectDocument(title, documents, true);
}
async function remoteDocumentsDialog(title, uuids) {
    let documents = [];
    for (let i of uuids) {
        documents.push(await fromUuid(i));
    }
    return await chris.selectDocuments(title, documents, true);
}
async function remoteAimCrosshair(tokenUuid, maxRange, icon, interval, size) {
    let token = await fromUuid(tokenUuid);
    return await chris.aimCrosshair(token, maxRange, icon, interval, size);
}
async function remoteMenu(title, buttons, inputs, useSpecialRender, info, header, extraOptions) {
    return await chris.menu(title, buttons, inputs, useSpecialRender, info, header, extraOptions);
}
;// CONCATENATED MODULE: ./scripts/runAsGM.js

async function updateCombatant(tokenId, updates) {
    let combatant = game.combat?.combatants?.get(tokenId);
    if (!combatant) return;
    await combatant.update(updates);
}
async function createEffect(actorUuid, effectData) {
    let actor = await fromUuid(actorUuid);
    if (!actor) return;
    if (actor instanceof TokenDocument) actor = actor.actor;
    if (!actor) return;
    let effects = await actor.createEmbeddedDocuments('ActiveEffect', [effectData]);
    return effects[0].uuid;
}
async function removeEffect(effectUuid) {
    let effect = await fromUuid(effectUuid);
    if (!effect) return;
    await effect.delete();
}
async function updateEffect(effectUuid, updates) {
    let effect = await fromUuid(effectUuid);
    if (!effect) return;
    await effect.update(updates);
}
let runAsGM = {
    'updateCombatant': updateCombatant,
    'updateEffect': updateEffect,
    'createEffect': createEffect,
    'removeEffect': removeEffect
}
async function rollItem(itemUuid, config, options) {
    let item = await fromUuid(itemUuid);
    if (!item) return;
    return await chris.rollItem(item, config, options);
}
let runAsUser = {
    'rollItem': rollItem
}
;// CONCATENATED MODULE: ./scripts/config.js
function setConfig() {
    let summonEffectOptions = [
        {'value': 'none', 'html': 'None'},
        {'value': 'default', 'html': 'Default'},
        {'value': 'celestial', 'html': 'Celestial'},
        {'value': 'fiend', 'html': 'Fiend'},
        {'value': 'fire', 'html': 'Fire'},
        {'value': 'water', 'html': 'Water'},
        {'value': 'air', 'html': 'Air'},
        {'value': 'earth', 'html': 'Earth'},
        {'value': 'nature', 'html': 'Nature'},
        {'value': 'shadow', 'html': 'Shadow'},
        {'value': 'future', 'html': 'Future'}
    ];
    setProperty(CONFIG, 'chrisPremades', {
        'module': 'chris-premades',
        'renamedItems': {
            'Form of Dread: Transform': 'Form of Dread',
            'Form of Dread': 'Form of Dread: Fear',
            'Ring of Spell Storing': 'Ring of Spell Storing (0/5)',
            'Mutagencraft - Consume Mutagen': 'Mutagencraft - Create Mutagen',
            'Reaper: Chill Touch': 'Reaper',
            'Reaper: Sapping Sting': 'Reaper',
            'Reaper: Spare the Dying': 'Reaper',
            'Reaper: Toll the Dead': 'Reaper'
        },
        'additionalItems': {
            'Blade Flourish': [
                'Blade Flourish Movement'
            ],
            'Arcane Armor': [
                'Arcane Armor: Guardian Model',
                'Arcane Armor: Infiltrator Model'
            ],
            'Eladrin Season: Autumn': [
                'Change Season'
            ],
            'Eladrin Season: Winter': [
                'Change Season'
            ],
            'Eladrin Season: Spring': [
                'Change Season'
            ],
            'Eladrin Season: Summer': [
                'Change Season'
            ],
            'Planar Wanderer': [
                'Planar Wanderer: Planar Adaptation'
            ],
            'Gunslinger': [
                'Reload Firearm',
                'Repair Firearm'
            ]
        },
        'removedItems': {
            'Animating Performance': [
                'Animating Performance: Animate',
                'Animating Performance: Dancing Item'
            ],
            'Arcane Armor': [
                'Guardian Armor: Thunder Gauntlets',
                'Guardian Armor: Thunder Gauntlets (STR)',
                'Guardian Armor: Defensive Field',
                'Infiltrator Armor: Lightning Launcher',
                'Infiltrator Armor: Lightning Launcher (DEX)'
            ],
            'Arcane Ward': [
                'Arcane Ward - Hit Points'
            ],
            'Blessing of the Raven Queen': [
                'Blessing of the Raven Queen (Resistance)'
            ],
            'Drake Companion: Summon': [
                'Bond of Fang and Scale: Acid Resistance',
                'Bond of Fang and Scale: Cold Resistance',
                'Bond of Fang and Scale: Fire Resistance',
                'Bond of Fang and Scale: Lightning Resistance',
                'Bond of Fang and Scale: Poison Resistance',
                'Drake Companion',
                'Drake Companion: Command',
                'Drake Companion: Drake Companion (Acid)',
                'Drake Companion: Drake Companion (Cold)',
                'Drake Companion: Drake Companion (Fire)',
                'Drake Companion: Drake Companion (Lightning)',
                'Drake Companion: Drake Companion (Poison)',
                'Reflexive Resistance',
            ],
            'Eladrin Season: Autumn': [
                'Fey Step (Autumn)'
            ],
            'Eladrin Season: Winter': [
                'Fey Step (Winter)'
            ],
            'Eladrin Season: Spring': [
                'Fey Step (Spring)'
            ],
            'Eladrin Season: Summer': [
                'Fey Step (Summer)'
            ],
            'Manifest Mind: Summon': [
                'Manifest Mind: Cast Spell',
                'Manifest Mind: Move'
            ],
            'Metamagic - Careful Spell': [
                'Metamagic: Careful Spell'
            ],
            'Metamagic - Distant Spell': [
                'Metamagic: Distant Spell'
            ],
            'Metamagic - Empowered Spell': [
                'Metamagic: Empowered Spell'
            ],
            'Metamagic - Extended Spell': [
                'Metamagic: Extended Spell'
            ],
            'Metamagic - Heightened Spell': [
                'Metamagic: Heightened Spell'
            ],
            'Metamagic - Quickened Spell': [
                'Metamagic: Quickened Spell'
            ],
            'Metamagic - Subtle Spell': [
                'Metamagic: Subtle Spell'
            ],
            'Metamagic - Transmuted Spell': [
                'Metamagic: Transmuted Spell'
            ],
            'Metamagic - Twinned Spell': [
                'Metamagic: Twinned Spell'
            ],
            'Starry Form': [
                'Starry Form: Archer',
                'Starry Form: Chalice',
                'Starry Form: Dragon'
            ],
            'Summon Wildfire Spirit': [
                'Summon Wildfire Spirit: Command'
            ],
            'Tentacle of the Deeps: Summon': [
                'Tentacle of the Deeps: Move',
                'Tentacle of the Deeps: Attack'
            ],
            'Bestial Soul': [
                'Form of the Beast: Bite',
                'Form of the Beast: Claws',
                'Form of the Beast: Tail',
                'Form of the Beast: Tail (reaction)'
            ],
            'Cartomancer: Hidden Ace - Imbue Card': [
                'Cartomancer: Hidden Ace - Flourish Imbued Card'
            ],
            'Elemental Cleaver': [
                'Elemental Cleaver: Change Damage Type'
            ],
            'Manifest Echo': [
                'Manifest Echo - Attack',
                'Manifest Echo - Teleport',
                'Manifest Echo - Opportunity Attack'
            ],
            'Dread Lord': [
                'Dread Lord Shadow Attack'
            ]
        },
        'restrictedItems': {
            'Radiant Soul': {
                'originalName': 'Radiant Soul',
                'requiredClass': 'Warlock',
                'requiredSubclass': 'The Celestial',
                'requiredRace': null,
                'requiredEquipment': [],
                'requiredFeatures': [],
                'replacedItemName': 'Radiant Soul',
                'removedItems': [],
                'additionalItems': [],
                'priority': 0
            },
            'Unarmored Defense 1': {
                'originalName': 'Unarmored Defense',
                'requiredClass': 'Barbarian',
                'requiredSubclass': null,
                'requiredRace': null,
                'requiredEquipment': [],
                'requiredFeatures': [],
                'replacedItemName': 'Unarmored Defense (Barbarian)',
                'removedItems': [],
                'additionalItems': [],
                'priority': 0
            },
            'Unarmored Defense 2': {
                'originalName': 'Unarmored Defense',
                'requiredClass': 'Monk',
                'requiredSubclass': null,
                'requiredRace': null,
                'requiredEquipment': [],
                'requiredFeatures': [],
                'replacedItemName': 'Unarmored Defense (Monk)',
                'removedItems': [],
                'additionalItems': [],
                'priority': 0
            },
            'Unarmed Strike': {
                'originalName': 'Unarmed Strike',
                'requiredClass': 'Monk',
                'requiredSubclass': null,
                'requiredRace': null,
                'requiredEquipment': [],
                'requiredFeatures': [],
                'replacedItemName': 'Unarmed Strike (Monk)',
                'removedItems': [],
                'additionalItems': [],
                'priority': 0
            },
            'Mental Discipline 1': {
                'originalName': 'Mental Discipline',
                'requiredClass': null,
                'requiredSubclass': null,
                'requiredRace': 'Kalashtar',
                'requiredEquipment': [],
                'requiredFeatures': [],
                'replacedItemName': 'Mental Discipline (Kalashtar)',
                'removedItems': [],
                'additionalItems': [],
                'priority': 0
            },
            'Mental Discipline 2': {
                'originalName': 'Mental Discipline',
                'requiredClass': null,
                'requiredSubclass': null,
                'requiredRace': 'Githzerai',
                'requiredEquipment': [],
                'requiredFeatures': [],
                'replacedItemName': 'Mental Discipline (Githzerai)',
                'removedItems': [],
                'additionalItems': [],
                'priority': 0
            }
        },
        'correctedItems': {
            'Metamagic - Careful Spell': {
                'system': {
                    'consume': {
                        'amount': null,
                        'target': '',
                        'type': '',
                    }
                }
            },
            'Metamagic - Empowered Spell': {
                'system': {
                    'consume': {
                        'amount': null,
                        'target': '',
                        'type': '',
                    }
                }
            },
            'Metamagic - Heightened Spell': {
                'system': {
                    'consume': {
                        'amount': null,
                        'target': '',
                        'type': '',
                    }
                }
            },
            'Metamagic - Seeking Spell': {
                'system': {
                    'consume': {
                        'amount': null,
                        'target': '',
                        'type': '',
                    }
                }
            },
            'Metamagic - Transmuted Spell': {
                'system': {
                    'consume': {
                        'amount': null,
                        'target': '',
                        'type': '',
                    }
                }
            },
            'Metamagic - Twinned Spell': {
                'system': {
                    'consume': {
                        'amount': null,
                        'target': '',
                        'type': '',
                    }
                }
            },
            'Steel Defender': {
                'system': {
                    'uses': {
                        'max': 1,
                        'per': 'lr',
                        'recovery': '',
                        'value': 1
                    }
                }
            },
            'Summon Wildfire Spirit': {
                'system': {
                    'consume': {
                        'amount': null,
                        'target': '',
                        'type': '',
                    }
                }
            },
            'Overchannel': {
                'system': {
                    'uses': {
                        'per': null,
                        'recovery': '',
                        'value': null
                    },
                    'consume': {
                        'amount': null,
                        'target': '',
                        'type': ''
                    }
                }
            },
            'Arcane Ward': {
                'system': {
                    'uses': {
                        'max': 1,
                        'per': 'charges',
                        'recovery': '',
                        'value': 0
                    }
                }
            }
        },
        'itemConfiguration': {
            'Magic Missile': {
                'checkbox': {
                    'homebrew': {
                        'label': 'Roll multiple dice?',
                        'default': false
                    }
                },
                'select': {
                    'color': {
                        'label': 'What color?',
                        'default': 'purple',
                        'values': [
                            {'value': 'white', 'html': 'White'},
                            {'value': 'dark_red', 'html': 'Red'},
                            {'value': 'orange', 'html': 'Orange'},
                            {'value': 'yellow', 'html': 'Yellow'},
                            {'value': 'green', 'html': 'Green'},
                            {'value': 'blue', 'html': 'Blue'},
                            {'value': 'purple', 'html': 'Purple'},
                            {'value': 'cycle', 'html': 'Cycle'},
                            {'value': 'random', 'html': 'Random'}
                        ]
                    }
                }
            },
            'Healing Spirit': {
                'text': {
                    'name': {
                        'label': 'Custom Name:',
                        'default': ''
                    },
                    'avatar': {
                        'label': 'Custom Avatar:',
                        'default': ''
                    },
                    'token': {
                        'label': 'Custom Token:',
                        'default': ''
                    }
                }
            },
            'Summon Aberration': {
                'text': {
                    'name-beholderkin': {
                        'label': 'Beholderkin Custom Name:',
                        'default': ''
                    },
                    'token-beholderkin': {
                        'label': 'Beholderkin Token:',
                        'default': ''
                    },
                    'avatar-beholderkin': {
                        'label': 'Beholderkin Avatar:',
                        'default': ''
                    },
                    'name-slaad': {
                        'label': 'Slaad Custom Name:',
                        'default': ''
                    },
                    'token-slaad': {
                        'label': 'Slaad Token:',
                        'default': ''
                    },
                    'avatar-slaad': {
                        'label': 'Slaad Avatar:',
                        'default': ''
                    },
                    'name-star-spawn': {
                        'label': 'Star Spawn Custom Name:',
                        'default': ''
                    },
                    'token-star-spawn': {
                        'label': 'Star Spawn Token:',
                        'default': ''
                    },
                    'avatar-star-spawn': {
                        'label': 'Star Spawn Avatar:',
                        'default': ''
                    }
                },
                'select': {
                    'animation-beholderkin': {
                        'label': 'Beholderkin Animation:',
                        'default': 'shadow',
                        'values': summonEffectOptions
                    },
                    'animation-slaad': {
                        'label': 'Slaad Animation:',
                        'default': 'shadow',
                        'values': summonEffectOptions
                    },
                    'animation-star-spawn': {
                        'label': 'Star Spawn Animation:',
                        'default': 'shadow',
                        'values': summonEffectOptions
                    }
                }
            },
            'Summon Beast': {
                'text': {
                    'name-air': {
                        'label': 'Air Custom Name:',
                        'default': ''
                    },
                    'token-air': {
                        'label': 'Air Token:',
                        'default': ''
                    },
                    'avatar-air': {
                        'label': 'Air Avatar:',
                        'default': ''
                    },
                    'name-land': {
                        'label': 'Land Custom Name:',
                        'default': ''
                    },
                    'token-land': {
                        'label': 'Land Token:',
                        'default': ''
                    },
                    'avatar-land': {
                        'label': 'Land Avatar:',
                        'default': ''
                    },
                    'name-water': {
                        'label': 'Water Custom Name:',
                        'default': ''
                    },
                    'token-water': {
                        'label': 'Water Token:',
                        'default': ''
                    },
                    'avatar-water': {
                        'label': 'Water Avatar:',
                        'default': ''
                    }
                },
                'select': {
                    'animation-air': {
                        'label': 'Air Animation:',
                        'default': 'air',
                        'values': summonEffectOptions
                    },
                    'animation-land': {
                        'label': 'Land Animation:',
                        'default': 'earth',
                        'values': summonEffectOptions
                    },
                    'animation-water': {
                        'label': 'Water Animation:',
                        'default': 'water',
                        'values': summonEffectOptions
                    }
                }
            },
            'Summon Celestial': {
                'text': {
                    'name-avenger': {
                        'label': 'Avenger Custom Name:',
                        'default': ''
                    },
                    'token-avenger': {
                        'label': 'Avenger Token:',
                        'default': ''
                    },
                    'avatar-avenger': {
                        'label': 'Avenger Avatar:',
                        'default': ''
                    },
                    'name-defender': {
                        'label': 'Defender Custom Name:',
                        'default': ''
                    },
                    'token-defender': {
                        'label': 'Defender Token:',
                        'default': ''
                    },
                    'avatar-defender': {
                        'label': 'Defender Avatar:',
                        'default': ''
                    }
                },
                'select': {
                    'animation-avenger': {
                        'label': 'Avenger Animation:',
                        'default': 'celestial',
                        'values': summonEffectOptions
                    },
                    'animation-defender': {
                        'label': 'Defender Animation:',
                        'default': 'celestial',
                        'values': summonEffectOptions
                    }
                }
            },
            'Summon Construct': {
                'text': {
                    'name-clay': {
                        'label': 'Clay Custom Name:',
                        'default': ''
                    },
                    'token-clay': {
                        'label': 'Clay Token:',
                        'default': ''
                    },
                    'avatar-clay': {
                        'label': 'Clay Avatar:',
                        'default': ''
                    },
                    'name-metal': {
                        'label': 'Metal Custom Name:',
                        'default': ''
                    },
                    'token-metal': {
                        'label': 'Metal Token:',
                        'default': ''
                    },
                    'avatar-metal': {
                        'label': 'Metal Avatar:',
                        'default': ''
                    },
                    'name-stone': {
                        'label': 'Stone Custom Name:',
                        'default': ''
                    },
                    'token-stone': {
                        'label': 'Stone Token:',
                        'default': ''
                    },
                    'avatar-stone': {
                        'label': 'Stone Avatar:',
                        'default': ''
                    }
                },
                'select': {
                    'animation-clay': {
                        'label': 'Clay Animation:',
                        'default': 'earth',
                        'values': summonEffectOptions
                    },
                    'animation-metal': {
                        'label': 'Metal Animation:',
                        'default': 'earth',
                        'values': summonEffectOptions
                    },
                    'animation-stone': {
                        'label': 'Stone Animation:',
                        'default': 'earth',
                        'values': summonEffectOptions
                    }
                }
            },
            'Summon Draconic Spirit': {
                'text': {
                    'name-chromatic': {
                        'label': 'Chromatic Custom Name:',
                        'default': ''
                    },
                    'token-chromatic': {
                        'label': 'Chromatic Token:',
                        'default': ''
                    },
                    'avatar-chromatic': {
                        'label': 'Chromatic Avatar:',
                        'default': ''
                    },
                    'name-metallic': {
                        'label': 'Metallic Custom Name:',
                        'default': ''
                    },
                    'token-metallic': {
                        'label': 'Metallic Token:',
                        'default': ''
                    },
                    'avatar-metallic': {
                        'label': 'Metallic Avatar:',
                        'default': ''
                    },
                    'name-gem': {
                        'label': 'Gem Custom Name:',
                        'default': ''
                    },
                    'token-gem': {
                        'label': 'Gem Token:',
                        'default': ''
                    },
                    'avatar-gem': {
                        'label': 'Gem Avatar:',
                        'default': ''
                    }
                },
                'select': {
                    'animation-chromatic': {
                        'label': 'Chromatic Animation:',
                        'default': 'fire',
                        'values': summonEffectOptions
                    },
                    'animation-metallic': {
                        'label': 'Metallic Animation:',
                        'default': 'fire',
                        'values': summonEffectOptions
                    },
                    'animation-gem': {
                        'label': 'Gem Animation:',
                        'default': 'fire',
                        'values': summonEffectOptions
                    }
                }
            },
            'Summon Elemental': {
                'text': {
                    'name-air': {
                        'label': 'Air Custom Name:',
                        'default': ''
                    },
                    'token-air': {
                        'label': 'Air Token:',
                        'default': ''
                    },
                    'avatar-air': {
                        'label': 'Air Avatar:',
                        'default': ''
                    },
                    'name-earth': {
                        'label': 'Earth Custom Name:',
                        'default': ''
                    },
                    'token-earth': {
                        'label': 'Earth Token:',
                        'default': ''
                    },
                    'avatar-earth': {
                        'label': 'Earth Avatar:',
                        'default': ''
                    },
                    'name-fire': {
                        'label': 'Fire Custom Name:',
                        'default': ''
                    },
                    'token-fire': {
                        'label': 'Fire Token:',
                        'default': ''
                    },
                    'avatar-fire': {
                        'label': 'Fire Avatar:',
                        'default': ''
                    },
                    'name-water': {
                        'label': 'Water Custom Name:',
                        'default': ''
                    },
                    'token-water': {
                        'label': 'Water Token:',
                        'default': ''
                    },
                    'avatar-water': {
                        'label': 'Water Avatar:',
                        'default': ''
                    }
                },
                'select': {
                    'animation-air': {
                        'label': 'Air Animation:',
                        'default': 'air',
                        'values': summonEffectOptions
                    },
                    'animation-earth': {
                        'label': 'Earth Animation:',
                        'default': 'earth',
                        'values': summonEffectOptions
                    },
                    'animation-fire': {
                        'label': 'Fire Animation:',
                        'default': 'fire',
                        'values': summonEffectOptions
                    },
                    'animation-water': {
                        'label': 'Water Animation:',
                        'default': 'water',
                        'values': summonEffectOptions
                    }
                }
            },
            'Summon Fey': {
                'text': {
                    'name-fuming': {
                        'label': 'Fuming Custom Name:',
                        'default': ''
                    },
                    'token-fuming': {
                        'label': 'Fuming Token:',
                        'default': ''
                    },
                    'avatar-fuming': {
                        'label': 'Fuming Avatar:',
                        'default': ''
                    },
                    'name-mirthful': {
                        'label': 'Mirthful Custom Name:',
                        'default': ''
                    },
                    'token-mirthful': {
                        'label': 'Mirthful Token:',
                        'default': ''
                    },
                    'avatar-mirthful': {
                        'label': 'Mirthful Avatar:',
                        'default': ''
                    },
                    'name-tricksy': {
                        'label': 'Tricksy Custom Name:',
                        'default': ''
                    },
                    'token-tricksy': {
                        'label': 'Tricksy Token:',
                        'default': ''
                    },
                    'avatar-tricksy': {
                        'label': 'Tricksy Avatar:',
                        'default': ''
                    }
                },
                'select': {
                    'animation-fuming': {
                        'label': 'Fuming Animation:',
                        'default': 'nature',
                        'values': summonEffectOptions
                    },
                    'animation-mirthful': {
                        'label': 'Mirthful Animation:',
                        'default': 'nature',
                        'values': summonEffectOptions
                    },
                    'animation-tricksy': {
                        'label': 'Tricksy Animation:',
                        'default': 'nature',
                        'values': summonEffectOptions
                    }
                }
            },
            'Summon Fiend': {
                'text': {
                    'name-demon': {
                        'label': 'Demon Custom Name:',
                        'default': ''
                    },
                    'token-demon': {
                        'label': 'Demon Token:',
                        'default': ''
                    },
                    'avatar-demon': {
                        'label': 'Demon Avatar:',
                        'default': ''
                    },
                    'name-devil': {
                        'label': 'Devil Custom Name:',
                        'default': ''
                    },
                    'token-devil': {
                        'label': 'Devil Token:',
                        'default': ''
                    },
                    'avatar-devil': {
                        'label': 'Devil Avatar:',
                        'default': ''
                    },
                    'name-yugoloth': {
                        'label': 'Yugoloth Custom Name:',
                        'default': ''
                    },
                    'token-yugoloth': {
                        'label': 'Yugoloth Token:',
                        'default': ''
                    },
                    'avatar-yugoloth': {
                        'label': 'Yugoloth Avatar:',
                        'default': ''
                    }
                },
                'select': {
                    'animation-demon': {
                        'label': 'Demon Animation:',
                        'default': 'fire',
                        'values': summonEffectOptions
                    },
                    'animation-devil': {
                        'label': 'Devil Animation:',
                        'default': 'fire',
                        'values': summonEffectOptions
                    },
                    'animation-yugoloth': {
                        'label': 'Yugoloth Animation:',
                        'default': 'fire',
                        'values': summonEffectOptions
                    }
                }
            },
            'Summon Shadowspawn': {
                'text': {
                    'name-fury': {
                        'label': 'Fury Custom Name:',
                        'default': ''
                    },
                    'token-fury': {
                        'label': 'Fury Token:',
                        'default': ''
                    },
                    'avatar-fury': {
                        'label': 'Fury Avatar:',
                        'default': ''
                    },
                    'name-despair': {
                        'label': 'Despair Custom Name:',
                        'default': ''
                    },
                    'token-despair': {
                        'label': 'Despair Token:',
                        'default': ''
                    },
                    'avatar-despair': {
                        'label': 'Despair Avatar:',
                        'default': ''
                    },
                    'name-fear': {
                        'label': 'Fear Custom Name:',
                        'default': ''
                    },
                    'token-fear': {
                        'label': 'Fear Token:',
                        'default': ''
                    },
                    'avatar-fear': {
                        'label': 'Fear Avatar:',
                        'default': ''
                    }
                },
                'select': {
                    'animation-fury': {
                        'label': 'Fury Animation:',
                        'default': 'shadow',
                        'values': summonEffectOptions
                    },
                    'animation-despair': {
                        'label': 'Despair Animation:',
                        'default': 'shadow',
                        'values': summonEffectOptions
                    },
                    'animation-fear': {
                        'label': 'Fear Animation:',
                        'default': 'shadow',
                        'values': summonEffectOptions
                    }
                }
            },
            'Summon Undead': {
                'text': {
                    'name-ghostly': {
                        'label': 'Ghostly Custom Name:',
                        'default': ''
                    },
                    'token-ghostly': {
                        'label': 'Ghostly Token:',
                        'default': ''
                    },
                    'avatar-ghostly': {
                        'label': 'Ghostly Avatar:',
                        'default': ''
                    },
                    'name-putrid': {
                        'label': 'Putrid Custom Name:',
                        'default': ''
                    },
                    'token-putrid': {
                        'label': 'Putrid Token:',
                        'default': ''
                    },
                    'avatar-putrid': {
                        'label': 'Putrid Avatar:',
                        'default': ''
                    },
                    'name-skeletal': {
                        'label': 'Skeletal Custom Name:',
                        'default': ''
                    },
                    'token-skeletal': {
                        'label': 'Skeletal Token:',
                        'default': ''
                    },
                    'avatar-skeletal': {
                        'label': 'Skeletal Avatar:',
                        'default': ''
                    }
                },
                'select': {
                    'animation-ghostly': {
                        'label': 'Ghostly Animation:',
                        'default': 'shadow',
                        'values': summonEffectOptions
                    },
                    'animation-putrid': {
                        'label': 'Putrid Animation:',
                        'default': 'shadow',
                        'values': summonEffectOptions
                    },
                    'animation-skeletal': {
                        'label': 'Skeletal Animation:',
                        'default': 'shadow',
                        'values': summonEffectOptions
                    }
                }
            },
            'Summon Wildfire Spirit': {
                'text': {
                    'name': {
                        'label': 'Custom Name:',
                        'default': ''
                    },
                    'avatar': {
                        'label': 'Custom Avatar:',
                        'default': ''
                    },
                    'token': {
                        'label': 'Custom Token:',
                        'default': ''
                    }
                },
                'select': {
                    'animation': {
                        'label': 'Animation:',
                        'default': 'fire',
                        'values': summonEffectOptions
                    }
                }
            },
            'Bigby\'s Hand': {
                'text': {
                    'name': {
                        'label': 'Custom Name:',
                        'default': ''
                    },
                    'avatar': {
                        'label': 'Custom Avatar:',
                        'default': ''
                    },
                    'token': {
                        'label': 'Custom Token:',
                        'default': ''
                    }
                },
                'select': {
                    'animation': {
                        'label': 'Animation:',
                        'default': 'earth',
                        'values': summonEffectOptions
                    }
                }
            },
            'Animating Performance': {
                'text': {
                    'name': {
                        'label': 'Custom Name:',
                        'default': ''
                    },
                    'avatar': {
                        'label': 'Custom Avatar:',
                        'default': ''
                    },
                    'token': {
                        'label': 'Custom Token:',
                        'default': ''
                    }
                },
                'select': {
                    'animation': {
                        'label': 'Animation:',
                        'default': 'default',
                        'values': summonEffectOptions
                    }
                }
            },
            'Drake Companion: Summon': {
                'text': {
                    'name-acid': {
                        'label': 'Acid Custom Name:',
                        'default': ''
                    },
                    'token-acid': {
                        'label': 'Acid Token:',
                        'default': ''
                    },
                    'avatar-acid': {
                        'label': 'Acid Avatar:',
                        'default': ''
                    },
                    'name-cold': {
                        'label': 'Cold Custom Name:',
                        'default': ''
                    },
                    'token-cold': {
                        'label': 'Cold Token:',
                        'default': ''
                    },
                    'avatar-cold': {
                        'label': 'Cold Avatar:',
                        'default': ''
                    },
                    'name-fire': {
                        'label': 'Fire Custom Name:',
                        'default': ''
                    },
                    'token-fire': {
                        'label': 'Fire Token:',
                        'default': ''
                    },
                    'avatar-fire': {
                        'label': 'Fire Avatar:',
                        'default': ''
                    },
                    'name-lightning': {
                        'label': 'Lightning Custom Name:',
                        'default': ''
                    },
                    'token-lightning': {
                        'label': 'Lightning Token:',
                        'default': ''
                    },
                    'avatar-lightning': {
                        'label': 'Lightning Avatar:',
                        'default': ''
                    },
                    'name-poison': {
                        'label': 'Poison Custom Name:',
                        'default': ''
                    },
                    'token-poison': {
                        'label': 'Poison Token:',
                        'default': ''
                    },
                    'avatar-poison': {
                        'label': 'Poison Avatar:',
                        'default': ''
                    }
                },
                'select': {
                    'animation-acid': {
                        'label': 'Acid Animation:',
                        'default': 'default',
                        'values': summonEffectOptions
                    },
                    'animation-cold': {
                        'label': 'Cold Animation:',
                        'default': 'default',
                        'values': summonEffectOptions
                    },
                    'animation-fire': {
                        'label': 'Fire Animation:',
                        'default': 'default',
                        'values': summonEffectOptions
                    },
                    'animation-lightning': {
                        'label': 'Lightning Animation:',
                        'default': 'default',
                        'values': summonEffectOptions
                    },
                    'animation-poision': {
                        'label': 'Poision Animation:',
                        'default': 'default',
                        'values': summonEffectOptions
                    }
                }
            },
            'Homunculus Servant': {
                'text': {
                    'name': {
                        'label': 'Custom Name:',
                        'default': ''
                    },
                    'avatar': {
                        'label': 'Custom Avatar:',
                        'default': ''
                    },
                    'token': {
                        'label': 'Custom Token:',
                        'default': ''
                    }
                },
                'select': {
                    'animation': {
                        'label': 'Animation:',
                        'default': 'earth',
                        'values': summonEffectOptions
                    }
                }
            },
            'Primal Companion': {
                'text': {
                    'name-land': {
                        'label': 'Land Custom Name:',
                        'default': ''
                    },
                    'token-land': {
                        'label': 'Land Token:',
                        'default': ''
                    },
                    'avatar-land': {
                        'label': 'Land Avatar:',
                        'default': ''
                    },
                    'name-sea': {
                        'label': 'Sea Custom Name:',
                        'default': ''
                    },
                    'token-sea': {
                        'label': 'Sea Token:',
                        'default': ''
                    },
                    'avatar-sea': {
                        'label': 'Sea Avatar:',
                        'default': ''
                    },
                    'name-sky': {
                        'label': 'Sky Custom Name:',
                        'default': ''
                    },
                    'token-sky': {
                        'label': 'Sky Token:',
                        'default': ''
                    },
                    'avatar-sky': {
                        'label': 'Sky Avatar:',
                        'default': ''
                    }
                },
                'select': {
                    'animation-land': {
                        'label': 'Land Animation:',
                        'default': 'earth',
                        'values': summonEffectOptions
                    },
                    'animation-sea': {
                        'label': 'Sea Animation:',
                        'default': 'water',
                        'values': summonEffectOptions
                    },
                    'animation-sky': {
                        'label': 'Sky Animation:',
                        'default': 'air',
                        'values': summonEffectOptions
                    }
                }
            },
            'Tentacle of the Deeps: Summon': {
                'text': {
                    'name': {
                        'label': 'Custom Name:',
                        'default': ''
                    },
                    'avatar': {
                        'label': 'Custom Avatar:',
                        'default': ''
                    },
                    'token': {
                        'label': 'Custom Token:',
                        'default': ''
                    }
                }
            },
            'Steel Defender': {
                'text': {
                    'name': {
                        'label': 'Custom Name:',
                        'default': ''
                    },
                    'avatar': {
                        'label': 'Custom Avatar:',
                        'default': ''
                    },
                    'token': {
                        'label': 'Custom Token:',
                        'default': ''
                    }
                },
                'select': {
                    'animation': {
                        'label': 'Animation:',
                        'default': 'default',
                        'values': summonEffectOptions
                    }
                }
            },
            'Piercer: Reroll Damage': {
                'checkbox': {
                    'auto': {
                        'label': 'Auto Reroll?',
                        'default': false
                    }
                },
                'number': {
                    'reroll': {
                        'label': 'Auto reroll at:',
                        'default': 1
                    }
                }
            },
            'Hybrid Transformation': {
                'text': {
                    'avatar': {
                        'label': 'Custom Avatar:',
                        'default': ''
                    },
                    'token': {
                        'label': 'Custom Token:',
                        'default': ''
                    }
                }
            },
            'Sneak Attack': {
                'checkbox': {
                    'auto': {
                        'label': 'Auto Sneak Attack?',
                        'default': false
                    },
                    'animation': {
                        'label': 'Play Animation?',
                        'default': true
                    }
                }
            },
            'Change Season': {
                'checkbox': {
                    'showicon': {
                        'label': 'Hide effect icon?',
                        'default': false
                    }
                },
                'text': {
                    'token-spring': {
                        'label': 'Spring Token:',
                        'default': ''
                    },
                    'avatar-spring': {
                        'label': 'Spring Avatar:',
                        'default': ''
                    },
                    'token-summer': {
                        'label': 'Summer Token:',
                        'default': ''
                    },
                    'avatar-summer': {
                        'label': 'Summer Avatar:',
                        'default': ''
                    },
                    'token-autumn': {
                        'label': 'Autumn Token:',
                        'default': ''
                    },
                    'avatar-autumn': {
                        'label': 'Autumn Avatar:',
                        'default': ''
                    },
                    'token-winter': {
                        'label': 'Winter Token:',
                        'default': ''
                    },
                    'avatar-winter': {
                        'label': 'Winter Avatar:',
                        'default': ''
                    }
                }
            },
            'Divine Strike': {
                'select': {
                    'damagetype': {
                        'label': 'Override damage type?',
                        'default': 'default',
                        'values': [
                            {'value': 'default', 'html': 'Default'},
                            {'value': 'acid', 'html': 'Acid'},
                            {'value': 'bludgeoning', 'html': 'Bludgeoning'},
                            {'value': 'cold', 'html': 'Cold'},
                            {'value': 'fire', 'html': 'Fire'},
                            {'value': 'force', 'html': 'Force'},
                            {'value': 'lightning', 'html': 'Lightning'},
                            {'value': 'necrotic', 'html': 'Necrotic'},
                            {'value': 'piercing', 'html': 'Piercing'},
                            {'value': 'poison', 'html': 'Poison'},
                            {'value': 'psychic', 'html': 'Psychic'},
                            {'value': 'radiant', 'html': 'Radiant'},
                            {'value': 'slashing', 'html': 'Slashing'},
                            {'value': 'thunder', 'html': 'Thunder'}
                        ]
                    }
                }
            },
            'Regeneration': {
                'checkbox': {
                    'acid': {
                        'label': 'Acid damage prevents healing?',
                        'default': false
                    },
                    'bludgeoning': {
                        'label': 'Bludgeoning damage prevents healing?',
                        'default': false
                    },
                    'cold': {
                        'label': 'Cold damage prevents healing?',
                        'default': false
                    },
                    'fire': {
                        'label': 'Fire damage prevents healing?',
                        'default': false
                    },
                    'force': {
                        'label': 'Force damage prevents healing?',
                        'default': false
                    },
                    'lightning': {
                        'label': 'Lightning damage prevents healing?',
                        'default': false
                    },
                    'necrotic': {
                        'label': 'Necrotic damage prevents healing?',
                        'default': false
                    },
                    'piercing': {
                        'label': 'Piercing damage prevents healing?',
                        'default': false
                    },
                    'poison': {
                        'label': 'Poison damage prevents healing?',
                        'default': false
                    },
                    'psychic': {
                        'label': 'Psychic damage prevents healing?',
                        'default': false
                    },
                    'radiant': {
                        'label': 'Radiant damage prevents healing?',
                        'default': false
                    },
                    'slashing': {
                        'label': 'Slashing damage prevents healing?',
                        'default': false
                    },
                    'thunder': {
                        'label': 'Thunder damage prevents healing?',
                        'default': false
                    },
                    'critical': {
                        'label': 'Critical hit prevents healing?',
                        'default': false
                    },
                    'zeroHP': {
                        'label': 'Don\'t regenerate at zero HP?',
                        'default': false
                    }
                },
                'number': {
                    'threshold': {
                        'label': 'Reduced healing threshold:',
                        'default': 0
                    }
                }
            },
            'Spirit Guardians': {
                'select': {
                    'color': {
                        'label': 'What color?',
                        'default': 'blueyellow',
                        'values': [
                            {'value': 'blueyellow', 'html': 'Blue-Yellow'},
                            {'value': 'blue', 'html': 'Blue'},
                            {'value': 'dark_black', 'html': 'Black'},
                            {'value': 'dark_blue', 'html': 'Dark Blue'},
                            {'value': 'dark_purple', 'html': 'Purple'},
                            {'value': 'dark_red', 'html': 'Red'},
                            {'value': 'dark_whiteblue', 'html': 'White-Blue'},
                            {'value': 'green', 'html': 'Green'},
                            {'value': 'orange', 'html': 'Orange'},
                            {'value': 'greenorange', 'html': 'Green-Orange'},
                            {'value': 'pinkpurple', 'html': 'Pink-Purple'},
                            {'value': 'random', 'html': 'Random'}
                        ]
                    },
                    'variation': {
                        'label': 'What variation?',
                        'default': 'ring',
                        'values': [
                            {'value': 'ring', 'html': 'Ring'},
                            {'value': 'no_ring', 'html': 'No Ring'},
                            {'value': 'particles', 'html': 'Particles'},
                            {'value': 'spirits', 'html': 'Spirits'}
                        ]
                    }
                }
            },
            'Channel Divinity: Turn Undead': {
                'text': {
                    'identifier': {
                        'label': 'Class Identifier:',
                        'default': 'cleric'
                    }
                }
            },
            'Spiritual Weapon': {
                'text': {
                    'name': {
                        'label': 'Custom Name:',
                        'default': ''
                    },
                    'avatar': {
                        'label': 'Custom Avatar:',
                        'default': ''
                    },
                    'token': {
                        'label': 'Custom Token:',
                        'default': ''
                    }
                }
            },
            'CPR - Randomizer': {
                'checkbox': {
                    'humanoid': {
                        'label': 'Disabled:',
                        'default': false
                    },
                    'spells': {
                        'label': 'Include Spellcasting:',
                        'default': true
                    }
                },
                'select': {
                    'abilities': {
                        'label': 'Abilities:',
                        'default': 'upgrade',
                        'values': [
                            {'value': 'source', 'html': 'Keep Source'},
                            {'value': 'target', 'html': 'Keep Target'},
                            {'value': 'upgrade', 'html': 'Upgrade'},
                            {'value': 'downgrade', 'html': 'Downgrade'}
                        ]
                    },
                    'skills': {
                        'label': 'Skills:',
                        'default': 'upgrade',
                        'values': [
                            {'value': 'source', 'html': 'Keep Source'},
                            {'value': 'target', 'html': 'Keep Target'},
                            {'value': 'upgrade', 'html': 'Upgrade'},
                            {'value': 'downgrade', 'html': 'Downgrade'}
                        ]
                    },
                    'avatar': {
                        'label': 'Avatar Image:',
                        'default': 'source',
                        'values': [
                            {'value': 'source', 'html': 'Use Source'},
                            {'value': 'target', 'html': 'Keep Target'}
                        ]
                    },
                    'token': {
                        'label': 'Token Image:',
                        'default': 'source',
                        'values': [
                            {'value': 'source', 'html': 'Use Source'},
                            {'value': 'target', 'html': 'Keep Target'}
                        ]
                    },
                    'features': {
                        'label': 'Features',
                        'default': 'merge',
                        'values': [
                            {'value': 'source', 'html': 'Use Source'},
                            {'value': 'target', 'html': 'Keep Target'},
                            {'value': 'merge', 'html': 'Merge'}
                        ]
                    },
                    'conditionimmunity': {
                        'label': 'Condition Immunities',
                        'default': 'merge',
                        'values': [
                            {'value': 'source', 'html': 'Use Source'},
                            {'value': 'target', 'html': 'Keep Target'},
                            {'value': 'merge', 'html': 'Merge'}
                        ]
                    },
                    'damageimmunity': {
                        'label': 'Damage Immunities',
                        'default': 'merge',
                        'values': [
                            {'value': 'source', 'html': 'Use Source'},
                            {'value': 'target', 'html': 'Keep Target'},
                            {'value': 'merge', 'html': 'Merge'}
                        ]
                    },
                    'damageresistance': {
                        'label': 'Damage Resistances',
                        'default': 'merge',
                        'values': [
                            {'value': 'source', 'html': 'Use Source'},
                            {'value': 'target', 'html': 'Keep Target'},
                            {'value': 'merge', 'html': 'Merge'}
                        ]
                    },
                    'damagevulnerability': {
                        'label': 'Damage Vulnerabilities',
                        'default': 'merge',
                        'values': [
                            {'value': 'source', 'html': 'Use Source'},
                            {'value': 'target', 'html': 'Keep Target'},
                            {'value': 'merge', 'html': 'Merge'}
                        ]
                    },
                    'languages': {
                        'label': 'Languages',
                        'default': 'merge',
                        'values': [
                            {'value': 'source', 'html': 'Use Source'},
                            {'value': 'target', 'html': 'Keep Target'},
                            {'value': 'merge', 'html': 'Merge'}
                        ]
                    },
                    'name': {
                        'label': 'Name',
                        'default': 'before',
                        'values': [
                            {'value': 'source', 'html': 'Use Source'},
                            {'value': 'target', 'html': 'Keep Target'},
                            {'value': 'before', 'html': 'Prepend'},
                            {'value': 'after', 'html': 'Append'}
                        ]
                    },
                    'ac': {
                        'label': 'Armor Calculation',
                        'default': 'source',
                        'values': [
                            {'value': 'source', 'html': 'Use Source'},
                            {'value': 'target', 'html': 'Keep Target'}
                        ]
                    },
                    'movement': {
                        'label': 'Movement',
                        'default': 'upgrade',
                        'values': [
                            {'value': 'source', 'html': 'Keep Source'},
                            {'value': 'target', 'html': 'Keep Target'},
                            {'value': 'upgrade', 'html': 'Upgrade'},
                            {'value': 'downgrade', 'html': 'Downgrade'}
                        ]
                    },
                    'senses': {
                        'label': 'Senses',
                        'default': 'source',
                        'values': [
                            {'value': 'source', 'html': 'Keep Source'},
                            {'value': 'target', 'html': 'Keep Target'}
                        ]
                    }
                }
            },
            'Eldritch Blast': {
                'checkbox': {
                    'agonizingblast': {
                        'label': 'Force Apply Agonizing Blast?',
                        'default': false
                    }
                },
                'select': {
                    'color': {
                        'label': 'What color?',
                        'default': 'purple',
                        'values': [
                            {'value': 'purple', 'html': 'Purple'},
                            {'value': 'dark_green', 'html': 'Dark Green'},
                            {'value': 'dark_red', 'html': 'Red'},
                            {'value': 'green', 'html': 'Green'},
                            {'value': 'lightblue', 'html': 'Blue'},
                            {'value': 'lightgreen', 'html': 'Light Green'},
                            {'value': 'orange', 'html': 'Orange'},
                            {'value': 'pink', 'html': 'Pink'},
                            {'value': 'yellow', 'html': 'Yellow'},
                            {'value': 'rainbow', 'html': 'Rainbow'},
                            {'value': 'cycle', 'html': 'Cycle'},
                            {'value': 'random', 'html': 'Random'},
                            {'value': 'none', 'html': 'None'}
                        ]
                    }
                }
            },
            'Guardian of Faith': {
                'text': {
                    'name': {
                        'label': 'Custom Name:',
                        'default': ''
                    },
                    'avatar': {
                        'label': 'Custom Avatar:',
                        'default': ''
                    },
                    'token': {
                        'label': 'Custom Token:',
                        'default': ''
                    }
                },
                'select': {
                    'color': {
                        'label': 'Animation Color:',
                        'default': 'yellow',
                        'values': [
                            {'value': 'yellow', 'html': 'Yellow'},
                            {'value': 'blue', 'html': 'Blue'},
                            {'value': 'green', 'html': 'Green'},
                            {'value': 'purple', 'html': 'Purple'}
                        ]
                    },
                    'animation': {
                        'label': 'Summon Animation:',
                        'default': 'celestial',
                        'values': summonEffectOptions
                    }
                }
            },
            'Awakened Spellbook: Replace Damage': {
                'checkbox': {
                    'cromaticorb': {
                        'label': 'Has Chromatic Orb?',
                        'default': false
                    },
                    'magicmissile': {
                        'label': 'Has Magic Missile?',
                        'default': false
                    },
                    'dragonsbreath': {
                        'label': 'Has Dragon\'s Breath?',
                        'default': false
                    },
                    'glyphofwarding': {
                        'label': 'Has Glyph of Warding?',
                        'default': false
                    },
                    'protectionfromenergy': {
                        'label': 'Has Protection from Energy?',
                        'default': false
                    },
                    'spiritshroud': {
                        'label': 'Has Spirit Shroud?',
                        'default': false
                    },
                    'vampirictouch': {
                        'label': 'Has Vampiric Touch?',
                        'default': false
                    },
                    'elementalbane': {
                        'label': 'Has Elemental Bane?',
                        'default': false
                    },
                    'cloudkill': {
                        'label': 'Has Cloudkill?',
                        'default': false
                    },
                    'primasticspray': {
                        'label': 'Has Prismatic Spray?',
                        'default': false
                    },
                    'illusorydragon': {
                        'label': 'Has Illusory Dragon?',
                        'default': false
                    },
                    'prismaticwall': {
                        'label': 'Has Prismatic Wall?',
                        'default': false
                    }
                }
            },
            'Dancing Greatsword': {
                'text': {
                    'name': {
                        'label': 'Custom Name:',
                        'default': ''
                    },
                    'avatar': {
                        'label': 'Custom Avatar:',
                        'default': ''
                    },
                    'token': {
                        'label': 'Custom Token:',
                        'default': ''
                    }
                }
            },
            'Dancing Longsword': {
                'text': {
                    'name': {
                        'label': 'Custom Name:',
                        'default': ''
                    },
                    'avatar': {
                        'label': 'Custom Avatar:',
                        'default': ''
                    },
                    'token': {
                        'label': 'Custom Token:',
                        'default': ''
                    }
                }
            },
            'Dancing Rapier': {
                'text': {
                    'name': {
                        'label': 'Custom Name:',
                        'default': ''
                    },
                    'avatar': {
                        'label': 'Custom Avatar:',
                        'default': ''
                    },
                    'token': {
                        'label': 'Custom Token:',
                        'default': ''
                    }
                }
            },
            'Dancing Scimitar': {
                'text': {
                    'name': {
                        'label': 'Custom Name:',
                        'default': ''
                    },
                    'avatar': {
                        'label': 'Custom Avatar:',
                        'default': ''
                    },
                    'token': {
                        'label': 'Custom Token:',
                        'default': ''
                    }
                }
            },
            'Dancing Shortsword': {
                'text': {
                    'name': {
                        'label': 'Custom Name:',
                        'default': ''
                    },
                    'avatar': {
                        'label': 'Custom Avatar:',
                        'default': ''
                    },
                    'token': {
                        'label': 'Custom Token:',
                        'default': ''
                    }
                }
            },
            'Conjure Animals': {
                'text': {
                    'folder': {
                        'label': 'Custom Folder:',
                        'default': ''
                    }
                },
                'checkbox': {
                    'overwriteInitiative': {
                        'label': 'Overwrite initiative setting? Default Seperate Initiative',
                        'default': false
                    }
                },
                'select': {
                    'animation': {
                        'label': 'Animation:',
                        'default': 'nature',
                        'values': summonEffectOptions
                    }
                }
            },
            'Conjure Celestial': {
                'text': {
                    'folder': {
                        'label': 'Custom Folder:',
                        'default': ''
                    }
                },
                'checkbox': {
                    'overwriteInitiative': {
                        'label': 'Overwrite initiative setting? Default Seperate Initiative',
                        'default': false
                    }
                },
                'select': {
                    'animation': {
                        'label': 'Animation:',
                        'default': 'celestial',
                        'values': summonEffectOptions
                    }
                }
            },
            'Conjure Elemental': {
                'text': {
                    'folder': {
                        'label': 'Custom Folder:',
                        'default': ''
                    }
                },
                'checkbox': {
                    'overwriteInitiative': {
                        'label': 'Overwrite initiative setting? Default Seperate Initiative',
                        'default': false
                    }
                },
                'select': {
                    'animation': {
                        'label': 'Animation:',
                        'default': 'default',
                        'values': summonEffectOptions
                    }
                }
            },
            'Conjure Fey': {
                'text': {
                    'folder': {
                        'label': 'Custom Folder:',
                        'default': ''
                    }
                },
                'checkbox': {
                    'overwriteInitiative': {
                        'label': 'Overwrite initiative setting? Default Seperate Initiative',
                        'default': false
                    }
                },
                'select': {
                    'animation': {
                        'label': 'Animation:',
                        'default': 'nature',
                        'values': summonEffectOptions
                    }
                }
            },
            'Conjure Minor Elementals': {
                'text': {
                    'folder': {
                        'label': 'Custom Folder:',
                        'default': ''
                    }
                },
                'checkbox': {
                    'overwriteInitiative': {
                        'label': 'Overwrite initiative setting? Default Seperate Initiative',
                        'default': false
                    }
                },
                'select': {
                    'animation': {
                        'label': 'Animation:',
                        'default': 'default',
                        'values': summonEffectOptions
                    }
                }
            },
            'Conjure Woodland Beings': {
                'text': {
                    'folder': {
                        'label': 'Custom Folder:',
                        'default': ''
                    }
                },
                'checkbox': {
                    'overwriteInitiative': {
                        'label': 'Overwrite initiative setting? Default Seperate Initiative',
                        'default': false
                    }
                },
                'select': {
                    'animation': {
                        'label': 'Animation:',
                        'default': 'nature',
                        'values': summonEffectOptions
                    }
                }
            },
            'Find Familiar': {
                'text': {
                    'folder': {
                        'label': 'Custom Folder:',
                        'default': ''
                    },
                    'name': {
                        'label': 'Familiar Name:',
                        'default': ''
                    }
                },
                'select': {
                    'animation-celestial': {
                        'label': 'Celestial Animation:',
                        'default': 'celestial',
                        'values': summonEffectOptions
                    },
                    'animation-fey': {
                        'label': 'Fey Animation:',
                        'default': 'nature',
                        'values': summonEffectOptions
                    },
                    'animation-fiend': {
                        'label': 'Fiend Animation:',
                        'default': 'fire',
                        'values': summonEffectOptions
                    }
                }
            },
            'Crystal Greatsword': {
                'checkbox': {
                    'healprompt': {
                        'label': 'Prompt to use heal?',
                        'default': true
                    }
                }
            },
            'Crystal Longsword': {
                'checkbox': {
                    'healprompt': {
                        'label': 'Prompt to use heal?',
                        'default': true
                    }
                }
            },
            'Crystal Rapier': {
                'checkbox': {
                    'healprompt': {
                        'label': 'Prompt to use heal?',
                        'default': true
                    }
                }
            },
            'Crystal Scimitar': {
                'checkbox': {
                    'healprompt': {
                        'label': 'Prompt to use heal?',
                        'default': true
                    }
                }
            },
            'Crystal Shortsword': {
                'checkbox': {
                    'healprompt': {
                        'label': 'Prompt to use heal?',
                        'default': true
                    }
                }
            },
            'Find Steed': {
                'text': {
                    'folder': {
                        'label': 'Custom Folder:',
                        'default': ''
                    },
                    'name': {
                        'label': 'Steed Name:',
                        'default': ''
                    }
                },
                'select': {
                    'animation-celestial': {
                        'label': 'Celestial Animation:',
                        'default': 'celestial',
                        'values': summonEffectOptions
                    },
                    'animation-fey': {
                        'label': 'Fey Animation:',
                        'default': 'nature',
                        'values': summonEffectOptions
                    },
                    'animation-fiend': {
                        'label': 'Fiend Animation:',
                        'default': 'fire',
                        'values': summonEffectOptions
                    }
                }
            },
            'Find Greater Steed': {
                'text': {
                    'folder': {
                        'label': 'Custom Folder:',
                        'default': ''
                    },
                    'name': {
                        'label': 'Greater Steed Name:',
                        'default': ''
                    }
                },
                'select': {
                    'animation-celestial': {
                        'label': 'Celestial Animation:',
                        'default': 'celestial',
                        'values': summonEffectOptions
                    },
                    'animation-fey': {
                        'label': 'Fey Animation:',
                        'default': 'nature',
                        'values': summonEffectOptions
                    },
                    'animation-fiend': {
                        'label': 'Fiend Animation:',
                        'default': 'fire',
                        'values': summonEffectOptions
                    }
                }
            },
            'Enhanced Weapon, +1': {
                'number': {
                    'level': {
                        'label': 'Level:',
                        'default': 1
                    }
                }
            },
            'Enhanced Weapon, +2': {
                'number': {
                    'level': {
                        'label': 'Level:',
                        'default': 2
                    }
                }
            },
            'Radiant Weapon': {
                'number': {
                    'savedc': {
                        'label': 'Save DC:',
                        'default': 10
                    }
                }
            },
            'Resistant Armor': {
                'select': {
                    'resistance': {
                        'label': 'What resistance?',
                        'default': 'acid',
                        'values': [
                            {'value': 'acid', 'html': 'Acid'},
                            {'value': 'cold', 'html': 'Cold'},
                            {'value': 'fire', 'html': 'Fire'},
                            {'value': 'force', 'html': 'Force'},
                            {'value': 'lightning', 'html': 'Lightning'},
                            {'value': 'necrotic', 'html': 'Necrotic'},
                            {'value': 'poison', 'html': 'Poison'},
                            {'value': 'psychic', 'html': 'Psychic'},
                            {'value': 'radiant', 'html': 'Radiant'},
                            {'value': 'thunder', 'html': 'Thunder'}
                        ]
                    }
                }
            },
            'Savage Attacker': {
                'checkbox': {
                    'auto': {
                        'label': 'Auto Reroll?',
                        'default': false
                    }
                },
                'number': {
                    'reroll': {
                        'label': 'Auto reroll at:',
                        'default': 1
                    }
                }
            },
            'Rage': {
                'select': {
                    'animation': {
                        'label': 'What animation?',
                        'default': 'default',
                        'values': [
                            {'value': 'default', 'html': 'Default'},
                            {'value': 'lightning', 'html': 'Purple Lightning'},
                            {'value': 'saiyan', 'html': 'Super Saiyan'},
                            {'value': 'none', 'html': 'None'}
                        ]
                    }
                }
            },
            'Burning Hands': {
                'select': {
                    'animation': {
                        'label': 'What animation?',
                        'default': 'default',
                        'values': [
                            {'value': 'default', 'html': 'Default'},
                            {'value': 'none', 'html': 'None'}
                        ]
                    }
                }
            },
            'Fly': {
                'select': {
                    'animation': {
                        'label': 'What animation?',
                        'default': 'default',
                        'values': [
                            {'value': 'default', 'html': 'Default'},
                            {'value': 'none', 'html': 'None'}
                        ]
                    }
                }
            },
            'Faerie Fire': {
                'select': {
                    'animation': {
                        'label': 'What animation?',
                        'default': 'green',
                        'values': [
                            {'value': 'green', 'html': 'Green'},
                            {'value': 'blue', 'html': 'Blue'},
                            {'value': 'purple', 'html': 'Violet'},
                            {'value': 'none', 'html': 'None'}
                        ]
                    }
                }
            },
            'Vortex Warp': {
                'select': {
                    'animation': {
                        'label': 'What animation?',
                        'default': 'default',
                        'values': [
                            {'value': 'default', 'html': 'Default'},
                            {'value': 'simple', 'html': 'Simple'}
                        ]
                    }
                }
            },
            'Disintegrate': {
                'select': {
                    'animation': {
                        'label': 'What animation?',
                        'default': 'default',
                        'values': [
                            {'value': 'default', 'html': 'Default'},
                            {'value': 'none', 'html': 'None'}
                        ]
                    }
                }
            },
            'Fire Storm': {
                'checkbox': {
                    'animation': {
                        'label': 'Play Animation?',
                        'default': true
                    }
                }
            },
            'Fire Shield': {
                'checkbox': {
                    'animation': {
                        'label': 'Play Animation?',
                        'default': true
                    }
                }
            },
            'Far Step': {
                'select': {
                    'animation': {
                        'label': 'What animation?',
                        'default': 'default',
                        'values': [
                            {'value': 'default', 'html': 'Default'},
                            {'value': 'simple', 'html': 'Simple'}
                        ]
                    }
                }
            },
            'Shocking Grasp': {
                'select': {
                    'color': {
                        'label': 'What color?',
                        'default': 'blue',
                        'values': [
                            {'value': 'blue', 'html': 'Blue'},
                            {'value': 'blue02', 'html': 'Alternate Blue'},
                            {'value': 'dark_purple', 'html': 'Dark Purple'},
                            {'value': 'dark_red', 'html': 'Dark Red'},
                            {'value': 'green', 'html': 'Green'},
                            {'value': 'green02', 'html': 'Alternate Green'},
                            {'value': 'orange', 'html': 'Orange'},
                            {'value': 'purple', 'html': 'Purple'},
                            {'value': 'red', 'html': 'Red'},
                            {'value': 'yellow', 'html': 'Yellow'},
                            {'value': 'random', 'html': 'Random'},
                            {'value': 'none', 'html': 'None'}
                        ]
                    }
                }
            },
            'Summon Lesser Demons': {
                'text': {
                    'folder': {
                        'label': 'Custom Folder:',
                        'default': ''
                    }
                },
                'select': {
                    'animation': {
                        'label': 'Animation:',
                        'default': 'default',
                        'values': summonEffectOptions
                    }
                }
            },
            'Manifest Mind: Summon': {
                'text': {
                    'name': {
                        'label': 'Custom Name:',
                        'default': ''
                    },
                    'avatar': {
                        'label': 'Custom Avatar:',
                        'default': ''
                    },
                    'token': {
                        'label': 'Custom Token:',
                        'default': ''
                    }
                },
                'select': {
                    'animation': {
                        'label': 'Animation:',
                        'default': 'default',
                        'values': summonEffectOptions
                    }
                }
            },
            'Parry': {
                'text': {
                    'acbonus': {
                        'label': 'AC Bonus:',
                        'default': '2'
                    }
                }
            },
            'Enlarge/Reduce': {
                'checkbox': {
                    'animation': {
                        'label': 'Play Animation?',
                        'default': true
                    }
                }
            },
            'Breath of the Dragon': {
                'checkbox': {
                    'animation': {
                        'label': 'Play Animation?',
                        'default': true
                    }
                }
            },
            'Wraps of Dyamak': {
                'select': {
                    'tier': {
                        'label': 'Tier:',
                        'default': 1,
                        'values': [
                            {'value': 1, 'html': '1'},
                            {'value': 2, 'html': '2'},
                            {'value': 3, 'html': '3'},
                        ]
                    }
                }
            },
            'Scorching Ray': {
                'select': {
                    'animation': {
                        'label': 'Animation:',
                        'default': 'complex',
                        'values': [
                            {'value': 'complex', 'html': 'Complex'},
                            {'value': 'simple', 'html': 'Simple'},
                            {'value': 'none', 'html': 'None'}
                        ]
                    },
                    'color': {
                        'label': 'Color:',
                        'default': 'orange',
                        'values': [
                            {'value': 'orange', 'html': 'Orange'},
                            {'value': 'blue', 'html': 'Blue'},
                            {'value': 'green', 'html': 'Green'},
                            {'value': 'pink', 'html': 'Pink'},
                            {'value': 'purple', 'html': 'Purple'},
                            {'value': 'rainbow01', 'html': 'Rainbow'},
                            {'value': 'rainbow02', 'html': 'Rainbow Alternate'},
                            {'value': 'cycle', 'html': 'Cycle'},
                            {'value': 'random', 'html': 'Random'}
                        ]
                    }
                }
            },
            'Firearm (CR)': {
                'number': {
                    'misfire': {
                        'label': 'Misfire Score:',
                        'default': 1
                    }
                },
                'select': {
                    'status': {
                        'label': 'Status:',
                        'default': 0,
                        'values': [
                            {'value': 0, 'html': 'Normal'},
                            {'value': 1, 'html': 'Damaged'},
                            {'value': 2, 'html': 'Broken'},
                        ]
                    }
                }
            },
            'Palm Pistol (Exandria)': {
                'number': {
                    'misfire': {
                        'label': 'Misfire Score:',
                        'default': 1
                    }
                },
                'select': {
                    'status': {
                        'label': 'Status:',
                        'default': 0,
                        'values': [
                            {'value': 0, 'html': 'Normal'},
                            {'value': 1, 'html': 'Damaged'},
                            {'value': 2, 'html': 'Broken'},
                        ]
                    }
                }
            },
            'Bad News (Exandria)': {
                'number': {
                    'misfire': {
                        'label': 'Misfire Score:',
                        'default': 3
                    }
                },
                'select': {
                    'status': {
                        'label': 'Status:',
                        'default': 0,
                        'values': [
                            {'value': 0, 'html': 'Normal'},
                            {'value': 1, 'html': 'Damaged'},
                            {'value': 2, 'html': 'Broken'},
                        ]
                    }
                }
            },
            'Blunderbuss (Exandria)': {
                'number': {
                    'misfire': {
                        'label': 'Misfire Score:',
                        'default': 2
                    }
                },
                'select': {
                    'status': {
                        'label': 'Status:',
                        'default': 0,
                        'values': [
                            {'value': 0, 'html': 'Normal'},
                            {'value': 1, 'html': 'Damaged'},
                            {'value': 2, 'html': 'Broken'},
                        ]
                    }
                }
            },
            'Musket (Exandria)': {
                'number': {
                    'misfire': {
                        'label': 'Misfire Score:',
                        'default': 2
                    }
                },
                'select': {
                    'status': {
                        'label': 'Status:',
                        'default': 0,
                        'values': [
                            {'value': 0, 'html': 'Normal'},
                            {'value': 1, 'html': 'Damaged'},
                            {'value': 2, 'html': 'Broken'},
                        ]
                    }
                }
            },
            'Pepperbox (Exandria)': {
                'number': {
                    'misfire': {
                        'label': 'Misfire Score:',
                        'default': 2
                    }
                },
                'select': {
                    'status': {
                        'label': 'Status:',
                        'default': 0,
                        'values': [
                            {'value': 0, 'html': 'Normal'},
                            {'value': 1, 'html': 'Damaged'},
                            {'value': 2, 'html': 'Broken'},
                        ]
                    }
                }
            },
            'Pistol (Exandria)': {
                'number': {
                    'misfire': {
                        'label': 'Misfire Score:',
                        'default': 1
                    }
                },
                'select': {
                    'status': {
                        'label': 'Status:',
                        'default': 0,
                        'values': [
                            {'value': 0, 'html': 'Normal'},
                            {'value': 1, 'html': 'Damaged'},
                            {'value': 2, 'html': 'Broken'},
                        ]
                    }
                }
            },
            'Booming Blade': {
                'select': {
                    'animation': {
                        'label': 'Animation:',
                        'default': 'blue',
                        'values': [
                            {'value': 'blue', 'html': 'Blue'},
                            {'value': 'blue02', 'html': 'Alternate Blue'},
                            {'value': 'dark_purple', 'html': 'Dark Purple'},
                            {'value': 'dark_red', 'html': 'Dark Red'},
                            {'value': 'green', 'html': 'Green'},
                            {'value': 'green02', 'html': 'Alternate Green'},
                            {'value': 'orange', 'html': 'Orange'},
                            {'value': 'red', 'html': 'Red'},
                            {'value': 'purple', 'html': 'Purple'},
                            {'value': 'yellow', 'html': 'Yellow'},
                            {'value': 'blue', 'html': 'Blue'},
                            {'value': 'random', 'html': 'Random'},
                            {'value': 'none', 'html': 'None'},
                        ]
                    }
                }
            },
            'Rime\'s Binding Ice': {
                'checkbox': {
                    'animation': {
                        'label': 'Play Animation?',
                        'default': true
                    }
                }
            },
            'Wild Surge': {
                'text': {
                    'flumph-avatar': {
                        'label': 'Flumph Avatar',
                        'default': ''
                    },
                    'flumph-token': {
                        'label': 'Flumph Token',
                        'default': ''
                    },
                    'pixie-avatar': {
                        'label': 'Pixie Avatar',
                        'default': ''
                    },
                    'pixie-token': {
                        'label': 'Pixie Token',
                        'default': ''
                    }
                }
            },
            'Quick Insert Summon': {
                'text': {
                    'prefill': {
                        'label': 'Prefill Text:',
                        'default': ''
                    }
                },
                'select': {
                    'animation': {
                        'label': 'Animation:',
                        'default': 'default',
                        'values': summonEffectOptions
                    }
                }
            },
            'Animate Dead': {
                'select': {
                    'animation': {
                        'label': 'Animation:',
                        'default': 'shadow',
                        'values': summonEffectOptions
                    }
                }
            },
            'Stunning Strike': {
                'checkbox': {
                    'onhit': {
                        'label': 'Prompt on hit?',
                        'default': false
                    }
                }
            },
            'Investiture of Flame': {
                'checkbox': {
                    'animation': {
                        'label': 'Play Animation?',
                        'default': true
                    }
                }
            },
            'Investiture of Ice': {
                'checkbox': {
                    'animation': {
                        'label': 'Play Animation?',
                        'default': true
                    }
                }
            },
            'Long-Limbed': {
                'checkbox': {
                    'displaycard': {
                        'label': 'Display Chat Card?',
                        'default': true
                    }
                }
            },
            'Grung Poison': {
                'checkbox': {
                    'prompt': {
                        'label': 'Prompt on each valid attack?',
                        'default': false
                    }
                }
            },
            'Bardic Inspiration': {
                'text': {
                    'classidentifier': {
                        'label': 'Class Identifier',
                        'default': 'bard'
                    },
                    'scaleidentifier': {
                        'label': 'Scale Identifier',
                        'default': 'bardic-inspiration'
                    }
                }
            },
            'Manifest Echo': {
                'text': {
                    'name': {
                        'label': 'Custom Name:',
                        'default': ''
                    },
                    'avatar': {
                        'label': 'Custom Avatar:',
                        'default': ''
                    },
                    'token': {
                        'label': 'Custom Token:',
                        'default': ''
                    }
                },
                'select': {
                    'animation': {
                        'label': 'Animation:',
                        'default': 'default',
                        'values': summonEffectOptions
                    }
                },
                'checkbox': {
                    'filter': {
                        'label': 'Apply Token Magic Filter?',
                        'default': true
                    }
                }
            },
            'Channel Divinity: Control Undead': {
                'checkbox': {
                    'animation': {
                        'label': 'Play animation?',
                        'default': true
                    }
                }
            },
            'Channel Divinity: Dreadful Aspect': {
                'checkbox': {
                    'animation': {
                        'label': 'Play animation?',
                        'default': true
                    }
                }
            },
            'Dread Lord': {
                'text': {
                    'avatar': {
                        'label': 'Custom Avatar:',
                        'default': ''
                    },
                    'token': {
                        'label': 'Custom Token:',
                        'default': ''
                    }
                },
                'checkbox': {
                    'animation': {
                        'label': 'Play animation?',
                        'default': true
                    }
                }
            },
            'Gathered Swarm': {
                'select': {
                    'animation': {
                        'label': 'Animation',
                        'default': 'fairies',
                        'values': [
                            {'value': 'fairies', 'html': 'Fairies'},
                            {'value': 'butterflies', 'html': 'Butterflies'},
                            {'value': false, 'html': 'None'}
                        ]
                    },
                    'color': {
                        'label': 'Color',
                        'default': 'bluepurple',
                        'values': [
                            {'value': 'bluepurple', 'html': 'Blue-Purple'},
                            {'value': 'greenyellow', 'html': 'Green-Yellow'},
                            {'value': 'white', 'html': 'White'}
                        ]
                    }
                }
            }
        },
        'automations': {
            'Armor of Agathys': {
                'name': 'Armor of Agathys',
                'version': '0.7.45',
                'settings': [
                    'On Hit'
                ],
                'hasAnimation': true
            },
            'Arms of Hadar': {
                'name': 'Arms of Hadar',
                'version': '0.7.01'
            },
            'Aura of Purity': {
                'name': 'Aura of Purity',
                'version': '0.7.01',
                'settings': [
                    'Effect Auras'
                ]
            },
            'Aura of Vitality': {
                'name': 'Aura of Vitality',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Aura of Vitality'
                }
            },
            'Beacon of Hope': {
                'name': 'Beacon of Hope',
                'version': '0.7.01',
                'settings': [
                    'Beacon of Hope'
                ]
            },
            'Bestow Curse': {
                'name': 'Bestow Curse',
                'version': '0.7.01',
            },
            'Bigby\'s Hand': {
                'name': 'Bigby\'s Hand',
                'version': '0.7.01',
                'actors': [
                    'CPR - Bigby\'s Hand'
                ]
            },
            'Blade Ward': {
                'name': 'Blade Ward',
                'version': '0.7.01'
            },
            'Blight': {
                'name': 'Blight',
                'version': '0.7.01'
            },
            'Blink': {
                'name': 'Blink',
                'version': '0.7.01'
            },
            'Call Lightning': {
                'name': 'Call Lightning',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Storm Bolt'
                }
            },
            'Chain Lightning': {
                'name': 'Chain Lightning',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Charm Person': {
                'name': 'Charm Person',
                'version': '0.7.01'
            },
            'Chill Touch': {
                'name': 'Chill Touch',
                'version': '0.7.01'
            },
            'Chromatic Orb': {
                'name': 'Chromatic Orb',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Cloudkill': {
                'name': 'Cloudkill',
                'version': '0.7.01',
                'settings': [
                    'Template Listener'
                ]
            },
            'Crown of Madness': {
                'name': 'Crown of Madness',
                'version': '0.7.01'
            },
            'Crusader\'s Mantle': {
                'name': 'Crusader\'s Mantle',
                'version': '0.7.01'
            },
            'Danse Macabre': {
                'name': 'Danse Macabre',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Danse Macabre'
                },
                'actors': [
                    'CPR - Skeleton',
                    'CPR - Zombie'
                ]
            },
            'Darkness': {
                'name': 'Darkness',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Dawn': {
                'name': 'Dawn',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Dawn'
                }
            },
            'Death Ward': {
                'name': 'Death Ward',
                'version': '0.7.01',
                'settings': [
                    'Death Ward'
                ]
            },
            'Destructive Wave': {
                'name': 'Destructive Wave',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Detect Magic': {
                'name': 'Detect Magic',
                'version': '0.7.01'
            },
            'Detect Thoughts': {
                'name': 'Detect Thoughts',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Detect Thoughts - Probe Deeper'
                }
            },
            'Dragon\'s Breath': {
                'name': 'Dragon\'s Breath',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Dragon Breath'
                }
            },
            'Strike of the Giants: Frost Strike': {
                'name': 'Strike of the Giants: Frost Strike',
                'version': '0.7.01'
            },
            'Strike of the Giants: Storm Strike': {
                'name': 'Strike of the Giants: Storm Strike',
                'version': '0.7.01'
            },
            'Strike of the Giants: Cloud Strike': {
                'name': 'Strike of the Giants: Cloud Strike',
                'version': '0.7.01'
            },
            'Strike of the Giants: Fire Strike': {
                'name': 'Strike of the Giants: Fire Strike',
                'version': '0.7.01'
            },
            'Strike of the Giants: Hill Strike': {
                'name': 'Strike of the Giants: Hill Strike',
                'version': '0.7.01'
            },
            'Strike of the Giants: Stone Strike': {
                'name': 'Strike of the Giants: Stone Strike',
                'version': '0.7.01'
            },
            'Guile of the Cloud Giant: Cloudy Escape': {
                'name': 'Guile of the Cloud Giant: Cloudy Escape',
                'version': '0.7.01'
            },
            'Vigor of the Hill Giant: Bulwark': {
                'name': 'Vigor of the Hill Giant: Bulwark',
                'version': '0.7.01'
            },
            'Ember of the Fire Giant: Searing Ignition': {
                'name': 'Ember of the Fire Giant: Searing Ignition',
                'version': '0.7.01'
            },
            'Fury of the Frost Giant: Frigid Retaliation': {
                'name': 'Fury of the Frost Giant: Frigid Retaliation',
                'version': '0.7.01'
            },
            'Keenness of the Stone Giant: Stone Throw': {
                'name': 'Keenness of the Stone Giant: Stone Throw',
                'version': '0.7.01'
            },
            'Favored Foe': {
                'name': 'Favored Foe',
                'version': '0.7.01'
            },
            'Toll the Dead': {
                'name': 'Toll the Dead',
                'version': '0.7.15'
            },
            'Ray of Enfeeblement': {
                'name': 'Ray of Enfeeblement',
                'version': '0.7.01'
            },
            'Shocking Grasp': {
                'name': 'Shocking Grasp',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Sanctuary': {
                'name': 'Sanctuary',
                'version': '0.9.53',
                'hasAnimation': true,
                'settings': [
                    'Sanctuary'
                ]
            },
            'Heat Metal': {
                'name': 'Heat Metal',
                'version': '0.7.01'
            },
            'Conjure Woodland Beings': {
                'name': 'Conjure Woodland Beings',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Conjure Woodland Beings'
                }
            },
            'Vortex Warp': {
                'name': 'Vortex Warp',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Tasha\'s Caustic Brew': {
                'name': 'Tasha\'s Caustic Brew',
                'version': '0.7.19'
            },
            'Crown of Madness': {
                'name': 'Crown of Madness',
                'version': '0.7.01'
            },
            'Crusader\'s Mantle': {
                'name': 'Crusader\'s Mantle',
                'version': '0.7.01'
            },
            'Sickening Radiance': {
                'name': 'Sickening Radiance',
                'version': '0.7.01',
                'settings': [
                    'Template Listener'
                ]
            },
            'Blight': {
                'name': 'Blight',
                'version': '0.7.01'
            },
            'Conjure Animals': {
                'name': 'Conjure Animals',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Conjure Animals'
                }
            },
            'Pass without Trace': {
                'name': 'Pass without Trace',
                'version': '0.7.01'
            },
            'Zone of Truth': {
                'name': 'Zone of Truth',
                'version': '0.7.01'
            },
            'Conjure Elemental': {
                'name': 'Conjure Elemental',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Conjure Elemental'
                }
            },
            'Summon Shadowspawn': {
                'name': 'Summon Shadowspawn',
                'version': '0.7.01',
                'actors': [
                    'CPR - Shadow Spirit'
                ]
            },
            'Storm Sphere': {
                'name': 'Storm Sphere',
                'version': '0.7.45',
                'hasAnimation': true,
                'mutation': {
                    'self': 'Storm Sphere Handler'
                }
            },
            'Summon Fey': {
                'name': 'Summon Fey',
                'version': '0.7.01',
                'actors': [
                    'CPR - Fey Spirit'
                ]
            },
            'Vitriolic Sphere': {
                'name': 'Vitriolic Sphere',
                'version': '0.7.01'
            },
            'Dawn': {
                'name': 'Dawn',
                'version': '0.7.01',
                'settings': [
                    'Template Listener'
                ],
                'muations': {
                    'self': 'Dawn'
                }
            },
            'Raulothim\'s Psychic Lance': {
                'name': 'Raulothim\'s Psychic Lance',
                'version': '0.7.01'
            },
            'Life Transference': {
                'name': 'Life Transference',
                'version': '0.7.01'
            },
            'Healing Spirit': {
                'name': 'Healing Spirit',
                'version': '0.7.01',
                'actors': [
                    'CPR - Healing Spirit'
                ],
                'mutation': {
                    'self': 'Healing Spirit'
                }
            },
            'Mirror Image': {
                'name': 'Mirror Image',
                'version': '0.7.01',
                'settings': [
                    'Mirror Image'
                ]
            },
            'Bigby\'s Hand': {
                'name': 'Bigby\'s Hand',
                'version': '0.7.01',
                'actors': [
                    'CPR - Bigby\'s Hand'
                ],
                'muation': {
                    'self': 'Bigby\'s Hand'
                }
            },
            'Protection from Evil and Good': {
                'name': 'Protection from Evil and Good',
                'version': '0.7.01',
                'settings': [
                    'Protection from Evil and Good'
                ]
            },
            'Chromatic Orb': {
                'name': 'Chromatic Orb',
                'version': '0.7.01'
            },
            'Aura of Vitality': {
                'name': 'Aura of Vitality',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Aura of Vitality'
                }
            },
            'Spike Growth': {
                'name': 'Spike Growth',
                'version': '0.7.01'
            },
            'Mass Cure Wounds': {
                'name': 'Mass Cure Wounds',
                'version': '0.7.01'
            },
            'Earth Tremor': {
                'name': 'Earth Tremor',
                'version': '0.7.01'
            },
            'Charm Person': {
                'name': 'Charm Person',
                'version': '0.7.01'
            },
            'Detect Magic': {
                'name': 'Detect Magic',
                'version': '0.7.01'
            },
            'Eldritch Blast': {
                'name': 'Eldritch Blast',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Summon Aberration': {
                'name': 'Summon Aberration',
                'version': '0.7.01',
                'actors': [
                    'CPR - Aberrant Spirit'
                ]
            },
            'Spirit Guardians': {
                'name': 'Spirit Guardians',
                'version': '0.7.45',
                'hasAnimation': true,
                'settings': [
                    'Movement Listener',
                    'Combat Listener'
                ]
            },
            'Sapping Sting': {
                'name': 'Sapping Sting',
                'version': '0.7.01'
            },
            'Hypnotic Pattern': {
                'name': 'Hypnotic Pattern',
                'version': '0.7.01'
            },
            'Summon Draconic Spirit': {
                'name': 'Summon Draconic Spirit',
                'version': '0.7.01',
                'actors': [
                    'CPR - Draconic Spirit'
                ]
            },
            'Blink': {
                'name': 'Blink',
                'version': '0.7.01'
            },
            'Danse Macabre': {
                'name': 'Danse Macabre',
                'version': '0.7.01',
                'actors': [
                    'CPR - Skeleton',
                    'CPR - Zombie'
                ],
                'mutation': {
                    'self': 'Danse Macabre - Command Undead'
                }
            },
            'Destructive Wave': {
                'name': 'Destructive Wave',
                'version': '0.7.01'
            },
            'Scorching Ray': {
                'name': 'Scorching Ray',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Chain Lightning': {
                'name': 'Chain Lightning',
                'version': '0.7.01'
            },
            'Misty Step': {
                'name': 'Misty Step',
                'version': '0.7.01'
            },
            'Conjure Celestial': {
                'name': 'Conjure Celestial',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Conjure Celestial'
                }
            },
            'Detect Thoughts': {
                'name': 'Detect Thoughts',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Detect Thoughts - Probe Deeper'
                }
            },
            'Wither and Bloom': {
                'name': 'Wither and Bloom',
                'version': '0.7.01'
            },
            'Darkness': {
                'name': 'Darkness',
                'version': '0.7.01',
                'settings': [
                    'Darkness'
                ]
            },
            'Hold Person': {
                'name': 'Hold Person',
                'version': '0.7.01',
                'settings': [
                    'Active Effect Additions'
                ]
            },
            'Shadow of Moil': {
                'name': 'Shadow of Moil',
                'version': '0.7.01',
                'settings': [
                    'Shadow of Moil',
                    'On Hit'
                ]
            },
            'Conjure Minor Elementals': {
                'name': 'Conjure Minor Elementals',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Conjure Minor Elementals'
                }
            },
            'Mind Sliver': {
                'name': 'Mind Sliver',
                'version': '0.7.01'
            },
            'Summon Construct': {
                'name': 'Summon Construct',
                'version': '0.7.01',
                'actors': [
                    'CPR - Construct Spirit'
                ],
                'settings': [
                    'On Hit'
                ]
            },
            'Thunder Step': {
                'name': 'Thunder Step',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Death Ward': {
                'name': 'Death Ward',
                'version': '0.7.01',
                'settings': [
                    'Death Ward'
                ]
            },
            'Conjure Fey': {
                'name': 'Conjure Fey',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Conjure Fey'
                }
            },
            'Hail of Thorns': {
                'name': 'Hail of Thorns',
                'version': '0.7.01'
            },
            'Cloudkill': {
                'name': 'Cloudkill',
                'version': '0.7.01',
                'settings': [
                    'Template Listener'
                ]
            },
            'Melf\'s Acid Arrow': {
                'name': 'Melf\'s Acid Arrow',
                'version': '0.7.01'
            },
            'Shadow Blade': {
                'name': 'Shadow Blade',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Shadow Blade Sword'
                }
            },
            'Warding Bond': {
                'name': 'Warding Bond',
                'version': '0.7.01',
                'settings': [
                    'Warding Bond',
                    'On Hit'
                ]
            },
            'Blade Ward': {
                'name': 'Blade Ward',
                'version': '0.7.01'
            },
            'Summon Elemental': {
                'name': 'Summon Elemental',
                'version': '0.7.16',
                'actors': [
                    'CPR - Elemental Spirit'
                ]
            },
            'Gaseous Form': {
                'name': 'Gaseous Form',
                'version': '0.7.01'
            },
            'Moonbeam': {
                'name': 'Moonbeam',
                'version': '0.7.01',
                'settings': [
                    'Template Listener'
                ],
                'mutation': {
                    'self': 'Moonbeam'
                }
            },
            'Summon Undead': {
                'name': 'Summon Undead',
                'version': '0.7.01',
                'actors': [
                    'CPR - Undead Spirit'
                ]
            },
            'Aura of Purity': {
                'name': 'Aura of Purity',
                'version': '0.7.01',
                'settings': [
                    'Effect Auras'
                ]
            },
            'Holy Weapon': {
                'name': 'Holy Weapon',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Holy Weapon'
                }
            },
            'Guardian of Faith': {
                'name': 'Guardian of Faith',
                'version': '0.7.45',
                'hasAnimation': true,
                'settings': [
                    'Movement Listener',
                    'Combat Listener'
                ],
                'actors': [
                    'CPR - Guardian of Faith'
                ]
            },
            'Magic Missile': {
                'name': 'Magic Missile',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Lightning Arrow': {
                'name': 'Lightning Arrow',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Thorn Whip': {
                'name': 'Thorn Whip',
                'version': '0.7.01'
            },
            'Dragon\'s Breath': {
                'name': 'Dragon\'s Breath',
                'version': '0.7.01'
            },
            'Animate Dead': {
                'name': 'Animate Dead',
                'version': '0.7.01',
                'actors': [
                    'CPR - Skeleton',
                    'CPR - Zombie'
                ]
            },
            'Lightning Lure': {
                'name': 'Lightning Lure',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Spiritual Weapon': {
                'name': 'Spiritual Weapon',
                'version': '0.7.01',
                'actors': [
                    'CPR - Spiritual Weapon'
                ],
                'mutation': {
                    'self': 'Spiritual Weapon'
                }
            },
            'Beacon of Hope': {
                'name': 'Beacon of Hope',
                'version': '0.7.01',
                'settings': [
                    'Beacon of Hope'
                ]
            },
            'Vampiric Touch': {
                'name': 'Vampiric Touch',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Vampiric Touch'
                }
            },
            'Hunter\'s Mark': {
                'name': 'Hunter\'s Mark',
                'version': '0.7.01',
                'mutation': {
                    'self': 'huntersMark'
                }
            },
            'Guiding Bolt': {
                'name': 'Guiding Bolt',
                'version': '0.7.01'
            },
            'Chill Touch': {
                'name': 'Chill Touch',
                'version': '0.7.01'
            },
            'Hex': {
                'name': 'Hex',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Hex'
                }
            },
            'Arms of Hadar': {
                'name': 'Arms of Hadar',
                'version': '0.7.01'
            },
            'Summon Celestial': {
                'name': 'Summon Celestial',
                'version': '0.7.01',
                'actors': [
                    'CPR - Celestial Spirit'
                ]
            },
            'Summon Fiend': {
                'name': 'Summon Fiend',
                'version': '0.7.01',
                'actors': [
                    'CPR - Fiendish Spirit'
                ]
            },
            'Tidal Wave': {
                'name': 'Tidal Wave',
                'version': '0.7.01'
            },
            'Summon Beast': {
                'name': 'Summon Beast',
                'version': '0.7.01',
                'actors': [
                    'CPR - Bestial Spirit'
                ]
            },
            'Bestow Curse': {
                'name': 'Bestow Curse',
                'version': '0.7.01'
            },
            'Fog Cloud': {
                'name': 'Fog Cloud',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Spirit Shroud': {
                'name': 'Spirit Shroud',
                'version': '0.7.01'
            },
            'Call Lightning': {
                'name': 'Call Lightning',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Storm Bolt'
                }
            },
            'Alchemical Savant': {
                'name': 'Alchemical Savant',
                'version': '0.7.01'
            },
            'Experimental Elixir': {
                'name': 'Experimental Elixir',
                'version': '0.7.01'
            },
            'Arcane Armor: Guardian Model': {
                'name': 'Arcane Armor: Guardian Model',
                'version': '0.7.01',
                'settings': [
                    'Rest Listener'
                ]
            },
            'Arcane Armor: Infiltrator Model': {
                'name': 'Arcane Armor: Infiltrator Model',
                'version': '0.7.01',
                'settings': [
                    'Rest Listener'
                ]
            },
            'Arcane Jolt': {
                'name': 'Arcane Jolt',
                'version': '0.7.01',
                'classes': [
                    'battle-smith'
                ],
                'scales': [
                    'arcane-jolt'
                ]
            },
            'Steel Defender': {
                'name': 'Steel Defender',
                'version': '0.7.01',
                'actors': [
                    'CPR - Steel Defender'
                ],
                'mutation': {
                    'self': 'Steel Defender'
                }
            },
            'Homunculus Servant': {
                'name': 'Homunculus Servant',
                'version': '0.7.46',
                'actors': [
                    'CPR - Homunculus Servant'
                ],
                'mutation': {
                    'self': 'Homunculus Servant'
                }
            },
            'Ancestral Protectors': {
                'name': 'Ancestral Protectors',
                'version': '0.7.01'
            },
            'Rage': {
                'name': 'Rage',
                'version': '0.7.45',
                'mutation': {
                    'self': 'Rage'
                },
                'hasAnimation': true,
                'settings': [
                    'On Hit'
                ]
            },
            'Totem Spirit: Bear': {
                'name': 'Totem Spirit: Bear',
                'version': '0.7.33'
            },
            'Danger Sense': {
                'name': 'Danger Sense',
                'version': '0.7.01',
                'settings': [
                    'Save Patching'
                ]
            },
            'Unarmored Defense (Barbarian)': {
                'name': 'Unarmored Defense (Barbarian)',
                'version': '0.7.01'
            },
            'Animating Performance': {
                'name': 'Animating Performance',
                'version': '0.7.01',
                'actors': [
                    'CPR - Dancing Item'
                ],
                'mutation': {
                    'self': 'Dancing Item'
                }
            },
            'Blade Flourish': {
                'name': 'Blade Flourish',
                'version': '0.7.01',
                'classes': [
                    'bard'
                ],
                'scales': [
                    'bardic-inspiration'
                ]
            },
            'Blade Flourish Movement': {
                'name': 'Blade Flourish Movement',
                'version': '0.7.01'
            },
            'Defensive Flourish': {
                'name': 'Defensive Flourish',
                'version': '0.7.01'
            },
            'Mobile Flourish': {
                'name': 'Mobile Flourish',
                'version': '0.7.01'
            },
            'Slashing Flourish': {
                'name': 'Slashing Flourish',
                'version': '0.7.01'
            },
            'Blood Curse of the Fallen Puppet': {
                'name': 'Blood Curse of the Fallen Puppet',
                'version': '0.7.01',
                'classes': [
                    'blood-hunter'
                ],
                'scales': [
                    'crimson-rite'
                ]
            },
            'Blood Curse of the Muddled Mind': {
                'name': 'Blood Curse of the Muddled Mind',
                'version': '0.7.01',
                'classes': [
                    'blood-hunter'
                ],
                'scales': [
                    'crimson-rite'
                ]
            },
            'Hybrid Transformation': {
                'name': 'Hybrid Transformation',
                'version': 'Hybrid Transformation',
                'mutation': {
                    'self': 'Hybrid Transformation'
                },
                'classes': [
                    'blood-hunter'
                ]
            },
            'Stalker\'s Prowess': {
                'name': 'Stalker\'s Prowess',
                'version': '0.7.01'
            },
            'Formulas: Aether': {
                'name': 'Formulas: Aether',
                'version': '0.7.01'
            },
            'Formulas: Alluring': {
                'name': 'Formulas: Alluring',
                'version': '0.7.01'
            },
            'Formulas: Celerity': {
                'name': 'Formulas: Celerity',
                'version': '0.7.01'
            },
            'Formulas: Conversant': {
                'name': 'Formulas: Conversant',
                'version': '0.7.01'
            },
            'Formulas: Cruelty': {
                'name': 'Formulas: Cruelty',
                'version': '0.7.01'
            },
            'Formulas: Deftness': {
                'name': 'Formulas: Deftness',
                'version': '0.7.01'
            },
            'Formulas: Embers': {
                'name': 'Formulas: Embers',
                'version': '0.7.01'
            },
            'Formulas: Gelid': {
                'name': 'Formulas: Gelid',
                'version': '0.7.01'
            },
            'Formulas: Impermeable': {
                'name': 'Formulas: Impermeable',
                'version': '0.7.01'
            },
            'Formulas: Mobility': {
                'name': 'Formulas: Mobility',
                'version': '0.7.01'
            },
            'Formulas: Nighteye': {
                'name': 'Formulas: Nighteye',
                'version': '0.7.01'
            },
            'Formulas: Percipient': {
                'name': 'Formulas: Percipient',
                'version': '0.7.01'
            },
            'Formulas: Potency': {
                'name': 'Formulas: Potency',
                'version': '0.7.01'
            },
            'Formulas: Precision': {
                'name': 'Formulas: Precision',
                'version': '0.7.01'
            },
            'Formulas: Rapidity': {
                'name': 'Formulas: Rapidity',
                'version': '0.7.01'
            },
            'Formulas: Reconstruction': {
                'name': 'Formulas: Reconstruction',
                'version': '0.7.01'
            },
            'Formulas: Sagacity': {
                'name': 'Formulas: Sagacity',
                'version': '0.7.01'
            },
            'Formulas: Shielded': {
                'name': 'Formulas: Shielded',
                'version': '0.7.01'
            },
            'Formulas: Unbreakable': {
                'name': 'Formulas: Unbreakable',
                'version': '0.7.01'
            },
            'Formulas: Vermillion': {
                'name': 'Formulas: Vermillion',
                'version': '0.7.01'
            },
            'Mutagencraft - Create Mutagen': {
                'name': 'Mutagencraft - Create Mutagen',
                'version': '0.7.01'
            },
            'Strange Metabolism': {
                'name': 'Strange Metabolism',
                'version': '0.7.01'
            },
            'Brand of Castigation': {
                'name': 'Brand of Castigation',
                'version': '0.7.01',
                'classes': [
                    'blood-hunter'
                ],
                'scales': [
                    'crimson-rite'
                ]
            },
            'Crimson Rite': {
                'name': 'Crimson Rite',
                'version': '0.7.01',
                'classes': [
                    'blood-hunter'
                ],
                'scales': [
                    'crimson-rite'
                ]
            },
            'Reaper': {
                'name': 'Reaper',
                'version': '0.7.01'
            },
            'Blessing of the Forge': {
                'name': 'Blessing of the Forge',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Blessing of the Forge'
                }
            },
            'Channel Divinity: Path to the Grave': {
                'name': 'Channel Divinity: Path to the Grave',
                'version': '0.7.01'
            },
            'Circle of Mortality': {
                'name': 'Circle of Mortality',
                'version': '0.7.01'
            },
            'Channel Divinity: Preserve Life': {
                'name': 'Channel Divinity: Preserve Life',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Channel Divinity: Radiance of the Dawn': {
                'name': 'Channel Divinity: Radiance of the Dawn',
                'version': '0.7.01'
            },
            'Channel Divinity: Balm of Peace': {
                'name': 'Channel Divinity: Balm of Peace',
                'version': '0.7.01'
            },
            'Emboldening Bond': {
                'name': 'Emboldening Bond',
                'version': '0.7.01',
                'settings': [
                    'Emboldening Bond'
                ]
            },
            'Expansive Bond': {
                'name': 'Expansive Bond',
                'version': '0.7.01',
                'settings': [
                    'Emboldening Bond'
                ]
            },
            'Protective Bond': {
                'name': 'Protective Bond',
                'version': '0.7.01',
                'settings': [
                    'Emboldening Bond'
                ]
            },
            'Channel Divinity: Destructive Wrath': {
                'name': 'Channel Divinity: Destructive Wrath',
                'version': '0.7.01'
            },
            'Thunderbolt Strike': {
                'name': 'Thunderbolt Strike',
                'version': '0.7.01'
            },
            'Wrath of the Storm': {
                'name': 'Wrath of the Storm',
                'version': '0.7.01'
            },
            'Channel Divinity: Twilight Sanctuary': {
                'name': 'Channel Divinity: Twilight Sanctuary',
                'version': '0.9.63'
            },
            'Eyes of Night': {
                'name': 'Eyes of Night',
                'version': '0.7.01'
            },
            'Steps of Night': {
                'name': 'Steps of Night',
                'version': '0.7.01'
            },
            'Vigilant Blessing': {
                'name': 'Vigilant Blessing',
                'version': '0.7.01'
            },
            'Blessed Strikes': {
                'name': 'Blessed Strikes',
                'version': '0.7.01'
            },
            'Channel Divinity: Turn Undead': {
                'name': 'Channel Divinity: Turn Undead',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Divine Strike': {
                'name': 'Divine Strike',
                'version': '0.7.01'
            },
            'Potent Spellcasting': {
                'name': 'Potent Spellcasting',
                'version': '0.7.01'
            },
            'Starry Form': {
                'name': 'Starry Form',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Starry Form'
                },
                'scales': [
                    'circle-of-stars'
                ],
                'classes': [
                    'druid'
                ]
            },
            'Twinkling Constellations': {
                'name': 'Twinkling Constellations',
                'version': '0.7.01'
            },
            'Summon Wildfire Spirit': {
                'name': 'Summon Wildfire Spirit',
                'version': '0.7.01',
                'actors': [
                    'CPR - Wildfire Spirit'
                ],
                'classes': [
                    'druid'
                ],
                'mutation': {
                    'self': 'Wildfire Spirit'
                }
            },
            'Primal Strike': {
                'name': 'Primal Strike',
                'version': '0.7.01'
            },
            'Wild Shape': {
                'name': 'Wild Shape',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Wild Shape'
                }
            },
            'Maneuvers: Ambush': {
                'name': 'Maneuvers: Ambush',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Bait and Switch': {
                'name': 'Maneuvers: Bait and Switch',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Brace': {
                'name': 'Maneuvers: Brace',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Commander\'s Strike': {
                'name': 'Maneuvers: Commander\'s Strike',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Disarming Attack': {
                'name': 'Maneuvers: Disarming Attack',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Distracting Strike': {
                'name': 'Maneuvers: Distracting Strike',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Evasive Footwork': {
                'name': 'Maneuvers: Evasive Footwork',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Feinting Attack': {
                'name': 'Maneuvers: Feinting Attack',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Goading Attack': {
                'name': 'Maneuvers: Goading Attack',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Grappling Strike': {
                'name': 'Maneuvers: Grappling Strike',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Lunging Attack': {
                'name': 'Maneuvers: Lunging Attack',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Maneuvering Attack': {
                'name': 'Maneuvers: Maneuvering Attack',
                'version': '0.9.35',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Menacing Attack': {
                'name': 'Maneuvers: Menacing Attack',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Parry': {
                'name': 'Maneuvers: Parry',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Precision Attack': {
                'name': 'Maneuvers: Precision Attack',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Pushing Attack': {
                'name': 'Maneuvers: Pushing Attack',
                'version': '0.7.39',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Quick Toss': {
                'name': 'Maneuvers: Quick Toss',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Rally': {
                'name': 'Maneuvers: Rally',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Riposte': {
                'name': 'Maneuvers: Riposte',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Sweeping Attack': {
                'name': 'Maneuvers: Sweeping Attack',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Tactical Assessment': {
                'name': 'Maneuvers: Tactical Assessment',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Maneuvers: Trip Attack': {
                'name': 'Maneuvers: Trip Attack',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Superiority Dice': {
                'name': 'Superiority Dice',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'combat-superiority-die'
                ]
            },
            'Fighting Spirit': {
                'name': 'Fighting Spirit',
                'version': '0.7.01',
                'classes': [
                    'fighter'
                ],
                'scales': [
                    'fighting-spirit'
                ]
            },
            'Shadow Step': {
                'name': 'Shadow Step',
                'version': '0.7.01'
            },
            'Evasion': {
                'name': 'Evasion',
                'version': '0.7.01'
            },
            'Focused Aim': {
                'name': 'Focused Aim',
                'version': '0.7.01'
            },
            'Patient Defense': {
                'name': 'Patient Defense',
                'version': '0.7.01'
            },
            'Quickened Healing': {
                'name': 'Quickened Healing',
                'version': '0.7.01',
                'classes': [
                    'monk'
                ],
                'scales': [
                    'quickened-healing'
                ]
            },
            'Stillness of Mind': {
                'name': 'Stillness of Mind',
                'version': '0.7.01'
            },
            'Stunning Strike': {
                'name': 'Stunning Strike',
                'version': '0.9.16'
            },
            'Unarmored Defense (Monk)': {
                'name': 'Unarmored Defense (Monk)',
                'version': '0.7.01'
            },
            'Aura of Alacrity': {
                'name': 'Aura of Alacrity',
                'version': '0.7.01'
            },
            'Channel Divinity: Inspiring Smite': {
                'name': 'Channel Divinity: Inspiring Smite',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Channel Divinity: Peerless Athlete': {
                'name': 'Channel Divinity: Peerless Athlete',
                'version': '0.7.01'
            },
            'Aura of Warding': {
                'name': 'Aura of Warding',
                'version': '0.9.4',
                'settings': [
                    'Effect Auras'
                ]
            },
            'Aura of Courage': {
                'name': 'Aura of Courage',
                'version': '0.7.01',
                'settings': [
                    'Effect Auras'
                ]
            },
            'Aura of Protection': {
                'name': 'Aura of Protection',
                'version': '0.7.01',
                'settings': [
                    'Effect Auras'
                ]
            },
            'Divine Smite': {
                'name': 'Divine Smite',
                'version': '0.7.01'
            },
            'Primal Companion': {
                'name': 'Primal Companion',
                'version': '0.7.01',
                'actors': [
                    'CPR - Primal Companion'
                ],
                'mutation': {
                    'self': 'Primal Companion'
                }
            },
            'Drake Companion: Summon': {
                'name': 'Drake Companion: Summon',
                'version': '0.7.01',
                'actors': [
                    'CPR - Drake Companion'
                ],
                'mutation': {
                    'self': 'Drake Companion'
                }
            },
            'Beguiling Twist': {
                'name': 'Beguiling Twist',
                'version': '0.7.01'
            },
            'Dreadful Strikes': {
                'name': 'Dreadful Strikes',
                'version': '0.7.01',
                'classes': [
                    'ranger'
                ],
                'scales': [
                    'dreadful-strikes'
                ]
            },
            'Dread Ambusher': {
                'name': 'Dread Ambusher',
                'version': '0.9.27'
            },
            'Favored Foe': {
                'name': 'Favored Foe',
                'version': '0.7.01',
                'classes': [
                    'ranger'
                ],
                'scales': [
                    'favored-foe'
                ]
            },
            'Rakish Audacity': {
                'name': 'Rakish Audacity',
                'version': '0.7.01'
            },
            'Evasion': {
                'name': 'Evasion',
                'version': '0.7.01'
            },
            'Sneak Attack': {
                'name': 'Sneak Attack',
                'version': '0.7.46'
            },
            'Favored by the Gods': {
                'name': 'Favored by the Gods',
                'version': '0.8.23'
            },
            'Metamagic - Careful Spell': {
                'name': 'Metamagic - Careful Spell',
                'version': '0.7.01'
            },
            'Metamagic - Twinned Spell': {
                'name': 'Metamagic - Twinned Spell',
                'version': '0.7.01'
            },
            'Metamagic - Transmuted Spell': {
                'name': 'Metamagic - Transmuted Spell',
                'version': '0.7.01'
            },
            'Metamagic - Seeking Spell': {
                'name': 'Metamagic - Seeking Spell',
                'version': '0.7.01'
            },
            'Metamagic - Heightened Spell': {
                'name': 'Metamagic - Heightened Spell',
                'version': '0.7.01'
            },
            'Metamagic - Empowered Spell': {
                'name': 'Metamagic - Empowered Spell',
                'version': '0.7.01'
            },
            'Strength of the Grave': {
                'name': 'Strength of the Grave',
                'version': '0.7.01',
                'settings': [
                    'Strength of the Grave'
                ]
            },
            'Heart of the Storm': {
                'name': 'Heart of the Storm',
                'version': '0.7.01'
            },
            'Sorcery Points': {
                'name': 'Sorcery Points',
                'version': '0.7.01'
            },
            'Devil\'s Sight': {
                'name': 'Devil\'s Sight',
                'version': '0.7.01'
            },
            'Eldritch Invocations: Agonizing Blast': {
                'name': 'Eldritch Invocations: Agonizing Blast',
                'version': '0.7.01'
            },
            'Eldritch Invocations: Grasp of Hadar': {
                'name': 'Eldritch Invocations: Grasp of Hadar',
                'version': '0.7.01'
            },
            'Eldritch Invocations: Repelling Blast': {
                'name': 'Eldritch Invocations: Repelling Blast',
                'version': '0.7.01'
            },
            'Eldritch Smite': {
                'name': 'Eldritch Smite',
                'version': '0.7.01'
            },
            'Maddening Hex': {
                'name': 'Maddening Hex',
                'version': '0.7.01'
            },
            'One with Shadows': {
                'name': 'One with Shadows',
                'version': '0.7.01'
            },
            'Relentless Hex': {
                'name': 'Relentless Hex',
                'version': '0.7.01'
            },
            'Fey Presence': {
                'name': 'Fey Presence',
                'version': '0.7.01'
            },
            'Misty Escape': {
                'name': 'Misty Escape',
                'version': '0.7.01'
            },
            'Healing Light': {
                'name': 'Healing Light',
                'version': '0.7.01'
            },
            'Radiant Soul': {
                'name': 'Radiant Soul',
                'version': '0.7.01'
            },
            'Tentacle of the Deeps: Summon': {
                'name': 'Tentacle of the Deeps: Summon',
                'version': '0.7.01',
                'actors': [
                    'CPR - Spectral Tentacle'
                ],
                'mutation': {
                    'self': 'Tentacle of the Deeps'
                }
            },
            'Dark One\'s Blessing': {
                'name': 'Dark One\'s Blessing',
                'version': '0.7.01'
            },
            'Dark One\'s Own Luck': {
                'name': 'Dark One\'s Own Luck',
                'version': '0.7.01'
            },
            'Elemental Gift - Flight': {
                'name': 'Elemental Gift - Flight',
                'version': '0.9.43'
            },
            'Elemental Gift: Elemental Gift (Dao)': {
                'name': 'Elemental Gift: Elemental Gift (Dao)',
                'version': '0.7.01'
            },
            'Elemental Gift: Elemental Gift (Djinni)': {
                'name': 'Elemental Gift: Elemental Gift (Djinni)',
                'version': '0.7.01'
            },
            'Elemental Gift: Elemental Gift (Efreeti)': {
                'name': 'Elemental Gift: Elemental Gift (Efreeti)',
                'version': '0.7.01'
            },
            'Elemental Gift: Elemental Gift (Marid)': {
                'name': 'Elemental Gift: Elemental Gift (Marid)',
                'version': '0.7.01'
            },
            'Genie\'s Vessel: Genie\'s Wrath (Dao)': {
                'name': 'Genie\'s Vessel: Genie\'s Wrath (Dao)',
                'version': '0.8.19'
            },
            'Genie\'s Vessel: Genie\'s Wrath (Djinni)': {
                'name': 'Genie\'s Vessel: Genie\'s Wrath (Djinni)',
                'version': '0.8.19'
            },
            'Genie\'s Vessel: Genie\'s Wrath (Efreeti)': {
                'name': 'Genie\'s Vessel: Genie\'s Wrath (Efreeti)',
                'version': '0.8.19'
            },
            'Genie\'s Vessel: Genie\'s Wrath (Marid)': {
                'name': 'Genie\'s Vessel: Genie\'s Wrath (Marid)',
                'version': '0.8.19'
            },
            'Hexblade\'s Curse': {
                'name': 'Hexblade\'s Curse',
                'version': '0.7.01',
                'classes': [
                    'warlock'
                ]
            },
            'Form of Dread': {
                'name': 'Form of Dread',
                'version': '0.7.38'
            },
            'Form of Dread: Fear': {
                'name': 'Form of Dread: Fear',
                'version': '0.7.38'
            },
            'Grave Touched': {
                'name': 'Grave Touched',
                'version': '0.7.38'
            },
            'Awakened Spellbook: Replace Damage': {
                'name': 'Awakened Spellbook: Replace Damage',
                'version': '0.7.01'
            },
            'Arcane Ward': {
                'name': 'Arcane Ward',
                'version': '0.7.34',
                'settings': [
                    'Rest Listener',
                    'Arcane Ward'
                ]
            },
            'Projected Ward': {
                'name': 'Projected Ward',
                'version': '0.7.01',
                'settings': [
                    'Arcane Ward'
                ]
            },
            'Expert Divination': {
                'name': 'Expert Divination',
                'version': '0.7.07'
            },
            'Grim Harvest': {
                'name': 'Grim Harvest',
                'version': '0.7.01'
            },
            'Undead Thralls': {
                'name': 'Undead Thralls',
                'version': '0.7.01'
            },
            'Elixir of Health': {
                'name': 'Elixir of Health',
                'version': '0.7.01'
            },
            'Oil of Sharpness': {
                'name': 'Oil of Sharpness',
                'version': '0.7.01'
            },
            'Potion of Advantage': {
                'name': 'Potion of Advantage',
                'version': '0.7.01'
            },
            'Potion of Aqueous Form': {
                'name': 'Potion of Aqueous Form',
                'version': '0.7.01'
            },
            'Potion of Diminution': {
                'name': 'Potion of Diminution',
                'version': '0.7.01'
            },
            'Potion of Fire Breath': {
                'name': 'Potion of Fire Breath',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Potion of Fire Breath'
                }
            },
            'Potion of Giant Size': {
                'name': 'Potion of Giant Size',
                'version': '0.7.01'
            },
            'Potion of Growth': {
                'name': 'Potion of Growth',
                'version': '0.7.01'
            },
            'Potion of Heroism': {
                'name': 'Potion of Heroism',
                'version': '0.7.01'
            },
            'Potion of Invisibility': {
                'name': 'Potion of Invisibility',
                'version': '0.7.01'
            },
            'Potion of Invulnerability': {
                'name': 'Potion of Invulnerability',
                'version': '0.7.01'
            },
            'Potion of Maximum Power': {
                'name': 'Potion of Maximum Power',
                'version': '0.7.01'
            },
            'Potion of Poison': {
                'name': 'Potion of Poison',
                'version': '0.7.01'
            },
            'Potion of Speed': {
                'name': 'Potion of Speed',
                'version': '0.7.01'
            },
            'Potion of Vitality': {
                'name': 'Potion of Vitality',
                'version': '0.7.01'
            },
            'Ring of Spell Storing (0/5)': {
                'name': 'Ring of Spell Storing (0/5)',
                'version': '0.7.01'
            },
            'Boots of Elvenkind': {
                'name': 'Boots of Elvenkind',
                'version': '0.7.01'
            },
            'Dragon Vessel (Ascendant)': {
                'name': 'Dragon Vessel (Ascendant)',
                'version': '0.7.01'
            },
            'Dragon Vessel (Slumbering)': {
                'name': 'Dragon Vessel (Slumbering)',
                'version': '0.7.01'
            },
            'Dragon Vessel (Stirring)': {
                'name': 'Dragon Vessel (Stirring)',
                'version': '0.7.01'
            },
            'Dragon Vessel (Wakened)': {
                'name': 'Dragon Vessel (Wakened)',
                'version': '0.7.01'
            },
            'Dragon-Touched Focus (Slumbering)': {
                'name': 'Dragon-Touched Focus (Slumbering)',
                'version': '0.7.01'
            },
            'Dragon-Touched Focus (Stirring / Chromatic)': {
                'name': 'Dragon-Touched Focus (Stirring / Chromatic)',
                'version': '0.7.01'
            },
            'Dragon-Touched Focus (Stirring / Gem)': {
                'name': 'Dragon-Touched Focus (Stirring / Gem)',
                'version': '0.7.01'
            },
            'Eyes of Minute Seeing': {
                'name': 'Eyes of Minute Seeing',
                'version': '0.7.01',
                'settings': [
                    'Skill Patching'
                ]
            },
            'Eyes of the Eagle': {
                'name': 'Eyes of the Eagle',
                'version': '0.7.01',
                'settings': [
                    'Skill Patching'
                ]
            },
            'Lantern of Revealing': {
                'name': 'Lantern of Revealing',
                'version': '0.7.01',
                'settings': [
                    'Effect Auras'
                ]
            },
            'Stormgirdle (Awakened)': {
                'name': 'Stormgirdle (Awakened)',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Storm Avatar'
                }
            },
            'Stormgirdle (Dormant)': {
                'name': 'Stormgirdle (Dormant)',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Storm Avatar'
                }
            },
            'Stormgirdle (Exalted)': {
                'name': 'Stormgirdle (Exalted)',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Storm Avatar'
                }
            },
            'Blackrazor': {
                'name': 'Blackrazor',
                'version': '0.7.01',
                'settings': [
                    'On Hit'
                ]
            },
            'Dancing Greatsword': {
                'name': 'Dancing Greatsword',
                'version': '0.7.01',
                'actors': [
                    'CPR - Dancing Sword'
                ],
                'mutation': {
                    'self': 'Dancing Sword'
                }
            },
            'Dancing Greatsword': {
                'name': 'Dancing Greatsword',
                'version': '0.7.01',
                'actors': [
                    'CPR - Dancing Sword'
                ],
                'mutation': {
                    'self': 'Dancing Sword'
                }
            },
            'Dancing Longsword': {
                'name': 'Dancing Longsword',
                'version': '0.7.01',
                'actors': [
                    'CPR - Dancing Sword'
                ],
                'mutation': {
                    'self': 'Dancing Sword'
                }
            },
            'Dancing Rapier': {
                'name': 'Dancing Rapier',
                'version': '0.7.01',
                'actors': [
                    'CPR - Dancing Sword'
                ],
                'mutation': {
                    'self': 'Dancing Sword'
                }
            },
            'Dancing Scimitar': {
                'name': 'Dancing Scimitar',
                'version': '0.7.01',
                'actors': [
                    'CPR - Dancing Sword'
                ],
                'mutation': {
                    'self': 'Dancing Sword'
                }
            },
            'Dancing Shortsword': {
                'name': 'Dancing Shortsword',
                'version': '0.7.01',
                'actors': [
                    'CPR - Dancing Sword'
                ],
                'mutation': {
                    'self': 'Dancing Sword'
                }
            },
            'Dragon\'s Wrath Weapon (Ascendant)': {
                'name': 'Dragon\'s Wrath Weapon (Ascendant)',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Dragon\'s Wrath Weapon (Slumbering)': {
                'name': 'Dragon\'s Wrath Weapon (Slumbering)',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Dragon\'s Wrath Weapon (Stirring)': {
                'name': 'Dragon\'s Wrath Weapon (Stirring)',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Dragon\'s Wrath Weapon (Wakened)': {
                'name': 'Dragon\'s Wrath Weapon (Wakened)',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Grovelthrash (Awakened)': {
                'name': 'Grovelthrash (Awakened)',
                'version': '0.7.01'
            },
            'Grovelthrash (Dormant)': {
                'name': 'Grovelthrash (Dormant)',
                'version': '0.7.01'
            },
            'Grovelthrash (Exalted)': {
                'name': 'Grovelthrash (Exalted)',
                'version': '0.7.01'
            },
            'Blood Spear': {
                'name': 'Blood Spear',
                'version': '0.7.01'
            },
            'Insignia of Claws': {
                'name': 'Insignia of Claws',
                'version': '0.7.01'
            },
            'Celestial Revelation (Necrotic Shroud)': {
                'name': 'Celestial Revelation (Necrotic Shroud)',
                'version': '0.7.01'
            },
            'Celestial Revelation (Radiant Consumption)': {
                'name': 'Celestial Revelation (Radiant Consumption)',
                'version': '0.7.53'
            },
            'Celestial Revelation (Radiant Soul)': {
                'name': 'Celestial Revelation (Radiant Soul)',
                'version': '0.7.53'
            },
            'Astral Trance': {
                'name': 'Astral Trance',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Trance'
                }
            },
            'Fey Ancestry': {
                'name': 'Fey Ancestry',
                'version': '0.7.01',
                'settings': [
                    'Condition Resistance'
                ]
            },
            'Starlight Step': {
                'name': 'Starlight Step',
                'version': '0.8.23'
            },
            'Vampiric Bite': {
                'name': 'Vampiric Bite',
                'version': '0.7.01'
            },
            'Dwarven Resilience': {
                'name': 'Dwarven Resilience',
                'version': '0.7.01',
                'settings': [
                    'Condition Resistance'
                ]
            },
            'Change Season': {
                'name': 'Change Season',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Eladrin Season'
                }
            },
            'Fey Step': {
                'name': 'Fey Step',
                'version': '0.7.01'
            },
            'Cunning Intuition': {
                'name': 'Cunning Intuition',
                'version': '0.7.01'
            },
            'Incisive Sense': {
                'name': 'Incisive Sense',
                'version': '0.7.01'
            },
            'Astral Spark': {
                'name': 'Astral Spark',
                'version': '0.7.01'
            },
            'Gnome Cunning': {
                'name': 'Gnome Cunning',
                'version': '0.7.01'
            },
            'Deductive Intuition': {
                'name': 'Deductive Intuition',
                'version': '0.7.01'
            },
            'Savage Attacks': {
                'name': 'Savage Attacks',
                'version': '0.7.35'
            },
            'Artisan\'s Intuition': {
                'name': 'Artisan\'s Intuition',
                'version': '0.7.01'
            },
            'Dual Mind': {
                'name': 'Dual Mind',
                'version': '0.7.01'
            },
            'Hungry Jaws': {
                'name': 'Hungry Jaws',
                'version': '0.7.01'
            },
            'Relentless Endurance': {
                'name': 'Relentless Endurance',
                'version': '0.7.01',
                'settings': [
                    'Relentless Endurance'
                ]
            },
            'Natural Resilience': {
                'name': 'Natural Resilience',
                'version': '0.7.01',
                'settings': [
                    'Condition Resistance'
                ]
            },
            'Blessing of the Raven Queen': {
                'name': 'Blessing of the Raven Queen',
                'version': '0.7.01'
            },
            'Shift - Wildhunt': {
                'name': 'Shift - Wildhunt',
                'version': '0.7.01',
                'settings': [
                    'Wildhunt'
                ]
            },
            'Telepathic Insight': {
                'name': 'Telepathic Insight',
                'version': '0.7.01'
            },
            'Constructed Resilience': {
                'name': 'Constructed Resilience',
                'version': '0.7.01',
                'settings': [
                    'Condition Resistance'
                ]
            },
            'Crusher: Critical': {
                'name': 'Crusher: Critical',
                'version': '0.7.01'
            },
            'Elemental Adept (Acid)': {
                'name': 'Elemental Adept (Acid)',
                'version': '0.7.01',
                'settings': [
                    'Elemental Adept'
                ]
            },
            'Elemental Adept (Cold)': {
                'name': 'Elemental Adept (Cold)',
                'version': '0.7.01',
                'settings': [
                    'Elemental Adept'
                ]
            },
            'Elemental Adept (Fire)': {
                'name': 'Elemental Adept (Fire)',
                'version': '0.7.01',
                'settings': [
                    'Elemental Adept'
                ]
            },
            'Elemental Adept (Lightning)': {
                'name': 'Elemental Adept (Lightning)',
                'version': '0.7.01',
                'settings': [
                    'Elemental Adept'
                ]
            },
            'Elemental Adept (Thunder)': {
                'name': 'Elemental Adept (Thunder)',
                'version': '0.7.01',
                'settings': [
                    'Elemental Adept'
                ]
            },
            'Ember of the Fire Giant: Searing Ignition': {
                'name': 'Ember of the Fire Giant: Searing Ignition',
                'version': '0.7.01'
            },
            'Fury of the Frost Giant: Frigid Retaliation': {
                'name': 'Fury of the Frost Giant: Frigid Retaliation',
                'version': '0.7.01'
            },
            'Gift of the Chromatic Dragon: Chromatic Infusion': {
                'name': 'Gift of the Chromatic Dragon: Chromatic Infusion',
                'version': '0.7.01',
                'mutation': {
                    'self': 'Chromatic Infusion'
                }
            },
            'Gift of the Chromatic Dragon: Reactive Resistance': {
                'name': 'Gift of the Chromatic Dragon: Reactive Resistance',
                'version': '0.7.01'
            },
            'Guile of the Cloud Giant: Cloudy Escape': {
                'name': 'Guile of the Cloud Giant: Cloudy Escape',
                'version': '0.7.01'
            },
            'Keenness of the Stone Giant: Stone Throw': {
                'name': 'Keenness of the Stone Giant: Stone Throw',
                'version': '0.7.01'
            },
            'Orcish Fury - Extra Damage': {
                'name': 'Orcish Fury - Extra Damage',
                'version': '0.7.01'
            },
            'Piercer: Critical Hit': {
                'name': 'Piercer: Critical Hit',
                'version': '0.7.01'
            },
            'Piercer: Reroll Damage': {
                'name': 'Piercer: Reroll Damage',
                'version': '0.7.01'
            },
            'Slasher: Critical Hit': {
                'name': 'Slasher: Critical Hit',
                'version': '0.7.01'
            },
            'Slasher: Reduce Speed': {
                'name': 'Slasher: Reduce Speed',
                'version': '0.7.01'
            },
            'Strike of the Giants: Cloud Strike': {
                'name': 'Strike of the Giants: Cloud Strike',
                'version': '0.7.01'
            },
            'Strike of the Giants: Fire Strike': {
                'name': 'Strike of the Giants: Fire Strike',
                'version': '0.7.01'
            },
            'Strike of the Giants: Frost Strike': {
                'name': 'Strike of the Giants: Frost Strike',
                'version': '0.7.01'
            },
            'Strike of the Giants: Hill Strike': {
                'name': 'Strike of the Giants: Hill Strike',
                'version': '0.7.01'
            },
            'Strike of the Giants: Stone Strike': {
                'name': 'Strike of the Giants: Stone Strike',
                'version': '0.7.01'
            },
            'Strike of the Giants: Storm Strike': {
                'name': 'Strike of the Giants: Storm Strike',
                'version': '0.7.01'
            },
            'Telekinetic: Shove': {
                'name': 'Telekinetic: Shove',
                'version': '0.7.01'
            },
            'Vigor of the Hill Giant: Bulwark': {
                'name': 'Vigor of the Hill Giant: Bulwark',
                'version': '0.7.01'
            },
            'Dash': {
                'name': 'Dash',
                'version': '0.7.01'
            },
            'Disengage': {
                'name': 'Disengage',
                'version': '0.7.01'
            },
            'Dodge': {
                'name': 'Dodge',
                'version': '0.7.01'
            },
            'Fall': {
                'name': 'Fall',
                'version': '0.8.17'
            },
            'Grapple': {
                'name': 'Grapple',
                'version': '0.8.17'
            },
            'Help': {
                'name': 'Help',
                'version': '0.8.17'
            },
            'Hide': {
                'name': 'Hide',
                'version': '0.8.17'
            },
            'Ready Action': {
                'name': 'Ready Action',
                'version': '0.7.01'
            },
            'Ready Spell': {
                'name': 'Ready Spell',
                'version': '0.7.01'
            },
            'Search': {
                'name': 'Search',
                'version': '0.8.17'
            },
            'Shove': {
                'name': 'Shove',
                'version': '0.8.17'
            },
            'Durable Magic': {
                'name': 'Durable Magic',
                'version': '0.7.02'
            },
            'Find Familiar': {
                'name': 'Find Familiar',
                'version': '0.7.03',
                'mutation': {
                    'self': 'Find Familiar'
                }
            },
            'Eldritch Invocations: Investment of the Chain Master': {
                'name': 'Eldritch Invocations: Investment of the Chain Master',
                'version': '0.7.03',
            },
            'Underwater': {
                'name': 'Underwater',
                'version': '0.8.17'
            },
            'Squeeze': {
                'name': 'Squeeze',
                'version': '0.7.03'
            },
            'Shield of Faith': {
                'name': 'Shield of Faith',
                'version': '0.7.03'
            },
            'Grease': {
                'name': 'Grease',
                'version': '0.7.04',
                'settings': [
                    'Template Listener'
                ]
            },
            'Dash': {
                'name': 'Dash',
                'version': '0.7.11'
            },
            'Disengage': {
                'name': 'Disengage',
                'version': '0.7.11'
            },
            'Dodge': {
                'name': 'Dodge',
                'version': '0.7.11'
            },
            'Fall': {
                'name': 'Fall',
                'version': '0.7.11'
            },
            'Grapple': {
                'name': 'Grapple',
                'version': '0.7.11'
            },
            'Help': {
                'name': 'Help',
                'version': '0.7.11'
            },
            'Hide': {
                'name': 'Hide',
                'version': '0.7.11'
            },
            'Ready Action': {
                'name': 'Ready Action',
                'version': '0.7.11'
            },
            'Ready Spell': {
                'name': 'Ready Spell',
                'version': '0.7.11'
            },
            'Search': {
                'name': 'Search',
                'version': '0.7.11'
            },
            'Shove': {
                'name': 'Shove',
                'version': '0.7.11'
            },
            'Squeeze': {
                'name': 'Squeeze',
                'version': '0.7.11'
            },
            'Underwater': {
                'name': 'Underwater',
                'version': '0.7.11'
            },
            'Sculpt Spells': {
                'name': 'Sculpt Spells',
                'version': '0.7.12'
            },
            'Potent Cantrip': {
                'name': 'Potent Cantrip',
                'version': '0.7.12'
            },
            'Empowered Evocation': {
                'name': 'Empowered Evocation',
                'version': '0.9.9'
            },
            'Overchannel': {
                'name': 'Overchannel',
                'version': '0.7.12'
            },
            'Aura of Devotion': {
                'name': 'Aura of Devotion',
                'version': '0.7.13',
                'settings': [
                    'Effect Auras'
                ]
            },
            'Channel Divinity: Sacred Weapon': {
                'name': 'Channel Divinity: Sacred Weapon',
                'version': '0.7.13',
                'mutation': {
                    'self': 'Sacred Weapon'
                }
            },
            'Holy Nimbus': {
                'name': 'Holy Nimbus',
                'version': '0.7.13',
                'settings': [
                    'Save Patching'
                ]
            },
            'Purity of Spirit': {
                'name': 'Purity of Spirit',
                'version': '0.7.13',
                'settings': [
                    'Protection from Evil and Good'
                ]
            },
            'Crystal Greatsword': {
                'name': 'Crystal Greatsword',
                'version': '0.9.9'
            },
            'Crystal Longsword': {
                'name': 'Crystal Longsword',
                'version': '0.9.9'
            },
            'Crystal Rapier': {
                'name': 'Crystal Rapier',
                'version': '0.9.9'
            },
            'Crystal Scimitar': {
                'name': 'Crystal Scimitar',
                'version': '0.9.9'
            },
            'Crystal Shortsword': {
                'name': 'Crystal Shortsword',
                'version': '0.9.9'
            },
            'Find Steed': {
                'name': 'Find Steed',
                'version': '0.7.14'
            },
            'Find Greater Steed': {
                'name': 'Find Greater Steed',
                'version': '0.7.14'
            },
            'Arcane Propulsion Armor': {
                'name': 'Arcane Propulsion Armor',
                'version': '0.7.14'
            },
            'Armor of Magical Strength': {
                'name': 'Armor of Magical Strength',
                'version': '0.7.14'
            },
            'Boots of the Winding Path': {
                'name': 'Boots of the Winding Path',
                'version': '0.7.15'
            },
            'Wand of the War Mage, +1': {
                'name': 'Wand of the War Mage, +1',
                'version': '0.7.15'
            },
            'Wand of the War Mage, +2': {
                'name': 'Wand of the War Mage, +2',
                'version': '0.7.15'
            },
            'Wand of the War Mage, +3': {
                'name': 'Wand of the War Mage, +3',
                'version': '0.7.15'
            },
            'Enhanced Arcane Focus, +1': {
                'name': 'Enhanced Arcane Focus, +1',
                'version': '0.7.15'
            },
            'Enhanced Arcane Focus, +2': {
                'name': 'Enhanced Arcane Focus, +2',
                'version': '0.7.15'
            },
            'Enhanced Weapon, +1': {
                'name': 'Enhanced Weapon, +1',
                'version': '0.7.16'
            },
            'Enhanced Weapon, +2': {
                'name': 'Enhanced Weapon, +2',
                'version': '0.7.16'
            },
            'Radiant Weapon': {
                'name': 'Radiant Weapon',
                'version': '0.9.24'
            },
            'Repeating Shot': {
                'name': 'Repeating Shot',
                'version': '0.7.18'
            },
            'Repulsion Shield': {
                'name': 'Repulsion Shield',
                'version': '0.7.18'
            },
            'Resistant Armor': {
                'name': 'Resistant Armor',
                'version': '0.7.18'
            },
            'Returning Weapon': {
                'name': 'Returning Weapon',
                'version': '0.7.18'
            },
            'Backbreaker': {
                'name': 'Backbreaker',
                'version': '0.8.28'
            },
            'Brace': {
                'name': 'Brace',
                'version': '0.8.28'
            },
            'Cleave': {
                'name': 'Cleave',
                'version': '0.8.28'
            },
            'Concussive Smash': {
                'name': 'Concussive Smash',
                'version': '0.8.28'
            },
            'Maiming Strike': {
                'name': 'Maiming Strike',
                'version': '0.8.28'
            },
            'Flourish': {
                'name': 'Flourish',
                'version': '0.8.28'
            },
            'Heartstopper': {
                'name': 'Heartstopper',
                'version': '0.8.28'
            },
            'Lacerate': {
                'name': 'Lacerate',
                'version': '0.8.28'
            },
            'Piercing Strike': {
                'name': 'Piercing Strike',
                'version': '0.8.28'
            },
            'Piercing Shot': {
                'name': 'Piercing Shot',
                'version': '0.8.28'
            },
            'Pommel Strike': {
                'name': 'Pommel Strike',
                'version': '0.8.28'
            },
            'Prepare': {
                'name': 'Prepare',
                'version': '0.8.28'
            },
            'Rush Attack': {
                'name': 'Rush Attack',
                'version': '0.8.28'
            },
            'Tenacity': {
                'name': 'Tenacity',
                'version': '0.8.28'
            },
            'Topple': {
                'name': 'Topple',
                'version': '0.8.28'
            },
            'Hamstring Shot': {
                'name': 'Hamstring Shot',
                'version': '0.8.28'
            },
            'Mobile Shot': {
                'name': 'Mobile Shot',
                'version': '0.8.28'
            },
            'Weakening Strike': {
                'name': 'Weakening Strike',
                'version': '0.8.28'
            },
            'Tasha\'s Otherworldly Guise': {
                'name': 'Tasha\'s Otherworldly Guise',
                'version': '0.7.22'
            },
            'Guardian of Nature': {
                'name': 'Guardian of Nature',
                'version': '0.7.27'
            },
            'Lucky Footwork': {
                'name': 'Lucky Footwork',
                'version': '0.8.19'
            },
            'Relentless': {
                'name': 'Relentless',
                'version': '0.7.27'
            },
            'Insect Plague': {
                'name': 'Insect Plague',
                'version': '0.7.27',
                'settings': [
                    'Template Listener'
                ]
            },
            'Savage Attacker': {
                'name': 'Savage Attacker',
                'version': '0.7.28'
            },
            'Crusher': {
                'name': 'Crusher',
                'version': '0.7.29'
            },
            'Burning Hands': {
                'name': 'Burning Hands',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Fly': {
                'name': 'Fly',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Faerie Fire': {
                'name': 'Faerie Fire',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Disintegrate': {
                'name': 'Disintegrate',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Form of the Beast': {
                'name': 'Form of the Beast',
                'version': '0.7.33'
            },
            'Bestial Soul': {
                'name': 'Bestial Soul',
                'version': '0.7.33'
            },
            'Infectious Fury': {
                'name': 'Infectious Fury',
                'version': '0.7.33'
            },
            'Call the Hunt': {
                'name': 'Call the Hunt',
                'version': '0.8.18'
            },
            'Fire Storm': {
                'name': 'Fire Storm',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Teleport': {
                'name': 'Teleport',
                'version': '0.7.35'
            },
            'Fire Shield': {
                'name': 'Fire Shield',
                'version': '0.7.45',
                'settings': [
                    'On Hit'
                ],
                'mutation': {
                    'self': 'Fire Shield'
                },
                'hasAnimation': true
            },
            'Far Step': {
                'name': 'Far Step',
                'version': '0.7.45',
                'mutation': {
                    'self': 'Far Step'
                },
                'hasAnimation': true
            },
            'Summon Lesser Demons': {
                'name': 'Summon Lesser Demons',
                'version': '0.7.45',
                'hasAnimation': true,
                'mutation': {
                    'self': 'Summon Lesser Demons'
                }
            },
            'Manifest Mind: Summon': {
                'name': 'Manifest Mind: Summon',
                'version': '0.7.44',
                'actors': [
                    'CPR - Manifest Mind'
                ],
                'mutation': {
                    'self': 'Manifest Mind'
                },
                'settings': [
                    'Rest Listener'
                ]
            },
            'Enlarge/Reduce': {
                'name': 'Enlarge/Reduce',
                'version': '0.7.45',
                'mutation': {
                    'target': 'Enlarge/Reduce'
                },
                'hasAnimation': true
            },
            'Frost Fingers': {
                'name': 'Frost Fingers',
                'version': '0.7.45',
                'hasAnimation': true
            },
            'Eye for Weakness': {
                'name': 'Eye for Weakness',
                'version': '0.7.46'
            },
            'Insightful Fighting': {
                'name': 'Insightful Fighting',
                'version': '0.7.46'
            },
            'Soul of the Storm Giant: Maelstrom Aura': {
                'name': 'Soul of the Storm Giant: Maelstrom Aura',
                'version': '0.7.46'
            },
            'Agent of Order: Stasis Strike': {
                'name': 'Agent of Order: Stasis Strike',
                'version': '0.7.46'
            },
            'Baleful Scion: Grasp of Avarice': {
                'name': 'Baleful Scion: Grasp of Avarice',
                'version': '0.7.46'
            },
            'Righteous Heritor: Soothe Pain': {
                'name': 'Righteous Heritor: Soothe Pain',
                'version': '0.7.46',
                'settings': [
                    'Righteous Heritor'
                ]
            },
            'Planar Wanderer: Planar Adaptation': {
                'name': 'Planar Wanderer: Planar Adaptation',
                'version': '0.7.46'
            },
            'Planar Wanderer: Portal Cracker': {
                'name': 'Planar Wanderer: Portal Cracker',
                'version': '0.7.46'
            },
            'Scion of the Outer Planes (Chaotic Outer Plane)': {
                'name': 'Scion of the Outer Planes (Chaotic Outer Plane)',
                'version': '0.7.46'
            },
            'Scion of the Outer Planes (Evil Outer Plane)': {
                'name': 'Scion of the Outer Planes (Evil Outer Plane)',
                'version': '0.7.46'
            },
            'Scion of the Outer Planes (Good Outer Plane)': {
                'name': 'Scion of the Outer Planes (Good Outer Plane)',
                'version': '0.7.46'
            },
            'Scion of the Outer Planes (Lawful Outer Plane)': {
                'name': 'Scion of the Outer Planes (Lawful Outer Plane)',
                'version': '0.7.46'
            },
            'Scion of the Outer Planes (The Outlands)': {
                'name': 'Scion of the Outer Planes (The Outlands)',
                'version': '0.7.46'
            },
            'Blood Curse of Binding': {
                'name': 'Blood Curse of Binding',
                'version': '0.7.46'
            },
            'Compelled Duel': {
                'name': 'Compelled Duel',
                'version': '0.9.64',
                'settings': [
                    'Compelled Duel',
                    'Movement Listener'
                ]
            },
            'Draconic Cry': {
                'name': 'Draconic Cry',
                'version': '0.7.47'
            },
            'Divine Fury: Necrotic': {
                'name': 'Divine Fury: Necrotic',
                'version': '0.7.53'
            },
            'Divine Fury: Radiant': {
                'name': 'Divine Fury: Radiant',
                'version': '0.7.53'
            },
            'Healing Hands': {
                'name': 'Healing Hands',
                'version': '0.7.54'
            },
            'Channel Divinity: Charm Animals and Plants': {
                'name': 'Channel Divinity: Charm Animals and Plants',
                'version': '0.7.54'
            },
            'Unarmed Strike (Monk)': {
                'name': 'Unarmed Strike (Monk)',
                'version': '0.7.54'
            },
            'Draconic Strike': {
                'name': 'Draconic Strike',
                'version': '0.7.54'
            },
            'Breath of the Dragon': {
                'name': 'Breath of the Dragon',
                'version': '0.7.54'
            },
            'Ki Points': {
                'name': 'Ki Points',
                'version': '0.7.54'
            },
            'Augment Breath': {
                'name': 'Augment Breath',
                'version': '0.7.54'
            },
            'Wraps of Dyamak':  {
                'name': 'Wraps of Dyamak',
                'version': '0.8.04'
            },
            'Hunger of Hadar': {
                'name': 'Hunger of Hadar',
                'version': '0.8.11',
                'settings': [
                    'Template Listener'
                ]
            },
            'Labyrinthine Recall': {
                'name': 'Labyrinthine Recall',
                'version': '0.8.11',
                'settings': [
                    'Skill Patching'
                ]
            },
            'Harness Divine Power': {
                'name': 'Harness Divine Power',
                'version': '0.8.13'
            },
            'Aura of Life': {
                'name': 'Aura of Life',
                'version': '0.8.13',
                'settings': [
                    'Aura of Life'
                ]
            },
            'Spider Climb': {
                'name': 'Spider Climb',
                'version': '0.8.13'
            },
            'Acid Breath Weapon': {
                'name': 'Acid Breath Weapon',
                'version': '0.8.13'
            },
            'Lightning Breath Weapon': {
                'name': 'Lightning Breath Weapon',
                'version': '0.8.13'
            },
            'Poison Breath Weapon': {
                'name': 'Poison Breath Weapon',
                'version': '0.8.13'
            },
            'Fire Breath Weapon': {
                'name': 'Fire Breath Weapon',
                'version': '0.8.13'
            },
            'Cold Breath Weapon': {
                'name': 'Cold Breath Weapon',
                'version': '0.8.13'
            },
            'Chromatic Warding (Acid)': {
                'name': 'Chromatic Warding (Acid)',
                'version': '0.8.13'
            },
            'Chromatic Warding (Cold)': {
                'name': 'Chromatic Warding (Cold)',
                'version': '0.8.13'
            },
            'Chromatic Warding (Fire)': {
                'name': 'Chromatic Warding (Fire)',
                'version': '0.8.13'
            },
            'Chromatic Warding (Lightning)': {
                'name': 'Chromatic Warding (Lightning)',
                'version': '0.8.13'
            },
            'Chromatic Warding (Poison)': {
                'name': 'Chromatic Warding (Poison)',
                'version': '0.8.13'
            },
            'Breath Weapon (Black)': {
                'name': 'Breath Weapon (Black)',
                'version': '0.8.13'
            },
            'Breath Weapon (Blue)': {
                'name': 'Breath Weapon (Blue)',
                'version': '0.8.13'
            },
            'Breath Weapon (Brass)': {
                'name': 'Breath Weapon (Brass)',
                'version': '0.8.13'
            },
            'Breath Weapon (Bronze)': {
                'name': 'Breath Weapon (Bronze)',
                'version': '0.8.13'
            },
            'Breath Weapon (Copper)': {
                'name': 'Breath Weapon (Copper)',
                'version': '0.8.13'
            },
            'Breath Weapon (Gold)': {
                'name': 'Breath Weapon (Gold)',
                'version': '0.8.13'
            },
            'Breath Weapon (Green)': {
                'name': 'Breath Weapon (Green)',
                'version': '0.8.13'
            },
            'Breath Weapon (Red)': {
                'name': 'Breath Weapon (Red)',
                'version': '0.8.13'
            },
            'Breath Weapon (Silver)': {
                'name': 'Breath Weapon (Silver)',
                'version': '0.8.13'
            },
            'Breath Weapon (White)': {
                'name': 'Breath Weapon (White)',
                'version': '0.8.13'
            },
            'Forceful Presence': {
                'name': 'Forceful Presence',
                'version': '0.8.13'
            },
            'Gem Flight': {
                'name': 'Gem Flight',
                'version': '0.8.13'
            },
            'Breath Weapon (Force)': {
                'name': 'Breath Weapon (Force)',
                'version': '0.8.13'
            },
            'Breath Weapon (Necrotic)': {
                'name': 'Breath Weapon (Necrotic)',
                'version': '0.8.13'
            },
            'Breath Weapon (Psychic)': {
                'name': 'Breath Weapon (Psychic)',
                'version': '0.8.13'
            },
            'Breath Weapon (Radiant)': {
                'name': 'Breath Weapon (Radiant)',
                'version': '0.8.13'
            },
            'Breath Weapon (Thunder)': {
                'name': 'Breath Weapon (Thunder)',
                'version': '0.8.13'
            },
            'Metallic Breath Weapon': {
                'name': 'Metallic Breath Weapon',
                'version': '0.8.16'
            },
            'Warder\'s Intuition': {
                'name': 'Warder\'s Intuition',
                'version': '0.8.16'
            },
            'Check Cover': {
                'name': 'Check Cover',
                'version': '0.8.17'
            },
            'Adept Marksman': {
                'name': 'Adept Marksman',
                'version': '0.8.20',
                'settings': [
                    'Critical Role Firearm Support'
                ]
            },
            'Bullying Shot': {
                'name': 'Bullying Shot',
                'version': '0.8.20',
                'settings': [
                    'Critical Role Firearm Support'
                ]
            },
            'Dazing Shot': {
                'name': 'Dazing Shot',
                'version': '0.8.20',
                'settings': [
                    'Critical Role Firearm Support'
                ]
            },
            'Deadeye Shot': {
                'name': 'Deadeye Shot',
                'version': '0.8.20',
                'settings': [
                    'Critical Role Firearm Support'
                ]
            },
            'Disarming Shot': {
                'name': 'Disarming Shot',
                'version': '0.8.20',
                'settings': [
                    'Critical Role Firearm Support'
                ]
            },
            'Forceful Shot': {
                'name': 'Forceful Shot',
                'version': '0.8.20',
                'settings': [
                    'Critical Role Firearm Support'
                ]
            },
            'Winging Shot': {
                'name': 'Winging Shot',
                'version': '0.8.20',
                'settings': [
                    'Critical Role Firearm Support'
                ]
            },
            'Hemorrhaging Critical': {
                'name': 'Hemorrhaging Critical',
                'version': '0.8.20',
                'settings': [
                    'Critical Role Firearm Support'
                ]
            },
            'Quickdraw': {
                'name': 'Quickdraw',
                'version': '0.8.20',
                'settings': [
                    'Critical Role Firearm Support'
                ]
            },
            'Reload Firearm': {
                'name': 'Reload Firearm',
                'version': '0.8.20',
                'settings': [
                    'Critical Role Firearm Support'
                ]
            },
            'Repair Firearm': {
                'name': 'Repair Firearm',
                'version': '0.8.20',
                'settings': [
                    'Critical Role Firearm Support'
                ]
            },
            'Vicious Intent': {
                'name': 'Vicious Intent',
                'version': '0.8.21',
                'settings': [
                    'Critical Role Firearm Support'
                ]
            },
            'Firearm (CR)': {
                'name': 'Firearm (CR)',
                'version': '0.8.20',
                'settings': [
                    'Critical Role Firearm Support'
                ]
            },
            'Lightning Reload': {
                'name': 'Lightning Reload',
                'version': '0.8.20',
                'settings': [
                    'Critical Role Firearm Support'
                ]
            },
            'Rapid Repair': {
                'name': 'Rapid Repair',
                'version': '0.8.20',
                'settings': [
                    'Critical Role Firearm Support'
                ]
            },
            'Violent Shot': {
                'name': 'Violent Shot',
                'version': '0.8.21',
                'settings': [
                    'Critical Role Firearm Support'
                ]
            },
            'Thunderwave': {
                'name': 'Thunderwave',
                'version': '0.8.25'
            },
            'Flame Blade': {
                'name': 'Flame Blade',
                'version': '0.8.22',
                'mutation': {
                    'self': 'Flame Blade'
                }
            },
            'Hidden Step': {
                'name': 'Hidden Step',
                'version': '0.8.22'
            },
            'Synaptic Static': {
                'name': 'Synaptic Static',
                'version': '0.8.23',
                'settings': [
                    'Active Effect Additions'
                ]
            },
            'Booming Blade': {
                'name': 'Booming Blade',
                'version': '0.8.26',
                'settings': [
                    'Booming Blade'
                ],
                'hasAnimation': true
            },
            'Green-Flame Blade': {
                'name': 'Green-Flame Blade',
                'version': '0.8.26'
            },
            'Spray of Cards': {
                'name': 'Spray of Cards',
                'version': '0.8.28'
            },
            'Antagonize': {
                'name': 'Antagonize',
                'version': '0.8.28'
            },
            'Cartomancer: Hidden Ace - Imbue Card': {
                'name': 'Cartomancer: Hidden Ace - Imbue Card',
                'version': '0.8.30',
                'mutation': {
                    'self': 'Cartomancer'
                }
            },
            'Astral Knowledge': {
                'name': 'Astral Knowledge',
                'version': '0.8.31'
            },
            'Mental Discipline (Githzerai)': {
                'name': 'Mental Discipline (Githzerai)',
                'version': '0.8.31'
            },
            'Mental Discipline (Kalashtar)': {
                'name': 'Mental Discipline (Kalashtar)',
                'version': '0.8.31'
            },
            'Thunderous Smite': {
                'name': 'Thunderous Smite',
                'version': '0.9.2'
            },
            'Rime\'s Binding Ice': {
                'name': 'Rime\'s Binding Ice',
                'version': '0.9.3',
                'hasAnimation': true
            },
            'Ice Storm': {
                'name': 'Ice Storm',
                'version': '0.9.3',
                'hasAnimation': true
            },
            'Searing Smite': {
                'name': 'Searing Smite',
                'version': '0.9.4'
            },
            'Wild Surge': {
                'name': 'Wild Surge',
                'version': '0.9.5',
                'actors': [
                    'CPR - Intangible Spirit'
                ]
            },
            'Controlled Surge': {
                'name': 'Controlled Surge',
                'version': '0.9.5'
            },
            'Unstable Backlash': {
                'name': 'Unstable Backlash',
                'version': '0.9.5'
            },
            'Bolstering Magic': {
                'name': 'Bolstering Magic',
                'version': '0.9.5'
            },
            'Piercing Shot CR': {
                'name': 'Piercing Shot CR',
                'version': '0.9.6',
                'settings': [
                    'Critical Role Firearm Support'
                ]
            },
            'Borrowed Knowledge': {
                'name': 'Borrowed Knowledge',
                'version': '0.9.6'
            },
            'Skill Empowerment': {
                'name': 'Skill Empowerment',
                'version': '0.9.6'
            },
            'Quick Insert Summon': {
                'name': 'Quick Insert Summon',
                'version': '0.9.10'
            },
            'Sleet Storm': {
                'name': 'Sleet Storm',
                'version': '0.9.14',
                'settings': [
                    'Template Listener'
                ]
            },
            'Giant\'s Havoc: Crushing Throw': {
                'name': 'Giant\'s Havoc: Crushing Throw',
                'version': '0.9.17'
            },
            'Giant\'s Havoc: Giant Stature': {
                'name': 'Giant\'s Havoc: Giant Stature',
                'version': '0.9.17'
            },
            'Demiurgic Colossus': {
                'name': 'Demiurgic Colossus',
                'version': '0.9.17'
            },
            'Elemental Cleaver': {
                'name': 'Elemental Cleaver',
                'version': '0.9.17',
                'mutation': {
                    'self': 'Elemental Cleaver'
                }
            },
            'Mighty Impel': {
                'name': 'Mighty Impel',
                'version': '0.9.17'
            },
            'Investiture of Flame': {
                'name': 'Investiture of Flame',
                'version': '0.9.22',
                'mutation': {
                    'self': 'Investiture of Flame'
                }
            },
            'Investiture of Ice': {
                'name': 'Investiture of Ice',
                'version': '0.9.22',
                'mutation': {
                    'self': 'Investiture of Ice'
                }
            },
            'Investiture of Stone': {
                'name': 'Investiture of Stone',
                'version': '0.9.22',
                'mutation': {
                    'self': 'Investiture of Stone'
                }
            },
            'Create Pact Weapon': {
                'name': 'Create Pact Weapon',
                'version': '0.9.24'
            },
            'Eldritch Invocations: Improved Pact Weapon': {
                'name': 'Eldritch Invocations: Improved Pact Weapon',
                'version': '0.9.24'
            },
            'Hex Warrior': {
                'name': 'Hex Warrior',
                'version': '0.9.24'
            },
            'Armor Modifications': {
                'name': 'Armor Modifications',
                'version': '0.9.27'
            },
            'Persistent Rage': {
                'name': 'Persistent Rage',
                'version': '0.9.28'
            },
            'Long-Limbed': {
                'name': 'Long-Limbed',
                'version': '0.9.28'
            },
            'Elemental Weapon': {
                'name': 'Elemental Weapon',
                'version': '0.9.29'
            },
            'Gifted Scribe': {
                'name': 'Gifted Scribe',
                'version': '0.9.31'
            },
            'Grung Poison': {
                'name': 'Grung Poison',
                'version': '0.9.31'
            },
            'Poisonous Skin': {
                'name': 'Poisonous Skin',
                'version': '0.9.31'
            },
            'Hadozee Dodge': {
                'name': 'Hadozee Dodge',
                'version': '0.9.31'
            },
            'Stone\'s Endurance': {
                'name': 'Stone\'s Endurance',
                'version': '0.9.60'
            },
            'Breath Weapon (Acid)': {
                'name': 'Breath Weapon (Acid)',
                'version': '0.9.31'
            },
            'Breath Weapon (Cold)': {
                'name': 'Breath Weapon (Cold)',
                'version': '0.9.31'
            },
            'Breath Weapon (Fire)': {
                'name': 'Breath Weapon (Fire)',
                'version': '0.9.31'
            },
            'Breath Weapon (Lightning)': {
                'name': 'Breath Weapon (Lightning)',
                'version': '0.9.31'
            },
            'Windwright\'s Intuition': {
                'name': 'Windwright\'s Intuition',
                'version': '0.9.32'
            },
            'Bladesong': {
                'name': 'Bladesong',
                'version': '0.9.33'
            },
            'Song of Defense': {
                'name': 'Bladesong',
                'version': '0.9.33'
            },
            'Song of Victory': {
                'name': 'Bladesong',
                'version': '0.9.33'
            },
            'Mote of Potential': {
                'name': 'Mote of Potential',
                'version': '0.9.35'
            },
            'Magical Inspiration': {
                'name': 'Magical Inspiration',
                'version': '0.9.35'
            },
            'Bardic Inspiration': {
                'name': 'Bardic Inspiration',
                'version': '0.9.35'
            },
            'Echo Avatar': {
                'name': 'Echo Avatar',
                'version': '0.9.40'
            },
            'Legion of One': {
                'name': 'Legion of One',
                'version': '0.9.40'
            },
            'Manifest Echo': {
                'name': 'Manifest Echo',
                'version': '0.9.40'
            },
            'Reclaim Potential': {
                'name': 'Reclaim Potential',
                'version': '0.9.40'
            },
            'Unleash Incarnation': {
                'name': 'Unleash Incarnation',
                'version': '0.9.40'
            },
            'Palm Pistol (Exandria)': {
                'name': 'Palm Pistol (Exandria)',
                'version': '0.9.45'
            },
            'Bad News (Exandria)': {
                'name': 'Bad News (Exandria)',
                'version': '0.9.45'
            },
            'Blunderbuss (Exandria)': {
                'name': 'Blunderbuss (Exandria)',
                'version': '0.9.45'
            },
            'Musket (Exandria)': {
                'name': 'Musket (Exandria)',
                'version': '0.9.45'
            },
            'Pepperbox (Exandria)': {
                'name': 'Pepperbox (Exandria)',
                'version': '0.9.45'
            },
            'Pistol (Exandria)': {
                'name': 'Pistol (Exandria)',
                'version': '0.9.45'
            },
            'Javelin of Lightning': {
                'name': 'Javelin of Lightning',
                'version': '0.9.46'
            },
            'Channel Divinity: Control Undead': {
                'name': 'Channel Divinity: Control Undead',
                'version': '0.9.52',
                'hasAnimation': true
            },
            'Channel Divinity: Dreadful Aspect': {
                'name': 'Channel Divinity: Dreadful Aspect',
                'version': '0.9.52',
                'hasAnimation': true
            },
            'Dread Lord': {
                'name': 'Dread Lord',
                'version': '0.9.52',
                'settings': [
                    'Effect Auras'
                ],
                'hasAnimation': true
            },
            'Gathered Swarm': {
                'name': 'Gathered Swarm',
                'version': '0.9.55'
            },
            'Brave': {
                'name': 'Brave',
                'version': '0.9.60'
            },
            'Lucky': {
                'name': 'Lucky',
                'version': '0.9.60'
            },
            'Medical Intuition': {
                'name': 'Medical Intuition',
                'version': '0.9.60'
            },
            'Ever Hospitable': {
                'name': 'Ever Hospitable',
                'version': '0.9.60'
            },
            'Stout Resilience': {
                'name': 'Stout Resilience',
                'version': '0.9.60'
            },
            'Amorphous': {
                'name': 'Amorphous',
                'version': '0.9.62',
                'settings': [
                    'Skill Patching'
                ]
            },
            'Dual Wielder': {
                'name': 'Dual Wielder',
                'version': '0.9.63'
            },
            'Twilight Shroud': {
                'name': 'Twilight Shroud',
                'version': '0.9.63'
            }
        }
    });
}
;// CONCATENATED MODULE: ./scripts/journal.js
let welcomeText = `<p>Thank you for using my module! If you find any bugs or have any requests please either either message <strong>chrisk123999</strong> on Discord or make a <a href="https://github.com/chrisk123999/chris-premades">Github</a> issue. Do not pester tposney, Zhell, or any other module authors with bugs or issues related to this module.</p>
<p>As a note, I generally work-around items that have been imported via the DDB importer module. If something works "as-is" from that module, it's unlikely I'll have it here.</p>
<p>To get started you can find my automations inside the compendiums that start with: "CPR."</p>
<p>You can also click the medical kit icon on the title bar to update the item with my automation. This will preserve your description already on the item.</p>
<hr>
<p>Any item, spell, or feature that is added to your sheet temporarily needs a description. Module updates will replace the compendiums they're stored in, so instead the descriptions will be pulled from this journal entry. All pages after this one will not get regenerated when updating this module.</p>
<hr>
<a href="https://ko-fi.com/chrisk123999">
    <img src="https://ko-fi.com/img/githubbutton_sm.svg">
</a>`;
async function setupJournalEntry() {
    let journalName = 'CPR - Descriptions';
    let journalEntry = game.journal.getName(journalName);
    if (!journalEntry) {
        journalEntry = await JournalEntry.create({
            'name': journalName,
            'pages': [
                {
                    'sort': 100000,
                    'name': 'Info',
                    'type': 'text',
                    'title': {
                        'show': true,
                        'level': 1
                    },
                    'text': {
                        'format': 1,
                        'content': welcomeText,
                        'markdown': ''
                    }
                }
            ],
            'ownership': {
                'default': 2
            }
        });
        let message = '<hr>View Chris\'s premades readme here: @UUID[JournalEntry.' + journalEntry.id + ']{Read Me}';
        ChatMessage.create({
            'speaker': {'alias': 'Chris\'s Premades'},
            'content': message
        });
    } else {
        let page = journalEntry.pages.getName('Info');
        if (page) {
            await page.update({
                'text.content': welcomeText
            });
        }
    }
    async function addPage(journalEntry, pageName, text) {
        await JournalEntryPage.create({
            'name': pageName, 
            'text': {'content': text}, 
            'title': {'show': false, 'level': 1}, 
            'sort': journalEntry.pages.contents.at(-1).sort + CONST.SORT_INTEGER_DENSITY
        }, 
        {
            'parent': journalEntry
        });
    }
    async function checkPage(journalEntry, name) {
        if (!journalEntry.pages.getName(name)) await addPage(journalEntry, name, '');
    }
    async function preparePages(journalEntry, packKey) {
        let gamePack = game.packs.get(packKey);
        if (!gamePack) {
            ui.notifications.error('Compendium was not loaded! Journal entries could not be updated.');
            return;
        }
        let packItems = await gamePack.getDocuments();
        for (let i of packItems) {
            if (i.name === '#[CF_tempEntity]') continue;
            await checkPage(journalEntry, i.name);
        }
    }
    await preparePages(journalEntry, 'chris-premades.CPR Spell Features');
    await preparePages(journalEntry, 'chris-premades.CPR Class Feature Items');
    await preparePages(journalEntry, 'chris-premades.CPR Monster Feature Items');
    await preparePages(journalEntry, 'chris-premades.CPR Item Features');
    await preparePages(journalEntry, 'chris-premades.CPR Race Feature Items');
    await preparePages(journalEntry, 'chris-premades.CPR Summon Features');
    await preparePages(journalEntry, 'chris-premades.CPR Actions');
    await preparePages(journalEntry, 'chris-premades.CPR Feat Features');
    await preparePages(journalEntry, 'chris-premades.CPR Homebrew Feature Items');
}
;// CONCATENATED MODULE: ./scripts/update.js
async function checkUpdate() {
    if (game.messages.contents.find(i => i.flags?.['chris-premades']?.update)) return;
    try {
        let reponse = await fetch('https://api.github.com/repos/chrisk123999/chris-premades/releases/latest');
        if (!reponse.ok) return;
        let info = await reponse.json();
        let currentVersion = game.modules.get('chris-premades').version;
        if (currentVersion === '#{VERSION}#') return;
        if (!isNewerVersion(info.tag_name, currentVersion)) return;
        let body = info.body.replaceAll('\r\n\r\n', '<hr>')
            .replaceAll('\r\n', '<br>')
            .replaceAll('New Content:', '<b><u>New Content:</u></b>')
            .replaceAll('New Monster Content:', '<b><u>New Monster Content:</u></b>')
            .replaceAll('Bug Fixes:', '<b><u>Bug Fixes:</u></b>')
            .replaceAll('Update Notes:', '<b><u>Update Notes:</u></b>')
            .replaceAll('New Enhanced Animations:', '<b><u>New Enhanced Animations:</u></b>');
        let message = '<hr>Chris\'s Premades update <b>' + info.tag_name + '</b> available!<hr>' + body;
        await ChatMessage.create({
            'speaker': {'alias': name},
            'content': message,
            'whisper': [game.user.id],
            'flags': {
                'chris-premades': {
                    'update': true
                }
            }
        });
    } catch {};
}
;// CONCATENATED MODULE: ./scripts/chat.js

async function addChatButton(message, options, user) {
    let flagData = message.flags?.['chris-premades']?.message?.button;
    if (!flagData) return;
    await warpgate.wait(100);
    let messageElement = document.querySelector('[data-message-id="' + message.id + '"]');
    if (!messageElement) return;
    if (flagData.settings) {
        let button = messageElement.querySelector('[class="chris-settings-button"]');
        if (button) button.addEventListener('click', () => {
            buttonSettings(flagData.settings, button, message);
        });
    }
    if (flagData.actors) {
        let button = messageElement.querySelector('[class="chris-actors-button"]');
        if (button) button.addEventListener('click', () => {
            buttonActors(flagData.actors, button, message);
        });
    }
    if (flagData.item) {
        let button = messageElement.querySelector('[class="chris-item-button"]');
        if (button) button.addEventListener('click', () => {
            buttonItem(flagData.item, button, message);
        });
    }
}
;// CONCATENATED MODULE: ./scripts/module.js










































let socket;
Hooks.once('init', async function() {
    registerSettings();
    setConfig();
});
Hooks.once('socketlib.ready', async function() {
    socket = socketlib.registerModule('chris-premades');
    socket.register('updateMoveTriggers', updateMoveTriggers);
    socket.register('updateGMTriggers', updateGMTriggers);
    socket.register('remoteAddEffectAura', effectSockets.remoteAdd);
    socket.register('remoteRemoveEffectAura', effectSockets.remoteRemove);
    socket.register('createCombatant', tashaSummon.createCombatant);
    socket.register('updateCombatant', runAsGM.updateCombatant);
    socket.register('remoteDialog', remoteDialog);
    socket.register('remoteDocumentDialog', remoteDocumentDialog);
    socket.register('remoteDocumentsDialog', remoteDocumentsDialog);
    socket.register('remoteAimCrosshair', remoteAimCrosshair);
    socket.register('remoteMenu', remoteMenu);
    socket.register('updateEffect', runAsGM.updateEffect);
    socket.register('createEffect', runAsGM.createEffect);
    socket.register('removeEffect', runAsGM.removeEffect);
    socket.register('rollItem', runAsUser.rollItem);
});
Hooks.once('ready', async function() {
    if (game.user.isGM) {
        let oldVersion = game.settings.get('chris-premades', 'Breaking Version Change');
        let currentVersion = 9;
        if (oldVersion < currentVersion && oldVersion === 8) {
            let message = '<hr><p>Bardic Inspiration, Mote of Potential, and Magical Inspiration have been split into separate items. You will need to replace the features for them to continue to work.</p>';
            ChatMessage.create({
                'speaker': {'alias': 'Chris\'s Premades'},
                'content': message
            });
            await game.settings.set('chris-premades', 'Breaking Version Change', 9);
            oldVersion = 1;
        }
        await setupJournalEntry();
        await tours.checkTour();
        if (game.settings.get('chris-premades', 'Tasha Actors')) await tashaSummon.setupFolder();
        if (game.modules.get('itemacro')?.active) {
            try {
                if (game.settings.get('itemacro', 'charsheet')) ui.notifications.error('Chris\'s Premades & Midi-Qol requires "Character Sheet Hook" in Item Macro\'s module settings to be turned off!');
            } catch {}
        }
        if (game.modules.get('ddb-importer')?.active) Hooks.on('getActorSheet5eHeaderButtons', createActorHeaderButton);
        game.settings.set('chris-premades', 'LastGM', game.user.id);
        if (game.settings.get('chris-premades', 'Combat Listener')) Hooks.on('updateCombat', combatUpdate);
        if (game.settings.get('chris-premades', 'Movement Listener')) {
            Hooks.on('preUpdateToken', tokenMovedEarly);
            Hooks.on('updateToken', tokenMoved);
        }
        if (game.settings.get('chris-premades', 'Emboldening Bond')) Hooks.on('updateToken', macros.emboldeningBond.move);
        if (game.settings.get('chris-premades', 'Template Listener')) {
            Hooks.on('updateToken', templates.move);
            Hooks.on('updateCombat', templates.combat);
        }
        if (game.settings.get('chris-premades', 'Effect Auras')) {
            Hooks.on('preUpdateActor', effectAuraHooks.preActorUpdate);
            Hooks.on('updateActor', effectAuraHooks.actorUpdate);
            Hooks.on('canvasReady', effectAuraHooks.canvasReady);
            Hooks.on('updateToken', effectAuraHooks.updateToken);
            Hooks.on('createToken', effectAuraHooks.createToken);
            Hooks.on('deleteToken', effectAuraHooks.deleteToken);
            Hooks.on('createActiveEffect', effectAuraHooks.createRemoveEffect);
            Hooks.on('deleteActiveEffect', effectAuraHooks.createRemoveEffect);
            effectAuras.registerAll();
        }
        if (game.settings.get('chris-premades', 'Warding Bond')) {
            Hooks.on('updateToken', macros.wardingBond.moveTarget);
            Hooks.on('updateToken', macros.wardingBond.moveSource);
        }
        if (game.settings.get('chris-premades', 'Compelled Duel')) Hooks.on('updateToken', macros.compelledDuel.movement);
        if (game.settings.get('chris-premades', 'Check For Updates')) checkUpdate();
        Hooks.on('createChatMessage', addChatButton);
    }
    await loadTriggers();
    if (game.settings.get('chris-premades', 'Condition Resistance')) {
        Hooks.on('midi-qol.preItemRoll', macros.conditionResistanceEarly);
        Hooks.on('midi-qol.RollComplete', macros.conditionResistanceLate);
    }
    if (game.settings.get('chris-premades', 'Condition Vulnerability')) {
        Hooks.on('midi-qol.preItemRoll', macros.conditionVulnerabilityEarly);
        Hooks.on('midi-qol.RollComplete', macros.conditionVulnerabilityLate);
    }
    if (game.settings.get('chris-premades', 'Beacon of Hope')) Hooks.on('midi-qol.preTargetDamageApplication', macros.beaconOfHope);
    if (game.settings.get('chris-premades', 'DMG Cleave')) {
        Hooks.on('midi-qol.RollComplete', macros.cleave.hit);
        Hooks.on('midi-qol.preCheckHits', macros.cleave.attack);
        Hooks.on('midi-qol.preDamageRollComplete', macros.cleave.damage);
    }
    if (game.settings.get('chris-premades', 'Darkness')) Hooks.on('midi-qol.preAttackRoll', macros.darkness.hook);
    if (game.settings.get('chris-premades', 'Death Ward')) Hooks.on('midi-qol.preTargetDamageApplication', macros.deathWard);
    if (game.settings.get('chris-premades', 'Rest Listener')) Hooks.on('dnd5e.restCompleted', rest_rest);
    if (game.settings.get('chris-premades', 'Elemental Adept')) {
        Hooks.on('midi-qol.postPreambleComplete', macros.elementalAdept.early);
        Hooks.on('midi-qol.preDamageRollComplete', macros.elementalAdept.damage);
        Hooks.on('midi-qol.RollComplete', macros.elementalAdept.late);
    }
    if (game.settings.get('chris-premades', 'Fog Cloud')) Hooks.on('midi-qol.preAttackRoll', macros.fogCloud.hook);
    if (game.settings.get('chris-premades', 'Mirror Image')) Hooks.on('midi-qol.AttackRollComplete', macros.mirrorImage);
    if (game.settings.get('chris-premades', 'On Hit')) Hooks.on('midi-qol.RollComplete', onHitMacro);
    if (game.settings.get('chris-premades', 'Protection from Evil and Good')) Hooks.on('midi-qol.preAttackRoll', macros.protectionFromEvilAndGood);
    if (game.settings.get('chris-premades', 'Sanctuary')) Hooks.on('midi-qol.preItemRoll', macros.sanctuary.hook);
    if (game.settings.get('chris-premades', 'Shield Guardian')) Hooks.on('midi-qol.preTargetDamageApplication', macros.mastersAmulet);
    if (game.settings.get('chris-premades', 'Undead Fortitude')) Hooks.on('midi-qol.preTargetDamageApplication', macros.monster.zombie.undeadFortitude);
    if (game.settings.get('chris-premades', 'Wildhunt')) Hooks.on('midi-qol.preAttackRoll', macros.wildhunt);
    if (game.settings.get('chris-premades', 'Active Effect Additions')) {
        Hooks.on('preCreateActiveEffect', itemDC);  
        Hooks.on('preCreateActiveEffect', noEffectAnimationCreate);
        Hooks.on('preDeleteActiveEffect', noEffectAnimationDelete);
        Hooks.on('getActiveEffectConfigHeaderButtons', effectTitleBar);
        patchActiveEffectSourceName(true);
    }
    if (game.settings.get('chris-premades', 'Active Effect Origin Fix')) Hooks.on('createToken', fixOrigin);
    if (game.settings.get('chris-premades', 'Automatic VAE Descriptions')) Hooks.on('preCreateActiveEffect', vaeEffectDescription);
    if (game.settings.get('chris-premades', 'VAE Temporary Item Buttons')) Hooks.on('visual-active-effects.createEffectButtons', vaeTempItemButton);
    if (game.settings.get('chris-premades', 'Condition Fixes')) removeDumbV10Effects();
    if (game.settings.get('chris-premades', 'Exploding Heals')) Hooks.on('midi-qol.preDamageRollComplete', macros.explodingHeals);
    if (game.settings.get('chris-premades', 'Attack Listener')) Hooks.on('midi-qol.preAttackRoll', flanking);
    if (game.settings.get('chris-premades', 'Strength of the Grave')) Hooks.on('midi-qol.preTargetDamageApplication', macros.strengthOfTheGrave);
    if (game.settings.get('chris-premades', 'Relentless Endurance')) Hooks.on('midi-qol.preTargetDamageApplication', macros.relentlessEndurance);
    if (game.settings.get('chris-premades', 'Shadow of Moil')) Hooks.on('midi-qol.preAttackRoll', macros.shadowOfMoil.hook);
    if (game.settings.get('chris-premades', 'Emboldening Bond')) Hooks.on('midi-qol.preTargetDamageApplication', macros.emboldeningBond.damage);
    if (game.settings.get('chris-premades', 'Manual Rolls')) {
        Hooks.on('midi-qol.preCheckHits', macros.manualRolls.attackRoll);
        Hooks.on('midi-qol.postCheckSaves', macros.manualRolls.saveRolls);
        Hooks.on('midi-qol.DamageRollComplete', macros.manualRolls.damageRoll);
    }
    if (game.user.isGM || game.settings.get('chris-premades', 'Item Replacer Access') || game.settings.get('chris-premades', 'Item Configuration Access')) {
        Hooks.on('getItemSheetHeaderButtons', createHeaderButton);
        Hooks.on('renderItemSheet', updateItemButton);
    }
    if (game.settings.get('chris-premades', 'Use Randomizer')) Hooks.on('createToken', npcRandomizer);
    if (game.settings.get('chris-premades', 'Skill Patching')) patchSkills(true);
    if (game.settings.get('chris-premades', 'Save Patching')) patchSaves(true);
    if (game.settings.get('chris-premades', 'Dice So Nice')) {
        Hooks.on('midi-qol.preItemRoll', diceSoNice.early);
        Hooks.on('midi-qol.DamageRollComplete', diceSoNice.late)
    }
    if (game.settings.get('chris-premades', 'Arcane Ward')) Hooks.on('midi-qol.preTargetDamageApplication', macros.arcaneWard.damage);
    if (game.settings.get('chris-premades', 'Automation Verification')) Hooks.on('midi-qol.preItemRoll', info);
    if (game.settings.get('chris-premades', 'Item Features')) {
        Hooks.on('preUpdateItem', itemFeatures);
        Hooks.on('preDeleteItem', itemFeaturesDelete);
    }
    if (game.settings.get('chris-premades', 'Baldur\'s Gate 3 Weapon Actions')) {
        Hooks.on('preUpdateItem', macros.bg3.addFeatures);
        Hooks.on('preDeleteItem', macros.bg3.removeFeatures);
        Hooks.on('midi-qol.preDamageRollComplete', macros.bg3.piercingStrike.damage);
        Hooks.on('dnd5e.restCompleted', macros.bg3.rest);
        Hooks.on('midi-qol.RollComplete', macros.bg3.healing);
    }
    if (game.settings.get('chris-premades', 'Cast Animations')) Hooks.on('midi-qol.postPreambleComplete', cast);
    if (game.settings.get('chris-premades', 'Righteous Heritor')) Hooks.on('midi-qol.preTargetDamageApplication', macros.soothePain);
    if (game.settings.get('chris-premades', 'Compelled Duel')) Hooks.on('midi-qol.RollComplete', macros.compelledDuel.attacked);
    Hooks.on('renderCompendium', compendiumRender);
    if (game.modules.get('dae')?.active) addDAEFlags();
    if (game.settings.get('chris-premades', 'Colorize Automated Animations')) {
        automatedAnimations.sortAutoRec();
        Hooks.on('renderItemSheet', automatedAnimations.titleBarButton);
    }
    if (game.settings.get('chris-premades', 'Colorize Build A Bonus')) {
        Hooks.on('renderItemSheet', buildABonus.titleBarButton);
        Hooks.on('renderDAEActiveEffectConfig', buildABonus.daeTitleBarButton);
        Hooks.on('renderActorSheet5e', buildABonus.actorTitleBarButtons);
    }
    if (game.settings.get('chris-premades', 'Colorize Dynamic Active Effects')) Hooks.on('renderItemSheet', colorizeDAETitleBarButton);
    if (game.settings.get('chris-premades', 'Colorize Template Macro')) Hooks.on('renderItemSheet', templateMacroTitleBarButton);
    if (game.settings.get('chris-premades', 'D&D5E Animations Sounds')) {
        dndAnimations.sortAutoRec();
        Hooks.on('midi-qol.AttackRollComplete', dndAnimations.attackDone);
        Hooks.on('midi-qol.DamageRollComplete', dndAnimations.damageDone);
        Hooks.on('midi-qol.RollComplete', dndAnimations.rollDone);
    }
    if (game.settings.get('chris-premades', 'Aura of Life')) {
        Hooks.on('preCreateActiveEffect', macros.auraOfLife.effect);
        Hooks.on('updateActiveEffect', macros.auraOfLife.effect);
    }
    if (game.settings.get('chris-premades', 'Critical Role Firearm Support')) firearm.setup(true);
    if (game.settings.get('chris-premades', 'Booming Blade')) Hooks.on('updateToken', macros.boomingBlade.moved);
    if (game.settings.get('chris-premades', 'Build A Bonus Overlapping Effects')) Hooks.on('babonus.filterBonuses', buildABonus.overlappingEffects);
    if (game.settings.get('chris-premades', 'Manifest Echo')) Hooks.on('dnd5e.rollAbilitySave', macros.manifestEcho.save);
    if (game.settings.get('chris-premades', 'Dual Wielder')) Hooks.on('updateItem', macros.dualWielder);
    if (game.settings.get('chris-premades', 'Twilight Shroud')) {
        Hooks.on('midi-qol.preCheckHits', macros.twilightShroud.attack);
        Hooks.on('midi-qol.preambleComplete', macros.twilightShroud.saveEarly);
        Hooks.on('midi-qol.RollComplete', macros.twilightShroud.saveLate);
    }
    Hooks.on('createToken', addActions);
});
//Hooks.once('tidy5e-sheet.ready', actionsTab);
let dev = {
    'setCompendiumItemInfo': setCompendiumItemInfo,
    'stripUnusedFlags': stripUnusedFlags,
    'applyEquipmentFlag': applyEquipmentFlag,
    'setItemName': setItemName,
    'removeFolderFlag': removeFolderFlag,
    'checkUpdate': checkUpdate,
    'updateAllCompendiums': updateAllCompendiums
}
globalThis['chrisPremades'] = {
    constants: constants_constants,
    dev,
    effectAuras: effectAuras,
    helpers: chris,
    macros: macros,
    queue: queue_queue,
    settingButton: settingButton,
    summonEffects: summonEffects,
    summons: summons,
    tashaSummon: tashaSummon,
    tokenMove: tokenMove,
    translate: translate,
    troubleshoot: troubleshoot
}
/******/ })()
;
//# sourceMappingURL=main.js.map